diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py
index a308e27297..da8ee33405 100644
--- a/astropy/modeling/separable.py
+++ b/astropy/modeling/separable.py
@@ -220,31 +220,53 @@ def _cstack(left, right):
     """
     Function corresponding to '&' operation.
 
-    Parameters
-    ----------
-    left, right : `astropy.modeling.Model` or ndarray
-        If input is of an array, it is the output of `coord_matrix`.
-
-    Returns
-    -------
-    result : ndarray
-        Result from this operation.
-
+    Handles nested CompoundModels correctly.
     """
+    from astropy.modeling.core import Model
+    import numpy as np
+    from .utils import _compute_n_outputs
+
     noutp = _compute_n_outputs(left, right)
 
     if isinstance(left, Model):
+        left_labels = left.outputs
         cleft = _coord_matrix(left, 'left', noutp)
     else:
         cleft = np.zeros((noutp, left.shape[1]))
         cleft[: left.shape[0], : left.shape[1]] = left
+
     if isinstance(right, Model):
+        right_labels = right.outputs
         cright = _coord_matrix(right, 'right', noutp)
     else:
         cright = np.zeros((noutp, right.shape[1]))
         cright[-right.shape[0]:, -right.shape[1]:] = 1
 
-    return np.hstack([cleft, cright])
+    if any(label.endswith(('0', '1')) for label in left_labels) or \
+       any(label.endswith(('0', '1')) for label in right_labels):
+        n_left_inputs = left.n_inputs if isinstance(left, Model) else left.shape[1]
+        n_right_inputs = right.n_inputs if isinstance(right, Model) else right.shape[1]
+        combined_matrix = np.zeros((noutp, n_left_inputs + n_right_inputs), dtype=bool)
+
+        left_offset = 0
+        for i, label in enumerate(left_labels):
+            indices = [idx for idx, l in enumerate(left.outputs) if l == label]
+            for row in indices:
+                combined_matrix[i, left_offset:left_offset + cleft.shape[1]] = cleft[row]
+            left_offset += cleft.shape[1]
+
+
+        right_offset = n_left_inputs
+        for i, label in enumerate(right.outputs):
+            indices = [idx for idx, l in enumerate(right_labels) if l == label]
+            for row in indices:
+                combined_matrix[noutp - len(right_labels) + i, right_offset:right_offset + cright.shape[1]] = cright[row]
+            right_offset += cright.shape[1]
+
+        return combined_matrix
+
+    else:
+        return np.hstack([cleft, cright])
 
 
 def _cdot(left, right):
