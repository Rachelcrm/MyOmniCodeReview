{
  "instance_id": "astropy__astropy-12907",
  "mode": "bugfixing",
  "model_name": "gemini/gemini-1.5-pro",
  "full_output": "Patch generated from ACR agentic mode. Source: baselines\\AutoCodeRover\\auto-code-rover\\results\\acr-run-1753671205\\astropy__astropy-12907_2025-07-27_20-53-33\\output_0\\extracted_patch_0.diff",
  "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..da8ee33405 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -220,31 +220,53 @@ def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n \n-    Parameters\n-    ----------\n-    left, right : `astropy.modeling.Model` or ndarray\n-        If input is of an array, it is the output of `coord_matrix`.\n-\n-    Returns\n-    -------\n-    result : ndarray\n-        Result from this operation.\n-\n+    Handles nested CompoundModels correctly.\n     \"\"\"\n+    from astropy.modeling.core import Model\n+    import numpy as np\n+    from .utils import _compute_n_outputs\n+\n     noutp = _compute_n_outputs(left, right)\n \n     if isinstance(left, Model):\n+        left_labels = left.outputs\n         cleft = _coord_matrix(left, 'left', noutp)\n     else:\n         cleft = np.zeros((noutp, left.shape[1]))\n         cleft[: left.shape[0], : left.shape[1]] = left\n+\n     if isinstance(right, Model):\n+        right_labels = right.outputs\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n         cright[-right.shape[0]:, -right.shape[1]:] = 1\n \n-    return np.hstack([cleft, cright])\n+    if any(label.endswith(('0', '1')) for label in left_labels) or \\\n+       any(label.endswith(('0', '1')) for label in right_labels):\n+        n_left_inputs = left.n_inputs if isinstance(left, Model) else left.shape[1]\n+        n_right_inputs = right.n_inputs if isinstance(right, Model) else right.shape[1]\n+        combined_matrix = np.zeros((noutp, n_left_inputs + n_right_inputs), dtype=bool)\n+\n+        left_offset = 0\n+        for i, label in enumerate(left_labels):\n+            indices = [idx for idx, l in enumerate(left.outputs) if l == label]\n+            for row in indices:\n+                combined_matrix[i, left_offset:left_offset + cleft.shape[1]] = cleft[row]\n+            left_offset += cleft.shape[1]\n+\n+\n+        right_offset = n_left_inputs\n+        for i, label in enumerate(right.outputs):\n+            indices = [idx for idx, l in enumerate(right_labels) if l == label]\n+            for row in indices:\n+                combined_matrix[noutp - len(right_labels) + i, right_offset:right_offset + cright.shape[1]] = cright[row]\n+            right_offset += cright.shape[1]\n+\n+        return combined_matrix\n+\n+    else:\n+        return np.hstack([cleft, cright])\n \n \n def _cdot(left, right):\n"
}