{
  "instance_id": "django__django-15503",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "To address the issue of `has_key`, `has_keys`, and `has_any_keys` JSONField() lookups not handling numeric keys on SQLite, MySQL, and Oracle, we need to create a comprehensive test suite. The test suite should cover the functionality of these lookups with both string and numeric keys across different database backends.\n\nHere's how we can structure the test suite:\n\n```\n<file>tests/test_json_field.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nfrom django.db.models import JSONField, Model\nfrom django.test import TestCase\n\nclass JsonFieldModel(Model):\n    data = JSONField()\n\n@pytest.mark.parametrize(\"key\", [\"string_key\", 12345])\ndef test_has_key_lookup(key):\n    JsonFieldModel.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n    result = JsonFieldModel.objects.filter(data__has_key=key).count()\n    assert result == 1\n\n@pytest.mark.parametrize(\"keys\", [[\"string_key\"], [12345]])\ndef test_has_keys_lookup(keys):\n    JsonFieldModel.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n    result = JsonFieldModel.objects.filter(data__has_keys=keys).count()\n    assert result == 1\n\n@pytest.mark.parametrize(\"keys\", [[\"string_key\", 12345]])\ndef test_has_any_keys_lookup(keys):\n    JsonFieldModel.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n    result = JsonFieldModel.objects.filter(data__has_any_keys=keys).count()\n    assert result == 1\n\ndef test_multiple_backends():\n    # Test on SQLite\n    connection = connections[\"default\"]\n    connection.vendor = \"sqlite\"\n    # Your test implementation here\n\n    # Test on MySQL\n    connection.vendor = \"mysql\"\n    # Your test implementation here\n\n    # Test on Oracle\n    connection.vendor = \"oracle\"\n    # Your test implementation here\n</patched>\n```\n\nHowever, to make the test suite more comprehensive and database-agnostic, we can utilize pytest fixtures and parametrize the tests for different database backends.\n\n```\n<file>tests/test_json_field.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nfrom django.db import connections\nfrom django.db.models import JSONField, Model\n\n@pytest.fixture\ndef json_field_model():\n    class JsonFieldModel(Model):\n        data = JSONField()\n    return JsonFieldModel\n\n@pytest.mark.parametrize(\"backend\", [\"sqlite\", \"mysql\", \"oracle\"])\n@pytest.mark.parametrize(\"key\", [\"string_key\", 12345])\ndef test_has_key_lookup(backend, key, json_field_model):\n    connection = connections[\"default\"]\n    connection.vendor = backend\n    json_field_model.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n    result = json_field_model.objects.filter(data__has_key=key).count()\n    assert result == 1\n\n@pytest.mark.parametrize(\"backend\", [\"sqlite\", \"mysql\", \"oracle\"])\n@pytest.mark.parametrize(\"keys\", [[\"string_key\"], [12345]])\ndef test_has_keys_lookup(backend, keys, json_field_model):\n    connection = connections[\"default\"]\n    connection.vendor = backend\n    json_field_model.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n    result = json_field_model.objects.filter(data__has_keys=keys).count()\n    assert result == 1\n\n@pytest.mark.parametrize(\"backend\", [\"sqlite\", \"mysql\", \"oracle\"])\n@pytest.mark.parametrize(\"keys\", [[\"string_key\", 12345]])\ndef test_has_any_keys_lookup(backend, keys, json_field_model):\n    connection = connections[\"default\"]\n    connection.vendor = backend\n    json_field_model.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n    result = json_field_model.objects.filter(data__has_any_keys=keys).count()\n    assert result == 1\n</patched>\n```",
  "patch": "--- a/tests/test_json_field.py\n+++ b/tests/test_json_field.py\n+import pytest\n+from django.db.models import JSONField, Model\n+from django.test import TestCase\n+\n+class JsonFieldModel(Model):\n+    data = JSONField()\n+\n+@pytest.mark.parametrize(\"key\", [\"string_key\", 12345])\n+def test_has_key_lookup(key):\n+    JsonFieldModel.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n+    result = JsonFieldModel.objects.filter(data__has_key=key).count()\n+    assert result == 1\n+\n+@pytest.mark.parametrize(\"keys\", [[\"string_key\"], [12345]])\n+def test_has_keys_lookup(keys):\n+    JsonFieldModel.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n+    result = JsonFieldModel.objects.filter(data__has_keys=keys).count()\n+    assert result == 1\n+\n+@pytest.mark.parametrize(\"keys\", [[\"string_key\", 12345]])\n+def test_has_any_keys_lookup(keys):\n+    JsonFieldModel.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n+    result = JsonFieldModel.objects.filter(data__has_any_keys=keys).count()\n+    assert result == 1\n+\n+def test_multiple_backends():\n+    # Test on SQLite\n+    connection = connections[\"default\"]\n+    connection.vendor = \"sqlite\"\n+    # Your test implementation here\n+\n+    # Test on MySQL\n+    connection.vendor = \"mysql\"\n+    # Your test implementation here\n+\n+    # Test on Oracle\n+    connection.vendor = \"oracle\"\n+    # Your test implementation here\n\n--- a/tests/test_json_field.py\n+++ b/tests/test_json_field.py\n+import pytest\n+from django.db import connections\n+from django.db.models import JSONField, Model\n+\n+@pytest.fixture\n+def json_field_model():\n+    class JsonFieldModel(Model):\n+        data = JSONField()\n+    return JsonFieldModel\n+\n+@pytest.mark.parametrize(\"backend\", [\"sqlite\", \"mysql\", \"oracle\"])\n+@pytest.mark.parametrize(\"key\", [\"string_key\", 12345])\n+def test_has_key_lookup(backend, key, json_field_model):\n+    connection = connections[\"default\"]\n+    connection.vendor = backend\n+    json_field_model.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n+    result = json_field_model.objects.filter(data__has_key=key).count()\n+    assert result == 1\n+\n+@pytest.mark.parametrize(\"backend\", [\"sqlite\", \"mysql\", \"oracle\"])\n+@pytest.mark.parametrize(\"keys\", [[\"string_key\"], [12345]])\n+def test_has_keys_lookup(backend, keys, json_field_model):\n+    connection = connections[\"default\"]\n+    connection.vendor = backend\n+    json_field_model.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n+    result = json_field_model.objects.filter(data__has_keys=keys).count()\n+    assert result == 1\n+\n+@pytest.mark.parametrize(\"backend\", [\"sqlite\", \"mysql\", \"oracle\"])\n+@pytest.mark.parametrize(\"keys\", [[\"string_key\", 12345]])\n+def test_has_any_keys_lookup(backend, keys, json_field_model):\n+    connection = connections[\"default\"]\n+    connection.vendor = backend\n+    json_field_model.objects.create(data={\"string_key\": \"value\", 12345: \"numeric_value\"})\n+    result = json_field_model.objects.filter(data__has_any_keys=keys).count()\n+    assert result == 1\n"
}