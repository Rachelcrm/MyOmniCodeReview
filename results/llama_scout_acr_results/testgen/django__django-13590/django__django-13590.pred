{
  "instance_id": "django__django-13590",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "<file>tests/test_sql_query.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db.models.sql.query import Query\nfrom collections import namedtuple\n\ndef test_resolve_lookup_value_namedtuple():\n    # Create a namedtuple class\n    Point = namedtuple('Point', ['x', 'y'])\n\n    # Create a Query object\n    query = Query()\n\n    # Test that resolve_lookup_value works with namedtuples\n    point = Point(x=1, y=2)\n    resolved_point = query.resolve_lookup_value(point, can_reuse=False, allow_joins=True)\n\n    assert resolved_point == point\n\ndef test_resolve_lookup_value_tuple():\n    # Create a tuple\n    point = (1, 2)\n\n    # Create a Query object\n    query = Query()\n\n    # Test that resolve_lookup_value works with tuples\n    resolved_point = query.resolve_lookup_value(point, can_reuse=False, allow_joins=True)\n\n    assert resolved_point == point\n\ndef test_resolve_lookup_value_list():\n    # Create a list\n    points = [(1, 2), (3, 4)]\n\n    # Create a Query object\n    query = Query()\n\n    # Test that resolve_lookup_value works with lists\n    resolved_points = query.resolve_lookup_value(points, can_reuse=False, allow_joins=True)\n\n    assert resolved_points == points\n\ndef test_resolve_lookup_value_iterator():\n    # Create an iterator\n    points = [(1, 2), (3, 4)]\n\n    # Create a Query object\n    query = Query()\n\n    # Test that resolve_lookup_value works with iterators\n    resolved_points = query.resolve_lookup_value(iter(points), can_reuse=False, allow_joins=True)\n\n    assert list(resolved_points) == points\n\ndef test_resolve_lookup_value_namedtuple_subclass():\n    # Create a namedtuple subclass\n    class Point(namedtuple('Point', ['x', 'y'])):\n        pass\n\n    # Create a Query object\n    query = Query()\n\n    # Test that resolve_lookup_value works with namedtuple subclasses\n    point = Point(x=1, y=2)\n    resolved_point = query.resolve_lookup_value(point, can_reuse=False, allow_joins=True)\n\n    assert resolved_point == point\n\ndef test_resolve_lookup_value_broken_namedtuple():\n    # Create a namedtuple class with __new__ that does not accept iterator\n    class BrokenPoint(namedtuple('BrokenPoint', ['x', 'y'])):\n        def __new__(cls, x, y):\n            return super().__new__(cls, x, y)\n\n    # Create a Query object\n    query = Query()\n\n    # Test that resolve_lookup_value raises TypeError\n    point = BrokenPoint(x=1, y=2)\n    with pytest.raises(TypeError):\n        query.resolve_lookup_value(point, can_reuse=False, allow_joins=True)\n</patched>\n```",
  "patch": "--- a/tests/test_sql_query.py\n+++ b/tests/test_sql_query.py\n-# Empty if creating new file\n+import pytest\n+from django.db.models.sql.query import Query\n+from collections import namedtuple\n+\n+def test_resolve_lookup_value_namedtuple():\n+    # Create a namedtuple class\n+    Point = namedtuple('Point', ['x', 'y'])\n+\n+    # Create a Query object\n+    query = Query()\n+\n+    # Test that resolve_lookup_value works with namedtuples\n+    point = Point(x=1, y=2)\n+    resolved_point = query.resolve_lookup_value(point, can_reuse=False, allow_joins=True)\n+\n+    assert resolved_point == point\n+\n+def test_resolve_lookup_value_tuple():\n+    # Create a tuple\n+    point = (1, 2)\n+\n+    # Create a Query object\n+    query = Query()\n+\n+    # Test that resolve_lookup_value works with tuples\n+    resolved_point = query.resolve_lookup_value(point, can_reuse=False, allow_joins=True)\n+\n+    assert resolved_point == point\n+\n+def test_resolve_lookup_value_list():\n+    # Create a list\n+    points = [(1, 2), (3, 4)]\n+\n+    # Create a Query object\n+    query = Query()\n+\n+    # Test that resolve_lookup_value works with lists\n+    resolved_points = query.resolve_lookup_value(points, can_reuse=False, allow_joins=True)\n+\n+    assert resolved_points == points\n+\n+def test_resolve_lookup_value_iterator():\n+    # Create an iterator\n+    points = [(1, 2), (3, 4)]\n+\n+    # Create a Query object\n+    query = Query()\n+\n+    # Test that resolve_lookup_value works with iterators\n+    resolved_points = query.resolve_lookup_value(iter(points), can_reuse=False, allow_joins=True)\n+\n+    assert list(resolved_points) == points\n+\n+def test_resolve_lookup_value_namedtuple_subclass():\n+    # Create a namedtuple subclass\n+    class Point(namedtuple('Point', ['x', 'y'])):\n+        pass\n+\n+    # Create a Query object\n+    query = Query()\n+\n+    # Test that resolve_lookup_value works with namedtuple subclasses\n+    point = Point(x=1, y=2)\n+    resolved_point = query.resolve_lookup_value(point, can_reuse=False, allow_joins=True)\n+\n+    assert resolved_point == point\n+\n+def test_resolve_lookup_value_broken_namedtuple():\n+    # Create a namedtuple class with __new__ that does not accept iterator\n+    class BrokenPoint(namedtuple('BrokenPoint', ['x', 'y'])):\n+        def __new__(cls, x, y):\n+            return super().__new__(cls, x, y)\n+\n+    # Create a Query object\n+    query = Query()\n+\n+    # Test that resolve_lookup_value raises TypeError\n+    point = BrokenPoint(x=1, y=2)\n+    with pytest.raises(TypeError):\n+        query.resolve_lookup_value(point, can_reuse=False, allow_joins=True)\n"
}