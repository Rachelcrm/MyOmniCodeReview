{
  "instance_id": "django__django-16100",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "To address the issue of adding transaction handling to Changelist list_editable processing, we need to ensure that the `changelist_view` method in Django admin is properly wrapped in a transaction. This will prevent unexpected states in the database in case of errors.\n\nThe first step is to identify the relevant test file where we can add our tests. Based on the provided information, we will create a new test file or modify an existing one to include tests for the `changelist_view` method with transaction handling.\n\n```python\n<file>tests/test_admin_views.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib.admin.views.main import ChangeList\nfrom django.contrib.admin.options import ModelAdmin\nfrom django.db import transaction\nfrom django.test import RequestFactory\n\n@pytest.fixture\ndef request_factory():\n    return RequestFactory()\n\ndef test_changelist_view_transaction(request_factory):\n    \"\"\"\n    Test that changelist_view is wrapped in a transaction.\n    \"\"\"\n    # Create a ModelAdmin instance\n    class TestModelAdmin(ModelAdmin):\n        list_editable = ['field1']\n\n    # Create a request\n    request = request_factory.post('/')\n\n    # Call changelist_view\n    with transaction.atomic():\n        TestModelAdmin().changelist_view(request)\n\n    # Assert that the transaction was committed\n    assert transaction.get_connection().transaction.atomic_rollback\n\ndef test_changelist_view_rollback_on_error(request_factory):\n    \"\"\"\n    Test that changelist_view rolls back the transaction on error.\n    \"\"\"\n    # Create a ModelAdmin instance\n    class TestModelAdmin(ModelAdmin):\n        list_editable = ['field1']\n\n    # Create a request\n    request = request_factory.post('/')\n\n    # Mock an error during save\n    def mock_save_model(self, request, obj, form, change):\n        raise Exception('Mock error')\n\n    TestModelAdmin.save_model = mock_save_model\n\n    # Call changelist_view\n    with pytest.raises(Exception):\n        TestModelAdmin().changelist_view(request)\n\n    # Assert that the transaction was rolled back\n    assert not transaction.get_connection().transaction.atomic_rollback\n</patched>\n```\n\nIn the above code, we have created two test cases: `test_changelist_view_transaction` and `test_changelist_view_rollback_on_error`. The first test checks if the `changelist_view` method is wrapped in a transaction, and the second test checks if the transaction is rolled back in case of an error.\n\nWe also need to modify the `changelist_view` method to include transaction handling:\n\n```python\n<file>django/contrib/admin/options.py</file>\n<original>\n    if formset.is_valid():\n        changecount = 0\n        for form in formset.forms:\n            if form.has_changed():\n                obj = self.save_form(request, form, change=True)\n                self.save_model(request, obj, form, change=True)\n                self.save_related(request, form, formsets=[], change=True)\n                change_msg = self.construct_change_message(request, form, None)\n                self.log_change(request, obj, change_msg)\n                changecount += 1\n</original>\n<patched>\n    if formset.is_valid():\n        changecount = 0\n        with transaction.atomic():\n            for form in formset.forms:\n                if form.has_changed():\n                    obj = self.save_form(request, form, change=True)\n                    self.save_model(request, obj, form, change=True)\n                    self.save_related(request, form, formsets=[], change=True)\n                    change_msg = self.construct_change_message(request, form, None)\n                    self.log_change(request, obj, change_msg)\n                    changecount += 1\n</patched>\n```",
  "patch": "--- a/tests/test_admin_views.py\n+++ b/tests/test_admin_views.py\n-# Empty if creating new file\n+import pytest\n+from django.contrib.admin.views.main import ChangeList\n+from django.contrib.admin.options import ModelAdmin\n+from django.db import transaction\n+from django.test import RequestFactory\n+\n+@pytest.fixture\n+def request_factory():\n+    return RequestFactory()\n+\n+def test_changelist_view_transaction(request_factory):\n+    \"\"\"\n+    Test that changelist_view is wrapped in a transaction.\n+    \"\"\"\n+    # Create a ModelAdmin instance\n+    class TestModelAdmin(ModelAdmin):\n+        list_editable = ['field1']\n+\n+    # Create a request\n+    request = request_factory.post('/')\n+\n+    # Call changelist_view\n+    with transaction.atomic():\n+        TestModelAdmin().changelist_view(request)\n+\n+    # Assert that the transaction was committed\n+    assert transaction.get_connection().transaction.atomic_rollback\n+\n+def test_changelist_view_rollback_on_error(request_factory):\n+    \"\"\"\n+    Test that changelist_view rolls back the transaction on error.\n+    \"\"\"\n+    # Create a ModelAdmin instance\n+    class TestModelAdmin(ModelAdmin):\n+        list_editable = ['field1']\n+\n+    # Create a request\n+    request = request_factory.post('/')\n+\n+    # Mock an error during save\n+    def mock_save_model(self, request, obj, form, change):\n+        raise Exception('Mock error')\n+\n+    TestModelAdmin.save_model = mock_save_model\n+\n+    # Call changelist_view\n+    with pytest.raises(Exception):\n+        TestModelAdmin().changelist_view(request)\n+\n+    # Assert that the transaction was rolled back\n+    assert not transaction.get_connection().transaction.atomic_rollback\n\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n-    if formset.is_valid():\n-        changecount = 0\n-        for form in formset.forms:\n-            if form.has_changed():\n-                obj = self.save_form(request, form, change=True)\n-                self.save_model(request, obj, form, change=True)\n-                self.save_related(request, form, formsets=[], change=True)\n-                change_msg = self.construct_change_message(request, form, None)\n-                self.log_change(request, obj, change_msg)\n-                changecount += 1\n+    if formset.is_valid():\n+        changecount = 0\n+        with transaction.atomic():\n+            for form in formset.forms:\n+                if form.has_changed():\n+                    obj = self.save_form(request, form, change=True)\n+                    self.save_model(request, obj, form, change=True)\n+                    self.save_related(request, form, formsets=[], change=True)\n+                    change_msg = self.construct_change_message(request, form, None)\n+                    self.log_change(request, obj, change_msg)\n+                    changecount += 1\n"
}