{
  "instance_id": "django__django-14493",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "To address the issue with `ManifestStaticFilesStorage` crashing when `max_post_process_passes` is set to 0, we need to create comprehensive tests that cover this scenario. The tests should be written in a way that they can be applied as a git patch to the repository.\n\nHere's how we can approach this:\n\n### Step 1: Identify the Relevant Test File\n\nThe issue is related to `ManifestStaticFilesStorage` and its handling of `max_post_process_passes`. Therefore, we should look into the test files related to static files storage.\n\n### Step 2: Create or Modify Test Files\n\nWe will create a new test file or modify an existing one to include tests for `ManifestStaticFilesStorage` with `max_post_process_passes` set to 0.\n\n### Step 3: Write Comprehensive Tests\n\nOur tests should cover the following:\n- A test that fails when `max_post_process_passes` is set to 0 before the fix is applied.\n- Tests that pass after the fix is applied, verifying that the fix works correctly.\n- Edge cases, such as setting `max_post_process_passes` to a negative number or to 0.\n\nLet's assume we are modifying or creating a test file in `tests/test_staticfiles_storage.py`.\n\n```\n<file>tests/test_staticfiles_storage.py</file>\n<original>\n# Original code here, if any\n</original>\n<patched>\nimport pytest\nfrom django.contrib.staticfiles.storage import ManifestStaticFilesStorage\nfrom django.core.management import call_command\n\n@pytest.fixture\nclass temp_storage:\n    def __init__(self, tmp_path):\n        self.tmp_path = tmp_path\n\n    def __enter__(self):\n        return self.tmp_path\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\ndef test_max_post_process_passes_zero_fails_before_fix(temp_storage):\n    # This test should fail before the fix is applied\n    class MyManifestStaticFilesStorage(ManifestStaticFilesStorage):\n        max_post_process_passes = 0\n\n    with pytest.raises(Exception) as e:\n        call_command('collectstatic', '--noinput', '--clear', storage=MyManifestStaticFilesStorage())\n    assert \"UnboundLocalError\" in str(e.value)\n\ndef test_max_post_process_passes_zero_passes_after_fix(temp_storage):\n    # This test should pass after the fix is applied\n    class MyManifestStaticFilesStorage(ManifestStaticFilesStorage):\n        max_post_process_passes = 0\n\n    call_command('collectstatic', '--noinput', '--clear', storage=MyManifestStaticFilesStorage())\n\ndef test_max_post_process_passes_negative_number(temp_storage):\n    # Test edge case with negative number\n    class MyManifestStaticFilesStorage(ManifestStaticFilesStorage):\n        max_post_process_passes = -1\n\n    call_command('collectstatic', '--noinput', '--clear', storage=MyManifestStaticFilesStorage())\n\ndef test_max_post_process_passes_default(temp_storage):\n    # Test with default max_post_process_passes\n    call_command('collectstatic', '--noinput', '--clear', storage=ManifestStaticFilesStorage())\n</patched>\n```\n\nThis patch includes tests for the scenario when `max_post_process_passes` is set to 0 (which should fail before the fix and pass after), a test for a negative `max_post_process_passes`, and a test with the default `max_post_process_passes` for comparison. \n\nPlease adjust the file paths and test logic according to your project's structure and requirements. \n\nThe goal is to ensure that the tests are comprehensive, cover the bug, and verify the fix correctly.",
  "patch": "--- a/tests/test_staticfiles_storage.py\n+++ b/tests/test_staticfiles_storage.py\n-# Original code here, if any\n+import pytest\n+from django.contrib.staticfiles.storage import ManifestStaticFilesStorage\n+from django.core.management import call_command\n+\n+@pytest.fixture\n+class temp_storage:\n+    def __init__(self, tmp_path):\n+        self.tmp_path = tmp_path\n+\n+    def __enter__(self):\n+        return self.tmp_path\n+\n+    def __exit__(self, exc_type, exc_val, exc_tb):\n+        pass\n+\n+def test_max_post_process_passes_zero_fails_before_fix(temp_storage):\n+    # This test should fail before the fix is applied\n+    class MyManifestStaticFilesStorage(ManifestStaticFilesStorage):\n+        max_post_process_passes = 0\n+\n+    with pytest.raises(Exception) as e:\n+        call_command('collectstatic', '--noinput', '--clear', storage=MyManifestStaticFilesStorage())\n+    assert \"UnboundLocalError\" in str(e.value)\n+\n+def test_max_post_process_passes_zero_passes_after_fix(temp_storage):\n+    # This test should pass after the fix is applied\n+    class MyManifestStaticFilesStorage(ManifestStaticFilesStorage):\n+        max_post_process_passes = 0\n+\n+    call_command('collectstatic', '--noinput', '--clear', storage=MyManifestStaticFilesStorage())\n+\n+def test_max_post_process_passes_negative_number(temp_storage):\n+    # Test edge case with negative number\n+    class MyManifestStaticFilesStorage(ManifestStaticFilesStorage):\n+        max_post_process_passes = -1\n+\n+    call_command('collectstatic', '--noinput', '--clear', storage=MyManifestStaticFilesStorage())\n+\n+def test_max_post_process_passes_default(temp_storage):\n+    # Test with default max_post_process_passes\n+    call_command('collectstatic', '--noinput', '--clear', storage=ManifestStaticFilesStorage())\n"
}