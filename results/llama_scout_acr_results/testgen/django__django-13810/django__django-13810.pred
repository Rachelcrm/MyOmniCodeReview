{
  "instance_id": "django__django-13810",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "<file>tests/test_handlers.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nfrom django.core.exceptions import MiddlewareNotUsed\nfrom django.core.handlers.base import BaseHandler\nfrom django.middleware import MiddlewareMixin\n\nclass SyncMiddleware(MiddlewareMixin):\n    def process_request(self, request):\n        return None\n\nclass AsyncMiddleware(MiddlewareMixin):\n    async def process_request(self, request):\n        return None\n\n@pytest.fixture\ndef base_handler():\n    return BaseHandler()\n\ndef test_load_middleware_sync(base_handler):\n    class TestMiddleware:\n        sync_capable = True\n        async_capable = False\n\n    base_handler.load_middleware(is_async=False)\n    assert base_handler._middleware_chain is not None\n\ndef test_load_middleware_async(base_handler):\n    class TestMiddleware:\n        sync_capable = False\n        async_capable = True\n\n    base_handler.load_middleware(is_async=True)\n    assert base_handler._middleware_chain is not None\n\ndef test_middleware_not_used_sync(base_handler):\n    class TestMiddleware:\n        sync_capable = True\n        async_capable = False\n\n        def __init__(self, get_response):\n            raise MiddlewareNotUsed\n\n    base_handler.load_middleware(is_async=False)\n    assert base_handler._middleware_chain is not None\n\ndef test_middleware_not_used_async(base_handler):\n    class TestMiddleware:\n        sync_capable = False\n        async_capable = True\n\n        def __init__(self, get_response):\n            raise MiddlewareNotUsed\n\n    base_handler.load_middleware(is_async=True)\n    assert base_handler._middleware_chain is not None\n\ndef test_middleware_chain_poisoning(base_handler):\n    # Arrange\n    class TestMiddleware:\n        sync_capable = True\n        async_capable = False\n\n        def __init__(self, get_response):\n            pass\n\n        def process_request(self, request):\n            return 'Invalid response'\n\n    base_handler.settings.MIDDLEWARE = ['tests.test_handlers.TestMiddleware']\n\n    # Act and Assert\n    with pytest.raises(RuntimeError):\n        base_handler.load_middleware(is_async=True)\n</patched>\n</file>\n\n<file>tests/test_integration.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nfrom django.test import RequestFactory\nfrom django.core.handlers.asgi import ASGIHandler\n\n@pytest.mark.asyncio\nasync def test_asgi_middleware_chain():\n    # Arrange\n    request = RequestFactory().get('/test')\n    handler = ASGIHandler()\n\n    # Act\n    response = await handler(request)\n\n    # Assert\n    assert response.status_code == 200\n</patched>\n</file>\n```",
  "patch": "--- a/tests/test_handlers.py\n+++ b/tests/test_handlers.py\n+import pytest\n+from django.core.exceptions import MiddlewareNotUsed\n+from django.core.handlers.base import BaseHandler\n+from django.middleware import MiddlewareMixin\n+\n+class SyncMiddleware(MiddlewareMixin):\n+    def process_request(self, request):\n+        return None\n+\n+class AsyncMiddleware(MiddlewareMixin):\n+    async def process_request(self, request):\n+        return None\n+\n+@pytest.fixture\n+def base_handler():\n+    return BaseHandler()\n+\n+def test_load_middleware_sync(base_handler):\n+    class TestMiddleware:\n+        sync_capable = True\n+        async_capable = False\n+\n+    base_handler.load_middleware(is_async=False)\n+    assert base_handler._middleware_chain is not None\n+\n+def test_load_middleware_async(base_handler):\n+    class TestMiddleware:\n+        sync_capable = False\n+        async_capable = True\n+\n+    base_handler.load_middleware(is_async=True)\n+    assert base_handler._middleware_chain is not None\n+\n+def test_middleware_not_used_sync(base_handler):\n+    class TestMiddleware:\n+        sync_capable = True\n+        async_capable = False\n+\n+        def __init__(self, get_response):\n+            raise MiddlewareNotUsed\n+\n+    base_handler.load_middleware(is_async=False)\n+    assert base_handler._middleware_chain is not None\n+\n+def test_middleware_not_used_async(base_handler):\n+    class TestMiddleware:\n+        sync_capable = False\n+        async_capable = True\n+\n+        def __init__(self, get_response):\n+            raise MiddlewareNotUsed\n+\n+    base_handler.load_middleware(is_async=True)\n+    assert base_handler._middleware_chain is not None\n+\n+def test_middleware_chain_poisoning(base_handler):\n+    # Arrange\n+    class TestMiddleware:\n+        sync_capable = True\n+        async_capable = False\n+\n+        def __init__(self, get_response):\n+            pass\n+\n+        def process_request(self, request):\n+            return 'Invalid response'\n+\n+    base_handler.settings.MIDDLEWARE = ['tests.test_handlers.TestMiddleware']\n+\n+    # Act and Assert\n+    with pytest.raises(RuntimeError):\n+        base_handler.load_middleware(is_async=True)\n\n--- a/tests/test_integration.py\n+++ b/tests/test_integration.py\n+import pytest\n+from django.test import RequestFactory\n+from django.core.handlers.asgi import ASGIHandler\n+\n+@pytest.mark.asyncio\n+async def test_asgi_middleware_chain():\n+    # Arrange\n+    request = RequestFactory().get('/test')\n+    handler = ASGIHandler()\n+\n+    # Act\n+    response = await handler(request)\n+\n+    # Assert\n+    assert response.status_code == 200\n"
}