--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
-def combine(self, rhs, connector):
-    ...
+def combine(self, rhs, connector):
+    ...
+    # Determine which existing joins can be reused. When combining the
+    # query with AND we must recreate all joins for m2m filters. When
+    # combining with OR we can reuse joins. The reason is that in AND
+    # case a single row can't fulfill a condition like:
+    # revrel__col=1 & revrel__col=2
+    # But, there might be two different related rows matching this
+    # condition. In OR case a single True is enough, so single row is
+    # enough, too.
+    #
+    # Note that we will be creating duplicate joins for non-m2m joins in
+    # the AND case. The results will be correct but this creates too many
+    # joins. This is something that could be fixed later on.
+    reuse = set() if conjunction else set(self.alias_map)
+    # Base table must be present in the query - this is the same
+    # table on both sides.
+    self.get_initial_alias()
+    joinpromoter = JoinPromoter(connector, 2, False)
+    joinpromoter.add_votes(
+        j for j in self.alias_map if self.alias_map[j].join_type == INNER)
+    rhs_votes = set()
+    # Now, add the joins from rhs query into the new query (skipping base
+    # table).
+    rhs_tables = list(rhs.alias_map)[1:]
+    for alias in rhs_tables:
+        join = rhs.alias_map[alias]
+        # If the left side of the join was already relabeled, use the
+        # updated alias.
+        join = join.relabeled_clone(change_map)
+        new_alias = self.join(join, reuse=reuse)
+        if join.join_type == INNER:
+            rhs_votes.add(new_alias)
+        # We can't reuse the same join again in the query. If we have two
+        # distinct joins for the same connection in rhs query, then the
+        # combined query must have two joins, too.
+        reuse.discard(new_alias)
+        if alias != new_alias:
+            change_map[alias] = new_alias
+        if not rhs.alias_refcount[alias]:
+            # The alias was unused in the rhs query. Unref it so that it
+            # will be unused in the new query, too. We have to add and
+            # unref the alias so that join promotion has information of
+            # the join type for the unused alias.
+            self.unref_alias(new_alias)
+        joinpromoter.add_votes(rhs_votes)
+    ...

--- a/tests/test_orm.py
+++ b/tests/test_orm.py
-# Original tests
+import pytest
+from django.db.models import Q
+from .models import Foo, Qux
+
+def test_combine_queries_with_or():
+    qux = Qux.objects.create()
+    qs1 = qux.foos.all()
+    qs2 = Foo.objects.filter(
+        Q(bars__baz__in=qux.bazes.all()) | Q(other_bars__baz__in=qux.bazes.all())
+    )
+    combined_qs = qs2 | qs1
+    assert combined_qs.count() == qs1.count() + qs2.count()
+
+def test_combine_queries_with_or_no_duplicates():
+    qux = Qux.objects.create()
+    qs1 = qux.foos.all()
+    qs2 = Foo.objects.filter(
+        Q(bars__baz__in=qux.bazes.all()) | Q(other_bars__baz__in=qux.bazes.all())
+    )
+    combined_qs = qs1 | qs2
+    assert combined_qs.count() == qs1.count() + qs2.count()
