{
  "patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 4b73d52293..9074104325 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -40,7 +40,7 @@ try:\n     from numpy.lib.histograms import histogram_bin_edges\n except ImportError:\n     # this function is new in np 1.15\n-    def histogram_bin_edges(arr, bins, range=None, weights=None):\n+    def histogram_bin_edges(arr, bins, xrange=None, weights=None):\n         # this in True for 1D arrays, and False for None and str\n         if np.ndim(bins) == 1:\n             return bins\n@@ -49,15 +49,15 @@ except ImportError:\n             # rather than backporting the internals, just do the full\n             # computation.  If this is too slow for users, they can\n             # update numpy, or pick a manual number of bins\n-            return np.histogram(arr, bins, range, weights)[1]\n+            return np.histogram(arr, bins, xrange, weights)[1]\n         else:\n             if bins is None:\n                 # hard-code numpy's default\n                 bins = 10\n-            if range is None:\n-                range = np.min(arr), np.max(arr)\n+            if xrange is None:\n+                xrange = np.min(arr), np.max(arr)\n \n-            return np.linspace(*range, bins + 1)\n+            return np.linspace(*xrange, bins + 1)\n \n \n _log = logging.getLogger(__name__)\n@@ -80,7 +80,7 @@ def _make_inset_locator(bounds, trans, parent):\n     _trans = trans\n     _parent = parent\n \n-    def inset_locator(ax, renderer):\n+    def inset_locator():\n         bbox = _bounds\n         bb = mtransforms.TransformedBbox(bbox, _trans)\n         tr = _parent.figure.transFigure.inverted()\n@@ -143,8 +143,8 @@ class Axes(_AxesBase):\n             title = {'left': self._left_title,\n                      'center': self.title,\n                      'right': self._right_title}[loc.lower()]\n-        except KeyError:\n-            raise ValueError(\"'%s' is not a valid location\" % loc)\n+        except KeyError as exc:\n+            raise ValueError(\"'%s' is not a valid location\" % loc) from exc\n         return title.get_text()\n \n     def set_title(self, label, fontdict=None, loc=None, pad=None,\n@@ -196,8 +196,8 @@ class Axes(_AxesBase):\n             title = {'left': self._left_title,\n                      'center': self.title,\n                      'right': self._right_title}[loc.lower()]\n-        except KeyError:\n-            raise ValueError(\"'%s' is not a valid location\" % loc)\n+        except KeyError as exc:\n+            raise ValueError(\"'%s' is not a valid location\" % loc) from exc\n         default = {\n             'fontsize': rcParams['axes.titlesize'],\n             'fontweight': rcParams['axes.titleweight'],\n@@ -292,8 +292,7 @@ class Axes(_AxesBase):\n         \"\"\"\n \n         # pass through to legend.\n-        handles, labels = mlegend._get_legend_handles_labels([self],\n-                legend_handler_map)\n+        handles, labels = mlegend.Legend.from_axes(self, legend_handler_map).get_handles_labels()\n         return handles, labels\n \n     @docstring.dedent_interpd\n@@ -397,10 +396,8 @@ class Axes(_AxesBase):\n         .. plot:: gallery/text_labels_and_annotations/legend.py\n \n         \"\"\"\n-        handles, labels, extra_args, kwargs = mlegend._parse_legend_args(\n-                [self],\n-                *args,\n-                **kwargs)\n+        l = mlegend.Legend(self, *args, **kwargs)\n+        handles, labels = l.get_handles_labels()\n         if len(extra_args):\n             raise TypeError('legend only accepts two non-keyword arguments')\n         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)\n"
}