{
  "patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..fc5efcf119 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -136,6 +136,9 @@ class RawQuery:\n class Query(BaseExpression):\n     \"\"\"A single SQL query.\"\"\"\n \n+    def __init__(self, model, where=WhereNode, alias_cols=True, output_field=None):\n+        super().__init__(output_field)\n+\n     alias_prefix = 'T'\n     subq_aliases = frozenset([alias_prefix])\n \n@@ -229,7 +232,6 @@ class Query(BaseExpression):\n         self.explain_format = None\n         self.explain_options = {}\n \n-    @property\n     def output_field(self):\n         if len(self.select) == 1:\n             select = self.select[0]\n@@ -310,23 +312,10 @@ class Query(BaseExpression):\n         # _annotation_select_cache point to the same underlying objects.\n         # It will get re-populated in the cloned queryset the next time it's\n         # used.\n-        obj._annotation_select_cache = None\n         obj.extra = self.extra.copy()\n-        if self.extra_select_mask is None:\n-            obj.extra_select_mask = None\n-        else:\n-            obj.extra_select_mask = self.extra_select_mask.copy()\n-        if self._extra_select_cache is None:\n-            obj._extra_select_cache = None\n-        else:\n-            obj._extra_select_cache = self._extra_select_cache.copy()\n-        if self.select_related is not False:\n-            # Use deepcopy because select_related stores fields in nested\n-            # dicts.\n-            obj.select_related = copy.deepcopy(obj.select_related)\n-        if 'subq_aliases' in self.__dict__:\n-            obj.subq_aliases = self.subq_aliases.copy()\n-        obj.used_aliases = self.used_aliases.copy()\n+        obj.extra_select_mask = self.extra_select_mask.copy() if self.extra_select_mask else None\n+        obj._extra_select_cache = self._extra_select_cache.copy() if self._extra_select_cache else None\n+        obj.select_related = copy.deepcopy(self.select_related) if self.select_related is not False else False\n         obj._filtered_relations = self._filtered_relations.copy()\n         # Clear the cached_property\n         try:\n@@ -421,7 +410,7 @@ class Query(BaseExpression):\n         existing_annotations = [\n             annotation for alias, annotation\n             in self.annotations.items()\n-            if alias not in added_aggregate_names\n+            if alias not in added_aggregate_names and getattr(annotation, 'contains_aggregate', True)\n         ]\n         # Decide if we need to use a subquery.\n         #\n"
}