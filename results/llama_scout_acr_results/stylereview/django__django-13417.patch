{
  "patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 85cd8311a7..43f5f3c333 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -218,7 +218,7 @@ class QuerySet:\n         # Address the circular dependency between `Queryset` and `Manager`.\n         from django.db.models.manager import Manager\n         manager = Manager.from_queryset(cls)()\n-        manager._built_with_as_manager = True\n+        manager.__dict__['_built_with_as_manager'] = True\n         return manager\n     as_manager.queryset_only = True\n     as_manager = classmethod(as_manager)\n@@ -327,7 +327,8 @@ class QuerySet:\n         return qs._result_cache[0]\n \n     def __class_getitem__(cls, *args, **kwargs):\n-        return cls\n+        # Avoid shadowing type.__class_getitem__ for Python 3.7\n+        return super().__class_getitem__(*args, **kwargs)\n \n     def __and__(self, other):\n         self._merge_sanity_check(other)\n@@ -375,7 +376,7 @@ class QuerySet:\n         \"\"\"\n         Return a dictionary containing the calculations (aggregation)\n         over the current queryset.\n-\n+        \n         If args is present the expression is passed as a kwarg using\n         the Aggregate object's default alias.\n         \"\"\"\n@@ -388,10 +389,10 @@ class QuerySet:\n             # attribute.\n             try:\n                 arg.default_alias\n-            except (AttributeError, TypeError):\n-                raise TypeError(\"Complex aggregates require an alias\")\n+            except (AttributeError, TypeError) as e:\n+                raise TypeError(\"Complex aggregates require an alias\") from e\n             kwargs[arg.default_alias] = arg\n-\n+        \n         query = self.query.chain()\n         for (alias, aggregate_expr) in kwargs.items():\n             query.add_annotation(aggregate_expr, alias, is_summary=True)\n"
}