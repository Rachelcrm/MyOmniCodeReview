{
  "patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..471469fb2e 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -100,7 +100,7 @@ def apply_limit_choices_to_to_formfield(formfield):\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            formfield.queryset = formfield.queryset.filter(limit_choices_to)\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n@@ -1251,13 +1251,18 @@ class ModelChoiceField(ChoiceField):\n             return self._choices\n \n         # Otherwise, execute the QuerySet in self.queryset to determine the\n-        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n+        # choices dynamically. Apply limit_choices_to if needed.\n+        queryset = self.queryset\n+        if self.limit_choices_to is not None:\n+            queryset = queryset.complex_filter(self.limit_choices_to)\n+\n+        # Return a fresh ModelChoiceIterator that has not been\n         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n         # time _get_choices() is called (and, thus, each time self.choices is\n         # accessed) so that we can ensure the QuerySet has not been consumed. This\n         # construct might look complicated but it allows for lazy evaluation of\n         # the queryset.\n-        return self.iterator(self)\n+        return self.iterator(queryset)\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n"
}