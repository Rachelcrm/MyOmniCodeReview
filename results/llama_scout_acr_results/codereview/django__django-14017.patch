{
  "patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..d4fb17a49c 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,7 +40,29 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n+        if isinstance(other, Q):\n+            # If the other Q() is empty, ignore it and just use `self`.\n+            if not other:\n+                _, args, kwargs = self.deconstruct()\n+                return type(self)(*args, **kwargs)\n+            # Or if this Q is empty, ignore it and just use `other`.\n+            elif not self:\n+                _, args, kwargs = other.deconstruct()\n+                return type(other)(*args, **kwargs)\n+\n+            obj = type(self)()\n+            obj.connector = conn\n+            obj.add(self, conn)\n+            obj.add(other, conn)\n+            return obj\n+        elif hasattr(other, 'conditional') and other.conditional:\n+            # Handle combining with other conditional objects like Exists\n+            obj = type(self)()\n+            obj.connector = conn\n+            obj.add(self, conn)\n+            obj.add(other, conn)\n+            return obj\n+        else:\n             raise TypeError(other)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n@@ -64,6 +86,12 @@ class Q(tree.Node):\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __ror__(self, other):\n+        return self._combine(other, self.OR)\n+\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n"
}