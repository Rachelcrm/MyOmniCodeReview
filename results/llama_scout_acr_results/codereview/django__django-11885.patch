{
  "patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..e348d13bce 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -227,22 +227,18 @@ class Collector:\n                     if self.can_fast_delete(sub_objs, from_field=field):\n                         self.fast_deletes.append(sub_objs)\n                     else:\n-                        related_model = related.related_model\n-                        # Non-referenced fields can be deferred if no signal\n-                        # receivers are connected for the related model as\n-                        # they'll never be exposed to the user. Skip field\n-                        # deferring when some relationships are select_related\n-                        # as interactions between both features are hard to\n-                        # get right. This should only happen in the rare\n-                        # cases where .related_objects is overridden anyway.\n-                        if not (sub_objs.query.select_related or self._has_signal_listeners(related_model)):\n-                            referenced_fields = set(chain.from_iterable(\n-                                (rf.attname for rf in rel.field.foreign_related_fields)\n-                                for rel in get_candidate_relations_to_delete(related_model._meta)\n-                            ))\n-                            sub_objs = sub_objs.only(*tuple(referenced_fields))\n-                        if sub_objs:\n-                            field.remote_field.on_delete(self, field, sub_objs, self.using)\n+                        or_queries = []\n+                        for sub_batch in self.get_del_batches(sub_objs, field):\n+                            sub_query = sql.Query()\n+                            sub_query.add_filter(\n+                                \"%s__in\" % field.name,\n+                                [obj.pk for obj in sub_batch]\n+                            )\n+                            or_queries.append(sub_query)\n+                        if or_queries:\n+                            combined_query = sql.Query()\n+                            combined_query.add_filters(or_queries, connector=sql.OR)\n+                            self.fast_deletes.append(related.related_model._base_manager.using(self.using).filter(combined_query))\n             for field in model._meta.private_fields:\n                 if hasattr(field, 'bulk_related_objects'):\n                     # It's something like generic foreign key.\n@@ -309,10 +305,13 @@ class Collector:\n                         sender=model, instance=obj, using=self.using\n                     )\n \n-            # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                    # fast deletes\n+                    for qs in self.fast_deletes:\n+                        if isinstance(qs, QuerySet):\n+                            count = qs._raw_delete(using=self.using)\n+                        else:\n+                            count = qs.delete_batch([], self.using)\n+                        deleted_counter[qs.model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n"
}