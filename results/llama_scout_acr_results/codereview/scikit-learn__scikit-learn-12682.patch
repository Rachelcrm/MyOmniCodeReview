{
  "patch": "diff --git a/sklearn/decomposition/dict_learning.py b/sklearn/decomposition/dict_learning.py\nindex a318c957f..3a0e4b267 100644\n--- a/sklearn/decomposition/dict_learning.py\n+++ b/sklearn/decomposition/dict_learning.py\n@@ -950,13 +950,16 @@ class SparseCoder(BaseEstimator, SparseCodingMixin):\n         and is overridden by `alpha` in the `omp` case.\n \n     transform_alpha : float, 1. by default\n-        If `algorithm='lasso_lars'` or `algorithm='lasso_cd'`, `alpha` is the\n-        penalty applied to the L1 norm.\n-        If `algorithm='threshold'`, `alpha` is the absolute value of the\n-        threshold below which coefficients will be squashed to zero.\n-        If `algorithm='omp'`, `alpha` is the tolerance parameter: the value of\n-        the reconstruction error targeted. In this case, it overrides\n-        `n_nonzero_coefs`.\n+         If `algorithm='lasso_lars'` or `algorithm='lasso_cd'`, `alpha` is the\n+         penalty applied to the L1 norm.\n+         If `algorithm='threshold'`, `alpha` is the absolute value of the\n+         threshold below which coefficients will be squashed to zero.\n+         If `algorithm='omp'`, `alpha` is the tolerance parameter: the value of\n+         the reconstruction error targeted. In this case, it overrides\n+         `n_nonzero_coefs`.\n+\n+    transform_max_iter : int, 1000 by default\n+         Maximum number of iterations to perform if `algorithm='lasso_cd'`.\n \n     split_sign : bool, False by default\n         Whether to split the sparse feature vector into the concatenation of\n@@ -991,12 +994,13 @@ class SparseCoder(BaseEstimator, SparseCodingMixin):\n \n     def __init__(self, dictionary, transform_algorithm='omp',\n                  transform_n_nonzero_coefs=None, transform_alpha=None,\n-                 split_sign=False, n_jobs=None, positive_code=False):\n+                 transform_max_iter=1000, split_sign=False, n_jobs=None, \n+                 positive_code=False):\n         self._set_sparse_coding_params(dictionary.shape[0],\n-                                       transform_algorithm,\n-                                       transform_n_nonzero_coefs,\n-                                       transform_alpha, split_sign, n_jobs,\n-                                       positive_code)\n+                                        transform_algorithm,\n+                                        transform_n_nonzero_coefs,\n+                                        transform_alpha, transform_max_iter,\n+                                        split_sign, n_jobs, positive_code)\n         self.components_ = dictionary\n \n     def fit(self, X, y=None):\n"
}