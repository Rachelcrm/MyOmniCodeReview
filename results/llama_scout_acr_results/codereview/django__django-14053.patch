{
  "patch": "To address the issue of `HashedFilesMixin's` `post_process()` yielding multiple times for the same file, we need to understand the root cause of this behavior. The method is designed to perform multiple passes over the files to ensure that nested references between them are correctly handled. However, it currently yields the same file multiple times if it requires multiple passes, which can lead to incorrect statistics and duplicated work.\n\nThe key insight here is that we want `post_process()` to yield each file only once, after it has been fully processed. This means we need to keep track of which files have already been yielded and avoid yielding them again.\n\nHere's the step-by-step reasoning:\n\n1. **Identify the Yield Statement**: The `yield` statement in question is inside the `for` loop that iterates over the results of `self._post_process(paths, adjustable_paths, hashed_files)`. This loop can potentially yield the same file multiple times if the file requires multiple processing passes.\n\n2. **Track Processed Files**: To ensure that each file is only yielded once, we need to keep track of the files that have already been processed and yielded.\n\n3. **Modify the Loop**: We should modify the loop so that it checks if a file has already been yielded before yielding it again.\n\nGiven this reasoning, the solution involves modifying the `post_process` method in `HashedFilesMixin` to keep track of processed files.\n\n```\n<file>django/contrib/staticfiles/storage.py</file>\n<original>\n221         # where to store the new paths\n222         hashed_files = {}\n223 \n224         # build a list of adjustable files\n225         adjustable_paths = [\n226             path for path in paths\n227             if matches_patterns(path, self._patterns)\n228         ]\n229         # Do a single pass first. Post-process all files once, then repeat for\n230         # adjustable files.\n231         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):\n232             yield name, hashed_name, processed\n233 \n234         paths = {path: paths[path] for path in adjustable_paths}\n235 \n236         for i in range(self.max_post_process_passes):\n237             substitutions = False\n238             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\n239                 yield name, hashed_name, processed\n240                 substitutions = substitutions or subst\n</original>\n<patched>\n221         # where to store the new paths\n222         hashed_files = {}\n223         processed_files = set()\n224 \n225         # build a list of adjustable files\n226         adjustable_paths = [\n227             path for path in paths\n228             if matches_patterns(path, self._patterns)\n229         ]\n230         # Do a single pass first. Post-process all files once, then repeat for\n231         # adjustable files.\n232         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):\n233             if name not in processed_files:\n234                 yield name, hashed_name, processed\n235                 processed_files.add(name)\n236 \n237         paths = {path: paths[path] for path in adjustable_paths}\n238 \n239         for i in range(self.max_post_process_passes):\n240             substitutions = False\n241             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\n242                 if name not in processed_files:\n243                     yield name, hashed_name, processed\n244                     processed_files.add(name)\n245                 substitutions = substitutions or subst\n</patched>\n```"
}