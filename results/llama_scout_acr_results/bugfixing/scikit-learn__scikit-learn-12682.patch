{
  "patch": "diff --git a/sklearn/decomposition/dict_learning.py b/sklearn/decomposition/dict_learning.py\nindex a318c957f..e9f6ae8b0 100644\n--- a/sklearn/decomposition/dict_learning.py\n+++ b/sklearn/decomposition/dict_learning.py\n@@ -862,17 +862,19 @@ class SparseCodingMixin(TransformerMixin):\n     \"\"\"Sparse coding mixin\"\"\"\n \n     def _set_sparse_coding_params(self, n_components,\n-                                  transform_algorithm='omp',\n-                                  transform_n_nonzero_coefs=None,\n-                                  transform_alpha=None, split_sign=False,\n-                                  n_jobs=None, positive_code=False):\n-        self.n_components = n_components\n-        self.transform_algorithm = transform_algorithm\n-        self.transform_n_nonzero_coefs = transform_n_nonzero_coefs\n-        self.transform_alpha = transform_alpha\n-        self.split_sign = split_sign\n-        self.n_jobs = n_jobs\n-        self.positive_code = positive_code\n+                                   transform_algorithm='omp',\n+                                   transform_n_nonzero_coefs=None,\n+                                   transform_alpha=None, transform_max_iter=1000,\n+                                   split_sign=False, n_jobs=None, \n+                                   positive_code=False):\n+            self.n_components = n_components\n+            self.transform_algorithm = transform_algorithm\n+            self.transform_n_nonzero_coefs = transform_n_nonzero_coefs\n+            self.transform_alpha = transform_alpha\n+            self.transform_max_iter = transform_max_iter\n+            self.split_sign = split_sign\n+            self.n_jobs = n_jobs\n+            self.positive_code = positive_code\n \n     def transform(self, X):\n         \"\"\"Encode the data as a sparse combination of the dictionary atoms.\n@@ -958,6 +960,10 @@ class SparseCoder(BaseEstimator, SparseCodingMixin):\n         the reconstruction error targeted. In this case, it overrides\n         `n_nonzero_coefs`.\n \n+    transform_max_iter : int, 1000 by default\n+        Maximum number of iterations to perform if `algorithm='lasso_cd'`\n+        or `algorithm='lasso_lars`.\n+\n     split_sign : bool, False by default\n         Whether to split the sparse feature vector into the concatenation of\n         its negative part and its positive part. This can improve the\n@@ -991,13 +997,14 @@ class SparseCoder(BaseEstimator, SparseCodingMixin):\n \n     def __init__(self, dictionary, transform_algorithm='omp',\n                  transform_n_nonzero_coefs=None, transform_alpha=None,\n-                 split_sign=False, n_jobs=None, positive_code=False):\n-        self._set_sparse_coding_params(dictionary.shape[0],\n-                                       transform_algorithm,\n-                                       transform_n_nonzero_coefs,\n-                                       transform_alpha, split_sign, n_jobs,\n-                                       positive_code)\n-        self.components_ = dictionary\n+                 transform_max_iter=1000, split_sign=False, n_jobs=None, \n+                 positive_code=False):\n+            self._set_sparse_coding_params(dictionary.shape[0],\n+                                           transform_algorithm,\n+                                           transform_n_nonzero_coefs,\n+                                           transform_alpha, transform_max_iter,\n+                                           split_sign, n_jobs, positive_code)\n+            self.components_ = dictionary\n \n     def fit(self, X, y=None):\n         \"\"\"Do nothing and return the estimator unchanged\n"
}