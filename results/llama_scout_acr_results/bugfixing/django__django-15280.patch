{
  "patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 0d50dad0c9..e52e5b6526 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -622,23 +622,28 @@ class Model(metaclass=ModelBase):\n         \"\"\"\n         Return a set containing names of deferred fields for this instance.\n         \"\"\"\n-        return {\n+        deferred_fields = {\n             f.attname for f in self._meta.concrete_fields\n             if f.attname not in self.__dict__\n         }\n+        # Check for prefetched fields\n+        for field in self._meta.private_fields:\n+            if field.prefetch_cache_name in self.__dict__:\n+                deferred_fields &= set(self.__dict__[field.prefetch_cache_name].keys())\n+        return deferred_fields\n \n     def refresh_from_db(self, using=None, fields=None):\n         \"\"\"\n         Reload field values from the database.\n-\n+        \n         By default, the reloading happens from the database this instance was\n         loaded from, or by the read router if this instance wasn't loaded from\n         any database. The using parameter will override the default.\n-\n+        \n         Fields can be used to specify which fields to reload. The fields\n         should be an iterable of field attnames. If fields is None, then\n         all non-deferred fields are reloaded.\n-\n+        \n         When accessing deferred fields of an instance, the deferred loading\n         of the field will call this method.\n         \"\"\"\n@@ -646,7 +651,7 @@ class Model(metaclass=ModelBase):\n             self._prefetched_objects_cache = {}\n         else:\n             prefetched_objects_cache = getattr(self, '_prefetched_objects_cache', ())\n-            for field in fields:\n+            for field in list(fields):\n                 if field in prefetched_objects_cache:\n                     del prefetched_objects_cache[field]\n                     fields.remove(field)\n"
}