{
  "patch": "Looking at the issue, the problem is in the `resolve_lookup_value` method in `django/db/models/sql/query.py`. When it encounters a namedtuple, it tries to reconstruct it using `type(value)(generator)`, but namedtuples expect individual arguments, not an iterable.\n\nThe issue occurs at lines 1080-1083 where the code uses:\n```python\nreturn type(value)(\n    self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n    for sub_value in value\n)\n```\n\nFor namedtuples, this fails because namedtuple constructors don't accept iterators directly. They need either individual arguments or to use the `_make()` class method.\n\nThe solution is to detect if the value is a namedtuple (by checking for the `_fields` attribute) and handle it specially using the `_make()` method, while preserving the existing behavior for regular tuples and lists.\n\n```\n<file>django/db/models/sql/query.py</file>\n<original>\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            return type(value)(\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n        return value\n</original>\n<patched>\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = [\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            ]\n            # Check if this is a namedtuple by looking for the _fields attribute\n            if hasattr(value, '_fields'):\n                # Use _make() for namedtuples since they can't be constructed from iterators\n                return type(value)._make(resolved_values)\n            else:\n                # Regular tuple or list\n                return type(value)(resolved_values)\n        return value\n</patched>\n```\n\nThis patch:\n\n1. **Detects namedtuples** by checking for the `_fields` attribute, which is present on all namedtuples but not on regular tuples or lists.\n\n2. **Resolves sub-values first** into a list to avoid consuming the generator multiple times.\n\n3. **Uses `_make()` for namedtuples** which is the proper way to construct a namedtuple from an iterable.\n\n4. **Preserves existing behavior** for regular tuples and lists by using `type(value)(resolved_values)`.\n\n5. **Maintains functionality** by ensuring all sub-values are still resolved through the recursive call to `resolve_lookup_value`.\n\nThis solution addresses the core issue where namedtuple constructors cannot accept iterators directly, while maintaining backward compatibility for all other tuple and list types."
}