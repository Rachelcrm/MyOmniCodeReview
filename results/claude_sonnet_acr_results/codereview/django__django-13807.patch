{
  "patch": "Looking at the issue, the problem is that SQLite's `PRAGMA foreign_key_check` and `PRAGMA foreign_key_list` statements fail when table names are SQL keywords because the table names are not properly quoted. The issue occurs in the SQLite backend's `check_constraints` method.\n\nLet me examine the code context to find the SQLite-specific implementation. From the issue description, the problem is in `django/db/backends/sqlite3/base.py` at line 327 in the `check_constraints` function, but I don't see that file in the provided locations. However, I can see that the other database backends (MySQL, Oracle, PostgreSQL) have their own `check_constraints` implementations.\n\nLooking at the issue more carefully, it mentions that the problem is specifically with SQLite and the PRAGMA statements not quoting table names properly. The error occurs in:\n- `PRAGMA foreign_key_check(%s)` \n- `PRAGMA foreign_key_list(%s)`\n\nSince I don't see the SQLite backend file in the provided locations, I need to look for where this might be implemented. Based on the error traceback and the intended behavior descriptions, it seems like the issue is that table names need to be quoted using `self.ops.quote_name()` when used in SQL statements.\n\nHowever, looking at the provided locations, I notice that the intended behavior descriptions for locations #1, #2, and #3 all mention the same line numbers (330, 336, 341-343) which suggests these are referring to the SQLite implementation that's not shown in the provided code.\n\nSince the issue specifically mentions SQLite and the error occurs in `django/db/backends/sqlite3/base.py`, and the provided locations don't include this file, I need to infer what the SQLite implementation looks like based on the error message and the intended behavior.\n\nBased on the error message and the pattern from other database backends, the SQLite `check_constraints` method likely looks similar to the MySQL implementation but uses PRAGMA statements instead of SELECT statements.\n\nLet me create a patch for the SQLite backend based on the error description:\n\n```\n<file>django/db/backends/sqlite3/base.py</file>\n<original>\n    def check_constraints(self, table_names=None):\n        \"\"\"\n        Check each table name in `table_names` for rows with invalid foreign\n        key references. This method is intended to be used in conjunction with\n        `disable_constraint_checking()` and `enable_constraint_checking()`, to\n        determine if rows with invalid references were entered while constraint\n        checks were off.\n        \"\"\"\n        with self.cursor() as cursor:\n            if table_names is None:\n                violations = cursor.execute('PRAGMA foreign_key_check').fetchall()\n            else:\n                violations = chain.from_iterable(\n                    cursor.execute('PRAGMA foreign_key_check(%s)' % table_name).fetchall()\n                    for table_name in table_names\n                )\n            for table_name, rowid, referenced_table_name, foreign_key_index in violations:\n                foreign_key = cursor.execute(\n                    'PRAGMA foreign_key_list(%s)' % table_name\n                ).fetchall()[foreign_key_index]\n                column_name, referenced_column_name = foreign_key[3:5]\n                primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n                primary_key_value, bad_value = cursor.execute(\n                    'SELECT %s, %s FROM %s WHERE rowid = %%s' % (\n                        primary_key_column_name, column_name, table_name,\n                    ),\n                    (rowid,)\n                ).fetchone()\n                raise IntegrityError(\n                    \"The row in table '%s' with primary key '%s' has an invalid \"\n                    \"foreign key: %s.%s contains a value '%s' that does not \"\n                    \"have a corresponding value in %s.%s.\"\n                    % (\n                        table_name, primary_key_value, table_name, column_name,\n                        bad_value, referenced_table_name, referenced_column_name,\n                    )\n                )\n</original>\n<patched>\n    def check_constraints(self, table_names=None):\n        \"\"\"\n        Check each table name in `table_names` for rows with invalid foreign\n        key references. This method is intended to be used in conjunction with\n        `disable_constraint_checking()` and `enable_constraint_checking()`, to\n        determine if rows with invalid references were entered while constraint\n        checks were off.\n        \"\"\"\n        with self.cursor() as cursor:\n            if table_names is None:\n                violations = cursor.execute('PRAGMA foreign_key_check').fetchall()\n            else:\n                violations = chain.from_iterable(\n                    cursor.execute('PRAGMA foreign_key_check(%s)' % self.ops.quote_name(table_name)).fetchall()\n                    for table_name in table_names\n                )\n            for table_name, rowid, referenced_table_name, foreign_key_index in violations:\n                foreign_key = cursor.execute(\n                    'PRAGMA foreign_key_list(%s)' % self.ops.quote_name(table_name)\n                ).fetchall()[foreign_key_index]\n                column_name, referenced_column_name = foreign_key[3:5]\n                primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n                primary_key_value, bad_value = cursor.execute(\n                    'SELECT %s, %s FROM %s WHERE rowid = %%s' % (\n                        self.ops.quote_name(primary_key_column_name), self.ops.quote_name(column_name), self.ops.quote_name(table_name),\n                    ),\n                    (rowid,)\n                ).fetchone()\n                raise IntegrityError(\n                    \"The row in table '%s' with primary key '%s' has an invalid \"\n                    \"foreign key: %s.%s contains a value '%s' that does not \"\n                    \"have a corresponding value in %s.%s.\"\n                    % (\n                        table_name, primary_key_value, table_name, column_name,\n                        bad_value, referenced_table_name, referenced_column_name,\n                    )\n                )\n</patched>\n```\n\nThe key changes in this patch are:\n\n1. **Line with `PRAGMA foreign_key_check(%s)`**: Changed from `'PRAGMA foreign_key_check(%s)' % table_name` to `'PRAGMA foreign_key_check(%s)' % self.ops.quote_name(table_name)` to properly quote the table name.\n\n2. **Line with `PRAGMA foreign_key_list(%s)`**: Changed from `'PRAGMA foreign_key_list(%s)' % table_name` to `'PRAGMA foreign_key_list(%s)' % self.ops.quote_name(table_name)` to properly quote the table name.\n\n3. **SELECT statement**: Changed from `'SELECT %s, %s FROM %s WHERE rowid = %%s' % (primary_key_column_name, column_name, table_name,)` to `'SELECT %s, %s FROM %s WHERE rowid = %%s' % (self.ops.quote_name(primary_key_column_name), self.ops.quote_name(column_name), self.ops.quote_name(table_name),)` to properly quote all identifiers.\n\nThese changes ensure that table names and column names that are SQL keywords (like \"order\") are properly quoted when used in SQL statements, preventing syntax errors in SQLite."
}