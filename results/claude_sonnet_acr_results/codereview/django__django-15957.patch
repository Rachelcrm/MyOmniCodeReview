{
  "patch": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex b192df4fbf..097dbe7780 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,6 +72,33 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+def _handle_sliced_queryset_for_prefetch(queryset, query_dict):\n+    \"\"\"\n+    Handle filtering of potentially sliced querysets for prefetch operations.\n+    \n+    If the queryset is sliced, temporarily remove the slice, apply the filter,\n+    and then reapply the slice. This avoids the \"Cannot filter a query once \n+    a slice has been taken\" error.\n+    \"\"\"\n+    if queryset.query.is_sliced:\n+        # Extract slice information\n+        start = queryset.query.low_mark\n+        stop = queryset.query.high_mark\n+        \n+        # Create an unsliced clone\n+        clone = queryset._chain()\n+        clone.query.clear_limits()\n+        \n+        # Apply the filter to the unsliced queryset\n+        filtered_queryset = clone.filter(**query_dict)\n+        \n+        # Reapply the slice\n+        return filtered_queryset[start:stop]\n+    else:\n+        # No slice, apply filter normally\n+        return queryset.filter(**query_dict)\n+\n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(\n@@ -145,7 +172,7 @@ class ForwardManyToOneDescriptor:\n             }\n         else:\n             query = {\"%s__in\" % self.field.related_query_name(): instances}\n-        queryset = queryset.filter(**query)\n+        queryset = _handle_sliced_queryset_for_prefetch(queryset, query)\n \n         # Since we're going to assign directly in the cache,\n         # we must manage the reverse relation cache manually.\n@@ -404,7 +431,7 @@ class ReverseOneToOneDescriptor:\n         instance_attr = self.related.field.get_foreign_related_value\n         instances_dict = {instance_attr(inst): inst for inst in instances}\n         query = {\"%s__in\" % self.related.field.name: instances}\n-        queryset = queryset.filter(**query)\n+        queryset = _handle_sliced_queryset_for_prefetch(queryset, query)\n \n         # Since we're going to assign directly in the cache,\n         # we must manage the reverse relation cache manually.\n@@ -719,7 +746,7 @@ def create_reverse_many_to_one_manager(superclass, rel):\n             instance_attr = self.field.get_foreign_related_value\n             instances_dict = {instance_attr(inst): inst for inst in instances}\n             query = {\"%s__in\" % self.field.name: instances}\n-            queryset = queryset.filter(**query)\n+            queryset = _handle_sliced_queryset_for_prefetch(queryset, query)\n \n             # Since we just bypassed this class' get_queryset(), we must manage\n             # the reverse relation manually.\n@@ -1052,7 +1079,7 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n             queryset = queryset.using(queryset._db or self._db)\n \n             query = {\"%s__in\" % self.query_field_name: instances}\n-            queryset = queryset._next_is_sticky().filter(**query)\n+            queryset = _handle_sliced_queryset_for_prefetch(queryset._next_is_sticky(), query)\n \n             # M2M: need to annotate the query in order to get the primary model\n             # that the secondary model was actually related to. We know that\n"
}