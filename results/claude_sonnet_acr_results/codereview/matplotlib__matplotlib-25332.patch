{
  "patch": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..53fbf81d3b 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -846,6 +846,56 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Prepare the object for pickling by converting weak references to strong references.\"\"\"\n+        self.clean()  # Remove any dead weak references first\n+        \n+        # Convert the weak reference mapping to strong references for pickling\n+        # We need to preserve the grouping structure\n+        strong_mapping = {}\n+        processed_groups = set()\n+        \n+        for key, group in self._mapping.items():\n+            # Get the actual object from the weak reference\n+            key_obj = key()\n+            if key_obj is None:\n+                continue  # Skip dead references\n+                \n+            # Convert the group ID to avoid processing the same group multiple times\n+            group_id = id(group)\n+            if group_id in processed_groups:\n+                continue\n+            processed_groups.add(group_id)\n+            \n+            # Convert weak references in the group to strong references\n+            strong_group = []\n+            for weak_ref in group:\n+                obj = weak_ref()\n+                if obj is not None:\n+                    strong_group.append(obj)\n+            \n+            # Store one representative from each group\n+            if strong_group:\n+                strong_mapping[id(strong_group)] = strong_group\n+        \n+        return {'groups': list(strong_mapping.values())}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore the object after unpickling by converting strong references back to weak references.\"\"\"\n+        # Reconstruct the weak reference mapping from the strong references\n+        self._mapping = {}\n+        \n+        for group in state['groups']:\n+            if not group:\n+                continue\n+                \n+            # Create weak references for all objects in the group\n+            weak_group = [weakref.ref(obj) for obj in group]\n+            \n+            # Map each weak reference to the same group list\n+            for weak_ref in weak_group:\n+                self._mapping[weak_ref] = weak_group\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\n"
}