{
  "patch": "diff --git a/sklearn/metrics/_ranking.py b/sklearn/metrics/_ranking.py\nindex 0cdead9233..1c2a73af58 100644\n--- a/sklearn/metrics/_ranking.py\n+++ b/sklearn/metrics/_ranking.py\n@@ -1019,7 +1019,9 @@ def roc_curve(\n     thresholds : ndarray of shape = (n_thresholds,)\n         Decreasing thresholds on the decision function used to compute\n         fpr and tpr. `thresholds[0]` represents no instances being predicted\n-        and is arbitrarily set to `max(y_score) + 1`.\n+        and is arbitrarily set to `max(y_score) + 1`. For probability estimates\n+        (when all y_score values are between 0 and 1), this threshold is capped\n+        at 1.0.\n \n     See Also\n     --------\n@@ -1083,7 +1085,13 @@ def roc_curve(\n     # to make sure that the curve starts at (0, 0)\n     tps = np.r_[0, tps]\n     fps = np.r_[0, fps]\n-    thresholds = np.r_[thresholds[0] + 1, thresholds]\n+    \n+    # Check if y_score appears to be probability estimates (all values between 0 and 1)\n+    # If so, cap the threshold at 1.0 to avoid exceeding probability bounds\n+    if np.all((y_score >= 0) & (y_score <= 1)):\n+        thresholds = np.r_[min(thresholds[0] + 1, 1.0), thresholds]\n+    else:\n+        thresholds = np.r_[thresholds[0] + 1, thresholds]\n \n     if fps[-1] <= 0:\n         warnings.warn(\n"
}