{
  "patch": "Looking at the issue, the problem is that when searching with multiple words in the Django admin, each word creates a separate `queryset.filter()` call. When search fields include related fields (like `clientoffice__name`), this results in multiple JOINs to the same table, causing performance issues.\n\nThe current code in `get_search_results` method processes each search term individually:\n\n```python\nfor bit in smart_split(search_term):\n    # ... process bit ...\n    or_queries = models.Q(...)\n    queryset = queryset.filter(or_queries)  # This creates a separate JOIN for each word\n```\n\nThe solution is to collect all the Q objects first and then apply them in a single filter call. This way, Django's ORM can optimize the query and avoid duplicate JOINs.\n\nHere's the reasoning:\n1. Instead of calling `queryset.filter()` for each search word, we need to build all Q objects first\n2. Combine them using AND logic (all words must match) \n3. Apply all filters in a single `queryset.filter()` call\n4. This preserves the existing search functionality while eliminating duplicate JOINs\n\n```\n<file>django/contrib/admin/options.py</file>\n<original>        may_have_duplicates = False\n        search_fields = self.get_search_fields(request)\n        if search_fields and search_term:\n            orm_lookups = [construct_search(str(search_field))\n                           for search_field in search_fields]\n            for bit in smart_split(search_term):\n                if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                    bit = unescape_string_literal(bit)\n                or_queries = models.Q(\n                    *((orm_lookup, bit) for orm_lookup in orm_lookups),\n                    _connector=models.Q.OR,\n                )\n                queryset = queryset.filter(or_queries)\n            may_have_duplicates |= any(\n                lookup_spawns_duplicates(self.opts, search_spec)\n                for search_spec in orm_lookups\n            )</original>\n<patched>        may_have_duplicates = False\n        search_fields = self.get_search_fields(request)\n        if search_fields and search_term:\n            orm_lookups = [construct_search(str(search_field))\n                           for search_field in search_fields]\n            and_queries = []\n            for bit in smart_split(search_term):\n                if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                    bit = unescape_string_literal(bit)\n                or_queries = models.Q(\n                    *((orm_lookup, bit) for orm_lookup in orm_lookups),\n                    _connector=models.Q.OR,\n                )\n                and_queries.append(or_queries)\n            if and_queries:\n                # Combine all search term queries with AND logic in a single filter call\n                combined_query = models.Q(*and_queries, _connector=models.Q.AND)\n                queryset = queryset.filter(combined_query)\n            may_have_duplicates |= any(\n                lookup_spawns_duplicates(self.opts, search_spec)\n                for search_spec in orm_lookups\n            )</patched>\n```"
}