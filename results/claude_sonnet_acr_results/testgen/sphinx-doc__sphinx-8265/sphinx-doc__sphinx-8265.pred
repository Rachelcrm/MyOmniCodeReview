{
  "instance_id": "sphinx-doc__sphinx-8265",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_util_inspect.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nimport inspect\nfrom sphinx.util.inspect import object_description, stringify_signature\n\n\nclass TestObjectDescription:\n    \"\"\"Test cases for object_description function handling of tuple defaults.\"\"\"\n    \n    def test_object_description_tuple_simple(self):\n        \"\"\"Test that object_description preserves parentheses for simple tuples.\"\"\"\n        # This test should fail before the fix is applied\n        result = object_description((1, 2, 3))\n        assert result == \"(1, 2, 3)\", f\"Expected '(1, 2, 3)', got '{result}'\"\n    \n    def test_object_description_tuple_single_element(self):\n        \"\"\"Test that object_description handles single-element tuples correctly.\"\"\"\n        result = object_description((1,))\n        assert result == \"(1,)\", f\"Expected '(1,)', got '{result}'\"\n    \n    def test_object_description_tuple_empty(self):\n        \"\"\"Test that object_description handles empty tuples correctly.\"\"\"\n        result = object_description(())\n        assert result == \"()\", f\"Expected '()', got '{result}'\"\n    \n    def test_object_description_tuple_nested(self):\n        \"\"\"Test that object_description handles nested tuples correctly.\"\"\"\n        result = object_description((1, (2, 3), 4))\n        assert result == \"(1, (2, 3), 4)\", f\"Expected '(1, (2, 3), 4)', got '{result}'\"\n    \n    def test_object_description_tuple_mixed_types(self):\n        \"\"\"Test that object_description handles tuples with mixed types.\"\"\"\n        result = object_description((1, 'hello', 3.14))\n        assert result == \"(1, 'hello', 3.14)\", f\"Expected \\\"(1, 'hello', 3.14)\\\", got '{result}'\"\n    \n    def test_object_description_preserves_other_types(self):\n        \"\"\"Test that object_description still works correctly for other types.\"\"\"\n        # Test dict\n        result = object_description({'a': 1, 'b': 2})\n        assert result == \"{'a': 1, 'b': 2}\"\n        \n        # Test set\n        result = object_description({1, 2, 3})\n        assert result == \"{1, 2, 3}\"\n        \n        # Test frozenset\n        result = object_description(frozenset([1, 2, 3]))\n        assert result == \"frozenset({1, 2, 3})\"\n        \n        # Test string\n        result = object_description(\"hello\")\n        assert result == \"'hello'\"\n        \n        # Test int\n        result = object_description(42)\n        assert result == \"42\"\n\n\nclass TestStringifySignature:\n    \"\"\"Test cases for stringify_signature function with tuple default values.\"\"\"\n    \n    def test_stringify_signature_tuple_default_reproduces_bug(self):\n        \"\"\"Test that reproduces the original bug with tuple defaults.\"\"\"\n        def sample_function(lines, color=(1, 1, 1), width=5, label=None, name=None):\n            pass\n        \n        sig = inspect.signature(sample_function)\n        result = stringify_signature(sig)\n        \n        # This test should fail before the fix, showing the bug\n        # The bug would show: color=1, 1, 1 instead of color=(1, 1, 1)\n        assert \"color=(1, 1, 1)\" in result, f\"Expected 'color=(1, 1, 1)' in signature, got: {result}\"\n        assert \"color=1, 1, 1\" not in result, f\"Bug detected: found 'color=1, 1, 1' in signature: {result}\"\n    \n    def test_stringify_signature_multiple_tuple_defaults(self):\n        \"\"\"Test stringify_signature with multiple tuple default parameters.\"\"\"\n        def sample_function(pos=(0, 0), size=(100, 100), color=(255, 255, 255)):\n            pass\n        \n        sig = inspect.signature(sample_function)\n        result = stringify_signature(sig)\n        \n        assert \"pos=(0, 0)\" in result\n        assert \"size=(100, 100)\" in result\n        assert \"color=(255, 255, 255)\" in result\n    \n    def test_stringify_signature_mixed_defaults(self):\n        \"\"\"Test stringify_signature with mixed default parameter types.\"\"\"\n        def sample_function(name=\"test\", coords=(1, 2), count=5, flags=None):\n            pass\n        \n        sig = inspect.signature(sample_function)\n        result = stringify_signature(sig)\n        \n        assert \"name='test'\" in result\n        assert \"coords=(1, 2)\" in result\n        assert \"count=5\" in result\n        assert \"flags=None\" in result\n    \n    def test_stringify_signature_nested_tuple_default(self):\n        \"\"\"Test stringify_signature with nested tuple defaults.\"\"\"\n        def sample_function(data=((1, 2), (3, 4))):\n            pass\n        \n        sig = inspect.signature(sig)\n        result = stringify_signature(sig)\n        \n        assert \"data=((1, 2), (3, 4))\" in result\n    \n    def test_stringify_signature_empty_tuple_default(self):\n        \"\"\"Test stringify_signature with empty tuple default.\"\"\"\n        def sample_function(items=()):\n            pass\n        \n        sig = inspect.signature(sample_function)\n        result = stringify_signature(sig)\n        \n        assert \"items=()\" in result\n    \n    def test_stringify_signature_single_element_tuple_default(self):\n        \"\"\"Test stringify_signature with single-element tuple default.\"\"\"\n        def sample_function(value=(42,)):\n            pass\n        \n        sig = inspect.signature(sample_function)\n        result = stringify_signature(sig)\n        \n        assert \"value=(42,)\" in result\n\n\nclass TestRegressionCases:\n    \"\"\"Regression test cases based on the original PyVista issue.\"\"\"\n    \n    def test_add_lines_signature_format(self):\n        \"\"\"Test the specific case mentioned in the bug report.\"\"\"\n        def add_lines(self, lines, color=(1, 1, 1), width=5, label=None, name=None):\n            \"\"\"Add lines to the plot.\"\"\"\n            pass\n        \n        sig = inspect.signature(add_lines)\n        result = stringify_signature(sig)\n        \n        # The expected format should be: add_lines(self, lines, color=(1, 1, 1), width=5, label=None, name=None)\n        # Not: add_lines(self, lines, color=1, 1, 1, width=5, label=None, name=None)\n        \n        assert \"color=(1, 1, 1)\" in result, f\"Expected 'color=(1, 1, 1)' in signature, got: {result}\"\n        assert \"width=5\" in result\n        assert \"label=None\" in result\n        assert \"name=None\" in result\n        \n        # Ensure the bug pattern is not present\n        assert \"color=1, 1, 1,\" not in result, f\"Bug pattern detected in: {result}\"\n    \n    def test_various_tuple_patterns(self):\n        \"\"\"Test various tuple patterns that might appear in real code.\"\"\"\n        def test_func(\n            rgb=(255, 255, 255),\n            position=(0.0, 0.0, 0.0),\n            size=(1, 1),\n            matrix=((1, 0), (0, 1)),\n            empty=(),\n            single=(1,)\n        ):\n            pass\n        \n        sig = inspect.signature(test_func)\n        result = stringify_signature(sig)\n        \n        expected_patterns = [\n            \"rgb=(255, 255, 255)\",\n            \"position=(0.0, 0.0, 0.0)\",\n            \"size=(1, 1)\",\n            \"matrix=((1, 0), (0, 1))\",\n            \"empty=()\",\n            \"single=(1,)\"\n        ]\n        \n        for pattern in expected_patterns:\n            assert pattern in result, f\"Expected '{pattern}' in signature, got: {result}\"\n\n\nclass TestEdgeCases:\n    \"\"\"Test edge cases and boundary conditions.\"\"\"\n    \n    def test_object_description_tuple_with_special_values(self):\n        \"\"\"Test object_description with tuples containing special values.\"\"\"\n        # Test with None\n        result = object_description((None, 1, None))\n        assert result == \"(None, 1, None)\"\n        \n        # Test with boolean values\n        result = object_description((True, False))\n        assert result == \"(True, False)\"\n        \n        # Test with float values\n        result = object_description((1.5, 2.7, 3.14))\n        assert result == \"(1.5, 2.7, 3.14)\"\n    \n    def test_object_description_tuple_with_complex_objects(self):\n        \"\"\"Test object_description with tuples containing complex objects.\"\"\"\n        # Test with strings containing special characters\n        result = object_description((\"hello\", \"world's\", 'test\"quote'))\n        expected = \"\"\"('hello', \"world's\", 'test\"quote')\"\"\"\n        assert result == expected\n    \n    def test_stringify_signature_with_annotations(self):\n        \"\"\"Test stringify_signature with type annotations and tuple defaults.\"\"\"\n        def annotated_func(coords: tuple = (0, 0), name: str = \"test\") -> None:\n            pass\n        \n        sig = inspect.signature(annotated_func)\n        result = stringify_signature(sig, show_annotation=True)\n        \n        assert \"coords: tuple = (0, 0)\" in result\n        assert \"name: str = 'test'\" in result\n        assert \"-> None\" in result\n    \n    def test_stringify_signature_no_annotations(self):\n        \"\"\"Test stringify_signature with annotations disabled.\"\"\"\n        def annotated_func(coords: tuple = (0, 0), name: str = \"test\") -> None:\n            pass\n        \n        sig = inspect.signature(annotated_func)\n        result = stringify_signature(sig, show_annotation=False)\n        \n        assert \"coords=(0, 0)\" in result\n        assert \"name='test'\" in result\n        assert \"-> None\" not in result\n        assert \": tuple\" not in result\n        assert \": str\" not in result\n</patched>\n```",
  "patch": "--- a/tests/test_util_inspect.py\n+++ b/tests/test_util_inspect.py\n+import pytest\n+import inspect\n+from sphinx.util.inspect import object_description, stringify_signature\n+\n+\n+class TestObjectDescription:\n+    \"\"\"Test cases for object_description function handling of tuple defaults.\"\"\"\n+    \n+    def test_object_description_tuple_simple(self):\n+        \"\"\"Test that object_description preserves parentheses for simple tuples.\"\"\"\n+        # This test should fail before the fix is applied\n+        result = object_description((1, 2, 3))\n+        assert result == \"(1, 2, 3)\", f\"Expected '(1, 2, 3)', got '{result}'\"\n+    \n+    def test_object_description_tuple_single_element(self):\n+        \"\"\"Test that object_description handles single-element tuples correctly.\"\"\"\n+        result = object_description((1,))\n+        assert result == \"(1,)\", f\"Expected '(1,)', got '{result}'\"\n+    \n+    def test_object_description_tuple_empty(self):\n+        \"\"\"Test that object_description handles empty tuples correctly.\"\"\"\n+        result = object_description(())\n+        assert result == \"()\", f\"Expected '()', got '{result}'\"\n+    \n+    def test_object_description_tuple_nested(self):\n+        \"\"\"Test that object_description handles nested tuples correctly.\"\"\"\n+        result = object_description((1, (2, 3), 4))\n+        assert result == \"(1, (2, 3), 4)\", f\"Expected '(1, (2, 3), 4)', got '{result}'\"\n+    \n+    def test_object_description_tuple_mixed_types(self):\n+        \"\"\"Test that object_description handles tuples with mixed types.\"\"\"\n+        result = object_description((1, 'hello', 3.14))\n+        assert result == \"(1, 'hello', 3.14)\", f\"Expected \\\"(1, 'hello', 3.14)\\\", got '{result}'\"\n+    \n+    def test_object_description_preserves_other_types(self):\n+        \"\"\"Test that object_description still works correctly for other types.\"\"\"\n+        # Test dict\n+        result = object_description({'a': 1, 'b': 2})\n+        assert result == \"{'a': 1, 'b': 2}\"\n+        \n+        # Test set\n+        result = object_description({1, 2, 3})\n+        assert result == \"{1, 2, 3}\"\n+        \n+        # Test frozenset\n+        result = object_description(frozenset([1, 2, 3]))\n+        assert result == \"frozenset({1, 2, 3})\"\n+        \n+        # Test string\n+        result = object_description(\"hello\")\n+        assert result == \"'hello'\"\n+        \n+        # Test int\n+        result = object_description(42)\n+        assert result == \"42\"\n+\n+\n+class TestStringifySignature:\n+    \"\"\"Test cases for stringify_signature function with tuple default values.\"\"\"\n+    \n+    def test_stringify_signature_tuple_default_reproduces_bug(self):\n+        \"\"\"Test that reproduces the original bug with tuple defaults.\"\"\"\n+        def sample_function(lines, color=(1, 1, 1), width=5, label=None, name=None):\n+            pass\n+        \n+        sig = inspect.signature(sample_function)\n+        result = stringify_signature(sig)\n+        \n+        # This test should fail before the fix, showing the bug\n+        # The bug would show: color=1, 1, 1 instead of color=(1, 1, 1)\n+        assert \"color=(1, 1, 1)\" in result, f\"Expected 'color=(1, 1, 1)' in signature, got: {result}\"\n+        assert \"color=1, 1, 1\" not in result, f\"Bug detected: found 'color=1, 1, 1' in signature: {result}\"\n+    \n+    def test_stringify_signature_multiple_tuple_defaults(self):\n+        \"\"\"Test stringify_signature with multiple tuple default parameters.\"\"\"\n+        def sample_function(pos=(0, 0), size=(100, 100), color=(255, 255, 255)):\n+            pass\n+        \n+        sig = inspect.signature(sample_function)\n+        result = stringify_signature(sig)\n+        \n+        assert \"pos=(0, 0)\" in result\n+        assert \"size=(100, 100)\" in result\n+        assert \"color=(255, 255, 255)\" in result\n+    \n+    def test_stringify_signature_mixed_defaults(self):\n+        \"\"\"Test stringify_signature with mixed default parameter types.\"\"\"\n+        def sample_function(name=\"test\", coords=(1, 2), count=5, flags=None):\n+            pass\n+        \n+        sig = inspect.signature(sample_function)\n+        result = stringify_signature(sig)\n+        \n+        assert \"name='test'\" in result\n+        assert \"coords=(1, 2)\" in result\n+        assert \"count=5\" in result\n+        assert \"flags=None\" in result\n+    \n+    def test_stringify_signature_nested_tuple_default(self):\n+        \"\"\"Test stringify_signature with nested tuple defaults.\"\"\"\n+        def sample_function(data=((1, 2), (3, 4))):\n+            pass\n+        \n+        sig = inspect.signature(sig)\n+        result = stringify_signature(sig)\n+        \n+        assert \"data=((1, 2), (3, 4))\" in result\n+    \n+    def test_stringify_signature_empty_tuple_default(self):\n+        \"\"\"Test stringify_signature with empty tuple default.\"\"\"\n+        def sample_function(items=()):\n+            pass\n+        \n+        sig = inspect.signature(sample_function)\n+        result = stringify_signature(sig)\n+        \n+        assert \"items=()\" in result\n+    \n+    def test_stringify_signature_single_element_tuple_default(self):\n+        \"\"\"Test stringify_signature with single-element tuple default.\"\"\"\n+        def sample_function(value=(42,)):\n+            pass\n+        \n+        sig = inspect.signature(sample_function)\n+        result = stringify_signature(sig)\n+        \n+        assert \"value=(42,)\" in result\n+\n+\n+class TestRegressionCases:\n+    \"\"\"Regression test cases based on the original PyVista issue.\"\"\"\n+    \n+    def test_add_lines_signature_format(self):\n+        \"\"\"Test the specific case mentioned in the bug report.\"\"\"\n+        def add_lines(self, lines, color=(1, 1, 1), width=5, label=None, name=None):\n+            \"\"\"Add lines to the plot.\"\"\"\n+            pass\n+        \n+        sig = inspect.signature(add_lines)\n+        result = stringify_signature(sig)\n+        \n+        # The expected format should be: add_lines(self, lines, color=(1, 1, 1), width=5, label=None, name=None)\n+        # Not: add_lines(self, lines, color=1, 1, 1, width=5, label=None, name=None)\n+        \n+        assert \"color=(1, 1, 1)\" in result, f\"Expected 'color=(1, 1, 1)' in signature, got: {result}\"\n+        assert \"width=5\" in result\n+        assert \"label=None\" in result\n+        assert \"name=None\" in result\n+        \n+        # Ensure the bug pattern is not present\n+        assert \"color=1, 1, 1,\" not in result, f\"Bug pattern detected in: {result}\"\n+    \n+    def test_various_tuple_patterns(self):\n+        \"\"\"Test various tuple patterns that might appear in real code.\"\"\"\n+        def test_func(\n+            rgb=(255, 255, 255),\n+            position=(0.0, 0.0, 0.0),\n+            size=(1, 1),\n+            matrix=((1, 0), (0, 1)),\n+            empty=(),\n+            single=(1,)\n+        ):\n+            pass\n+        \n+        sig = inspect.signature(test_func)\n+        result = stringify_signature(sig)\n+        \n+        expected_patterns = [\n+            \"rgb=(255, 255, 255)\",\n+            \"position=(0.0, 0.0, 0.0)\",\n+            \"size=(1, 1)\",\n+            \"matrix=((1, 0), (0, 1))\",\n+            \"empty=()\",\n+            \"single=(1,)\"\n+        ]\n+        \n+        for pattern in expected_patterns:\n+            assert pattern in result, f\"Expected '{pattern}' in signature, got: {result}\"\n+\n+\n+class TestEdgeCases:\n+    \"\"\"Test edge cases and boundary conditions.\"\"\"\n+    \n+    def test_object_description_tuple_with_special_values(self):\n+        \"\"\"Test object_description with tuples containing special values.\"\"\"\n+        # Test with None\n+        result = object_description((None, 1, None))\n+        assert result == \"(None, 1, None)\"\n+        \n+        # Test with boolean values\n+        result = object_description((True, False))\n+        assert result == \"(True, False)\"\n+        \n+        # Test with float values\n+        result = object_description((1.5, 2.7, 3.14))\n+        assert result == \"(1.5, 2.7, 3.14)\"\n+    \n+    def test_object_description_tuple_with_complex_objects(self):\n+        \"\"\"Test object_description with tuples containing complex objects.\"\"\"\n+        # Test with strings containing special characters\n+        result = object_description((\"hello\", \"world's\", 'test\"quote'))\n+        expected = \"\"\"('hello', \"world's\", 'test\"quote')\"\"\"\n+        assert result == expected\n+    \n+    def test_stringify_signature_with_annotations(self):\n+        \"\"\"Test stringify_signature with type annotations and tuple defaults.\"\"\"\n+        def annotated_func(coords: tuple = (0, 0), name: str = \"test\") -> None:\n+            pass\n+        \n+        sig = inspect.signature(annotated_func)\n+        result = stringify_signature(sig, show_annotation=True)\n+        \n+        assert \"coords: tuple = (0, 0)\" in result\n+        assert \"name: str = 'test'\" in result\n+        assert \"-> None\" in result\n+    \n+    def test_stringify_signature_no_annotations(self):\n+        \"\"\"Test stringify_signature with annotations disabled.\"\"\"\n+        def annotated_func(coords: tuple = (0, 0), name: str = \"test\") -> None:\n+            pass\n+        \n+        sig = inspect.signature(annotated_func)\n+        result = stringify_signature(sig, show_annotation=False)\n+        \n+        assert \"coords=(0, 0)\" in result\n+        assert \"name='test'\" in result\n+        assert \"-> None\" not in result\n+        assert \": tuple\" not in result\n+        assert \": str\" not in result\n"
}