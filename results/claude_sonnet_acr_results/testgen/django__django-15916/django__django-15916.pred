{
  "instance_id": "django__django-15916",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/forms_tests/test_modelform_factory_formfield_callback.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django import forms\nfrom django.db import models\nfrom django.test import TestCase\n\n\nclass TestModel(models.Model):\n    \"\"\"Test model for formfield_callback tests.\"\"\"\n    active = models.BooleanField(default=False)\n    name = models.CharField(max_length=64, blank=True, null=True)\n    \n    class Meta:\n        app_label = 'forms_tests'\n\n\ndef all_required_callback(field, **kwargs):\n    \"\"\"Callback that makes all fields required.\"\"\"\n    formfield = field.formfield(**kwargs)\n    formfield.required = True\n    return formfield\n\n\ndef custom_widget_callback(field, **kwargs):\n    \"\"\"Callback that adds custom widgets.\"\"\"\n    formfield = field.formfield(**kwargs)\n    if isinstance(field, models.CharField):\n        formfield.widget = forms.TextInput(attrs={'class': 'custom-text'})\n    return formfield\n\n\nclass ModelFormFactoryFormfieldCallbackTests(TestCase):\n    \"\"\"Test that modelform_factory properly inherits formfield_callback from base forms.\"\"\"\n    \n    def test_modelform_factory_without_callback_parameter_inherits_from_meta(self):\n        \"\"\"\n        Test that when no formfield_callback is passed to modelform_factory,\n        it inherits the callback from the base form's Meta class.\n        This is the main bug described in the issue.\n        \"\"\"\n        # Create a base form with formfield_callback in Meta\n        class BaseForm(forms.ModelForm):\n            class Meta:\n                model = TestModel\n                fields = ['active', 'name']\n                formfield_callback = staticmethod(all_required_callback)\n        \n        # Create factory form without explicit callback\n        FactoryForm = forms.modelform_factory(TestModel, form=BaseForm)\n        \n        # Both forms should have required fields due to inherited callback\n        base_form = BaseForm()\n        factory_form = FactoryForm()\n        \n        # Check that both forms have the same required field behavior\n        self.assertTrue(base_form.fields['active'].required)\n        self.assertTrue(base_form.fields['name'].required)\n        self.assertTrue(factory_form.fields['active'].required)\n        self.assertTrue(factory_form.fields['name'].required)\n        \n        # Verify the callback is properly set on the factory form's Meta\n        self.assertTrue(hasattr(FactoryForm.Meta, 'formfield_callback'))\n        self.assertEqual(FactoryForm.Meta.formfield_callback, all_required_callback)\n    \n    def test_modelform_factory_explicit_callback_overrides_base_form(self):\n        \"\"\"\n        Test that when formfield_callback is explicitly passed to modelform_factory,\n        it overrides the base form's callback (existing behavior should be preserved).\n        \"\"\"\n        # Create a base form with one callback\n        class BaseForm(forms.ModelForm):\n            class Meta:\n                model = TestModel\n                fields = ['active', 'name']\n                formfield_callback = staticmethod(all_required_callback)\n        \n        # Create factory form with different explicit callback\n        FactoryForm = forms.modelform_factory(\n            TestModel, \n            form=BaseForm, \n            formfield_callback=custom_widget_callback\n        )\n        \n        base_form = BaseForm()\n        factory_form = FactoryForm()\n        \n        # Base form should have required fields\n        self.assertTrue(base_form.fields['active'].required)\n        self.assertTrue(base_form.fields['name'].required)\n        \n        # Factory form should use the explicit callback (custom widgets, not required)\n        self.assertFalse(factory_form.fields['active'].required)\n        self.assertFalse(factory_form.fields['name'].required)\n        self.assertEqual(\n            factory_form.fields['name'].widget.attrs.get('class'), \n            'custom-text'\n        )\n        \n        # Verify the explicit callback is set on the factory form's Meta\n        self.assertEqual(FactoryForm.Meta.formfield_callback, custom_widget_callback)\n    \n    def test_modelform_factory_no_base_callback_no_explicit_callback(self):\n        \"\"\"\n        Test that when neither base form nor explicit parameter has a callback,\n        the factory form works normally (existing behavior should be preserved).\n        \"\"\"\n        # Create a base form without callback\n        class BaseForm(forms.ModelForm):\n            class Meta:\n                model = TestModel\n                fields = ['active', 'name']\n        \n        # Create factory form without explicit callback\n        FactoryForm = forms.modelform_factory(TestModel, form=BaseForm)\n        \n        base_form = BaseForm()\n        factory_form = FactoryForm()\n        \n        # Both forms should have default field behavior (not required for nullable fields)\n        self.assertTrue(base_form.fields['active'].required)  # BooleanField is required by default\n        self.assertFalse(base_form.fields['name'].required)  # CharField with blank=True, null=True\n        self.assertTrue(factory_form.fields['active'].required)\n        self.assertFalse(factory_form.fields['name'].required)\n        \n        # Verify no callback is set\n        self.assertFalse(hasattr(FactoryForm.Meta, 'formfield_callback'))\n    \n    def test_modelform_factory_explicit_none_callback_overrides_base_form(self):\n        \"\"\"\n        Test that when formfield_callback=None is explicitly passed to modelform_factory,\n        it overrides the base form's callback.\n        \"\"\"\n        # Create a base form with callback\n        class BaseForm(forms.ModelForm):\n            class Meta:\n                model = TestModel\n                fields = ['active', 'name']\n                formfield_callback = staticmethod(all_required_callback)\n        \n        # Create factory form with explicit None callback\n        FactoryForm = forms.modelform_factory(\n            TestModel, \n            form=BaseForm, \n            formfield_callback=None\n        )\n        \n        base_form = BaseForm()\n        factory_form = FactoryForm()\n        \n        # Base form should have required fields\n        self.assertTrue(base_form.fields['active'].required)\n        self.assertTrue(base_form.fields['name'].required)\n        \n        # Factory form should use default behavior (no callback)\n        self.assertTrue(factory_form.fields['active'].required)  # BooleanField default\n        self.assertFalse(factory_form.fields['name'].required)  # CharField with blank=True, null=True\n        \n        # Verify no callback is set on the factory form\n        self.assertIsNone(FactoryForm.formfield_callback)\n    \n    def test_modelform_factory_callback_consistency_between_meta_and_class(self):\n        \"\"\"\n        Test that the formfield_callback is consistently set on both the Meta class\n        and the form class itself.\n        \"\"\"\n        # Create a base form with callback\n        class BaseForm(forms.ModelForm):\n            class Meta:\n                model = TestModel\n                fields = ['active', 'name']\n                formfield_callback = staticmethod(all_required_callback)\n        \n        # Create factory form that should inherit the callback\n        FactoryForm = forms.modelform_factory(TestModel, form=BaseForm)\n        \n        # Check that both Meta and class have the callback\n        self.assertTrue(hasattr(FactoryForm.Meta, 'formfield_callback'))\n        self.assertTrue(hasattr(FactoryForm, 'formfield_callback'))\n        self.assertEqual(FactoryForm.Meta.formfield_callback, all_required_callback)\n        self.assertEqual(FactoryForm.formfield_callback, all_required_callback)\n    \n    def test_modelform_factory_inheritance_with_multiple_base_classes(self):\n        \"\"\"\n        Test that formfield_callback inheritance works correctly when the base form\n        inherits from multiple classes.\n        \"\"\"\n        # Create a mixin with callback\n        class CallbackMixin:\n            class Meta:\n                formfield_callback = staticmethod(all_required_callback)\n        \n        # Create a base form that inherits from the mixin\n        class BaseForm(CallbackMixin, forms.ModelForm):\n            class Meta(CallbackMixin.Meta):\n                model = TestModel\n                fields = ['active', 'name']\n        \n        # Create factory form\n        FactoryForm = forms.modelform_factory(TestModel, form=BaseForm)\n        \n        factory_form = FactoryForm()\n        \n        # Should inherit the callback and make fields required\n        self.assertTrue(factory_form.fields['active'].required)\n        self.assertTrue(factory_form.fields['name'].required)\n        self.assertEqual(FactoryForm.Meta.formfield_callback, all_required_callback)\n    \n    def test_failing_case_before_fix(self):\n        \"\"\"\n        This test demonstrates the bug described in the issue.\n        Before the fix, this test should fail because the factory form\n        doesn't inherit the formfield_callback from the base form.\n        \"\"\"\n        # This is the exact example from the issue description\n        def all_required(field, **kwargs):\n            formfield = field.formfield(**kwargs)\n            formfield.required = True\n            return formfield\n        \n        class MyForm(forms.ModelForm):\n            class Meta:\n                model = TestModel\n                formfield_callback = staticmethod(all_required)\n                fields = ['active', 'name']\n        \n        FactoryForm = forms.modelform_factory(TestModel, form=MyForm)\n        \n        # Create instances of both forms\n        my_form = MyForm()\n        factory_form = FactoryForm()\n        \n        # Both forms should have the same behavior - all fields required\n        # This assertion will fail before the fix is applied\n        self.assertEqual(\n            my_form.fields['name'].required,\n            factory_form.fields['name'].required,\n            \"Factory form should inherit formfield_callback from base form\"\n        )\n        \n        # Both should be True (required) due to the callback\n        self.assertTrue(my_form.fields['name'].required)\n        self.assertTrue(factory_form.fields['name'].required)\n</patched>\n```",
  "patch": "--- a/tests/forms_tests/test_modelform_factory_formfield_callback.py\n+++ b/tests/forms_tests/test_modelform_factory_formfield_callback.py\n-# Empty if creating new file\n+import pytest\n+from django import forms\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class TestModel(models.Model):\n+    \"\"\"Test model for formfield_callback tests.\"\"\"\n+    active = models.BooleanField(default=False)\n+    name = models.CharField(max_length=64, blank=True, null=True)\n+    \n+    class Meta:\n+        app_label = 'forms_tests'\n+\n+\n+def all_required_callback(field, **kwargs):\n+    \"\"\"Callback that makes all fields required.\"\"\"\n+    formfield = field.formfield(**kwargs)\n+    formfield.required = True\n+    return formfield\n+\n+\n+def custom_widget_callback(field, **kwargs):\n+    \"\"\"Callback that adds custom widgets.\"\"\"\n+    formfield = field.formfield(**kwargs)\n+    if isinstance(field, models.CharField):\n+        formfield.widget = forms.TextInput(attrs={'class': 'custom-text'})\n+    return formfield\n+\n+\n+class ModelFormFactoryFormfieldCallbackTests(TestCase):\n+    \"\"\"Test that modelform_factory properly inherits formfield_callback from base forms.\"\"\"\n+    \n+    def test_modelform_factory_without_callback_parameter_inherits_from_meta(self):\n+        \"\"\"\n+        Test that when no formfield_callback is passed to modelform_factory,\n+        it inherits the callback from the base form's Meta class.\n+        This is the main bug described in the issue.\n+        \"\"\"\n+        # Create a base form with formfield_callback in Meta\n+        class BaseForm(forms.ModelForm):\n+            class Meta:\n+                model = TestModel\n+                fields = ['active', 'name']\n+                formfield_callback = staticmethod(all_required_callback)\n+        \n+        # Create factory form without explicit callback\n+        FactoryForm = forms.modelform_factory(TestModel, form=BaseForm)\n+        \n+        # Both forms should have required fields due to inherited callback\n+        base_form = BaseForm()\n+        factory_form = FactoryForm()\n+        \n+        # Check that both forms have the same required field behavior\n+        self.assertTrue(base_form.fields['active'].required)\n+        self.assertTrue(base_form.fields['name'].required)\n+        self.assertTrue(factory_form.fields['active'].required)\n+        self.assertTrue(factory_form.fields['name'].required)\n+        \n+        # Verify the callback is properly set on the factory form's Meta\n+        self.assertTrue(hasattr(FactoryForm.Meta, 'formfield_callback'))\n+        self.assertEqual(FactoryForm.Meta.formfield_callback, all_required_callback)\n+    \n+    def test_modelform_factory_explicit_callback_overrides_base_form(self):\n+        \"\"\"\n+        Test that when formfield_callback is explicitly passed to modelform_factory,\n+        it overrides the base form's callback (existing behavior should be preserved).\n+        \"\"\"\n+        # Create a base form with one callback\n+        class BaseForm(forms.ModelForm):\n+            class Meta:\n+                model = TestModel\n+                fields = ['active', 'name']\n+                formfield_callback = staticmethod(all_required_callback)\n+        \n+        # Create factory form with different explicit callback\n+        FactoryForm = forms.modelform_factory(\n+            TestModel, \n+            form=BaseForm, \n+            formfield_callback=custom_widget_callback\n+        )\n+        \n+        base_form = BaseForm()\n+        factory_form = FactoryForm()\n+        \n+        # Base form should have required fields\n+        self.assertTrue(base_form.fields['active'].required)\n+        self.assertTrue(base_form.fields['name'].required)\n+        \n+        # Factory form should use the explicit callback (custom widgets, not required)\n+        self.assertFalse(factory_form.fields['active'].required)\n+        self.assertFalse(factory_form.fields['name'].required)\n+        self.assertEqual(\n+            factory_form.fields['name'].widget.attrs.get('class'), \n+            'custom-text'\n+        )\n+        \n+        # Verify the explicit callback is set on the factory form's Meta\n+        self.assertEqual(FactoryForm.Meta.formfield_callback, custom_widget_callback)\n+    \n+    def test_modelform_factory_no_base_callback_no_explicit_callback(self):\n+        \"\"\"\n+        Test that when neither base form nor explicit parameter has a callback,\n+        the factory form works normally (existing behavior should be preserved).\n+        \"\"\"\n+        # Create a base form without callback\n+        class BaseForm(forms.ModelForm):\n+            class Meta:\n+                model = TestModel\n+                fields = ['active', 'name']\n+        \n+        # Create factory form without explicit callback\n+        FactoryForm = forms.modelform_factory(TestModel, form=BaseForm)\n+        \n+        base_form = BaseForm()\n+        factory_form = FactoryForm()\n+        \n+        # Both forms should have default field behavior (not required for nullable fields)\n+        self.assertTrue(base_form.fields['active'].required)  # BooleanField is required by default\n+        self.assertFalse(base_form.fields['name'].required)  # CharField with blank=True, null=True\n+        self.assertTrue(factory_form.fields['active'].required)\n+        self.assertFalse(factory_form.fields['name'].required)\n+        \n+        # Verify no callback is set\n+        self.assertFalse(hasattr(FactoryForm.Meta, 'formfield_callback'))\n+    \n+    def test_modelform_factory_explicit_none_callback_overrides_base_form(self):\n+        \"\"\"\n+        Test that when formfield_callback=None is explicitly passed to modelform_factory,\n+        it overrides the base form's callback.\n+        \"\"\"\n+        # Create a base form with callback\n+        class BaseForm(forms.ModelForm):\n+            class Meta:\n+                model = TestModel\n+                fields = ['active', 'name']\n+                formfield_callback = staticmethod(all_required_callback)\n+        \n+        # Create factory form with explicit None callback\n+        FactoryForm = forms.modelform_factory(\n+            TestModel, \n+            form=BaseForm, \n+            formfield_callback=None\n+        )\n+        \n+        base_form = BaseForm()\n+        factory_form = FactoryForm()\n+        \n+        # Base form should have required fields\n+        self.assertTrue(base_form.fields['active'].required)\n+        self.assertTrue(base_form.fields['name'].required)\n+        \n+        # Factory form should use default behavior (no callback)\n+        self.assertTrue(factory_form.fields['active'].required)  # BooleanField default\n+        self.assertFalse(factory_form.fields['name'].required)  # CharField with blank=True, null=True\n+        \n+        # Verify no callback is set on the factory form\n+        self.assertIsNone(FactoryForm.formfield_callback)\n+    \n+    def test_modelform_factory_callback_consistency_between_meta_and_class(self):\n+        \"\"\"\n+        Test that the formfield_callback is consistently set on both the Meta class\n+        and the form class itself.\n+        \"\"\"\n+        # Create a base form with callback\n+        class BaseForm(forms.ModelForm):\n+            class Meta:\n+                model = TestModel\n+                fields = ['active', 'name']\n+                formfield_callback = staticmethod(all_required_callback)\n+        \n+        # Create factory form that should inherit the callback\n+        FactoryForm = forms.modelform_factory(TestModel, form=BaseForm)\n+        \n+        # Check that both Meta and class have the callback\n+        self.assertTrue(hasattr(FactoryForm.Meta, 'formfield_callback'))\n+        self.assertTrue(hasattr(FactoryForm, 'formfield_callback'))\n+        self.assertEqual(FactoryForm.Meta.formfield_callback, all_required_callback)\n+        self.assertEqual(FactoryForm.formfield_callback, all_required_callback)\n+    \n+    def test_modelform_factory_inheritance_with_multiple_base_classes(self):\n+        \"\"\"\n+        Test that formfield_callback inheritance works correctly when the base form\n+        inherits from multiple classes.\n+        \"\"\"\n+        # Create a mixin with callback\n+        class CallbackMixin:\n+            class Meta:\n+                formfield_callback = staticmethod(all_required_callback)\n+        \n+        # Create a base form that inherits from the mixin\n+        class BaseForm(CallbackMixin, forms.ModelForm):\n+            class Meta(CallbackMixin.Meta):\n+                model = TestModel\n+                fields = ['active', 'name']\n+        \n+        # Create factory form\n+        FactoryForm = forms.modelform_factory(TestModel, form=BaseForm)\n+        \n+        factory_form = FactoryForm()\n+        \n+        # Should inherit the callback and make fields required\n+        self.assertTrue(factory_form.fields['active'].required)\n+        self.assertTrue(factory_form.fields['name'].required)\n+        self.assertEqual(FactoryForm.Meta.formfield_callback, all_required_callback)\n+    \n+    def test_failing_case_before_fix(self):\n+        \"\"\"\n+        This test demonstrates the bug described in the issue.\n+        Before the fix, this test should fail because the factory form\n+        doesn't inherit the formfield_callback from the base form.\n+        \"\"\"\n+        # This is the exact example from the issue description\n+        def all_required(field, **kwargs):\n+            formfield = field.formfield(**kwargs)\n+            formfield.required = True\n+            return formfield\n+        \n+        class MyForm(forms.ModelForm):\n+            class Meta:\n+                model = TestModel\n+                formfield_callback = staticmethod(all_required)\n+                fields = ['active', 'name']\n+        \n+        FactoryForm = forms.modelform_factory(TestModel, form=MyForm)\n+        \n+        # Create instances of both forms\n+        my_form = MyForm()\n+        factory_form = FactoryForm()\n+        \n+        # Both forms should have the same behavior - all fields required\n+        # This assertion will fail before the fix is applied\n+        self.assertEqual(\n+            my_form.fields['name'].required,\n+            factory_form.fields['name'].required,\n+            \"Factory form should inherit formfield_callback from base form\"\n+        )\n+        \n+        # Both should be True (required) due to the callback\n+        self.assertTrue(my_form.fields['name'].required)\n+        self.assertTrue(factory_form.fields['name'].required)\n"
}