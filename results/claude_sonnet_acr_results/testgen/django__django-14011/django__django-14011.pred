{
  "instance_id": "django__django-14011",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/servers/test_liveserverthread.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport threading\nimport time\nimport pytest\nfrom unittest import mock\nfrom django.test import TestCase, LiveServerTestCase, override_settings\nfrom django.db import connection, connections\nfrom django.core.servers.basehttp import ThreadedWSGIServer, WSGIServer\nfrom django.test.testcases import LiveServerThread\nfrom django.test.utils import override_settings\nfrom django.contrib.staticfiles.testing import StaticLiveServerTestCase\n\n\nclass LiveServerThreadTest(TestCase):\n    \"\"\"Test that LiveServerThread properly closes database connections.\"\"\"\n    \n    def test_closes_connections(self):\n        \"\"\"\n        Test that LiveServerThread closes database connections after each thread.\n        This reproduces the bug where ThreadedWSGIServer doesn't close database\n        connections, causing \"database is being accessed by other users\" errors.\n        \"\"\"\n        # Track the number of database connections before starting\n        initial_connections = len(connections.all())\n        \n        # Create a custom LiveServerThread that uses ThreadedWSGIServer\n        class TestLiveServerThread(LiveServerThread):\n            def _create_server(self):\n                return ThreadedWSGIServer(\n                    (self.host, self.port), \n                    self.static_handler,\n                    allow_reuse_address=False\n                )\n        \n        # Start the live server thread\n        thread = TestLiveServerThread('127.0.0.1', 0, connections_override={})\n        thread.daemon = True\n        thread.start()\n        \n        try:\n            # Wait for the server to start\n            thread.is_ready.wait()\n            \n            # Simulate multiple requests that would create database connections\n            import urllib.request\n            for i in range(3):\n                try:\n                    response = urllib.request.urlopen(f'http://{thread.host}:{thread.port}/')\n                    response.read()\n                    response.close()\n                except:\n                    # Ignore connection errors, we're just testing connection cleanup\n                    pass\n            \n            # Give threads time to finish\n            time.sleep(0.1)\n            \n        finally:\n            # Stop the server\n            thread.terminate()\n            thread.join()\n        \n        # Check that connections are properly closed\n        # This should not fail with \"database is being accessed by other users\"\n        for alias in connections:\n            connections[alias].close()\n        \n        # Verify no lingering connections\n        final_connections = len(connections.all())\n        self.assertEqual(initial_connections, final_connections)\n\n\nclass ThreadedWSGIServerConnectionTest(TestCase):\n    \"\"\"Test ThreadedWSGIServer database connection handling.\"\"\"\n    \n    def test_daemon_threads_setting(self):\n        \"\"\"\n        Test that ThreadedWSGIServer has daemon_threads set appropriately.\n        Before the fix, daemon_threads=True causes connection cleanup issues.\n        After the fix, daemon_threads=False ensures proper cleanup.\n        \"\"\"\n        server = ThreadedWSGIServer(('127.0.0.1', 0), None)\n        \n        # This test will fail before the fix (daemon_threads=True)\n        # and pass after the fix (daemon_threads=False)\n        self.assertFalse(server.daemon_threads, \n                        \"daemon_threads should be False to ensure proper connection cleanup\")\n\n\nclass LiveServerTestCaseConnectionTest(LiveServerTestCase):\n    \"\"\"Test that LiveServerTestCase properly handles database connections.\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        # Track connections before test\n        cls.initial_connection_count = len(connections.all())\n        super().setUpClass()\n    \n    def test_database_connections_cleaned_up(self):\n        \"\"\"\n        Test that database connections are properly cleaned up after requests.\n        This test reproduces the race condition described in the issue.\n        \"\"\"\n        import urllib.request\n        \n        # Make multiple requests to the live server\n        for i in range(5):\n            try:\n                response = urllib.request.urlopen(f'{self.live_server_url}/')\n                response.read()\n                response.close()\n            except:\n                # Ignore connection errors, focus on connection cleanup\n                pass\n        \n        # Force garbage collection to clean up any lingering references\n        import gc\n        gc.collect()\n        \n        # This assertion helps verify connections are managed properly\n        # The actual connection count may vary, but we shouldn't have\n        # an excessive number of open connections\n        current_connections = len(connections.all())\n        self.assertLessEqual(current_connections, self.initial_connection_count + 2,\n                           \"Too many database connections remain open\")\n\n\nclass NonThreadedLiveServerTest(LiveServerTestCase):\n    \"\"\"Test using non-threaded server as a control case.\"\"\"\n    \n    class NonThreadedLiveServerThread(LiveServerThread):\n        \"\"\"Custom LiveServerThread that uses WSGIServer instead of ThreadedWSGIServer.\"\"\"\n        def _create_server(self):\n            from django.core.servers.basehttp import WSGIServer\n            from django.test.testcases import QuietWSGIRequestHandler\n            return WSGIServer((self.host, self.port), QuietWSGIRequestHandler, \n                            allow_reuse_address=False)\n    \n    server_thread_class = NonThreadedLiveServerThread\n    \n    def test_non_threaded_server_connections(self):\n        \"\"\"\n        Test that non-threaded server doesn't have connection issues.\n        This serves as a control test to verify the issue is specific to threading.\n        \"\"\"\n        import urllib.request\n        \n        # Make requests to the non-threaded live server\n        for i in range(3):\n            try:\n                response = urllib.request.urlopen(f'{self.live_server_url}/')\n                response.read()\n                response.close()\n            except:\n                pass\n        \n        # Non-threaded server should not have connection cleanup issues\n        for alias in connections:\n            connections[alias].close()\n        \n        # This should always pass since non-threaded server doesn't have the race condition\n        self.assertTrue(True, \"Non-threaded server should handle connections properly\")\n\n\nclass ThreadedWSGIServerShutdownTest(TestCase):\n    \"\"\"Test ThreadedWSGIServer shutdown behavior.\"\"\"\n    \n    def test_server_waits_for_threads_on_shutdown(self):\n        \"\"\"\n        Test that ThreadedWSGIServer waits for threads to complete on shutdown.\n        This is the core fix - daemon_threads=False ensures proper cleanup.\n        \"\"\"\n        from django.core.servers.basehttp import ThreadedWSGIServer\n        from django.test.testcases import QuietWSGIRequestHandler\n        \n        # Create server instance\n        server = ThreadedWSGIServer(('127.0.0.1', 0), QuietWSGIRequestHandler)\n        \n        # Verify daemon_threads setting\n        self.assertFalse(server.daemon_threads, \n                        \"daemon_threads must be False for proper thread cleanup\")\n        \n        # Test that the server inherits from ThreadingMixIn\n        import socketserver\n        self.assertTrue(isinstance(server, socketserver.ThreadingMixIn),\n                       \"Server should inherit from ThreadingMixIn for threading support\")\n\n\n@pytest.mark.skipif(\n    connection.vendor == 'sqlite' and ':memory:' in connection.settings_dict.get('NAME', ''),\n    reason=\"SQLite in-memory database doesn't support connection tracking\"\n)\nclass DatabaseConnectionRaceConditionTest(LiveServerTestCase):\n    \"\"\"Test for the specific race condition mentioned in the issue.\"\"\"\n    \n    def test_destroy_test_db_race_condition(self):\n        \"\"\"\n        Test that reproduces the race condition where destroy_test_db() fails\n        with \"database is being accessed by other users\" error.\n        \"\"\"\n        import urllib.request\n        import threading\n        import time\n        \n        # Track any exceptions from background threads\n        exceptions = []\n        \n        def make_request():\n            try:\n                response = urllib.request.urlopen(f'{self.live_server_url}/')\n                response.read()\n                response.close()\n                # Simulate some database work\n                from django.contrib.auth.models import User\n                User.objects.count()\n            except Exception as e:\n                exceptions.append(e)\n        \n        # Start multiple threads making requests simultaneously\n        threads = []\n        for i in range(10):\n            thread = threading.Thread(target=make_request)\n            thread.start()\n            threads.append(thread)\n        \n        # Wait for all threads to complete\n        for thread in threads:\n            thread.join(timeout=5.0)\n        \n        # Check for any exceptions\n        if exceptions:\n            self.fail(f\"Exceptions occurred in background threads: {exceptions}\")\n        \n        # Force connection cleanup\n        for alias in connections:\n            connections[alias].close()\n        \n        # This test verifies that we can clean up properly without the\n        # \"database is being accessed by other users\" error\n        self.assertTrue(True, \"Database connections cleaned up successfully\")\n\n\nclass StaticLiveServerConnectionTest(StaticLiveServerTestCase):\n    \"\"\"Test StaticLiveServerTestCase for connection issues.\"\"\"\n    \n    def test_static_live_server_connections(self):\n        \"\"\"\n        Test that StaticLiveServerTestCase (which inherits from LiveServerTestCase)\n        also properly handles database connections.\n        \"\"\"\n        import urllib.request\n        \n        # Make requests to static live server\n        for i in range(3):\n            try:\n                response = urllib.request.urlopen(f'{self.live_server_url}/')\n                response.read()\n                response.close()\n            except:\n                pass\n        \n        # Verify connections can be closed without issues\n        for alias in connections:\n            connections[alias].close()\n        \n        self.assertTrue(True, \"StaticLiveServerTestCase handles connections properly\")\n</patched>\n</file>\n```",
  "patch": "--- a/tests/servers/test_liveserverthread.py\n+++ b/tests/servers/test_liveserverthread.py\n-# Empty if creating new file\n+import threading\n+import time\n+import pytest\n+from unittest import mock\n+from django.test import TestCase, LiveServerTestCase, override_settings\n+from django.db import connection, connections\n+from django.core.servers.basehttp import ThreadedWSGIServer, WSGIServer\n+from django.test.testcases import LiveServerThread\n+from django.test.utils import override_settings\n+from django.contrib.staticfiles.testing import StaticLiveServerTestCase\n+\n+\n+class LiveServerThreadTest(TestCase):\n+    \"\"\"Test that LiveServerThread properly closes database connections.\"\"\"\n+    \n+    def test_closes_connections(self):\n+        \"\"\"\n+        Test that LiveServerThread closes database connections after each thread.\n+        This reproduces the bug where ThreadedWSGIServer doesn't close database\n+        connections, causing \"database is being accessed by other users\" errors.\n+        \"\"\"\n+        # Track the number of database connections before starting\n+        initial_connections = len(connections.all())\n+        \n+        # Create a custom LiveServerThread that uses ThreadedWSGIServer\n+        class TestLiveServerThread(LiveServerThread):\n+            def _create_server(self):\n+                return ThreadedWSGIServer(\n+                    (self.host, self.port), \n+                    self.static_handler,\n+                    allow_reuse_address=False\n+                )\n+        \n+        # Start the live server thread\n+        thread = TestLiveServerThread('127.0.0.1', 0, connections_override={})\n+        thread.daemon = True\n+        thread.start()\n+        \n+        try:\n+            # Wait for the server to start\n+            thread.is_ready.wait()\n+            \n+            # Simulate multiple requests that would create database connections\n+            import urllib.request\n+            for i in range(3):\n+                try:\n+                    response = urllib.request.urlopen(f'http://{thread.host}:{thread.port}/')\n+                    response.read()\n+                    response.close()\n+                except:\n+                    # Ignore connection errors, we're just testing connection cleanup\n+                    pass\n+            \n+            # Give threads time to finish\n+            time.sleep(0.1)\n+            \n+        finally:\n+            # Stop the server\n+            thread.terminate()\n+            thread.join()\n+        \n+        # Check that connections are properly closed\n+        # This should not fail with \"database is being accessed by other users\"\n+        for alias in connections:\n+            connections[alias].close()\n+        \n+        # Verify no lingering connections\n+        final_connections = len(connections.all())\n+        self.assertEqual(initial_connections, final_connections)\n+\n+\n+class ThreadedWSGIServerConnectionTest(TestCase):\n+    \"\"\"Test ThreadedWSGIServer database connection handling.\"\"\"\n+    \n+    def test_daemon_threads_setting(self):\n+        \"\"\"\n+        Test that ThreadedWSGIServer has daemon_threads set appropriately.\n+        Before the fix, daemon_threads=True causes connection cleanup issues.\n+        After the fix, daemon_threads=False ensures proper cleanup.\n+        \"\"\"\n+        server = ThreadedWSGIServer(('127.0.0.1', 0), None)\n+        \n+        # This test will fail before the fix (daemon_threads=True)\n+        # and pass after the fix (daemon_threads=False)\n+        self.assertFalse(server.daemon_threads, \n+                        \"daemon_threads should be False to ensure proper connection cleanup\")\n+\n+\n+class LiveServerTestCaseConnectionTest(LiveServerTestCase):\n+    \"\"\"Test that LiveServerTestCase properly handles database connections.\"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        # Track connections before test\n+        cls.initial_connection_count = len(connections.all())\n+        super().setUpClass()\n+    \n+    def test_database_connections_cleaned_up(self):\n+        \"\"\"\n+        Test that database connections are properly cleaned up after requests.\n+        This test reproduces the race condition described in the issue.\n+        \"\"\"\n+        import urllib.request\n+        \n+        # Make multiple requests to the live server\n+        for i in range(5):\n+            try:\n+                response = urllib.request.urlopen(f'{self.live_server_url}/')\n+                response.read()\n+                response.close()\n+            except:\n+                # Ignore connection errors, focus on connection cleanup\n+                pass\n+        \n+        # Force garbage collection to clean up any lingering references\n+        import gc\n+        gc.collect()\n+        \n+        # This assertion helps verify connections are managed properly\n+        # The actual connection count may vary, but we shouldn't have\n+        # an excessive number of open connections\n+        current_connections = len(connections.all())\n+        self.assertLessEqual(current_connections, self.initial_connection_count + 2,\n+                           \"Too many database connections remain open\")\n+\n+\n+class NonThreadedLiveServerTest(LiveServerTestCase):\n+    \"\"\"Test using non-threaded server as a control case.\"\"\"\n+    \n+    class NonThreadedLiveServerThread(LiveServerThread):\n+        \"\"\"Custom LiveServerThread that uses WSGIServer instead of ThreadedWSGIServer.\"\"\"\n+        def _create_server(self):\n+            from django.core.servers.basehttp import WSGIServer\n+            from django.test.testcases import QuietWSGIRequestHandler\n+            return WSGIServer((self.host, self.port), QuietWSGIRequestHandler, \n+                            allow_reuse_address=False)\n+    \n+    server_thread_class = NonThreadedLiveServerThread\n+    \n+    def test_non_threaded_server_connections(self):\n+        \"\"\"\n+        Test that non-threaded server doesn't have connection issues.\n+        This serves as a control test to verify the issue is specific to threading.\n+        \"\"\"\n+        import urllib.request\n+        \n+        # Make requests to the non-threaded live server\n+        for i in range(3):\n+            try:\n+                response = urllib.request.urlopen(f'{self.live_server_url}/')\n+                response.read()\n+                response.close()\n+            except:\n+                pass\n+        \n+        # Non-threaded server should not have connection cleanup issues\n+        for alias in connections:\n+            connections[alias].close()\n+        \n+        # This should always pass since non-threaded server doesn't have the race condition\n+        self.assertTrue(True, \"Non-threaded server should handle connections properly\")\n+\n+\n+class ThreadedWSGIServerShutdownTest(TestCase):\n+    \"\"\"Test ThreadedWSGIServer shutdown behavior.\"\"\"\n+    \n+    def test_server_waits_for_threads_on_shutdown(self):\n+        \"\"\"\n+        Test that ThreadedWSGIServer waits for threads to complete on shutdown.\n+        This is the core fix - daemon_threads=False ensures proper cleanup.\n+        \"\"\"\n+        from django.core.servers.basehttp import ThreadedWSGIServer\n+        from django.test.testcases import QuietWSGIRequestHandler\n+        \n+        # Create server instance\n+        server = ThreadedWSGIServer(('127.0.0.1', 0), QuietWSGIRequestHandler)\n+        \n+        # Verify daemon_threads setting\n+        self.assertFalse(server.daemon_threads, \n+                        \"daemon_threads must be False for proper thread cleanup\")\n+        \n+        # Test that the server inherits from ThreadingMixIn\n+        import socketserver\n+        self.assertTrue(isinstance(server, socketserver.ThreadingMixIn),\n+                       \"Server should inherit from ThreadingMixIn for threading support\")\n+\n+\n+@pytest.mark.skipif(\n+    connection.vendor == 'sqlite' and ':memory:' in connection.settings_dict.get('NAME', ''),\n+    reason=\"SQLite in-memory database doesn't support connection tracking\"\n+)\n+class DatabaseConnectionRaceConditionTest(LiveServerTestCase):\n+    \"\"\"Test for the specific race condition mentioned in the issue.\"\"\"\n+    \n+    def test_destroy_test_db_race_condition(self):\n+        \"\"\"\n+        Test that reproduces the race condition where destroy_test_db() fails\n+        with \"database is being accessed by other users\" error.\n+        \"\"\"\n+        import urllib.request\n+        import threading\n+        import time\n+        \n+        # Track any exceptions from background threads\n+        exceptions = []\n+        \n+        def make_request():\n+            try:\n+                response = urllib.request.urlopen(f'{self.live_server_url}/')\n+                response.read()\n+                response.close()\n+                # Simulate some database work\n+                from django.contrib.auth.models import User\n+                User.objects.count()\n+            except Exception as e:\n+                exceptions.append(e)\n+        \n+        # Start multiple threads making requests simultaneously\n+        threads = []\n+        for i in range(10):\n+            thread = threading.Thread(target=make_request)\n+            thread.start()\n+            threads.append(thread)\n+        \n+        # Wait for all threads to complete\n+        for thread in threads:\n+            thread.join(timeout=5.0)\n+        \n+        # Check for any exceptions\n+        if exceptions:\n+            self.fail(f\"Exceptions occurred in background threads: {exceptions}\")\n+        \n+        # Force connection cleanup\n+        for alias in connections:\n+            connections[alias].close()\n+        \n+        # This test verifies that we can clean up properly without the\n+        # \"database is being accessed by other users\" error\n+        self.assertTrue(True, \"Database connections cleaned up successfully\")\n+\n+\n+class StaticLiveServerConnectionTest(StaticLiveServerTestCase):\n+    \"\"\"Test StaticLiveServerTestCase for connection issues.\"\"\"\n+    \n+    def test_static_live_server_connections(self):\n+        \"\"\"\n+        Test that StaticLiveServerTestCase (which inherits from LiveServerTestCase)\n+        also properly handles database connections.\n+        \"\"\"\n+        import urllib.request\n+        \n+        # Make requests to static live server\n+        for i in range(3):\n+            try:\n+                response = urllib.request.urlopen(f'{self.live_server_url}/')\n+                response.read()\n+                response.close()\n+            except:\n+                pass\n+        \n+        # Verify connections can be closed without issues\n+        for alias in connections:\n+            connections[alias].close()\n+        \n+        self.assertTrue(True, \"StaticLiveServerTestCase handles connections properly\")\n"
}