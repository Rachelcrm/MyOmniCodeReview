{
  "instance_id": "django__django-13807",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/backends/sqlite/test_constraint_checking.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import connection, models\nfrom django.db.utils import IntegrityError\nfrom django.test import TestCase, TransactionTestCase\nfrom django.test.utils import override_settings\nimport sqlite3\n\n\nclass OrderModel(models.Model):\n    \"\"\"Model with table name 'order' which is a SQL keyword.\"\"\"\n    name = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n        db_table = 'order'\n\n\nclass GroupModel(models.Model):\n    \"\"\"Model with table name 'group' which is a SQL keyword.\"\"\"\n    name = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n        db_table = 'group'\n\n\nclass SelectModel(models.Model):\n    \"\"\"Model with table name 'select' which is a SQL keyword.\"\"\"\n    name = models.CharField(max_length=100)\n    order = models.ForeignKey(OrderModel, on_delete=models.CASCADE, null=True)\n    \n    class Meta:\n        app_label = 'test_app'\n        db_table = 'select'\n\n\n@override_settings(USE_TZ=False)\nclass SQLiteConstraintCheckingTestCase(TransactionTestCase):\n    \"\"\"Test constraint checking with SQL keyword table names in SQLite.\"\"\"\n    \n    available_apps = ['test_app']\n    \n    def setUp(self):\n        \"\"\"Set up test models and database tables.\"\"\"\n        if connection.vendor != 'sqlite':\n            self.skipTest(\"This test is specific to SQLite backend\")\n            \n        # Create tables for our test models\n        with connection.schema_editor() as schema_editor:\n            schema_editor.create_model(OrderModel)\n            schema_editor.create_model(GroupModel)\n            schema_editor.create_model(SelectModel)\n    \n    def tearDown(self):\n        \"\"\"Clean up test tables.\"\"\"\n        if connection.vendor == 'sqlite':\n            with connection.schema_editor() as schema_editor:\n                schema_editor.delete_model(SelectModel)\n                schema_editor.delete_model(GroupModel)\n                schema_editor.delete_model(OrderModel)\n    \n    def test_check_constraints_with_keyword_table_names_fails_before_fix(self):\n        \"\"\"\n        Test that check_constraints fails with SQL keyword table names before fix.\n        This test demonstrates the bug by directly calling the problematic code.\n        \"\"\"\n        # This test should fail before the fix is applied\n        table_names = ['order', 'group', 'select']\n        \n        # Before the fix, this should raise sqlite3.OperationalError\n        with self.assertRaises(sqlite3.OperationalError) as cm:\n            # Directly test the buggy behavior by calling check_constraints\n            # with table names that are SQL keywords\n            connection.check_constraints(table_names)\n        \n        # The error message should mention syntax error near the keyword\n        self.assertIn('syntax error', str(cm.exception).lower())\n    \n    def test_check_constraints_with_keyword_table_names_passes_after_fix(self):\n        \"\"\"\n        Test that check_constraints works with SQL keyword table names after fix.\n        This test verifies the fix works correctly.\n        \"\"\"\n        # Create some test data\n        order_obj = OrderModel.objects.create(name=\"Test Order\")\n        group_obj = GroupModel.objects.create(name=\"Test Group\")\n        select_obj = SelectModel.objects.create(name=\"Test Select\", order=order_obj)\n        \n        # After the fix, this should work without errors\n        table_names = ['order', 'group', 'select']\n        \n        try:\n            # This should not raise any exceptions after the fix\n            connection.check_constraints(table_names)\n        except sqlite3.OperationalError as e:\n            self.fail(f\"check_constraints failed with SQL keyword table names: {e}\")\n    \n    def test_check_constraints_with_no_table_names(self):\n        \"\"\"Test that check_constraints works when table_names is None.\"\"\"\n        # Create some test data\n        order_obj = OrderModel.objects.create(name=\"Test Order\")\n        \n        try:\n            # This should work regardless of table names being keywords\n            connection.check_constraints(None)\n        except sqlite3.OperationalError as e:\n            self.fail(f\"check_constraints failed with table_names=None: {e}\")\n    \n    def test_check_constraints_with_foreign_key_violations(self):\n        \"\"\"Test that check_constraints properly detects foreign key violations.\"\"\"\n        # Create test data with valid foreign key\n        order_obj = OrderModel.objects.create(name=\"Test Order\")\n        select_obj = SelectModel.objects.create(name=\"Test Select\", order=order_obj)\n        \n        # Disable constraint checking to create invalid data\n        connection.disable_constraint_checking()\n        \n        try:\n            # Delete the referenced order while constraint checking is disabled\n            order_obj.delete()\n            \n            # Re-enable constraint checking\n            connection.enable_constraint_checking()\n            \n            # Now check constraints - this should detect the violation\n            with self.assertRaises(IntegrityError):\n                connection.check_constraints(['select'])\n                \n        finally:\n            # Clean up - re-enable constraints if they were left disabled\n            connection.enable_constraint_checking()\n    \n    def test_pragma_foreign_key_check_direct_sql_keyword_table(self):\n        \"\"\"\n        Test direct PRAGMA foreign_key_check with SQL keyword table names.\n        This test directly exercises the problematic SQL statements.\n        \"\"\"\n        # Create a table with a keyword name\n        OrderModel.objects.create(name=\"Test Order\")\n        \n        with connection.cursor() as cursor:\n            # Before fix: This would fail with syntax error\n            # After fix: This should work with quoted table names\n            try:\n                # Test the specific PRAGMA statements that were failing\n                cursor.execute('PRAGMA foreign_key_check(\"order\")')\n                result = cursor.fetchall()\n                # Should not raise an exception\n                self.assertIsInstance(result, list)\n            except sqlite3.OperationalError as e:\n                if 'syntax error' in str(e).lower():\n                    self.fail(\"PRAGMA foreign_key_check failed with quoted table name\")\n                else:\n                    # Re-raise if it's a different error\n                    raise\n    \n    def test_pragma_foreign_key_list_direct_sql_keyword_table(self):\n        \"\"\"\n        Test direct PRAGMA foreign_key_list with SQL keyword table names.\n        \"\"\"\n        # Create tables with foreign key relationship\n        order_obj = OrderModel.objects.create(name=\"Test Order\")\n        SelectModel.objects.create(name=\"Test Select\", order=order_obj)\n        \n        with connection.cursor() as cursor:\n            try:\n                # Test the specific PRAGMA statement that was failing\n                cursor.execute('PRAGMA foreign_key_list(\"select\")')\n                result = cursor.fetchall()\n                # Should not raise an exception and should return foreign key info\n                self.assertIsInstance(result, list)\n            except sqlite3.OperationalError as e:\n                if 'syntax error' in str(e).lower():\n                    self.fail(\"PRAGMA foreign_key_list failed with quoted table name\")\n                else:\n                    # Re-raise if it's a different error\n                    raise\n    \n    def test_edge_case_table_names_with_special_characters(self):\n        \"\"\"Test constraint checking with table names containing special characters.\"\"\"\n        # Test with table names that might cause issues\n        special_table_names = [\n            'order',      # SQL keyword\n            'group',      # SQL keyword  \n            'select',     # SQL keyword\n            'table-name', # Hyphen\n            'table_name', # Underscore (should be fine)\n        ]\n        \n        # This should not crash even with special table names\n        try:\n            connection.check_constraints(special_table_names)\n        except sqlite3.OperationalError as e:\n            if 'syntax error' in str(e).lower():\n                self.fail(f\"check_constraints failed with special table names: {e}\")\n            # Other operational errors might be expected (e.g., table doesn't exist)\n    \n    def test_empty_table_names_list(self):\n        \"\"\"Test constraint checking with empty table names list.\"\"\"\n        # Empty list should not cause issues\n        try:\n            connection.check_constraints([])\n        except sqlite3.OperationalError as e:\n            self.fail(f\"check_constraints failed with empty table names list: {e}\")\n\n\nclass SQLiteConstraintCheckingUnitTest(TestCase):\n    \"\"\"Unit tests for SQLite constraint checking functionality.\"\"\"\n    \n    def test_quote_name_functionality(self):\n        \"\"\"Test that the quote_name method works correctly for SQLite.\"\"\"\n        if connection.vendor != 'sqlite':\n            self.skipTest(\"This test is specific to SQLite backend\")\n        \n        # Test basic quoting\n        self.assertEqual(connection.ops.quote_name('order'), '\"order\"')\n        self.assertEqual(connection.ops.quote_name('group'), '\"group\"')\n        self.assertEqual(connection.ops.quote_name('select'), '\"select\"')\n        \n        # Test that already quoted names are not double-quoted\n        self.assertEqual(connection.ops.quote_name('\"order\"'), '\"order\"')\n        \n        # Test normal table names\n        self.assertEqual(connection.ops.quote_name('normal_table'), '\"normal_table\"')\n    \n    def test_supports_pragma_foreign_key_check_feature(self):\n        \"\"\"Test that SQLite backend supports PRAGMA foreign_key_check.\"\"\"\n        if connection.vendor != 'sqlite':\n            self.skipTest(\"This test is specific to SQLite backend\")\n        \n        # SQLite should support PRAGMA foreign_key_check\n        self.assertTrue(connection.features.supports_pragma_foreign_key_check)\n</patched>\n</file>\n```\n\n```\n<file>tests/fixtures/test_loaddata_sql_keywords.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport os\nimport tempfile\nimport json\nfrom django.core.management import call_command\nfrom django.db import models, connection\nfrom django.test import TestCase, TransactionTestCase\nfrom django.test.utils import override_settings\nfrom io import StringIO\nimport sqlite3\n\n\nclass OrderFixtureModel(models.Model):\n    \"\"\"Model for testing loaddata with SQL keyword table name.\"\"\"\n    name = models.CharField(max_length=100)\n    description = models.TextField(blank=True)\n    \n    class Meta:\n        app_label = 'test_fixtures'\n        db_table = 'order'\n\n\nclass GroupFixtureModel(models.Model):\n    \"\"\"Model for testing loaddata with SQL keyword table name.\"\"\"\n    name = models.CharField(max_length=100)\n    order = models.ForeignKey(OrderFixtureModel, on_delete=models.CASCADE, null=True)\n    \n    class Meta:\n        app_label = 'test_fixtures'\n        db_table = 'group'\n\n\n@override_settings(USE_TZ=False)\nclass LoadDataSQLKeywordTestCase(TransactionTestCase):\n    \"\"\"Test loaddata command with SQL keyword table names.\"\"\"\n    \n    available_apps = ['test_fixtures']\n    \n    def setUp(self):\n        \"\"\"Set up test models and database tables.\"\"\"\n        if connection.vendor != 'sqlite':\n            self.skipTest(\"This test is specific to SQLite backend\")\n            \n        # Create tables for our test models\n        with connection.schema_editor() as schema_editor:\n            schema_editor.create_model(OrderFixtureModel)\n            schema_editor.create_model(GroupFixtureModel)\n    \n    def tearDown(self):\n        \"\"\"Clean up test tables.\"\"\"\n        if connection.vendor == 'sqlite':\n            with connection.schema_editor() as schema_editor:\n                schema_editor.delete_model(GroupFixtureModel)\n                schema_editor.delete_model(OrderFixtureModel)\n    \n    def test_loaddata_fails_with_sql_keyword_table_before_fix(self):\n        \"\"\"\n        Test that loaddata fails with SQL keyword table names before fix.\n        This reproduces the original bug described in the issue.\n        \"\"\"\n        # Create fixture data for the 'order' table (SQL keyword)\n        fixture_data = [\n            {\n                \"model\": \"test_fixtures.orderfixture\",\n                \"pk\": 1,\n                \"fields\": {\n                    \"name\": \"Test Order 1\",\n                    \"description\": \"First test order\"\n                }\n            },\n            {\n                \"model\": \"test_fixtures.orderfixture\", \n                \"pk\": 2,\n                \"fields\": {\n                    \"name\": \"Test Order 2\",\n                    \"description\": \"Second test order\"\n                }\n            }\n        ]\n        \n        # Write fixture to temporary file\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            json.dump(fixture_data, f)\n            fixture_file = f.name\n        \n        try:\n            # Before the fix, this should fail with sqlite3.OperationalError\n            # due to unquoted table name in PRAGMA foreign_key_check\n            with self.assertRaises(sqlite3.OperationalError) as cm:\n                call_command('loaddata', fixture_file, verbosity=0)\n            \n            # Verify it's the expected syntax error\n            self.assertIn('syntax error', str(cm.exception).lower())\n            self.assertIn('order', str(cm.exception).lower())\n            \n        finally:\n            # Clean up temporary file\n            os.unlink(fixture_file)\n    \n    def test_loaddata_succeeds_with_sql_keyword_table_after_fix(self):\n        \"\"\"\n        Test that loaddata works with SQL keyword table names after fix.\n        \"\"\"\n        # Create fixture data for the 'order' table (SQL keyword)\n        fixture_data = [\n            {\n                \"model\": \"test_fixtures.orderfixture\",\n                \"pk\": 1,\n                \"fields\": {\n                    \"name\": \"Test Order 1\",\n                    \"description\": \"First test order\"\n                }\n            },\n            {\n                \"model\": \"test_fixtures.orderfixture\",\n                \"pk\": 2, \n                \"fields\": {\n                    \"name\": \"Test Order 2\",\n                    \"description\": \"Second test order\"\n                }\n            }\n        ]\n        \n        # Write fixture to temporary file\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            json.dump(fixture_data, f)\n            fixture_file = f.name\n        \n        try:\n            # After the fix, this should work without errors\n            stdout = StringIO()\n            call_command('loaddata', fixture_file, verbosity=1, stdout=stdout)\n            \n            # Verify data was loaded successfully\n            self.assertEqual(OrderFixtureModel.objects.count(), 2)\n            \n            # Verify the actual data\n            order1 = OrderFixtureModel.objects.get(pk=1)\n            self.assertEqual(order1.name, \"Test Order 1\")\n            self.assertEqual(order1.description, \"First test order\")\n            \n            order2 = OrderFixtureModel.objects.get(pk=2)\n            self.assertEqual(order2.name, \"Test Order 2\")\n            self.assertEqual(order2.description, \"Second test order\")\n            \n        except sqlite3.OperationalError as e:\n            self.fail(f\"loaddata failed with SQL keyword table names: {e}\")\n        finally:\n            # Clean up temporary file\n            os.unlink(fixture_file)\n    \n    def test_loaddata_with_foreign_keys_and_sql_keywords(self):\n        \"\"\"\n        Test loaddata with foreign key relationships between SQL keyword tables.\n        \"\"\"\n        # Create fixture data with foreign key relationships\n        fixture_data = [\n            {\n                \"model\": \"test_fixtures.orderfixture\",\n                \"pk\": 1,\n                \"fields\": {\n                    \"name\": \"Parent Order\",\n                    \"description\": \"Parent order for testing\"\n                }\n            },\n            {\n                \"model\": \"test_fixtures.groupfixture\",\n                \"pk\": 1,\n                \"fields\": {\n                    \"name\": \"Test Group\",",
  "patch": "--- a/tests/backends/sqlite/test_constraint_checking.py\n+++ b/tests/backends/sqlite/test_constraint_checking.py\n-# Empty if creating new file\n+import pytest\n+from django.db import connection, models\n+from django.db.utils import IntegrityError\n+from django.test import TestCase, TransactionTestCase\n+from django.test.utils import override_settings\n+import sqlite3\n+\n+\n+class OrderModel(models.Model):\n+    \"\"\"Model with table name 'order' which is a SQL keyword.\"\"\"\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'order'\n+\n+\n+class GroupModel(models.Model):\n+    \"\"\"Model with table name 'group' which is a SQL keyword.\"\"\"\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'group'\n+\n+\n+class SelectModel(models.Model):\n+    \"\"\"Model with table name 'select' which is a SQL keyword.\"\"\"\n+    name = models.CharField(max_length=100)\n+    order = models.ForeignKey(OrderModel, on_delete=models.CASCADE, null=True)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'select'\n+\n+\n+@override_settings(USE_TZ=False)\n+class SQLiteConstraintCheckingTestCase(TransactionTestCase):\n+    \"\"\"Test constraint checking with SQL keyword table names in SQLite.\"\"\"\n+    \n+    available_apps = ['test_app']\n+    \n+    def setUp(self):\n+        \"\"\"Set up test models and database tables.\"\"\"\n+        if connection.vendor != 'sqlite':\n+            self.skipTest(\"This test is specific to SQLite backend\")\n+            \n+        # Create tables for our test models\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(OrderModel)\n+            schema_editor.create_model(GroupModel)\n+            schema_editor.create_model(SelectModel)\n+    \n+    def tearDown(self):\n+        \"\"\"Clean up test tables.\"\"\"\n+        if connection.vendor == 'sqlite':\n+            with connection.schema_editor() as schema_editor:\n+                schema_editor.delete_model(SelectModel)\n+                schema_editor.delete_model(GroupModel)\n+                schema_editor.delete_model(OrderModel)\n+    \n+    def test_check_constraints_with_keyword_table_names_fails_before_fix(self):\n+        \"\"\"\n+        Test that check_constraints fails with SQL keyword table names before fix.\n+        This test demonstrates the bug by directly calling the problematic code.\n+        \"\"\"\n+        # This test should fail before the fix is applied\n+        table_names = ['order', 'group', 'select']\n+        \n+        # Before the fix, this should raise sqlite3.OperationalError\n+        with self.assertRaises(sqlite3.OperationalError) as cm:\n+            # Directly test the buggy behavior by calling check_constraints\n+            # with table names that are SQL keywords\n+            connection.check_constraints(table_names)\n+        \n+        # The error message should mention syntax error near the keyword\n+        self.assertIn('syntax error', str(cm.exception).lower())\n+    \n+    def test_check_constraints_with_keyword_table_names_passes_after_fix(self):\n+        \"\"\"\n+        Test that check_constraints works with SQL keyword table names after fix.\n+        This test verifies the fix works correctly.\n+        \"\"\"\n+        # Create some test data\n+        order_obj = OrderModel.objects.create(name=\"Test Order\")\n+        group_obj = GroupModel.objects.create(name=\"Test Group\")\n+        select_obj = SelectModel.objects.create(name=\"Test Select\", order=order_obj)\n+        \n+        # After the fix, this should work without errors\n+        table_names = ['order', 'group', 'select']\n+        \n+        try:\n+            # This should not raise any exceptions after the fix\n+            connection.check_constraints(table_names)\n+        except sqlite3.OperationalError as e:\n+            self.fail(f\"check_constraints failed with SQL keyword table names: {e}\")\n+    \n+    def test_check_constraints_with_no_table_names(self):\n+        \"\"\"Test that check_constraints works when table_names is None.\"\"\"\n+        # Create some test data\n+        order_obj = OrderModel.objects.create(name=\"Test Order\")\n+        \n+        try:\n+            # This should work regardless of table names being keywords\n+            connection.check_constraints(None)\n+        except sqlite3.OperationalError as e:\n+            self.fail(f\"check_constraints failed with table_names=None: {e}\")\n+    \n+    def test_check_constraints_with_foreign_key_violations(self):\n+        \"\"\"Test that check_constraints properly detects foreign key violations.\"\"\"\n+        # Create test data with valid foreign key\n+        order_obj = OrderModel.objects.create(name=\"Test Order\")\n+        select_obj = SelectModel.objects.create(name=\"Test Select\", order=order_obj)\n+        \n+        # Disable constraint checking to create invalid data\n+        connection.disable_constraint_checking()\n+        \n+        try:\n+            # Delete the referenced order while constraint checking is disabled\n+            order_obj.delete()\n+            \n+            # Re-enable constraint checking\n+            connection.enable_constraint_checking()\n+            \n+            # Now check constraints - this should detect the violation\n+            with self.assertRaises(IntegrityError):\n+                connection.check_constraints(['select'])\n+                \n+        finally:\n+            # Clean up - re-enable constraints if they were left disabled\n+            connection.enable_constraint_checking()\n+    \n+    def test_pragma_foreign_key_check_direct_sql_keyword_table(self):\n+        \"\"\"\n+        Test direct PRAGMA foreign_key_check with SQL keyword table names.\n+        This test directly exercises the problematic SQL statements.\n+        \"\"\"\n+        # Create a table with a keyword name\n+        OrderModel.objects.create(name=\"Test Order\")\n+        \n+        with connection.cursor() as cursor:\n+            # Before fix: This would fail with syntax error\n+            # After fix: This should work with quoted table names\n+            try:\n+                # Test the specific PRAGMA statements that were failing\n+                cursor.execute('PRAGMA foreign_key_check(\"order\")')\n+                result = cursor.fetchall()\n+                # Should not raise an exception\n+                self.assertIsInstance(result, list)\n+            except sqlite3.OperationalError as e:\n+                if 'syntax error' in str(e).lower():\n+                    self.fail(\"PRAGMA foreign_key_check failed with quoted table name\")\n+                else:\n+                    # Re-raise if it's a different error\n+                    raise\n+    \n+    def test_pragma_foreign_key_list_direct_sql_keyword_table(self):\n+        \"\"\"\n+        Test direct PRAGMA foreign_key_list with SQL keyword table names.\n+        \"\"\"\n+        # Create tables with foreign key relationship\n+        order_obj = OrderModel.objects.create(name=\"Test Order\")\n+        SelectModel.objects.create(name=\"Test Select\", order=order_obj)\n+        \n+        with connection.cursor() as cursor:\n+            try:\n+                # Test the specific PRAGMA statement that was failing\n+                cursor.execute('PRAGMA foreign_key_list(\"select\")')\n+                result = cursor.fetchall()\n+                # Should not raise an exception and should return foreign key info\n+                self.assertIsInstance(result, list)\n+            except sqlite3.OperationalError as e:\n+                if 'syntax error' in str(e).lower():\n+                    self.fail(\"PRAGMA foreign_key_list failed with quoted table name\")\n+                else:\n+                    # Re-raise if it's a different error\n+                    raise\n+    \n+    def test_edge_case_table_names_with_special_characters(self):\n+        \"\"\"Test constraint checking with table names containing special characters.\"\"\"\n+        # Test with table names that might cause issues\n+        special_table_names = [\n+            'order',      # SQL keyword\n+            'group',      # SQL keyword  \n+            'select',     # SQL keyword\n+            'table-name', # Hyphen\n+            'table_name', # Underscore (should be fine)\n+        ]\n+        \n+        # This should not crash even with special table names\n+        try:\n+            connection.check_constraints(special_table_names)\n+        except sqlite3.OperationalError as e:\n+            if 'syntax error' in str(e).lower():\n+                self.fail(f\"check_constraints failed with special table names: {e}\")\n+            # Other operational errors might be expected (e.g., table doesn't exist)\n+    \n+    def test_empty_table_names_list(self):\n+        \"\"\"Test constraint checking with empty table names list.\"\"\"\n+        # Empty list should not cause issues\n+        try:\n+            connection.check_constraints([])\n+        except sqlite3.OperationalError as e:\n+            self.fail(f\"check_constraints failed with empty table names list: {e}\")\n+\n+\n+class SQLiteConstraintCheckingUnitTest(TestCase):\n+    \"\"\"Unit tests for SQLite constraint checking functionality.\"\"\"\n+    \n+    def test_quote_name_functionality(self):\n+        \"\"\"Test that the quote_name method works correctly for SQLite.\"\"\"\n+        if connection.vendor != 'sqlite':\n+            self.skipTest(\"This test is specific to SQLite backend\")\n+        \n+        # Test basic quoting\n+        self.assertEqual(connection.ops.quote_name('order'), '\"order\"')\n+        self.assertEqual(connection.ops.quote_name('group'), '\"group\"')\n+        self.assertEqual(connection.ops.quote_name('select'), '\"select\"')\n+        \n+        # Test that already quoted names are not double-quoted\n+        self.assertEqual(connection.ops.quote_name('\"order\"'), '\"order\"')\n+        \n+        # Test normal table names\n+        self.assertEqual(connection.ops.quote_name('normal_table'), '\"normal_table\"')\n+    \n+    def test_supports_pragma_foreign_key_check_feature(self):\n+        \"\"\"Test that SQLite backend supports PRAGMA foreign_key_check.\"\"\"\n+        if connection.vendor != 'sqlite':\n+            self.skipTest(\"This test is specific to SQLite backend\")\n+        \n+        # SQLite should support PRAGMA foreign_key_check\n+        self.assertTrue(connection.features.supports_pragma_foreign_key_check)\n"
}