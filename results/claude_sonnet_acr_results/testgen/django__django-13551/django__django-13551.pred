{
  "instance_id": "django__django-13551",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/auth_tests/test_tokens.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom datetime import datetime, timedelta\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.tokens import default_token_generator, PasswordResetTokenGenerator\nfrom django.test import TestCase, override_settings\nfrom django.contrib.auth.models import AbstractBaseUser\nfrom django.db import models\n\n\nclass CustomUserWithEmail(AbstractBaseUser):\n    \"\"\"Custom user model with email field for testing.\"\"\"\n    email = models.EmailField(unique=True)\n    username = models.CharField(max_length=150, unique=True)\n    is_active = models.BooleanField(default=True)\n    \n    USERNAME_FIELD = 'username'\n    EMAIL_FIELD = 'email'\n    \n    class Meta:\n        app_label = 'auth_tests'\n\n\nclass CustomUserWithoutEmail(AbstractBaseUser):\n    \"\"\"Custom user model without email field for testing.\"\"\"\n    username = models.CharField(max_length=150, unique=True)\n    is_active = models.BooleanField(default=True)\n    \n    USERNAME_FIELD = 'username'\n    \n    class Meta:\n        app_label = 'auth_tests'\n\n\nclass PasswordResetTokenEmailChangeTests(TestCase):\n    \"\"\"Test that password reset tokens are invalidated when email changes.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        User = get_user_model()\n        self.user = User.objects.create_user(\n            username='testuser',\n            email='original@example.com',\n            password='testpass123'\n        )\n        self.token_generator = PasswordResetTokenGenerator()\n    \n    def test_token_invalidated_when_email_changes_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: token remains valid after email change.\n        This test should FAIL before the fix is applied.\n        \"\"\"\n        # Generate token with original email\n        original_token = self.token_generator.make_token(self.user)\n        \n        # Verify token is valid with original email\n        self.assertTrue(\n            self.token_generator.check_token(self.user, original_token),\n            \"Token should be valid with original email\"\n        )\n        \n        # Change user's email address\n        self.user.email = 'changed@example.com'\n        self.user.save()\n        \n        # Token should be invalid after email change (this will fail before fix)\n        # This assertion demonstrates the bug - it will fail because the token\n        # remains valid even after email change\n        with self.assertRaises(AssertionError, msg=\"Bug: Token remains valid after email change\"):\n            self.assertFalse(\n                self.token_generator.check_token(self.user, original_token),\n                \"Token should be invalid after email change\"\n            )\n    \n    def test_token_invalidated_when_email_changes_after_fix(self):\n        \"\"\"\n        Test that verifies the fix: token becomes invalid after email change.\n        This test should PASS after the fix is applied.\n        \"\"\"\n        # Generate token with original email\n        original_token = self.token_generator.make_token(self.user)\n        \n        # Verify token is valid with original email\n        self.assertTrue(\n            self.token_generator.check_token(self.user, original_token),\n            \"Token should be valid with original email\"\n        )\n        \n        # Change user's email address\n        self.user.email = 'changed@example.com'\n        self.user.save()\n        \n        # After fix, token should be invalid after email change\n        self.assertFalse(\n            self.token_generator.check_token(self.user, original_token),\n            \"Token should be invalid after email change\"\n        )\n    \n    def test_new_token_valid_after_email_change(self):\n        \"\"\"Test that a new token is valid after email change.\"\"\"\n        # Change user's email address\n        self.user.email = 'changed@example.com'\n        self.user.save()\n        \n        # Generate new token with changed email\n        new_token = self.token_generator.make_token(self.user)\n        \n        # New token should be valid\n        self.assertTrue(\n            self.token_generator.check_token(self.user, new_token),\n            \"New token should be valid with changed email\"\n        )\n    \n    def test_token_remains_valid_when_email_unchanged(self):\n        \"\"\"Test that token remains valid when email doesn't change.\"\"\"\n        # Generate token\n        token = self.token_generator.make_token(self.user)\n        \n        # Verify token is valid\n        self.assertTrue(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be valid\"\n        )\n        \n        # Save user without changing email\n        self.user.save()\n        \n        # Token should still be valid\n        self.assertTrue(\n            self.token_generator.check_token(self.user, token),\n            \"Token should remain valid when email unchanged\"\n        )\n    \n    def test_token_invalidated_when_email_set_to_none(self):\n        \"\"\"Test token invalidation when email is set to None.\"\"\"\n        # Generate token with email\n        token = self.token_generator.make_token(self.user)\n        \n        # Set email to None\n        self.user.email = None\n        self.user.save()\n        \n        # Token should be invalid\n        self.assertFalse(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be invalid when email set to None\"\n        )\n    \n    def test_token_invalidated_when_email_set_from_none(self):\n        \"\"\"Test token invalidation when email is set from None to a value.\"\"\"\n        # Start with no email\n        self.user.email = None\n        self.user.save()\n        \n        # Generate token with no email\n        token = self.token_generator.make_token(self.user)\n        \n        # Set email to a value\n        self.user.email = 'newemail@example.com'\n        self.user.save()\n        \n        # Token should be invalid\n        self.assertFalse(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be invalid when email set from None\"\n        )\n    \n    def test_multiple_email_changes_invalidate_all_previous_tokens(self):\n        \"\"\"Test that multiple email changes invalidate all previous tokens.\"\"\"\n        # Generate tokens with different email states\n        tokens = []\n        \n        # Token 1: original email\n        tokens.append(self.token_generator.make_token(self.user))\n        \n        # Token 2: first email change\n        self.user.email = 'first@example.com'\n        self.user.save()\n        tokens.append(self.token_generator.make_token(self.user))\n        \n        # Token 3: second email change\n        self.user.email = 'second@example.com'\n        self.user.save()\n        tokens.append(self.token_generator.make_token(self.user))\n        \n        # Only the latest token should be valid\n        self.assertFalse(\n            self.token_generator.check_token(self.user, tokens[0]),\n            \"First token should be invalid\"\n        )\n        self.assertFalse(\n            self.token_generator.check_token(self.user, tokens[1]),\n            \"Second token should be invalid\"\n        )\n        self.assertTrue(\n            self.token_generator.check_token(self.user, tokens[2]),\n            \"Latest token should be valid\"\n        )\n\n\nclass PasswordResetTokenNoEmailFieldTests(TestCase):\n    \"\"\"Test password reset tokens with user models that don't have email fields.\"\"\"\n    \n    def test_token_generation_without_email_field(self):\n        \"\"\"Test that token generation works for users without email field.\"\"\"\n        # This test simulates a user model without an email field\n        # We'll mock the behavior by temporarily removing the email attribute\n        user = get_user_model().objects.create_user(\n            username='noemailuser',\n            password='testpass123'\n        )\n        \n        # Remove email attribute to simulate user without email field\n        if hasattr(user, 'email'):\n            delattr(user, 'email')\n        \n        token_generator = PasswordResetTokenGenerator()\n        \n        # Should not raise an exception\n        token = token_generator.make_token(user)\n        self.assertIsNotNone(token, \"Token should be generated even without email field\")\n        \n        # Token should be valid\n        self.assertTrue(\n            token_generator.check_token(user, token),\n            \"Token should be valid for user without email field\"\n        )\n    \n    def test_hash_value_consistency_without_email(self):\n        \"\"\"Test that _make_hash_value is consistent for users without email.\"\"\"\n        user = get_user_model().objects.create_user(\n            username='consistencyuser',\n            password='testpass123'\n        )\n        \n        # Remove email attribute\n        if hasattr(user, 'email'):\n            delattr(user, 'email')\n        \n        token_generator = PasswordResetTokenGenerator()\n        timestamp = 1234567890\n        \n        # Generate hash value multiple times\n        hash1 = token_generator._make_hash_value(user, timestamp)\n        hash2 = token_generator._make_hash_value(user, timestamp)\n        \n        self.assertEqual(hash1, hash2, \"Hash values should be consistent\")\n\n\nclass PasswordResetTokenEdgeCaseTests(TestCase):\n    \"\"\"Test edge cases for password reset token generation.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        User = get_user_model()\n        self.user = User.objects.create_user(\n            username='edgeuser',\n            email='edge@example.com',\n            password='testpass123'\n        )\n        self.token_generator = PasswordResetTokenGenerator()\n    \n    def test_empty_email_string(self):\n        \"\"\"Test behavior with empty email string.\"\"\"\n        # Set email to empty string\n        self.user.email = ''\n        self.user.save()\n        \n        token = self.token_generator.make_token(self.user)\n        \n        # Change to different empty-like value\n        self.user.email = None\n        self.user.save()\n        \n        # Token should be invalid due to email change\n        self.assertFalse(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be invalid when email changes from empty string to None\"\n        )\n    \n    def test_whitespace_email_changes(self):\n        \"\"\"Test that whitespace changes in email invalidate tokens.\"\"\"\n        # Set email with whitespace\n        self.user.email = ' test@example.com '\n        self.user.save()\n        \n        token = self.token_generator.make_token(self.user)\n        \n        # Change email by removing whitespace\n        self.user.email = 'test@example.com'\n        self.user.save()\n        \n        # Token should be invalid\n        self.assertFalse(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be invalid when email whitespace changes\"\n        )\n    \n    def test_case_sensitive_email_changes(self):\n        \"\"\"Test that email case changes invalidate tokens.\"\"\"\n        # Set email in lowercase\n        self.user.email = 'test@example.com'\n        self.user.save()\n        \n        token = self.token_generator.make_token(self.user)\n        \n        # Change email case\n        self.user.email = 'TEST@EXAMPLE.COM'\n        self.user.save()\n        \n        # Token should be invalid\n        self.assertFalse(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be invalid when email case changes\"\n        )\n    \n    def test_unicode_email_changes(self):\n        \"\"\"Test that unicode email changes invalidate tokens.\"\"\"\n        # Set email with unicode characters\n        self.user.email = 't\u00ebst@example.com'\n        self.user.save()\n        \n        token = self.token_generator.make_token(self.user)\n        \n        # Change email\n        self.user.email = 'test@example.com'\n        self.user.save()\n        \n        # Token should be invalid\n        self.assertFalse(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be invalid when unicode email changes\"\n        )\n\n\nclass PasswordResetTokenBackwardCompatibilityTests(TestCase):\n    \"\"\"Test that the fix doesn't break existing functionality.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        User = get_user_model()\n        self.user = User.objects.create_user(\n            username='compatuser',\n            email='compat@example.com',\n            password='testpass123'\n        )\n        self.token_generator = PasswordResetTokenGenerator()\n    \n    def test_password_change_still_invalidates_token(self):\n        \"\"\"Test that password changes still invalidate tokens.\"\"\"\n        token = self.token_generator.make_token(self.user)\n        \n        # Change password\n        self.user.set_password('newpassword123')\n        self.user.save()\n        \n        # Token should be invalid\n        self.assertFalse(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be invalid after password change\"\n        )\n    \n    def test_last_login_change_still_invalidates_token(self):\n        \"\"\"Test that last_login changes still invalidate tokens.\"\"\"\n        # Set initial last_login\n        self.user.last_login = datetime.now() - timedelta(days=1)\n        self.user.save()\n        \n        token = self.token_generator.make_token(self.user)\n        \n        # Change last_login\n        self.user.last_login = datetime.now()\n        self.user.save()\n        \n        # Token should be invalid\n        self.assertFalse(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be invalid after last_login change\"\n        )\n    \n    def test_token_timeout_still_works(self):\n        \"\"\"Test that token timeout functionality still works.\"\"\"\n        # This test verifies that the timeout mechanism isn't broken\n        # We can't easily test actual timeout without mocking time,\n        # but we can verify the token generation still includes timestamp\n        token = self.token_generator.make_token(self.user)\n        \n        # Token should be valid immediately\n        self.assertTrue(\n            self.token_generator.check_token(self.user, token),\n            \"Token should be valid immediately after generation\"\n        )\n        \n        # Verify token format (should contain timestamp)\n        self.assertIn('-', token, \"Token should contain timestamp separator\")\n        parts = token.split('-')\n        self.assertEqual(len(parts), 2, \"Token should have exactly 2 parts\")\n    \n    def test_default_token_generator_behavior(self):\n        \"\"\"Test that the default token generator still works correctly.\"\"\"\n        # Test with the default token generator instance\n        token = default_token_generator.make_token(self.user)\n        \n        self.assertTrue(\n            default_token_generator.check_token(self.user, token),\n            \"Default token generator should work correctly\"\n        )\n        \n        # Change email and verify token is invalid\n        self.user.email = 'changed@example.com'\n        self.user.save()\n        \n        self.assertFalse(\n            default_token_generator.check_token(self.user, token),\n            \"Default token generator should invalidate token after email change\"\n        )\n</patched>\n```",
  "patch": "--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n-# Empty if creating new file\n+import pytest\n+from datetime import datetime, timedelta\n+from django.contrib.auth import get_user_model\n+from django.contrib.auth.tokens import default_token_generator, PasswordResetTokenGenerator\n+from django.test import TestCase, override_settings\n+from django.contrib.auth.models import AbstractBaseUser\n+from django.db import models\n+\n+\n+class CustomUserWithEmail(AbstractBaseUser):\n+    \"\"\"Custom user model with email field for testing.\"\"\"\n+    email = models.EmailField(unique=True)\n+    username = models.CharField(max_length=150, unique=True)\n+    is_active = models.BooleanField(default=True)\n+    \n+    USERNAME_FIELD = 'username'\n+    EMAIL_FIELD = 'email'\n+    \n+    class Meta:\n+        app_label = 'auth_tests'\n+\n+\n+class CustomUserWithoutEmail(AbstractBaseUser):\n+    \"\"\"Custom user model without email field for testing.\"\"\"\n+    username = models.CharField(max_length=150, unique=True)\n+    is_active = models.BooleanField(default=True)\n+    \n+    USERNAME_FIELD = 'username'\n+    \n+    class Meta:\n+        app_label = 'auth_tests'\n+\n+\n+class PasswordResetTokenEmailChangeTests(TestCase):\n+    \"\"\"Test that password reset tokens are invalidated when email changes.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        User = get_user_model()\n+        self.user = User.objects.create_user(\n+            username='testuser',\n+            email='original@example.com',\n+            password='testpass123'\n+        )\n+        self.token_generator = PasswordResetTokenGenerator()\n+    \n+    def test_token_invalidated_when_email_changes_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: token remains valid after email change.\n+        This test should FAIL before the fix is applied.\n+        \"\"\"\n+        # Generate token with original email\n+        original_token = self.token_generator.make_token(self.user)\n+        \n+        # Verify token is valid with original email\n+        self.assertTrue(\n+            self.token_generator.check_token(self.user, original_token),\n+            \"Token should be valid with original email\"\n+        )\n+        \n+        # Change user's email address\n+        self.user.email = 'changed@example.com'\n+        self.user.save()\n+        \n+        # Token should be invalid after email change (this will fail before fix)\n+        # This assertion demonstrates the bug - it will fail because the token\n+        # remains valid even after email change\n+        with self.assertRaises(AssertionError, msg=\"Bug: Token remains valid after email change\"):\n+            self.assertFalse(\n+                self.token_generator.check_token(self.user, original_token),\n+                \"Token should be invalid after email change\"\n+            )\n+    \n+    def test_token_invalidated_when_email_changes_after_fix(self):\n+        \"\"\"\n+        Test that verifies the fix: token becomes invalid after email change.\n+        This test should PASS after the fix is applied.\n+        \"\"\"\n+        # Generate token with original email\n+        original_token = self.token_generator.make_token(self.user)\n+        \n+        # Verify token is valid with original email\n+        self.assertTrue(\n+            self.token_generator.check_token(self.user, original_token),\n+            \"Token should be valid with original email\"\n+        )\n+        \n+        # Change user's email address\n+        self.user.email = 'changed@example.com'\n+        self.user.save()\n+        \n+        # After fix, token should be invalid after email change\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, original_token),\n+            \"Token should be invalid after email change\"\n+        )\n+    \n+    def test_new_token_valid_after_email_change(self):\n+        \"\"\"Test that a new token is valid after email change.\"\"\"\n+        # Change user's email address\n+        self.user.email = 'changed@example.com'\n+        self.user.save()\n+        \n+        # Generate new token with changed email\n+        new_token = self.token_generator.make_token(self.user)\n+        \n+        # New token should be valid\n+        self.assertTrue(\n+            self.token_generator.check_token(self.user, new_token),\n+            \"New token should be valid with changed email\"\n+        )\n+    \n+    def test_token_remains_valid_when_email_unchanged(self):\n+        \"\"\"Test that token remains valid when email doesn't change.\"\"\"\n+        # Generate token\n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Verify token is valid\n+        self.assertTrue(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be valid\"\n+        )\n+        \n+        # Save user without changing email\n+        self.user.save()\n+        \n+        # Token should still be valid\n+        self.assertTrue(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should remain valid when email unchanged\"\n+        )\n+    \n+    def test_token_invalidated_when_email_set_to_none(self):\n+        \"\"\"Test token invalidation when email is set to None.\"\"\"\n+        # Generate token with email\n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Set email to None\n+        self.user.email = None\n+        self.user.save()\n+        \n+        # Token should be invalid\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be invalid when email set to None\"\n+        )\n+    \n+    def test_token_invalidated_when_email_set_from_none(self):\n+        \"\"\"Test token invalidation when email is set from None to a value.\"\"\"\n+        # Start with no email\n+        self.user.email = None\n+        self.user.save()\n+        \n+        # Generate token with no email\n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Set email to a value\n+        self.user.email = 'newemail@example.com'\n+        self.user.save()\n+        \n+        # Token should be invalid\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be invalid when email set from None\"\n+        )\n+    \n+    def test_multiple_email_changes_invalidate_all_previous_tokens(self):\n+        \"\"\"Test that multiple email changes invalidate all previous tokens.\"\"\"\n+        # Generate tokens with different email states\n+        tokens = []\n+        \n+        # Token 1: original email\n+        tokens.append(self.token_generator.make_token(self.user))\n+        \n+        # Token 2: first email change\n+        self.user.email = 'first@example.com'\n+        self.user.save()\n+        tokens.append(self.token_generator.make_token(self.user))\n+        \n+        # Token 3: second email change\n+        self.user.email = 'second@example.com'\n+        self.user.save()\n+        tokens.append(self.token_generator.make_token(self.user))\n+        \n+        # Only the latest token should be valid\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, tokens[0]),\n+            \"First token should be invalid\"\n+        )\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, tokens[1]),\n+            \"Second token should be invalid\"\n+        )\n+        self.assertTrue(\n+            self.token_generator.check_token(self.user, tokens[2]),\n+            \"Latest token should be valid\"\n+        )\n+\n+\n+class PasswordResetTokenNoEmailFieldTests(TestCase):\n+    \"\"\"Test password reset tokens with user models that don't have email fields.\"\"\"\n+    \n+    def test_token_generation_without_email_field(self):\n+        \"\"\"Test that token generation works for users without email field.\"\"\"\n+        # This test simulates a user model without an email field\n+        # We'll mock the behavior by temporarily removing the email attribute\n+        user = get_user_model().objects.create_user(\n+            username='noemailuser',\n+            password='testpass123'\n+        )\n+        \n+        # Remove email attribute to simulate user without email field\n+        if hasattr(user, 'email'):\n+            delattr(user, 'email')\n+        \n+        token_generator = PasswordResetTokenGenerator()\n+        \n+        # Should not raise an exception\n+        token = token_generator.make_token(user)\n+        self.assertIsNotNone(token, \"Token should be generated even without email field\")\n+        \n+        # Token should be valid\n+        self.assertTrue(\n+            token_generator.check_token(user, token),\n+            \"Token should be valid for user without email field\"\n+        )\n+    \n+    def test_hash_value_consistency_without_email(self):\n+        \"\"\"Test that _make_hash_value is consistent for users without email.\"\"\"\n+        user = get_user_model().objects.create_user(\n+            username='consistencyuser',\n+            password='testpass123'\n+        )\n+        \n+        # Remove email attribute\n+        if hasattr(user, 'email'):\n+            delattr(user, 'email')\n+        \n+        token_generator = PasswordResetTokenGenerator()\n+        timestamp = 1234567890\n+        \n+        # Generate hash value multiple times\n+        hash1 = token_generator._make_hash_value(user, timestamp)\n+        hash2 = token_generator._make_hash_value(user, timestamp)\n+        \n+        self.assertEqual(hash1, hash2, \"Hash values should be consistent\")\n+\n+\n+class PasswordResetTokenEdgeCaseTests(TestCase):\n+    \"\"\"Test edge cases for password reset token generation.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        User = get_user_model()\n+        self.user = User.objects.create_user(\n+            username='edgeuser',\n+            email='edge@example.com',\n+            password='testpass123'\n+        )\n+        self.token_generator = PasswordResetTokenGenerator()\n+    \n+    def test_empty_email_string(self):\n+        \"\"\"Test behavior with empty email string.\"\"\"\n+        # Set email to empty string\n+        self.user.email = ''\n+        self.user.save()\n+        \n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Change to different empty-like value\n+        self.user.email = None\n+        self.user.save()\n+        \n+        # Token should be invalid due to email change\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be invalid when email changes from empty string to None\"\n+        )\n+    \n+    def test_whitespace_email_changes(self):\n+        \"\"\"Test that whitespace changes in email invalidate tokens.\"\"\"\n+        # Set email with whitespace\n+        self.user.email = ' test@example.com '\n+        self.user.save()\n+        \n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Change email by removing whitespace\n+        self.user.email = 'test@example.com'\n+        self.user.save()\n+        \n+        # Token should be invalid\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be invalid when email whitespace changes\"\n+        )\n+    \n+    def test_case_sensitive_email_changes(self):\n+        \"\"\"Test that email case changes invalidate tokens.\"\"\"\n+        # Set email in lowercase\n+        self.user.email = 'test@example.com'\n+        self.user.save()\n+        \n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Change email case\n+        self.user.email = 'TEST@EXAMPLE.COM'\n+        self.user.save()\n+        \n+        # Token should be invalid\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be invalid when email case changes\"\n+        )\n+    \n+    def test_unicode_email_changes(self):\n+        \"\"\"Test that unicode email changes invalidate tokens.\"\"\"\n+        # Set email with unicode characters\n+        self.user.email = 't\u00ebst@example.com'\n+        self.user.save()\n+        \n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Change email\n+        self.user.email = 'test@example.com'\n+        self.user.save()\n+        \n+        # Token should be invalid\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be invalid when unicode email changes\"\n+        )\n+\n+\n+class PasswordResetTokenBackwardCompatibilityTests(TestCase):\n+    \"\"\"Test that the fix doesn't break existing functionality.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        User = get_user_model()\n+        self.user = User.objects.create_user(\n+            username='compatuser',\n+            email='compat@example.com',\n+            password='testpass123'\n+        )\n+        self.token_generator = PasswordResetTokenGenerator()\n+    \n+    def test_password_change_still_invalidates_token(self):\n+        \"\"\"Test that password changes still invalidate tokens.\"\"\"\n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Change password\n+        self.user.set_password('newpassword123')\n+        self.user.save()\n+        \n+        # Token should be invalid\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be invalid after password change\"\n+        )\n+    \n+    def test_last_login_change_still_invalidates_token(self):\n+        \"\"\"Test that last_login changes still invalidate tokens.\"\"\"\n+        # Set initial last_login\n+        self.user.last_login = datetime.now() - timedelta(days=1)\n+        self.user.save()\n+        \n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Change last_login\n+        self.user.last_login = datetime.now()\n+        self.user.save()\n+        \n+        # Token should be invalid\n+        self.assertFalse(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be invalid after last_login change\"\n+        )\n+    \n+    def test_token_timeout_still_works(self):\n+        \"\"\"Test that token timeout functionality still works.\"\"\"\n+        # This test verifies that the timeout mechanism isn't broken\n+        # We can't easily test actual timeout without mocking time,\n+        # but we can verify the token generation still includes timestamp\n+        token = self.token_generator.make_token(self.user)\n+        \n+        # Token should be valid immediately\n+        self.assertTrue(\n+            self.token_generator.check_token(self.user, token),\n+            \"Token should be valid immediately after generation\"\n+        )\n+        \n+        # Verify token format (should contain timestamp)\n+        self.assertIn('-', token, \"Token should contain timestamp separator\")\n+        parts = token.split('-')\n+        self.assertEqual(len(parts), 2, \"Token should have exactly 2 parts\")\n+    \n+    def test_default_token_generator_behavior(self):\n+        \"\"\"Test that the default token generator still works correctly.\"\"\"\n+        # Test with the default token generator instance\n+        token = default_token_generator.make_token(self.user)\n+        \n+        self.assertTrue(\n+            default_token_generator.check_token(self.user, token),\n+            \"Default token generator should work correctly\"\n+        )\n+        \n+        # Change email and verify token is invalid\n+        self.user.email = 'changed@example.com'\n+        self.user.save()\n+        \n+        self.assertFalse(\n+            default_token_generator.check_token(self.user, token),\n+            \"Default token generator should invalidate token after email change\"\n+        )\n"
}