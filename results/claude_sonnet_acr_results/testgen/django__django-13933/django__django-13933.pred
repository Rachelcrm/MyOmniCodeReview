{
  "instance_id": "django__django-13933",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/forms_tests/test_models.py</file>\n<original>\n# This will be added to the existing test file\n</original>\n<patched>\nimport pytest\nfrom django.core.exceptions import ValidationError\nfrom django.forms import ModelChoiceField, ModelMultipleChoiceField\nfrom django.test import TestCase\nfrom django.db import models\n\n\nclass TestModel(models.Model):\n    \"\"\"Test model for ModelChoiceField tests.\"\"\"\n    name = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'forms_tests'\n\n\nclass ModelChoiceFieldValidationErrorTests(TestCase):\n    \"\"\"Test that ModelChoiceField provides value in ValidationError messages.\"\"\"\n    \n    @classmethod\n    def setUpTestData(cls):\n        \"\"\"Create test data.\"\"\"\n        cls.test_obj1 = TestModel.objects.create(name=\"Test Object 1\")\n        cls.test_obj2 = TestModel.objects.create(name=\"Test Object 2\")\n    \n    def test_model_choice_field_invalid_choice_includes_value_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: ModelChoiceField doesn't include \n        the invalid value in ValidationError message.\n        This test should fail before the fix is applied.\n        \"\"\"\n        field = ModelChoiceField(queryset=TestModel.objects.all())\n        \n        # Try to validate an invalid choice\n        invalid_value = 999  # Non-existent primary key\n        \n        with self.assertRaises(ValidationError) as cm:\n            field.to_python(invalid_value)\n        \n        error = cm.exception\n        \n        # Before fix: This assertion will fail because the error message \n        # doesn't contain the invalid value\n        self.assertIn(str(invalid_value), str(error))\n        \n        # Also check that the error has the correct code\n        self.assertEqual(error.code, 'invalid_choice')\n    \n    def test_model_choice_field_invalid_choice_includes_value_after_fix(self):\n        \"\"\"\n        Test that ModelChoiceField includes the invalid value in ValidationError \n        message after the fix is applied.\n        \"\"\"\n        field = ModelChoiceField(queryset=TestModel.objects.all())\n        \n        # Try to validate an invalid choice\n        invalid_value = 999  # Non-existent primary key\n        \n        with self.assertRaises(ValidationError) as cm:\n            field.to_python(invalid_value)\n        \n        error = cm.exception\n        \n        # After fix: The error message should contain the invalid value\n        self.assertIn(str(invalid_value), str(error))\n        self.assertEqual(error.code, 'invalid_choice')\n        \n        # Check that params contain the value\n        if hasattr(error, 'params') and error.params:\n            self.assertIn('value', error.params)\n            self.assertEqual(error.params['value'], invalid_value)\n    \n    def test_model_choice_field_invalid_string_choice_includes_value(self):\n        \"\"\"Test that string invalid choices are also included in error message.\"\"\"\n        field = ModelChoiceField(queryset=TestModel.objects.all())\n        \n        # Try to validate an invalid string choice\n        invalid_value = \"invalid_string\"\n        \n        with self.assertRaises(ValidationError) as cm:\n            field.to_python(invalid_value)\n        \n        error = cm.exception\n        \n        # The error message should contain the invalid value\n        self.assertIn(invalid_value, str(error))\n        self.assertEqual(error.code, 'invalid_choice')\n    \n    def test_model_choice_field_valid_choice_works(self):\n        \"\"\"Test that valid choices still work correctly.\"\"\"\n        field = ModelChoiceField(queryset=TestModel.objects.all())\n        \n        # Valid choice should work\n        valid_value = self.test_obj1.pk\n        result = field.to_python(valid_value)\n        \n        self.assertEqual(result, self.test_obj1)\n    \n    def test_model_choice_field_empty_value_works(self):\n        \"\"\"Test that empty values are handled correctly.\"\"\"\n        field = ModelChoiceField(queryset=TestModel.objects.all(), required=False)\n        \n        # Empty values should return None\n        self.assertIsNone(field.to_python(''))\n        self.assertIsNone(field.to_python(None))\n    \n    def test_model_choice_field_error_message_format_consistency(self):\n        \"\"\"\n        Test that ModelChoiceField error message format is consistent \n        with ModelMultipleChoiceField and ChoiceField.\n        \"\"\"\n        # Test ModelChoiceField\n        model_field = ModelChoiceField(queryset=TestModel.objects.all())\n        \n        with self.assertRaises(ValidationError) as cm:\n            model_field.to_python(999)\n        \n        model_error_msg = str(cm.exception)\n        \n        # Test ModelMultipleChoiceField for comparison\n        multi_field = ModelMultipleChoiceField(queryset=TestModel.objects.all())\n        \n        with self.assertRaises(ValidationError) as cm:\n            multi_field._check_values([999])\n        \n        multi_error_msg = str(cm.exception)\n        \n        # Both should contain the invalid value\n        self.assertIn('999', model_error_msg)\n        self.assertIn('999', multi_error_msg)\n        \n        # Both should have similar message structure\n        self.assertIn('Select a valid choice', model_error_msg)\n        self.assertIn('Select a valid choice', multi_error_msg)\n        self.assertIn('not one of the available choices', model_error_msg)\n        self.assertIn('not one of the available choices', multi_error_msg)\n    \n    def test_model_choice_field_custom_to_field_name(self):\n        \"\"\"Test that custom to_field_name works with error messages.\"\"\"\n        # Create a field that uses 'name' instead of 'pk'\n        field = ModelChoiceField(\n            queryset=TestModel.objects.all(),\n            to_field_name='name'\n        )\n        \n        invalid_value = \"nonexistent_name\"\n        \n        with self.assertRaises(ValidationError) as cm:\n            field.to_python(invalid_value)\n        \n        error = cm.exception\n        \n        # The error message should contain the invalid value\n        self.assertIn(invalid_value, str(error))\n        self.assertEqual(error.code, 'invalid_choice')\n    \n    def test_model_choice_field_model_instance_invalid(self):\n        \"\"\"Test error message when passing invalid model instance.\"\"\"\n        field = ModelChoiceField(queryset=TestModel.objects.filter(pk=self.test_obj1.pk))\n        \n        # Pass a model instance that's not in the queryset\n        invalid_instance = self.test_obj2\n        \n        with self.assertRaises(ValidationError) as cm:\n            field.to_python(invalid_instance)\n        \n        error = cm.exception\n        \n        # The error message should contain the invalid value (pk of the instance)\n        self.assertIn(str(invalid_instance.pk), str(error))\n        self.assertEqual(error.code, 'invalid_choice')\n    \n    def test_model_choice_field_error_message_template_has_value_placeholder(self):\n        \"\"\"Test that the error message template includes %(value)s placeholder.\"\"\"\n        field = ModelChoiceField(queryset=TestModel.objects.all())\n        \n        # Check that the error message template includes the value placeholder\n        error_msg_template = field.error_messages['invalid_choice']\n        self.assertIn('%(value)s', error_msg_template)\n        \n        # Verify the template can be formatted with a value\n        formatted_msg = error_msg_template % {'value': 'test_value'}\n        self.assertIn('test_value', formatted_msg)\n</patched>\n```",
  "patch": "--- a/tests/forms_tests/test_models.py\n+++ b/tests/forms_tests/test_models.py\n-# This will be added to the existing test file\n+import pytest\n+from django.core.exceptions import ValidationError\n+from django.forms import ModelChoiceField, ModelMultipleChoiceField\n+from django.test import TestCase\n+from django.db import models\n+\n+\n+class TestModel(models.Model):\n+    \"\"\"Test model for ModelChoiceField tests.\"\"\"\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'forms_tests'\n+\n+\n+class ModelChoiceFieldValidationErrorTests(TestCase):\n+    \"\"\"Test that ModelChoiceField provides value in ValidationError messages.\"\"\"\n+    \n+    @classmethod\n+    def setUpTestData(cls):\n+        \"\"\"Create test data.\"\"\"\n+        cls.test_obj1 = TestModel.objects.create(name=\"Test Object 1\")\n+        cls.test_obj2 = TestModel.objects.create(name=\"Test Object 2\")\n+    \n+    def test_model_choice_field_invalid_choice_includes_value_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: ModelChoiceField doesn't include \n+        the invalid value in ValidationError message.\n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        field = ModelChoiceField(queryset=TestModel.objects.all())\n+        \n+        # Try to validate an invalid choice\n+        invalid_value = 999  # Non-existent primary key\n+        \n+        with self.assertRaises(ValidationError) as cm:\n+            field.to_python(invalid_value)\n+        \n+        error = cm.exception\n+        \n+        # Before fix: This assertion will fail because the error message \n+        # doesn't contain the invalid value\n+        self.assertIn(str(invalid_value), str(error))\n+        \n+        # Also check that the error has the correct code\n+        self.assertEqual(error.code, 'invalid_choice')\n+    \n+    def test_model_choice_field_invalid_choice_includes_value_after_fix(self):\n+        \"\"\"\n+        Test that ModelChoiceField includes the invalid value in ValidationError \n+        message after the fix is applied.\n+        \"\"\"\n+        field = ModelChoiceField(queryset=TestModel.objects.all())\n+        \n+        # Try to validate an invalid choice\n+        invalid_value = 999  # Non-existent primary key\n+        \n+        with self.assertRaises(ValidationError) as cm:\n+            field.to_python(invalid_value)\n+        \n+        error = cm.exception\n+        \n+        # After fix: The error message should contain the invalid value\n+        self.assertIn(str(invalid_value), str(error))\n+        self.assertEqual(error.code, 'invalid_choice')\n+        \n+        # Check that params contain the value\n+        if hasattr(error, 'params') and error.params:\n+            self.assertIn('value', error.params)\n+            self.assertEqual(error.params['value'], invalid_value)\n+    \n+    def test_model_choice_field_invalid_string_choice_includes_value(self):\n+        \"\"\"Test that string invalid choices are also included in error message.\"\"\"\n+        field = ModelChoiceField(queryset=TestModel.objects.all())\n+        \n+        # Try to validate an invalid string choice\n+        invalid_value = \"invalid_string\"\n+        \n+        with self.assertRaises(ValidationError) as cm:\n+            field.to_python(invalid_value)\n+        \n+        error = cm.exception\n+        \n+        # The error message should contain the invalid value\n+        self.assertIn(invalid_value, str(error))\n+        self.assertEqual(error.code, 'invalid_choice')\n+    \n+    def test_model_choice_field_valid_choice_works(self):\n+        \"\"\"Test that valid choices still work correctly.\"\"\"\n+        field = ModelChoiceField(queryset=TestModel.objects.all())\n+        \n+        # Valid choice should work\n+        valid_value = self.test_obj1.pk\n+        result = field.to_python(valid_value)\n+        \n+        self.assertEqual(result, self.test_obj1)\n+    \n+    def test_model_choice_field_empty_value_works(self):\n+        \"\"\"Test that empty values are handled correctly.\"\"\"\n+        field = ModelChoiceField(queryset=TestModel.objects.all(), required=False)\n+        \n+        # Empty values should return None\n+        self.assertIsNone(field.to_python(''))\n+        self.assertIsNone(field.to_python(None))\n+    \n+    def test_model_choice_field_error_message_format_consistency(self):\n+        \"\"\"\n+        Test that ModelChoiceField error message format is consistent \n+        with ModelMultipleChoiceField and ChoiceField.\n+        \"\"\"\n+        # Test ModelChoiceField\n+        model_field = ModelChoiceField(queryset=TestModel.objects.all())\n+        \n+        with self.assertRaises(ValidationError) as cm:\n+            model_field.to_python(999)\n+        \n+        model_error_msg = str(cm.exception)\n+        \n+        # Test ModelMultipleChoiceField for comparison\n+        multi_field = ModelMultipleChoiceField(queryset=TestModel.objects.all())\n+        \n+        with self.assertRaises(ValidationError) as cm:\n+            multi_field._check_values([999])\n+        \n+        multi_error_msg = str(cm.exception)\n+        \n+        # Both should contain the invalid value\n+        self.assertIn('999', model_error_msg)\n+        self.assertIn('999', multi_error_msg)\n+        \n+        # Both should have similar message structure\n+        self.assertIn('Select a valid choice', model_error_msg)\n+        self.assertIn('Select a valid choice', multi_error_msg)\n+        self.assertIn('not one of the available choices', model_error_msg)\n+        self.assertIn('not one of the available choices', multi_error_msg)\n+    \n+    def test_model_choice_field_custom_to_field_name(self):\n+        \"\"\"Test that custom to_field_name works with error messages.\"\"\"\n+        # Create a field that uses 'name' instead of 'pk'\n+        field = ModelChoiceField(\n+            queryset=TestModel.objects.all(),\n+            to_field_name='name'\n+        )\n+        \n+        invalid_value = \"nonexistent_name\"\n+        \n+        with self.assertRaises(ValidationError) as cm:\n+            field.to_python(invalid_value)\n+        \n+        error = cm.exception\n+        \n+        # The error message should contain the invalid value\n+        self.assertIn(invalid_value, str(error))\n+        self.assertEqual(error.code, 'invalid_choice')\n+    \n+    def test_model_choice_field_model_instance_invalid(self):\n+        \"\"\"Test error message when passing invalid model instance.\"\"\"\n+        field = ModelChoiceField(queryset=TestModel.objects.filter(pk=self.test_obj1.pk))\n+        \n+        # Pass a model instance that's not in the queryset\n+        invalid_instance = self.test_obj2\n+        \n+        with self.assertRaises(ValidationError) as cm:\n+            field.to_python(invalid_instance)\n+        \n+        error = cm.exception\n+        \n+        # The error message should contain the invalid value (pk of the instance)\n+        self.assertIn(str(invalid_instance.pk), str(error))\n+        self.assertEqual(error.code, 'invalid_choice')\n+    \n+    def test_model_choice_field_error_message_template_has_value_placeholder(self):\n+        \"\"\"Test that the error message template includes %(value)s placeholder.\"\"\"\n+        field = ModelChoiceField(queryset=TestModel.objects.all())\n+        \n+        # Check that the error message template includes the value placeholder\n+        error_msg_template = field.error_messages['invalid_choice']\n+        self.assertIn('%(value)s', error_msg_template)\n+        \n+        # Verify the template can be formatted with a value\n+        formatted_msg = error_msg_template % {'value': 'test_value'}\n+        self.assertIn('test_value', formatted_msg)\n"
}