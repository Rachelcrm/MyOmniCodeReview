{
  "instance_id": "django__django-13658",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/admin_scripts/test_management_utility.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport os\nimport sys\nimport pytest\nfrom unittest import mock\nfrom django.core.management import ManagementUtility, execute_from_command_line\nfrom django.core.management.base import CommandParser\n\n\nclass TestManagementUtilityProgName:\n    \"\"\"Test that ManagementUtility uses the computed prog_name consistently.\"\"\"\n\n    def test_prog_name_computed_from_argv(self):\n        \"\"\"Test that prog_name is correctly computed from provided argv.\"\"\"\n        # Test with regular script name\n        argv = ['/path/to/manage.py', 'help']\n        utility = ManagementUtility(argv)\n        assert utility.prog_name == 'manage.py'\n        \n        # Test with __main__.py\n        argv = ['/path/to/__main__.py', 'help']\n        utility = ManagementUtility(argv)\n        assert utility.prog_name == 'python -m django'\n        \n        # Test with custom script name\n        argv = ['/custom/path/my_script.py', 'help']\n        utility = ManagementUtility(argv)\n        assert utility.prog_name == 'my_script.py'\n\n    def test_prog_name_with_none_argv_zero(self):\n        \"\"\"Test that prog_name handles None in argv[0] gracefully.\"\"\"\n        # This reproduces the bug scenario where sys.argv[0] is None\n        argv = [None, 'help']\n        with pytest.raises((TypeError, AttributeError)):\n            # This should fail before the fix because os.path.basename(None) fails\n            ManagementUtility(argv)\n\n    @mock.patch('django.core.management.sys.argv', [None, 'help'])\n    def test_execute_from_command_line_with_custom_argv_none_sys_argv(self):\n        \"\"\"Test execute_from_command_line with custom argv when sys.argv[0] is None.\"\"\"\n        # This tests the scenario described in the issue where sys.argv[0] is None\n        # but we provide a custom argv to execute_from_command_line\n        custom_argv = ['/path/to/manage.py', 'help']\n        \n        # This should work without raising exceptions after the fix\n        try:\n            execute_from_command_line(custom_argv)\n        except SystemExit:\n            # SystemExit is expected for help command\n            pass\n\n    def test_command_parser_uses_computed_prog_name(self):\n        \"\"\"Test that CommandParser receives the computed prog_name.\"\"\"\n        argv = ['/custom/path/my_django_script.py', 'help']\n        utility = ManagementUtility(argv)\n        \n        # Mock CommandParser to capture the arguments passed to it\n        with mock.patch('django.core.management.CommandParser') as mock_parser:\n            mock_parser_instance = mock.Mock()\n            mock_parser.return_value = mock_parser_instance\n            mock_parser_instance.parse_known_args.return_value = (mock.Mock(settings=None, pythonpath=None), [])\n            \n            try:\n                utility.execute()\n            except SystemExit:\n                # SystemExit is expected for help command\n                pass\n            \n            # Verify that CommandParser was called with prog=self.prog_name\n            mock_parser.assert_called_with(\n                prog='my_django_script.py',\n                usage='%(prog)s subcommand [options] [args]',\n                add_help=False,\n                allow_abbrev=False\n            )\n\n    def test_command_parser_prog_name_consistency_main_py(self):\n        \"\"\"Test CommandParser prog consistency with __main__.py.\"\"\"\n        argv = ['/path/to/__main__.py', 'help']\n        utility = ManagementUtility(argv)\n        \n        with mock.patch('django.core.management.CommandParser') as mock_parser:\n            mock_parser_instance = mock.Mock()\n            mock_parser.return_value = mock_parser_instance\n            mock_parser_instance.parse_known_args.return_value = (mock.Mock(settings=None, pythonpath=None), [])\n            \n            try:\n                utility.execute()\n            except SystemExit:\n                pass\n            \n            # Verify that CommandParser was called with the transformed prog name\n            mock_parser.assert_called_with(\n                prog='python -m django',\n                usage='%(prog)s subcommand [options] [args]',\n                add_help=False,\n                allow_abbrev=False\n            )\n\n    @mock.patch('django.core.management.sys.argv', [None])\n    def test_bug_reproduction_none_sys_argv_without_custom_argv(self):\n        \"\"\"Test that demonstrates the bug when sys.argv[0] is None and no custom argv is provided.\"\"\"\n        # This test reproduces the original bug scenario\n        with pytest.raises((TypeError, AttributeError)):\n            # This should fail because sys.argv[0] is None\n            execute_from_command_line()\n\n    def test_command_parser_receives_prog_argument_bug_reproduction(self):\n        \"\"\"Test that reproduces the bug where CommandParser doesn't receive prog argument.\"\"\"\n        argv = ['/path/to/manage.py', 'help']\n        utility = ManagementUtility(argv)\n        \n        # Before the fix, this would fail because CommandParser wouldn't receive\n        # the prog argument and would default to sys.argv[0]\n        with mock.patch('django.core.management.sys.argv', ['/different/path/sys_argv_script.py']):\n            with mock.patch('django.core.management.CommandParser') as mock_parser:\n                mock_parser_instance = mock.Mock()\n                mock_parser.return_value = mock_parser_instance\n                mock_parser_instance.parse_known_args.return_value = (mock.Mock(settings=None, pythonpath=None), [])\n                \n                try:\n                    utility.execute()\n                except SystemExit:\n                    pass\n                \n                # After the fix, CommandParser should be called with prog='manage.py'\n                # not with the default from sys.argv[0] which would be 'sys_argv_script.py'\n                call_args = mock_parser.call_args\n                assert call_args is not None\n                assert 'prog' in call_args.kwargs\n                assert call_args.kwargs['prog'] == 'manage.py'\n\n    def test_edge_case_empty_argv(self):\n        \"\"\"Test edge case with empty argv.\"\"\"\n        with pytest.raises(IndexError):\n            ManagementUtility([])\n\n    def test_edge_case_relative_path(self):\n        \"\"\"Test with relative path in argv[0].\"\"\"\n        argv = ['manage.py', 'help']\n        utility = ManagementUtility(argv)\n        assert utility.prog_name == 'manage.py'\n\n    def test_edge_case_path_with_spaces(self):\n        \"\"\"Test with path containing spaces.\"\"\"\n        argv = ['/path with spaces/manage.py', 'help']\n        utility = ManagementUtility(argv)\n        assert utility.prog_name == 'manage.py'\n</patched>\n```",
  "patch": "--- a/tests/admin_scripts/test_management_utility.py\n+++ b/tests/admin_scripts/test_management_utility.py\n-# Empty if creating new file\n+import os\n+import sys\n+import pytest\n+from unittest import mock\n+from django.core.management import ManagementUtility, execute_from_command_line\n+from django.core.management.base import CommandParser\n+\n+\n+class TestManagementUtilityProgName:\n+    \"\"\"Test that ManagementUtility uses the computed prog_name consistently.\"\"\"\n+\n+    def test_prog_name_computed_from_argv(self):\n+        \"\"\"Test that prog_name is correctly computed from provided argv.\"\"\"\n+        # Test with regular script name\n+        argv = ['/path/to/manage.py', 'help']\n+        utility = ManagementUtility(argv)\n+        assert utility.prog_name == 'manage.py'\n+        \n+        # Test with __main__.py\n+        argv = ['/path/to/__main__.py', 'help']\n+        utility = ManagementUtility(argv)\n+        assert utility.prog_name == 'python -m django'\n+        \n+        # Test with custom script name\n+        argv = ['/custom/path/my_script.py', 'help']\n+        utility = ManagementUtility(argv)\n+        assert utility.prog_name == 'my_script.py'\n+\n+    def test_prog_name_with_none_argv_zero(self):\n+        \"\"\"Test that prog_name handles None in argv[0] gracefully.\"\"\"\n+        # This reproduces the bug scenario where sys.argv[0] is None\n+        argv = [None, 'help']\n+        with pytest.raises((TypeError, AttributeError)):\n+            # This should fail before the fix because os.path.basename(None) fails\n+            ManagementUtility(argv)\n+\n+    @mock.patch('django.core.management.sys.argv', [None, 'help'])\n+    def test_execute_from_command_line_with_custom_argv_none_sys_argv(self):\n+        \"\"\"Test execute_from_command_line with custom argv when sys.argv[0] is None.\"\"\"\n+        # This tests the scenario described in the issue where sys.argv[0] is None\n+        # but we provide a custom argv to execute_from_command_line\n+        custom_argv = ['/path/to/manage.py', 'help']\n+        \n+        # This should work without raising exceptions after the fix\n+        try:\n+            execute_from_command_line(custom_argv)\n+        except SystemExit:\n+            # SystemExit is expected for help command\n+            pass\n+\n+    def test_command_parser_uses_computed_prog_name(self):\n+        \"\"\"Test that CommandParser receives the computed prog_name.\"\"\"\n+        argv = ['/custom/path/my_django_script.py', 'help']\n+        utility = ManagementUtility(argv)\n+        \n+        # Mock CommandParser to capture the arguments passed to it\n+        with mock.patch('django.core.management.CommandParser') as mock_parser:\n+            mock_parser_instance = mock.Mock()\n+            mock_parser.return_value = mock_parser_instance\n+            mock_parser_instance.parse_known_args.return_value = (mock.Mock(settings=None, pythonpath=None), [])\n+            \n+            try:\n+                utility.execute()\n+            except SystemExit:\n+                # SystemExit is expected for help command\n+                pass\n+            \n+            # Verify that CommandParser was called with prog=self.prog_name\n+            mock_parser.assert_called_with(\n+                prog='my_django_script.py',\n+                usage='%(prog)s subcommand [options] [args]',\n+                add_help=False,\n+                allow_abbrev=False\n+            )\n+\n+    def test_command_parser_prog_name_consistency_main_py(self):\n+        \"\"\"Test CommandParser prog consistency with __main__.py.\"\"\"\n+        argv = ['/path/to/__main__.py', 'help']\n+        utility = ManagementUtility(argv)\n+        \n+        with mock.patch('django.core.management.CommandParser') as mock_parser:\n+            mock_parser_instance = mock.Mock()\n+            mock_parser.return_value = mock_parser_instance\n+            mock_parser_instance.parse_known_args.return_value = (mock.Mock(settings=None, pythonpath=None), [])\n+            \n+            try:\n+                utility.execute()\n+            except SystemExit:\n+                pass\n+            \n+            # Verify that CommandParser was called with the transformed prog name\n+            mock_parser.assert_called_with(\n+                prog='python -m django',\n+                usage='%(prog)s subcommand [options] [args]',\n+                add_help=False,\n+                allow_abbrev=False\n+            )\n+\n+    @mock.patch('django.core.management.sys.argv', [None])\n+    def test_bug_reproduction_none_sys_argv_without_custom_argv(self):\n+        \"\"\"Test that demonstrates the bug when sys.argv[0] is None and no custom argv is provided.\"\"\"\n+        # This test reproduces the original bug scenario\n+        with pytest.raises((TypeError, AttributeError)):\n+            # This should fail because sys.argv[0] is None\n+            execute_from_command_line()\n+\n+    def test_command_parser_receives_prog_argument_bug_reproduction(self):\n+        \"\"\"Test that reproduces the bug where CommandParser doesn't receive prog argument.\"\"\"\n+        argv = ['/path/to/manage.py', 'help']\n+        utility = ManagementUtility(argv)\n+        \n+        # Before the fix, this would fail because CommandParser wouldn't receive\n+        # the prog argument and would default to sys.argv[0]\n+        with mock.patch('django.core.management.sys.argv', ['/different/path/sys_argv_script.py']):\n+            with mock.patch('django.core.management.CommandParser') as mock_parser:\n+                mock_parser_instance = mock.Mock()\n+                mock_parser.return_value = mock_parser_instance\n+                mock_parser_instance.parse_known_args.return_value = (mock.Mock(settings=None, pythonpath=None), [])\n+                \n+                try:\n+                    utility.execute()\n+                except SystemExit:\n+                    pass\n+                \n+                # After the fix, CommandParser should be called with prog='manage.py'\n+                # not with the default from sys.argv[0] which would be 'sys_argv_script.py'\n+                call_args = mock_parser.call_args\n+                assert call_args is not None\n+                assert 'prog' in call_args.kwargs\n+                assert call_args.kwargs['prog'] == 'manage.py'\n+\n+    def test_edge_case_empty_argv(self):\n+        \"\"\"Test edge case with empty argv.\"\"\"\n+        with pytest.raises(IndexError):\n+            ManagementUtility([])\n+\n+    def test_edge_case_relative_path(self):\n+        \"\"\"Test with relative path in argv[0].\"\"\"\n+        argv = ['manage.py', 'help']\n+        utility = ManagementUtility(argv)\n+        assert utility.prog_name == 'manage.py'\n+\n+    def test_edge_case_path_with_spaces(self):\n+        \"\"\"Test with path containing spaces.\"\"\"\n+        argv = ['/path with spaces/manage.py', 'help']\n+        utility = ManagementUtility(argv)\n+        assert utility.prog_name == 'manage.py'\n"
}