{
  "instance_id": "django__django-15695",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/migrations/test_rename_index_bug.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import connection, models\nfrom django.db.migrations.operations.models import RenameIndex\nfrom django.db.migrations.state import ProjectState, ModelState\nfrom django.test import TransactionTestCase\nfrom django.test.utils import isolate_apps\n\n\nclass RenameIndexBugTests(TransactionTestCase):\n    \"\"\"\n    Test suite for RenameIndex operation bug where unnamed index renaming\n    crashes when moving backward and forward.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test environment with a test model.\"\"\"\n        self.app_label = \"test_app\"\n        self.model_name = \"TestModel\"\n        self.table_name = f\"{self.app_label}_{self.model_name.lower()}\"\n        \n        # Create initial project state with a model that has unique_together\n        # which creates an unnamed index\n        self.project_state = ProjectState()\n        self.project_state.add_model(\n            ModelState(\n                app_label=self.app_label,\n                name=self.model_name,\n                fields=[\n                    (\"id\", models.AutoField(primary_key=True)),\n                    (\"field1\", models.CharField(max_length=100)),\n                    (\"field2\", models.CharField(max_length=100)),\n                ],\n                options={\n                    \"unique_together\": [(\"field1\", \"field2\")],\n                },\n            )\n        )\n        \n        # Create the table in the database\n        with connection.schema_editor() as editor:\n            editor.create_model(self.project_state.apps.get_model(self.app_label, self.model_name))\n    \n    def tearDown(self):\n        \"\"\"Clean up test environment.\"\"\"\n        # Drop the table if it exists\n        try:\n            with connection.schema_editor() as editor:\n                model = self.project_state.apps.get_model(self.app_label, self.model_name)\n                editor.delete_model(model)\n        except Exception:\n            pass\n    \n    def get_index_names(self):\n        \"\"\"Helper method to get all index names for the test table.\"\"\"\n        with connection.cursor() as cursor:\n            return connection.introspection.get_constraints(cursor, self.table_name)\n    \n    def assertIndexExists(self, index_name):\n        \"\"\"Assert that an index with the given name exists.\"\"\"\n        constraints = self.get_index_names()\n        self.assertIn(index_name, constraints, f\"Index {index_name} should exist\")\n    \n    def assertIndexNotExists(self, index_name):\n        \"\"\"Assert that an index with the given name does not exist.\"\"\"\n        constraints = self.get_index_names()\n        self.assertNotIn(index_name, constraints, f\"Index {index_name} should not exist\")\n    \n    def test_rename_unnamed_index_forward_backward_forward_fails(self):\n        \"\"\"\n        Test that demonstrates the bug: RenameIndex crashes when an unnamed \n        index is moved backward and then forward again.\n        \n        This test should FAIL before the fix is applied, demonstrating the bug.\n        \"\"\"\n        # Create RenameIndex operation for unnamed index (using old_fields)\n        operation = RenameIndex(\n            model_name=self.model_name,\n            new_name=\"new_test_idx\",\n            old_fields=[\"field1\", \"field2\"]\n        )\n        \n        # Get the original auto-generated index name\n        original_constraints = self.get_index_names()\n        original_index_names = [\n            name for name, info in original_constraints.items() \n            if info.get('unique') and set(info.get('columns', [])) == {'field1', 'field2'}\n        ]\n        self.assertEqual(len(original_index_names), 1, \"Should have exactly one unique index for field1, field2\")\n        original_index_name = original_index_names[0]\n        \n        # Create new state after rename\n        new_state = self.project_state.clone()\n        operation.state_forwards(self.app_label, new_state)\n        \n        # Step 1: Apply the rename operation (forward)\n        with connection.schema_editor() as editor:\n            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n        \n        # Verify the index was renamed\n        self.assertIndexExists(\"new_test_idx\")\n        self.assertIndexNotExists(original_index_name)\n        \n        # Step 2: Reverse the rename operation (backward)\n        with connection.schema_editor() as editor:\n            operation.database_backwards(self.app_label, editor, new_state, self.project_state)\n        \n        # After backward operation, the original index name should be restored\n        # This is where the bug manifests - the backward operation is a no-op\n        # so the index still has the new name\n        \n        # Step 3: Re-apply the rename operation (forward again)\n        # This should work but will fail due to the bug\n        with self.assertRaises(Exception) as cm:\n            with connection.schema_editor() as editor:\n                operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n        \n        # The error should be about the relation already existing\n        self.assertIn(\"already exists\", str(cm.exception).lower())\n    \n    def test_rename_unnamed_index_backward_restores_original_name(self):\n        \"\"\"\n        Test that after the fix, the backward operation properly restores\n        the original auto-generated index name.\n        \n        This test should PASS after the fix is applied.\n        \"\"\"\n        # Create RenameIndex operation for unnamed index\n        operation = RenameIndex(\n            model_name=self.model_name,\n            new_name=\"new_test_idx\",\n            old_fields=[\"field1\", \"field2\"]\n        )\n        \n        # Get the original auto-generated index name\n        original_constraints = self.get_index_names()\n        original_index_names = [\n            name for name, info in original_constraints.items() \n            if info.get('unique') and set(info.get('columns', [])) == {'field1', 'field2'}\n        ]\n        original_index_name = original_index_names[0]\n        \n        # Create new state after rename\n        new_state = self.project_state.clone()\n        operation.state_forwards(self.app_label, new_state)\n        \n        # Apply forward operation\n        with connection.schema_editor() as editor:\n            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n        \n        self.assertIndexExists(\"new_test_idx\")\n        self.assertIndexNotExists(original_index_name)\n        \n        # Apply backward operation\n        with connection.schema_editor() as editor:\n            operation.database_backwards(self.app_label, editor, new_state, self.project_state)\n        \n        # After fix: the original index name should be restored\n        self.assertIndexExists(original_index_name)\n        self.assertIndexNotExists(\"new_test_idx\")\n    \n    def test_rename_unnamed_index_forward_backward_forward_succeeds_after_fix(self):\n        \"\"\"\n        Test that after the fix, the complete forward-backward-forward cycle works.\n        \n        This test should PASS after the fix is applied.\n        \"\"\"\n        # Create RenameIndex operation for unnamed index\n        operation = RenameIndex(\n            model_name=self.model_name,\n            new_name=\"new_test_idx\",\n            old_fields=[\"field1\", \"field2\"]\n        )\n        \n        # Get the original auto-generated index name\n        original_constraints = self.get_index_names()\n        original_index_names = [\n            name for name, info in original_constraints.items() \n            if info.get('unique') and set(info.get('columns', [])) == {'field1', 'field2'}\n        ]\n        original_index_name = original_index_names[0]\n        \n        # Create new state after rename\n        new_state = self.project_state.clone()\n        operation.state_forwards(self.app_label, new_state)\n        \n        # Step 1: Forward operation\n        with connection.schema_editor() as editor:\n            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n        \n        self.assertIndexExists(\"new_test_idx\")\n        self.assertIndexNotExists(original_index_name)\n        \n        # Step 2: Backward operation\n        with connection.schema_editor() as editor:\n            operation.database_backwards(self.app_label, editor, new_state, self.project_state)\n        \n        self.assertIndexExists(original_index_name)\n        self.assertIndexNotExists(\"new_test_idx\")\n        \n        # Step 3: Forward operation again (should succeed after fix)\n        with connection.schema_editor() as editor:\n            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n        \n        self.assertIndexExists(\"new_test_idx\")\n        self.assertIndexNotExists(original_index_name)\n    \n    def test_rename_named_index_backward_forward_still_works(self):\n        \"\"\"\n        Test that the fix doesn't break the existing functionality for named indexes.\n        \n        This test should PASS both before and after the fix.\n        \"\"\"\n        # First create a named index\n        create_index_op = models.Index(fields=[\"field1\"], name=\"original_named_idx\")\n        \n        # Add the index to our model state\n        test_state = self.project_state.clone()\n        test_state.add_index(self.app_label, self.model_name.lower(), create_index_op)\n        \n        # Create the named index in the database\n        with connection.schema_editor() as editor:\n            model = test_state.apps.get_model(self.app_label, self.model_name)\n            editor.add_index(model, create_index_op)\n        \n        # Now test renaming the named index\n        operation = RenameIndex(\n            model_name=self.model_name,\n            new_name=\"renamed_named_idx\",\n            old_name=\"original_named_idx\"\n        )\n        \n        # Create new state after rename\n        new_state = test_state.clone()\n        operation.state_forwards(self.app_label, new_state)\n        \n        # Forward operation\n        with connection.schema_editor() as editor:\n            operation.database_forwards(self.app_label, editor, test_state, new_state)\n        \n        self.assertIndexExists(\"renamed_named_idx\")\n        self.assertIndexNotExists(\"original_named_idx\")\n        \n        # Backward operation\n        with connection.schema_editor() as editor:\n            operation.database_backwards(self.app_label, editor, new_state, test_state)\n        \n        self.assertIndexExists(\"original_named_idx\")\n        self.assertIndexNotExists(\"renamed_named_idx\")\n        \n        # Forward operation again\n        with connection.schema_editor() as editor:\n            operation.database_forwards(self.app_label, editor, test_state, new_state)\n        \n        self.assertIndexExists(\"renamed_named_idx\")\n        self.assertIndexNotExists(\"original_named_idx\")\n    \n    def test_rename_unnamed_index_with_no_queries_on_backward_noop(self):\n        \"\"\"\n        Test that the current backward operation for unnamed indexes is a no-op\n        (demonstrating the current buggy behavior).\n        \n        This test documents the current behavior and should be updated after the fix.\n        \"\"\"\n        operation = RenameIndex(\n            model_name=self.model_name,\n            new_name=\"new_test_idx\",\n            old_fields=[\"field1\", \"field2\"]\n        )\n        \n        new_state = self.project_state.clone()\n        operation.state_forwards(self.app_label, new_state)\n        \n        # Apply forward operation first\n        with connection.schema_editor() as editor:\n            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n        \n        # The backward operation should currently be a no-op (0 queries)\n        # This demonstrates the bug - no actual database operation occurs\n        from django.test.utils import override_settings\n        from django.db import connection\n        \n        queries_before = len(connection.queries)\n        with connection.schema_editor() as editor:\n            operation.database_backwards(self.app_label, editor, new_state, self.project_state)\n        queries_after = len(connection.queries)\n        \n        # Currently this is 0 (no-op), but after fix it should be > 0\n        # This test documents the current buggy behavior\n        self.assertEqual(queries_after - queries_before, 0, \n                        \"Current implementation: backward operation is a no-op for unnamed indexes\")\n        \n        # The index should still have the new name (demonstrating the bug)\n        self.assertIndexExists(\"new_test_idx\")\n</patched>\n```",
  "patch": "--- a/tests/migrations/test_rename_index_bug.py\n+++ b/tests/migrations/test_rename_index_bug.py\n-# Empty if creating new file\n+import pytest\n+from django.db import connection, models\n+from django.db.migrations.operations.models import RenameIndex\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.test import TransactionTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+class RenameIndexBugTests(TransactionTestCase):\n+    \"\"\"\n+    Test suite for RenameIndex operation bug where unnamed index renaming\n+    crashes when moving backward and forward.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test environment with a test model.\"\"\"\n+        self.app_label = \"test_app\"\n+        self.model_name = \"TestModel\"\n+        self.table_name = f\"{self.app_label}_{self.model_name.lower()}\"\n+        \n+        # Create initial project state with a model that has unique_together\n+        # which creates an unnamed index\n+        self.project_state = ProjectState()\n+        self.project_state.add_model(\n+            ModelState(\n+                app_label=self.app_label,\n+                name=self.model_name,\n+                fields=[\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"field1\", models.CharField(max_length=100)),\n+                    (\"field2\", models.CharField(max_length=100)),\n+                ],\n+                options={\n+                    \"unique_together\": [(\"field1\", \"field2\")],\n+                },\n+            )\n+        )\n+        \n+        # Create the table in the database\n+        with connection.schema_editor() as editor:\n+            editor.create_model(self.project_state.apps.get_model(self.app_label, self.model_name))\n+    \n+    def tearDown(self):\n+        \"\"\"Clean up test environment.\"\"\"\n+        # Drop the table if it exists\n+        try:\n+            with connection.schema_editor() as editor:\n+                model = self.project_state.apps.get_model(self.app_label, self.model_name)\n+                editor.delete_model(model)\n+        except Exception:\n+            pass\n+    \n+    def get_index_names(self):\n+        \"\"\"Helper method to get all index names for the test table.\"\"\"\n+        with connection.cursor() as cursor:\n+            return connection.introspection.get_constraints(cursor, self.table_name)\n+    \n+    def assertIndexExists(self, index_name):\n+        \"\"\"Assert that an index with the given name exists.\"\"\"\n+        constraints = self.get_index_names()\n+        self.assertIn(index_name, constraints, f\"Index {index_name} should exist\")\n+    \n+    def assertIndexNotExists(self, index_name):\n+        \"\"\"Assert that an index with the given name does not exist.\"\"\"\n+        constraints = self.get_index_names()\n+        self.assertNotIn(index_name, constraints, f\"Index {index_name} should not exist\")\n+    \n+    def test_rename_unnamed_index_forward_backward_forward_fails(self):\n+        \"\"\"\n+        Test that demonstrates the bug: RenameIndex crashes when an unnamed \n+        index is moved backward and then forward again.\n+        \n+        This test should FAIL before the fix is applied, demonstrating the bug.\n+        \"\"\"\n+        # Create RenameIndex operation for unnamed index (using old_fields)\n+        operation = RenameIndex(\n+            model_name=self.model_name,\n+            new_name=\"new_test_idx\",\n+            old_fields=[\"field1\", \"field2\"]\n+        )\n+        \n+        # Get the original auto-generated index name\n+        original_constraints = self.get_index_names()\n+        original_index_names = [\n+            name for name, info in original_constraints.items() \n+            if info.get('unique') and set(info.get('columns', [])) == {'field1', 'field2'}\n+        ]\n+        self.assertEqual(len(original_index_names), 1, \"Should have exactly one unique index for field1, field2\")\n+        original_index_name = original_index_names[0]\n+        \n+        # Create new state after rename\n+        new_state = self.project_state.clone()\n+        operation.state_forwards(self.app_label, new_state)\n+        \n+        # Step 1: Apply the rename operation (forward)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n+        \n+        # Verify the index was renamed\n+        self.assertIndexExists(\"new_test_idx\")\n+        self.assertIndexNotExists(original_index_name)\n+        \n+        # Step 2: Reverse the rename operation (backward)\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(self.app_label, editor, new_state, self.project_state)\n+        \n+        # After backward operation, the original index name should be restored\n+        # This is where the bug manifests - the backward operation is a no-op\n+        # so the index still has the new name\n+        \n+        # Step 3: Re-apply the rename operation (forward again)\n+        # This should work but will fail due to the bug\n+        with self.assertRaises(Exception) as cm:\n+            with connection.schema_editor() as editor:\n+                operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n+        \n+        # The error should be about the relation already existing\n+        self.assertIn(\"already exists\", str(cm.exception).lower())\n+    \n+    def test_rename_unnamed_index_backward_restores_original_name(self):\n+        \"\"\"\n+        Test that after the fix, the backward operation properly restores\n+        the original auto-generated index name.\n+        \n+        This test should PASS after the fix is applied.\n+        \"\"\"\n+        # Create RenameIndex operation for unnamed index\n+        operation = RenameIndex(\n+            model_name=self.model_name,\n+            new_name=\"new_test_idx\",\n+            old_fields=[\"field1\", \"field2\"]\n+        )\n+        \n+        # Get the original auto-generated index name\n+        original_constraints = self.get_index_names()\n+        original_index_names = [\n+            name for name, info in original_constraints.items() \n+            if info.get('unique') and set(info.get('columns', [])) == {'field1', 'field2'}\n+        ]\n+        original_index_name = original_index_names[0]\n+        \n+        # Create new state after rename\n+        new_state = self.project_state.clone()\n+        operation.state_forwards(self.app_label, new_state)\n+        \n+        # Apply forward operation\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n+        \n+        self.assertIndexExists(\"new_test_idx\")\n+        self.assertIndexNotExists(original_index_name)\n+        \n+        # Apply backward operation\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(self.app_label, editor, new_state, self.project_state)\n+        \n+        # After fix: the original index name should be restored\n+        self.assertIndexExists(original_index_name)\n+        self.assertIndexNotExists(\"new_test_idx\")\n+    \n+    def test_rename_unnamed_index_forward_backward_forward_succeeds_after_fix(self):\n+        \"\"\"\n+        Test that after the fix, the complete forward-backward-forward cycle works.\n+        \n+        This test should PASS after the fix is applied.\n+        \"\"\"\n+        # Create RenameIndex operation for unnamed index\n+        operation = RenameIndex(\n+            model_name=self.model_name,\n+            new_name=\"new_test_idx\",\n+            old_fields=[\"field1\", \"field2\"]\n+        )\n+        \n+        # Get the original auto-generated index name\n+        original_constraints = self.get_index_names()\n+        original_index_names = [\n+            name for name, info in original_constraints.items() \n+            if info.get('unique') and set(info.get('columns', [])) == {'field1', 'field2'}\n+        ]\n+        original_index_name = original_index_names[0]\n+        \n+        # Create new state after rename\n+        new_state = self.project_state.clone()\n+        operation.state_forwards(self.app_label, new_state)\n+        \n+        # Step 1: Forward operation\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n+        \n+        self.assertIndexExists(\"new_test_idx\")\n+        self.assertIndexNotExists(original_index_name)\n+        \n+        # Step 2: Backward operation\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(self.app_label, editor, new_state, self.project_state)\n+        \n+        self.assertIndexExists(original_index_name)\n+        self.assertIndexNotExists(\"new_test_idx\")\n+        \n+        # Step 3: Forward operation again (should succeed after fix)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n+        \n+        self.assertIndexExists(\"new_test_idx\")\n+        self.assertIndexNotExists(original_index_name)\n+    \n+    def test_rename_named_index_backward_forward_still_works(self):\n+        \"\"\"\n+        Test that the fix doesn't break the existing functionality for named indexes.\n+        \n+        This test should PASS both before and after the fix.\n+        \"\"\"\n+        # First create a named index\n+        create_index_op = models.Index(fields=[\"field1\"], name=\"original_named_idx\")\n+        \n+        # Add the index to our model state\n+        test_state = self.project_state.clone()\n+        test_state.add_index(self.app_label, self.model_name.lower(), create_index_op)\n+        \n+        # Create the named index in the database\n+        with connection.schema_editor() as editor:\n+            model = test_state.apps.get_model(self.app_label, self.model_name)\n+            editor.add_index(model, create_index_op)\n+        \n+        # Now test renaming the named index\n+        operation = RenameIndex(\n+            model_name=self.model_name,\n+            new_name=\"renamed_named_idx\",\n+            old_name=\"original_named_idx\"\n+        )\n+        \n+        # Create new state after rename\n+        new_state = test_state.clone()\n+        operation.state_forwards(self.app_label, new_state)\n+        \n+        # Forward operation\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(self.app_label, editor, test_state, new_state)\n+        \n+        self.assertIndexExists(\"renamed_named_idx\")\n+        self.assertIndexNotExists(\"original_named_idx\")\n+        \n+        # Backward operation\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(self.app_label, editor, new_state, test_state)\n+        \n+        self.assertIndexExists(\"original_named_idx\")\n+        self.assertIndexNotExists(\"renamed_named_idx\")\n+        \n+        # Forward operation again\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(self.app_label, editor, test_state, new_state)\n+        \n+        self.assertIndexExists(\"renamed_named_idx\")\n+        self.assertIndexNotExists(\"original_named_idx\")\n+    \n+    def test_rename_unnamed_index_with_no_queries_on_backward_noop(self):\n+        \"\"\"\n+        Test that the current backward operation for unnamed indexes is a no-op\n+        (demonstrating the current buggy behavior).\n+        \n+        This test documents the current behavior and should be updated after the fix.\n+        \"\"\"\n+        operation = RenameIndex(\n+            model_name=self.model_name,\n+            new_name=\"new_test_idx\",\n+            old_fields=[\"field1\", \"field2\"]\n+        )\n+        \n+        new_state = self.project_state.clone()\n+        operation.state_forwards(self.app_label, new_state)\n+        \n+        # Apply forward operation first\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(self.app_label, editor, self.project_state, new_state)\n+        \n+        # The backward operation should currently be a no-op (0 queries)\n+        # This demonstrates the bug - no actual database operation occurs\n+        from django.test.utils import override_settings\n+        from django.db import connection\n+        \n+        queries_before = len(connection.queries)\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(self.app_label, editor, new_state, self.project_state)\n+        queries_after = len(connection.queries)\n+        \n+        # Currently this is 0 (no-op), but after fix it should be > 0\n+        # This test documents the current buggy behavior\n+        self.assertEqual(queries_after - queries_before, 0, \n+                        \"Current implementation: backward operation is a no-op for unnamed indexes\")\n+        \n+        # The index should still have the new name (demonstrating the bug)\n+        self.assertIndexExists(\"new_test_idx\")\n"
}