{
  "instance_id": "django__django-11239",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/backends/postgresql/test_client.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport os\nimport subprocess\nfrom unittest import mock\n\nimport pytest\n\nfrom django.db.backends.postgresql.client import DatabaseClient\nfrom django.test import SimpleTestCase\n\n\nclass PostgreSQLDbshellTests(SimpleTestCase):\n    def test_basic_params_no_ssl(self):\n        \"\"\"Test that basic connection parameters work without SSL options.\"\"\"\n        conn_params = {\n            'database': 'test_db',\n            'user': 'test_user',\n            'password': 'test_pass',\n            'host': 'localhost',\n            'port': '5432',\n        }\n        \n        with mock.patch('subprocess.run') as mock_run:\n            with mock.patch('signal.signal'):\n                DatabaseClient.runshell_db(conn_params)\n        \n        # Verify the command arguments\n        args, kwargs = mock_run.call_args\n        cmd_args = args[0]\n        \n        expected_args = [\n            'psql',\n            '-U', 'test_user',\n            '-h', 'localhost', \n            '-p', '5432',\n            'test_db'\n        ]\n        assert cmd_args == expected_args\n        \n        # Verify password is set in environment\n        env = kwargs['env']\n        assert env['PGPASSWORD'] == 'test_pass'\n\n    def test_ssl_parameters_before_fix(self):\n        \"\"\"Test that SSL parameters are ignored before the fix (demonstrates the bug).\"\"\"\n        conn_params = {\n            'database': 'test_db',\n            'user': 'test_user',\n            'password': 'test_pass',\n            'host': 'localhost',\n            'port': '5432',\n            'sslmode': 'verify-ca',\n            'sslrootcert': '/path/to/ca.crt',\n            'sslcert': '/path/to/client.crt',\n            'sslkey': '/path/to/client.key',\n        }\n        \n        with mock.patch('subprocess.run') as mock_run:\n            with mock.patch('signal.signal'):\n                DatabaseClient.runshell_db(conn_params)\n        \n        # Before the fix, SSL parameters should be ignored\n        args, kwargs = mock_run.call_args\n        env = kwargs['env']\n        \n        # These environment variables should NOT be set before the fix\n        assert 'PGSSLMODE' not in env\n        assert 'PGSSLROOTCERT' not in env\n        assert 'PGSSLCERT' not in env\n        assert 'PGSSLKEY' not in env\n\n    def test_ssl_parameters_after_fix(self):\n        \"\"\"Test that SSL parameters are properly handled after the fix.\"\"\"\n        conn_params = {\n            'database': 'test_db',\n            'user': 'test_user',\n            'password': 'test_pass',\n            'host': 'localhost',\n            'port': '5432',\n            'sslmode': 'verify-ca',\n            'sslrootcert': '/path/to/ca.crt',\n            'sslcert': '/path/to/client.crt',\n            'sslkey': '/path/to/client.key',\n        }\n        \n        with mock.patch('subprocess.run') as mock_run:\n            with mock.patch('signal.signal'):\n                # Mock the fixed version of runshell_db\n                with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n                    DatabaseClient.runshell_db(conn_params)\n        \n        # After the fix, SSL parameters should be set as environment variables\n        args, kwargs = mock_run.call_args\n        env = kwargs['env']\n        \n        assert env['PGSSLMODE'] == 'verify-ca'\n        assert env['PGSSLROOTCERT'] == '/path/to/ca.crt'\n        assert env['PGSSLCERT'] == '/path/to/client.crt'\n        assert env['PGSSLKEY'] == '/path/to/client.key'\n        assert env['PGPASSWORD'] == 'test_pass'\n\n    def test_partial_ssl_parameters(self):\n        \"\"\"Test that only provided SSL parameters are set.\"\"\"\n        conn_params = {\n            'database': 'test_db',\n            'user': 'test_user',\n            'sslmode': 'require',\n            'sslcert': '/path/to/client.crt',\n            # Note: missing sslkey, sslrootcert, password\n        }\n        \n        with mock.patch('subprocess.run') as mock_run:\n            with mock.patch('signal.signal'):\n                with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n                    DatabaseClient.runshell_db(conn_params)\n        \n        args, kwargs = mock_run.call_args\n        env = kwargs['env']\n        \n        # Only provided SSL parameters should be set\n        assert env['PGSSLMODE'] == 'require'\n        assert env['PGSSLCERT'] == '/path/to/client.crt'\n        assert 'PGSSLKEY' not in env\n        assert 'PGSSLROOTCERT' not in env\n        assert 'PGPASSWORD' not in env\n\n    def test_ssl_parameters_with_empty_values(self):\n        \"\"\"Test that empty SSL parameter values are not set.\"\"\"\n        conn_params = {\n            'database': 'test_db',\n            'sslmode': '',\n            'sslcert': None,\n            'sslkey': '/path/to/client.key',\n        }\n        \n        with mock.patch('subprocess.run') as mock_run:\n            with mock.patch('signal.signal'):\n                with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n                    DatabaseClient.runshell_db(conn_params)\n        \n        args, kwargs = mock_run.call_args\n        env = kwargs['env']\n        \n        # Empty/None values should not be set\n        assert 'PGSSLMODE' not in env\n        assert 'PGSSLCERT' not in env\n        # Only non-empty values should be set\n        assert env['PGSSLKEY'] == '/path/to/client.key'\n\n    def test_ssl_parameters_preserve_existing_env(self):\n        \"\"\"Test that SSL parameters don't overwrite existing environment variables.\"\"\"\n        original_env = os.environ.copy()\n        original_env['EXISTING_VAR'] = 'existing_value'\n        original_env['PGSSLMODE'] = 'existing_ssl_mode'\n        \n        conn_params = {\n            'database': 'test_db',\n            'sslmode': 'verify-ca',\n            'sslcert': '/path/to/client.crt',\n        }\n        \n        with mock.patch('subprocess.run') as mock_run:\n            with mock.patch('signal.signal'):\n                with mock.patch('os.environ.copy', return_value=original_env):\n                    with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n                        DatabaseClient.runshell_db(conn_params)\n        \n        args, kwargs = mock_run.call_args\n        env = kwargs['env']\n        \n        # Existing environment variables should be preserved\n        assert env['EXISTING_VAR'] == 'existing_value'\n        # SSL parameters from conn_params should override existing ones\n        assert env['PGSSLMODE'] == 'verify-ca'\n        assert env['PGSSLCERT'] == '/path/to/client.crt'\n\n    def test_integration_with_get_connection_params(self):\n        \"\"\"Test that SSL parameters from OPTIONS are properly passed through.\"\"\"\n        # This simulates how the parameters would come from get_connection_params\n        settings_dict = {\n            'NAME': 'test_db',\n            'USER': 'test_user',\n            'PASSWORD': 'test_pass',\n            'HOST': 'localhost',\n            'PORT': '5432',\n            'OPTIONS': {\n                'sslmode': 'verify-ca',\n                'sslrootcert': '/path/to/ca.crt',\n                'sslcert': '/path/to/client.crt',\n                'sslkey': '/path/to/client.key',\n                'isolation_level': 'READ_COMMITTED',  # This should be ignored\n            }\n        }\n        \n        # Simulate what get_connection_params does\n        conn_params = {\n            'database': settings_dict['NAME'],\n            **settings_dict['OPTIONS'],\n        }\n        conn_params.pop('isolation_level', None)\n        if settings_dict['USER']:\n            conn_params['user'] = settings_dict['USER']\n        if settings_dict['PASSWORD']:\n            conn_params['password'] = settings_dict['PASSWORD']\n        if settings_dict['HOST']:\n            conn_params['host'] = settings_dict['HOST']\n        if settings_dict['PORT']:\n            conn_params['port'] = settings_dict['PORT']\n        \n        with mock.patch('subprocess.run') as mock_run:\n            with mock.patch('signal.signal'):\n                with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n                    DatabaseClient.runshell_db(conn_params)\n        \n        args, kwargs = mock_run.call_args\n        env = kwargs['env']\n        \n        # All SSL parameters should be properly set\n        assert env['PGSSLMODE'] == 'verify-ca'\n        assert env['PGSSLROOTCERT'] == '/path/to/ca.crt'\n        assert env['PGSSLCERT'] == '/path/to/client.crt'\n        assert env['PGSSLKEY'] == '/path/to/client.key'\n        assert env['PGPASSWORD'] == 'test_pass'\n        \n        # isolation_level should not be in environment\n        assert 'isolation_level' not in env\n\n    def _fixed_runshell_db(self, conn_params):\n        \"\"\"\n        Mock implementation of the fixed runshell_db method.\n        This simulates what the method should do after the fix is applied.\n        \"\"\"\n        import signal\n        \n        args = ['psql']\n        \n        host = conn_params.get('host', '')\n        port = conn_params.get('port', '')\n        dbname = conn_params.get('database', '')\n        user = conn_params.get('user', '')\n        passwd = conn_params.get('password', '')\n        \n        if user:\n            args += ['-U', user]\n        if host:\n            args += ['-h', host]\n        if port:\n            args += ['-p', str(port)]\n        args += [dbname]\n        \n        sigint_handler = signal.getsignal(signal.SIGINT)\n        subprocess_env = os.environ.copy()\n        if passwd:\n            subprocess_env['PGPASSWORD'] = str(passwd)\n        \n        # Add SSL parameters to environment - this is the fix\n        ssl_params = {\n            'sslmode': 'PGSSLMODE',\n            'sslrootcert': 'PGSSLROOTCERT', \n            'sslcert': 'PGSSLCERT',\n            'sslkey': 'PGSSLKEY',\n        }\n        \n        for param, env_var in ssl_params.items():\n            value = conn_params.get(param)\n            if value:\n                subprocess_env[env_var] = str(value)\n        \n        try:\n            signal.signal(signal.SIGINT, signal.SIG_IGN)\n            subprocess.run(args, check=True, env=subprocess_env)\n        finally:\n            signal.signal(signal.SIGINT, sigint_handler)\n</patched>\n</file>\n```",
  "patch": "--- a/tests/backends/postgresql/test_client.py\n+++ b/tests/backends/postgresql/test_client.py\n-# Empty if creating new file\n+import os\n+import subprocess\n+from unittest import mock\n+\n+import pytest\n+\n+from django.db.backends.postgresql.client import DatabaseClient\n+from django.test import SimpleTestCase\n+\n+\n+class PostgreSQLDbshellTests(SimpleTestCase):\n+    def test_basic_params_no_ssl(self):\n+        \"\"\"Test that basic connection parameters work without SSL options.\"\"\"\n+        conn_params = {\n+            'database': 'test_db',\n+            'user': 'test_user',\n+            'password': 'test_pass',\n+            'host': 'localhost',\n+            'port': '5432',\n+        }\n+        \n+        with mock.patch('subprocess.run') as mock_run:\n+            with mock.patch('signal.signal'):\n+                DatabaseClient.runshell_db(conn_params)\n+        \n+        # Verify the command arguments\n+        args, kwargs = mock_run.call_args\n+        cmd_args = args[0]\n+        \n+        expected_args = [\n+            'psql',\n+            '-U', 'test_user',\n+            '-h', 'localhost', \n+            '-p', '5432',\n+            'test_db'\n+        ]\n+        assert cmd_args == expected_args\n+        \n+        # Verify password is set in environment\n+        env = kwargs['env']\n+        assert env['PGPASSWORD'] == 'test_pass'\n+\n+    def test_ssl_parameters_before_fix(self):\n+        \"\"\"Test that SSL parameters are ignored before the fix (demonstrates the bug).\"\"\"\n+        conn_params = {\n+            'database': 'test_db',\n+            'user': 'test_user',\n+            'password': 'test_pass',\n+            'host': 'localhost',\n+            'port': '5432',\n+            'sslmode': 'verify-ca',\n+            'sslrootcert': '/path/to/ca.crt',\n+            'sslcert': '/path/to/client.crt',\n+            'sslkey': '/path/to/client.key',\n+        }\n+        \n+        with mock.patch('subprocess.run') as mock_run:\n+            with mock.patch('signal.signal'):\n+                DatabaseClient.runshell_db(conn_params)\n+        \n+        # Before the fix, SSL parameters should be ignored\n+        args, kwargs = mock_run.call_args\n+        env = kwargs['env']\n+        \n+        # These environment variables should NOT be set before the fix\n+        assert 'PGSSLMODE' not in env\n+        assert 'PGSSLROOTCERT' not in env\n+        assert 'PGSSLCERT' not in env\n+        assert 'PGSSLKEY' not in env\n+\n+    def test_ssl_parameters_after_fix(self):\n+        \"\"\"Test that SSL parameters are properly handled after the fix.\"\"\"\n+        conn_params = {\n+            'database': 'test_db',\n+            'user': 'test_user',\n+            'password': 'test_pass',\n+            'host': 'localhost',\n+            'port': '5432',\n+            'sslmode': 'verify-ca',\n+            'sslrootcert': '/path/to/ca.crt',\n+            'sslcert': '/path/to/client.crt',\n+            'sslkey': '/path/to/client.key',\n+        }\n+        \n+        with mock.patch('subprocess.run') as mock_run:\n+            with mock.patch('signal.signal'):\n+                # Mock the fixed version of runshell_db\n+                with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n+                    DatabaseClient.runshell_db(conn_params)\n+        \n+        # After the fix, SSL parameters should be set as environment variables\n+        args, kwargs = mock_run.call_args\n+        env = kwargs['env']\n+        \n+        assert env['PGSSLMODE'] == 'verify-ca'\n+        assert env['PGSSLROOTCERT'] == '/path/to/ca.crt'\n+        assert env['PGSSLCERT'] == '/path/to/client.crt'\n+        assert env['PGSSLKEY'] == '/path/to/client.key'\n+        assert env['PGPASSWORD'] == 'test_pass'\n+\n+    def test_partial_ssl_parameters(self):\n+        \"\"\"Test that only provided SSL parameters are set.\"\"\"\n+        conn_params = {\n+            'database': 'test_db',\n+            'user': 'test_user',\n+            'sslmode': 'require',\n+            'sslcert': '/path/to/client.crt',\n+            # Note: missing sslkey, sslrootcert, password\n+        }\n+        \n+        with mock.patch('subprocess.run') as mock_run:\n+            with mock.patch('signal.signal'):\n+                with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n+                    DatabaseClient.runshell_db(conn_params)\n+        \n+        args, kwargs = mock_run.call_args\n+        env = kwargs['env']\n+        \n+        # Only provided SSL parameters should be set\n+        assert env['PGSSLMODE'] == 'require'\n+        assert env['PGSSLCERT'] == '/path/to/client.crt'\n+        assert 'PGSSLKEY' not in env\n+        assert 'PGSSLROOTCERT' not in env\n+        assert 'PGPASSWORD' not in env\n+\n+    def test_ssl_parameters_with_empty_values(self):\n+        \"\"\"Test that empty SSL parameter values are not set.\"\"\"\n+        conn_params = {\n+            'database': 'test_db',\n+            'sslmode': '',\n+            'sslcert': None,\n+            'sslkey': '/path/to/client.key',\n+        }\n+        \n+        with mock.patch('subprocess.run') as mock_run:\n+            with mock.patch('signal.signal'):\n+                with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n+                    DatabaseClient.runshell_db(conn_params)\n+        \n+        args, kwargs = mock_run.call_args\n+        env = kwargs['env']\n+        \n+        # Empty/None values should not be set\n+        assert 'PGSSLMODE' not in env\n+        assert 'PGSSLCERT' not in env\n+        # Only non-empty values should be set\n+        assert env['PGSSLKEY'] == '/path/to/client.key'\n+\n+    def test_ssl_parameters_preserve_existing_env(self):\n+        \"\"\"Test that SSL parameters don't overwrite existing environment variables.\"\"\"\n+        original_env = os.environ.copy()\n+        original_env['EXISTING_VAR'] = 'existing_value'\n+        original_env['PGSSLMODE'] = 'existing_ssl_mode'\n+        \n+        conn_params = {\n+            'database': 'test_db',\n+            'sslmode': 'verify-ca',\n+            'sslcert': '/path/to/client.crt',\n+        }\n+        \n+        with mock.patch('subprocess.run') as mock_run:\n+            with mock.patch('signal.signal'):\n+                with mock.patch('os.environ.copy', return_value=original_env):\n+                    with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n+                        DatabaseClient.runshell_db(conn_params)\n+        \n+        args, kwargs = mock_run.call_args\n+        env = kwargs['env']\n+        \n+        # Existing environment variables should be preserved\n+        assert env['EXISTING_VAR'] == 'existing_value'\n+        # SSL parameters from conn_params should override existing ones\n+        assert env['PGSSLMODE'] == 'verify-ca'\n+        assert env['PGSSLCERT'] == '/path/to/client.crt'\n+\n+    def test_integration_with_get_connection_params(self):\n+        \"\"\"Test that SSL parameters from OPTIONS are properly passed through.\"\"\"\n+        # This simulates how the parameters would come from get_connection_params\n+        settings_dict = {\n+            'NAME': 'test_db',\n+            'USER': 'test_user',\n+            'PASSWORD': 'test_pass',\n+            'HOST': 'localhost',\n+            'PORT': '5432',\n+            'OPTIONS': {\n+                'sslmode': 'verify-ca',\n+                'sslrootcert': '/path/to/ca.crt',\n+                'sslcert': '/path/to/client.crt',\n+                'sslkey': '/path/to/client.key',\n+                'isolation_level': 'READ_COMMITTED',  # This should be ignored\n+            }\n+        }\n+        \n+        # Simulate what get_connection_params does\n+        conn_params = {\n+            'database': settings_dict['NAME'],\n+            **settings_dict['OPTIONS'],\n+        }\n+        conn_params.pop('isolation_level', None)\n+        if settings_dict['USER']:\n+            conn_params['user'] = settings_dict['USER']\n+        if settings_dict['PASSWORD']:\n+            conn_params['password'] = settings_dict['PASSWORD']\n+        if settings_dict['HOST']:\n+            conn_params['host'] = settings_dict['HOST']\n+        if settings_dict['PORT']:\n+            conn_params['port'] = settings_dict['PORT']\n+        \n+        with mock.patch('subprocess.run') as mock_run:\n+            with mock.patch('signal.signal'):\n+                with mock.patch.object(DatabaseClient, 'runshell_db', side_effect=self._fixed_runshell_db):\n+                    DatabaseClient.runshell_db(conn_params)\n+        \n+        args, kwargs = mock_run.call_args\n+        env = kwargs['env']\n+        \n+        # All SSL parameters should be properly set\n+        assert env['PGSSLMODE'] == 'verify-ca'\n+        assert env['PGSSLROOTCERT'] == '/path/to/ca.crt'\n+        assert env['PGSSLCERT'] == '/path/to/client.crt'\n+        assert env['PGSSLKEY'] == '/path/to/client.key'\n+        assert env['PGPASSWORD'] == 'test_pass'\n+        \n+        # isolation_level should not be in environment\n+        assert 'isolation_level' not in env\n+\n+    def _fixed_runshell_db(self, conn_params):\n+        \"\"\"\n+        Mock implementation of the fixed runshell_db method.\n+        This simulates what the method should do after the fix is applied.\n+        \"\"\"\n+        import signal\n+        \n+        args = ['psql']\n+        \n+        host = conn_params.get('host', '')\n+        port = conn_params.get('port', '')\n+        dbname = conn_params.get('database', '')\n+        user = conn_params.get('user', '')\n+        passwd = conn_params.get('password', '')\n+        \n+        if user:\n+            args += ['-U', user]\n+        if host:\n+            args += ['-h', host]\n+        if port:\n+            args += ['-p', str(port)]\n+        args += [dbname]\n+        \n+        sigint_handler = signal.getsignal(signal.SIGINT)\n+        subprocess_env = os.environ.copy()\n+        if passwd:\n+            subprocess_env['PGPASSWORD'] = str(passwd)\n+        \n+        # Add SSL parameters to environment - this is the fix\n+        ssl_params = {\n+            'sslmode': 'PGSSLMODE',\n+            'sslrootcert': 'PGSSLROOTCERT', \n+            'sslcert': 'PGSSLCERT',\n+            'sslkey': 'PGSSLKEY',\n+        }\n+        \n+        for param, env_var in ssl_params.items():\n+            value = conn_params.get(param)\n+            if value:\n+                subprocess_env[env_var] = str(value)\n+        \n+        try:\n+            signal.signal(signal.SIGINT, signal.SIG_IGN)\n+            subprocess.run(args, check=True, env=subprocess_env)\n+        finally:\n+            signal.signal(signal.SIGINT, sigint_handler)\n"
}