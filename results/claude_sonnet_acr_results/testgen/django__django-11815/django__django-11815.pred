{
  "instance_id": "django__django-11815",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/migrations/test_enum_serialization.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom enum import Enum\nfrom django.db import models\nfrom django.db.migrations.serializer import serializer_factory, EnumSerializer\nfrom django.utils.translation import gettext_lazy as _\n\n\nclass Status(Enum):\n    \"\"\"Test enum with translatable values.\"\"\"\n    GOOD = _('Good')\n    BAD = _('Bad')\n    PENDING = _('Pending')\n\n    def __str__(self):\n        return self.name\n\n\nclass SimpleStatus(Enum):\n    \"\"\"Test enum with simple string values.\"\"\"\n    ACTIVE = 'active'\n    INACTIVE = 'inactive'\n\n\nclass IntStatus(Enum):\n    \"\"\"Test enum with integer values.\"\"\"\n    DRAFT = 1\n    PUBLISHED = 2\n\n\nclass TestEnumSerialization:\n    \"\"\"Test suite for enum serialization in Django migrations.\"\"\"\n\n    def test_enum_serializer_uses_name_not_value(self):\n        \"\"\"Test that EnumSerializer uses enum name instead of value.\"\"\"\n        # Test with translatable enum value\n        serializer = EnumSerializer(Status.GOOD)\n        serialized, imports = serializer.serialize()\n        \n        # Should use name-based access, not value-based constructor\n        assert 'Status.GOOD' in serialized or 'Status[\\'GOOD\\']' in serialized\n        assert 'Status(\\'Good\\')' not in serialized\n        assert 'Status(_(' not in serialized\n\n    def test_enum_serializer_with_simple_string_values(self):\n        \"\"\"Test enum serialization with simple string values.\"\"\"\n        serializer = EnumSerializer(SimpleStatus.ACTIVE)\n        serialized, imports = serializer.serialize()\n        \n        # Should use name-based access\n        assert 'SimpleStatus.ACTIVE' in serialized or 'SimpleStatus[\\'ACTIVE\\']' in serialized\n        assert 'SimpleStatus(\\'active\\')' not in serialized\n\n    def test_enum_serializer_with_integer_values(self):\n        \"\"\"Test enum serialization with integer values.\"\"\"\n        serializer = EnumSerializer(IntStatus.DRAFT)\n        serialized, imports = serializer.serialize()\n        \n        # Should use name-based access\n        assert 'IntStatus.DRAFT' in serialized or 'IntStatus[\\'DRAFT\\']' in serialized\n        assert 'IntStatus(1)' not in serialized\n\n    def test_enum_serializer_imports(self):\n        \"\"\"Test that enum serializer includes correct imports.\"\"\"\n        serializer = EnumSerializer(Status.GOOD)\n        serialized, imports = serializer.serialize()\n        \n        # Should include the enum class module in imports\n        expected_import = 'tests.migrations.test_enum_serialization.Status'\n        assert any(expected_import in imp for imp in imports)\n\n    def test_serializer_factory_with_enum(self):\n        \"\"\"Test that serializer_factory returns EnumSerializer for enum values.\"\"\"\n        serializer = serializer_factory(Status.GOOD)\n        assert isinstance(serializer, EnumSerializer)\n\n    def test_enum_serialization_preserves_functionality(self):\n        \"\"\"Test that serialized enum can be properly reconstructed.\"\"\"\n        # This test ensures the serialized form is valid Python code\n        serializer = EnumSerializer(Status.GOOD)\n        serialized, imports = serializer.serialize()\n        \n        # The serialized form should be executable Python code\n        # that references the enum by name\n        assert 'Status' in serialized\n        assert 'GOOD' in serialized\n\n    def test_enum_with_translated_values_migration_compatibility(self):\n        \"\"\"\n        Test that enum serialization works correctly when values are translated.\n        \n        This is the core issue: when enum values are translatable strings,\n        the migration should not break when the translation changes.\n        \"\"\"\n        # Simulate what happens in a migration file\n        serializer = EnumSerializer(Status.GOOD)\n        serialized, imports = serializer.serialize()\n        \n        # The serialized form should not depend on the current translation\n        # It should use the enum name, not the translated value\n        assert '_(' not in serialized  # No translation function calls\n        assert 'Good' not in serialized  # No hardcoded translated value\n        assert 'Status.GOOD' in serialized or 'Status[\\'GOOD\\']' in serialized\n\n    def test_enum_serialization_different_enum_types(self):\n        \"\"\"Test serialization works with different types of enum values.\"\"\"\n        test_cases = [\n            (Status.GOOD, 'Status'),\n            (SimpleStatus.ACTIVE, 'SimpleStatus'), \n            (IntStatus.DRAFT, 'IntStatus'),\n        ]\n        \n        for enum_value, enum_class_name in test_cases:\n            serializer = EnumSerializer(enum_value)\n            serialized, imports = serializer.serialize()\n            \n            # Should contain the enum class name and member name\n            assert enum_class_name in serialized\n            assert enum_value.name in serialized\n            \n            # Should not contain the value in constructor form\n            assert f'{enum_class_name}({repr(enum_value.value)})' not in serialized\n\n    def test_enum_serialization_edge_cases(self):\n        \"\"\"Test enum serialization with edge cases.\"\"\"\n        # Test enum with special characters in name\n        class SpecialEnum(Enum):\n            SPECIAL_CASE = 'special'\n            ANOTHER_CASE = 'another'\n        \n        serializer = EnumSerializer(SpecialEnum.SPECIAL_CASE)\n        serialized, imports = serializer.serialize()\n        \n        assert 'SpecialEnum' in serialized\n        assert 'SPECIAL_CASE' in serialized\n        assert 'SpecialEnum(\\'special\\')' not in serialized\n\n    def test_enum_serialization_backwards_compatibility(self):\n        \"\"\"\n        Test that the new serialization approach maintains backwards compatibility.\n        \n        The serialized enum should still be a valid enum reference that can be\n        used in migration files without breaking existing functionality.\n        \"\"\"\n        serializer = EnumSerializer(Status.BAD)\n        serialized, imports = serializer.serialize()\n        \n        # Should be a valid enum reference\n        assert 'Status' in serialized\n        assert 'BAD' in serialized\n        \n        # Should not be a constructor call that could fail with translation\n        assert not serialized.startswith('Status(')\n\n    def test_multiple_enum_serialization(self):\n        \"\"\"Test serialization of multiple enum values from same enum.\"\"\"\n        enum_values = [Status.GOOD, Status.BAD, Status.PENDING]\n        \n        for enum_value in enum_values:\n            serializer = EnumSerializer(enum_value)\n            serialized, imports = serializer.serialize()\n            \n            # Each should use name-based access\n            assert 'Status' in serialized\n            assert enum_value.name in serialized\n            assert f'Status({repr(enum_value.value)})' not in serialized\n</patched>\n```\n\n```\n<file>tests/migrations/test_enum_migration_integration.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom enum import Enum\nfrom django.db import models\nfrom django.db.migrations.writer import MigrationWriter\nfrom django.db.migrations.autodetector import MigrationAutodetector\nfrom django.db.migrations.state import ProjectState\nfrom django.utils.translation import gettext_lazy as _\nfrom django.test import TestCase, override_settings\nfrom django.apps import apps\n\n\nclass StatusEnum(Enum):\n    \"\"\"Test enum for migration integration tests.\"\"\"\n    GOOD = _('Good')\n    BAD = _('Bad')\n    \n    def __str__(self):\n        return self.name\n\n\nclass TestModel(models.Model):\n    \"\"\"Test model with enum default value.\"\"\"\n    status = models.CharField(max_length=20, default=StatusEnum.GOOD)\n    \n    class Meta:\n        app_label = 'test_app'\n\n\nclass TestEnumMigrationIntegration(TestCase):\n    \"\"\"Integration tests for enum serialization in Django migrations.\"\"\"\n\n    def test_enum_default_in_migration_file(self):\n        \"\"\"\n        Test that enum defaults are properly serialized in migration files.\n        \n        This test verifies that when a model field has an enum default value,\n        the generated migration file uses the enum name rather than value.\n        \"\"\"\n        # Create a mock migration with enum default\n        from django.db.migrations import Migration\n        from django.db.migrations.operations import CreateModel\n        \n        operation = CreateModel(\n            name='TestModel',\n            fields=[\n                ('id', models.AutoField(primary_key=True)),\n                ('status', models.CharField(max_length=20, default=StatusEnum.GOOD)),\n            ],\n        )\n        \n        migration = Migration('0001_initial', 'test_app')\n        migration.operations = [operation]\n        \n        # Generate migration file content\n        writer = MigrationWriter(migration)\n        migration_string = writer.as_string()\n        \n        # The migration should use enum name, not value\n        assert 'StatusEnum.GOOD' in migration_string or 'StatusEnum[\\'GOOD\\']' in migration_string\n        assert 'StatusEnum(_(' not in migration_string\n        assert 'StatusEnum(\\'Good\\')' not in migration_string\n\n    def test_enum_serialization_with_translation_changes(self):\n        \"\"\"\n        Test that enum serialization is robust against translation changes.\n        \n        This simulates the scenario described in the issue where translation\n        changes would break old migration files.\n        \"\"\"\n        # Test with different language settings\n        with override_settings(LANGUAGE_CODE='en'):\n            from django.db.migrations.serializer import serializer_factory\n            \n            serializer = serializer_factory(StatusEnum.GOOD)\n            serialized_en, imports_en = serializer.serialize()\n            \n        with override_settings(LANGUAGE_CODE='es'):\n            # Even with different language, serialization should be the same\n            serializer = serializer_factory(StatusEnum.GOOD)\n            serialized_es, imports_es = serializer.serialize()\n            \n        # Serialization should be identical regardless of language\n        assert serialized_en == serialized_es\n        assert imports_en == imports_es\n        \n        # Should not contain language-specific content\n        assert '_(' not in serialized_en\n        assert 'Good' not in serialized_en  # No hardcoded English text\n\n    def test_migration_with_enum_field_creation(self):\n        \"\"\"Test creating a migration that adds a field with enum default.\"\"\"\n        # Simulate adding a field with enum default to existing model\n        from django.db.migrations.operations import AddField\n        \n        operation = AddField(\n            model_name='testmodel',\n            name='priority',\n            field=models.CharField(max_length=20, default=StatusEnum.BAD),\n        )\n        \n        # Serialize the operation\n        from django.db.migrations.serializer import serializer_factory\n        serializer = serializer_factory(operation)\n        serialized, imports = serializer.serialize()\n        \n        # The serialized operation should contain proper enum reference\n        assert 'StatusEnum' in serialized\n        assert 'BAD' in serialized\n        assert 'StatusEnum(_(' not in serialized\n\n    def test_enum_in_field_choices(self):\n        \"\"\"Test enum serialization when used in field choices.\"\"\"\n        choices = [(StatusEnum.GOOD, 'Good Status'), (StatusEnum.BAD, 'Bad Status')]\n        \n        from django.db.migrations.serializer import serializer_factory\n        serializer = serializer_factory(choices)\n        serialized, imports = serializer.serialize()\n        \n        # Should serialize enum members by name\n        assert 'StatusEnum.GOOD' in serialized or 'StatusEnum[\\'GOOD\\']' in serialized\n        assert 'StatusEnum.BAD' in serialized or 'StatusEnum[\\'BAD\\']' in serialized\n        \n        # Should not serialize by value\n        assert 'StatusEnum(_(' not in serialized\n\n    def test_complex_enum_migration_scenario(self):\n        \"\"\"\n        Test a complex scenario with multiple enum usages in a migration.\n        \n        This tests the real-world scenario where enums are used in multiple\n        places within the same migration.\n        \"\"\"\n        from django.db.migrations.operations import CreateModel, AddField\n        \n        # Create model with enum default\n        create_op = CreateModel(\n            name='Document',\n            fields=[\n                ('id', models.AutoField(primary_key=True)),\n                ('status', models.CharField(max_length=20, default=StatusEnum.GOOD)),\n                ('priority', models.CharField(\n                    max_length=20, \n                    choices=[(StatusEnum.GOOD, 'High'), (StatusEnum.BAD, 'Low')],\n                    default=StatusEnum.BAD\n                )),\n            ],\n        )\n        \n        # Add field with enum default\n        add_op = AddField(\n            model_name='document',\n            name='review_status',\n            field=models.CharField(max_length=20, default=StatusEnum.GOOD),\n        )\n        \n        operations = [create_op, add_op]\n        \n        # Serialize all operations\n        from django.db.migrations.serializer import serializer_factory\n        for operation in operations:\n            serializer = serializer_factory(operation)\n            serialized, imports = serializer.serialize()\n            \n            # All enum references should use name-based access\n            if 'StatusEnum' in serialized:\n                assert 'StatusEnum.GOOD' in serialized or 'StatusEnum[\\'GOOD\\']' in serialized\n                assert 'StatusEnum.BAD' in serialized or 'StatusEnum[\\'BAD\\']' in serialized\n                assert 'StatusEnum(_(' not in serialized\n\n    def test_enum_migration_file_generation(self):\n        \"\"\"\n        Test end-to-end migration file generation with enum defaults.\n        \n        This test ensures that the complete migration generation process\n        produces correct enum serialization.\n        \"\"\"\n        # Mock a model state change that would trigger migration\n        from django.db.migrations import Migration\n        from django.db.migrations.operations import CreateModel\n        \n        fields = [\n            ('id', models.AutoField(primary_key=True)),\n            ('name', models.CharField(max_length=100)),\n            ('status', models.CharField(max_length=20, default=StatusEnum.GOOD)),\n        ]\n        \n        operation = CreateModel(name='TestDocument', fields=fields)\n        migration = Migration('0001_initial', 'test_app')\n        migration.operations = [operation]\n        \n        # Generate the migration file\n        writer = MigrationWriter(migration)\n        migration_content = writer.as_string()\n        \n        # Verify the generated content\n        lines = migration_content.split('\\n')\n        enum_lines = [line for line in lines if 'StatusEnum' in line]\n        \n        # Should have at least one line with enum reference\n        assert len(enum_lines) > 0\n        \n        # All enum references should be name-based\n        for line in enum_lines:\n            if 'default=' in line:\n                assert 'StatusEnum.GOOD' in line or 'StatusEnum[\\'GOOD\\']' in line\n                assert 'StatusEnum(_(' not in line\n                assert 'StatusEnum(\\'Good\\')' not in line\n\n    def test_enum_serialization_preserves_migration_validity(self):\n        \"\"\"\n        Test that enum serialization produces valid Python code for migrations.\n        \n        This ensures that the serialized enum references can be properly\n        executed when the migration is applied.\n        \"\"\"\n        from django.db.migrations.serializer import serializer_factory\n        \n        # Test various enum values\n        test_enums = [StatusEnum.GOOD, StatusEnum.BAD]\n        \n        for enum_value in test_enums:\n            serializer = serializer_factory(enum_value)\n            serialized, imports = serializer.serialize()\n            \n            # The serialized form should be valid Python syntax\n            # that references the enum by name\n            assert serialized.count('.') >= 1 or '[' in serialized  # Name-based access\n            assert not serialized.startswith('StatusEnum(')  # Not constructor call\n            \n            # Should include proper import information\n            assert len(imports) > 0\n            assert any('StatusEnum' in imp for imp in imports)\n</patched>\n```\n\n```\n<file>tests/migrations/test_enum_edge_cases.py</file>\n",
  "patch": "--- a/tests/migrations/test_enum_serialization.py\n+++ b/tests/migrations/test_enum_serialization.py\n-# Empty if creating new file\n+import pytest\n+from enum import Enum\n+from django.db import models\n+from django.db.migrations.serializer import serializer_factory, EnumSerializer\n+from django.utils.translation import gettext_lazy as _\n+\n+\n+class Status(Enum):\n+    \"\"\"Test enum with translatable values.\"\"\"\n+    GOOD = _('Good')\n+    BAD = _('Bad')\n+    PENDING = _('Pending')\n+\n+    def __str__(self):\n+        return self.name\n+\n+\n+class SimpleStatus(Enum):\n+    \"\"\"Test enum with simple string values.\"\"\"\n+    ACTIVE = 'active'\n+    INACTIVE = 'inactive'\n+\n+\n+class IntStatus(Enum):\n+    \"\"\"Test enum with integer values.\"\"\"\n+    DRAFT = 1\n+    PUBLISHED = 2\n+\n+\n+class TestEnumSerialization:\n+    \"\"\"Test suite for enum serialization in Django migrations.\"\"\"\n+\n+    def test_enum_serializer_uses_name_not_value(self):\n+        \"\"\"Test that EnumSerializer uses enum name instead of value.\"\"\"\n+        # Test with translatable enum value\n+        serializer = EnumSerializer(Status.GOOD)\n+        serialized, imports = serializer.serialize()\n+        \n+        # Should use name-based access, not value-based constructor\n+        assert 'Status.GOOD' in serialized or 'Status[\\'GOOD\\']' in serialized\n+        assert 'Status(\\'Good\\')' not in serialized\n+        assert 'Status(_(' not in serialized\n+\n+    def test_enum_serializer_with_simple_string_values(self):\n+        \"\"\"Test enum serialization with simple string values.\"\"\"\n+        serializer = EnumSerializer(SimpleStatus.ACTIVE)\n+        serialized, imports = serializer.serialize()\n+        \n+        # Should use name-based access\n+        assert 'SimpleStatus.ACTIVE' in serialized or 'SimpleStatus[\\'ACTIVE\\']' in serialized\n+        assert 'SimpleStatus(\\'active\\')' not in serialized\n+\n+    def test_enum_serializer_with_integer_values(self):\n+        \"\"\"Test enum serialization with integer values.\"\"\"\n+        serializer = EnumSerializer(IntStatus.DRAFT)\n+        serialized, imports = serializer.serialize()\n+        \n+        # Should use name-based access\n+        assert 'IntStatus.DRAFT' in serialized or 'IntStatus[\\'DRAFT\\']' in serialized\n+        assert 'IntStatus(1)' not in serialized\n+\n+    def test_enum_serializer_imports(self):\n+        \"\"\"Test that enum serializer includes correct imports.\"\"\"\n+        serializer = EnumSerializer(Status.GOOD)\n+        serialized, imports = serializer.serialize()\n+        \n+        # Should include the enum class module in imports\n+        expected_import = 'tests.migrations.test_enum_serialization.Status'\n+        assert any(expected_import in imp for imp in imports)\n+\n+    def test_serializer_factory_with_enum(self):\n+        \"\"\"Test that serializer_factory returns EnumSerializer for enum values.\"\"\"\n+        serializer = serializer_factory(Status.GOOD)\n+        assert isinstance(serializer, EnumSerializer)\n+\n+    def test_enum_serialization_preserves_functionality(self):\n+        \"\"\"Test that serialized enum can be properly reconstructed.\"\"\"\n+        # This test ensures the serialized form is valid Python code\n+        serializer = EnumSerializer(Status.GOOD)\n+        serialized, imports = serializer.serialize()\n+        \n+        # The serialized form should be executable Python code\n+        # that references the enum by name\n+        assert 'Status' in serialized\n+        assert 'GOOD' in serialized\n+\n+    def test_enum_with_translated_values_migration_compatibility(self):\n+        \"\"\"\n+        Test that enum serialization works correctly when values are translated.\n+        \n+        This is the core issue: when enum values are translatable strings,\n+        the migration should not break when the translation changes.\n+        \"\"\"\n+        # Simulate what happens in a migration file\n+        serializer = EnumSerializer(Status.GOOD)\n+        serialized, imports = serializer.serialize()\n+        \n+        # The serialized form should not depend on the current translation\n+        # It should use the enum name, not the translated value\n+        assert '_(' not in serialized  # No translation function calls\n+        assert 'Good' not in serialized  # No hardcoded translated value\n+        assert 'Status.GOOD' in serialized or 'Status[\\'GOOD\\']' in serialized\n+\n+    def test_enum_serialization_different_enum_types(self):\n+        \"\"\"Test serialization works with different types of enum values.\"\"\"\n+        test_cases = [\n+            (Status.GOOD, 'Status'),\n+            (SimpleStatus.ACTIVE, 'SimpleStatus'), \n+            (IntStatus.DRAFT, 'IntStatus'),\n+        ]\n+        \n+        for enum_value, enum_class_name in test_cases:\n+            serializer = EnumSerializer(enum_value)\n+            serialized, imports = serializer.serialize()\n+            \n+            # Should contain the enum class name and member name\n+            assert enum_class_name in serialized\n+            assert enum_value.name in serialized\n+            \n+            # Should not contain the value in constructor form\n+            assert f'{enum_class_name}({repr(enum_value.value)})' not in serialized\n+\n+    def test_enum_serialization_edge_cases(self):\n+        \"\"\"Test enum serialization with edge cases.\"\"\"\n+        # Test enum with special characters in name\n+        class SpecialEnum(Enum):\n+            SPECIAL_CASE = 'special'\n+            ANOTHER_CASE = 'another'\n+        \n+        serializer = EnumSerializer(SpecialEnum.SPECIAL_CASE)\n+        serialized, imports = serializer.serialize()\n+        \n+        assert 'SpecialEnum' in serialized\n+        assert 'SPECIAL_CASE' in serialized\n+        assert 'SpecialEnum(\\'special\\')' not in serialized\n+\n+    def test_enum_serialization_backwards_compatibility(self):\n+        \"\"\"\n+        Test that the new serialization approach maintains backwards compatibility.\n+        \n+        The serialized enum should still be a valid enum reference that can be\n+        used in migration files without breaking existing functionality.\n+        \"\"\"\n+        serializer = EnumSerializer(Status.BAD)\n+        serialized, imports = serializer.serialize()\n+        \n+        # Should be a valid enum reference\n+        assert 'Status' in serialized\n+        assert 'BAD' in serialized\n+        \n+        # Should not be a constructor call that could fail with translation\n+        assert not serialized.startswith('Status(')\n+\n+    def test_multiple_enum_serialization(self):\n+        \"\"\"Test serialization of multiple enum values from same enum.\"\"\"\n+        enum_values = [Status.GOOD, Status.BAD, Status.PENDING]\n+        \n+        for enum_value in enum_values:\n+            serializer = EnumSerializer(enum_value)\n+            serialized, imports = serializer.serialize()\n+            \n+            # Each should use name-based access\n+            assert 'Status' in serialized\n+            assert enum_value.name in serialized\n+            assert f'Status({repr(enum_value.value)})' not in serialized\n\n--- a/tests/migrations/test_enum_migration_integration.py\n+++ b/tests/migrations/test_enum_migration_integration.py\n-# Empty if creating new file\n+import pytest\n+from enum import Enum\n+from django.db import models\n+from django.db.migrations.writer import MigrationWriter\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState\n+from django.utils.translation import gettext_lazy as _\n+from django.test import TestCase, override_settings\n+from django.apps import apps\n+\n+\n+class StatusEnum(Enum):\n+    \"\"\"Test enum for migration integration tests.\"\"\"\n+    GOOD = _('Good')\n+    BAD = _('Bad')\n+    \n+    def __str__(self):\n+        return self.name\n+\n+\n+class TestModel(models.Model):\n+    \"\"\"Test model with enum default value.\"\"\"\n+    status = models.CharField(max_length=20, default=StatusEnum.GOOD)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class TestEnumMigrationIntegration(TestCase):\n+    \"\"\"Integration tests for enum serialization in Django migrations.\"\"\"\n+\n+    def test_enum_default_in_migration_file(self):\n+        \"\"\"\n+        Test that enum defaults are properly serialized in migration files.\n+        \n+        This test verifies that when a model field has an enum default value,\n+        the generated migration file uses the enum name rather than value.\n+        \"\"\"\n+        # Create a mock migration with enum default\n+        from django.db.migrations import Migration\n+        from django.db.migrations.operations import CreateModel\n+        \n+        operation = CreateModel(\n+            name='TestModel',\n+            fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('status', models.CharField(max_length=20, default=StatusEnum.GOOD)),\n+            ],\n+        )\n+        \n+        migration = Migration('0001_initial', 'test_app')\n+        migration.operations = [operation]\n+        \n+        # Generate migration file content\n+        writer = MigrationWriter(migration)\n+        migration_string = writer.as_string()\n+        \n+        # The migration should use enum name, not value\n+        assert 'StatusEnum.GOOD' in migration_string or 'StatusEnum[\\'GOOD\\']' in migration_string\n+        assert 'StatusEnum(_(' not in migration_string\n+        assert 'StatusEnum(\\'Good\\')' not in migration_string\n+\n+    def test_enum_serialization_with_translation_changes(self):\n+        \"\"\"\n+        Test that enum serialization is robust against translation changes.\n+        \n+        This simulates the scenario described in the issue where translation\n+        changes would break old migration files.\n+        \"\"\"\n+        # Test with different language settings\n+        with override_settings(LANGUAGE_CODE='en'):\n+            from django.db.migrations.serializer import serializer_factory\n+            \n+            serializer = serializer_factory(StatusEnum.GOOD)\n+            serialized_en, imports_en = serializer.serialize()\n+            \n+        with override_settings(LANGUAGE_CODE='es'):\n+            # Even with different language, serialization should be the same\n+            serializer = serializer_factory(StatusEnum.GOOD)\n+            serialized_es, imports_es = serializer.serialize()\n+            \n+        # Serialization should be identical regardless of language\n+        assert serialized_en == serialized_es\n+        assert imports_en == imports_es\n+        \n+        # Should not contain language-specific content\n+        assert '_(' not in serialized_en\n+        assert 'Good' not in serialized_en  # No hardcoded English text\n+\n+    def test_migration_with_enum_field_creation(self):\n+        \"\"\"Test creating a migration that adds a field with enum default.\"\"\"\n+        # Simulate adding a field with enum default to existing model\n+        from django.db.migrations.operations import AddField\n+        \n+        operation = AddField(\n+            model_name='testmodel',\n+            name='priority',\n+            field=models.CharField(max_length=20, default=StatusEnum.BAD),\n+        )\n+        \n+        # Serialize the operation\n+        from django.db.migrations.serializer import serializer_factory\n+        serializer = serializer_factory(operation)\n+        serialized, imports = serializer.serialize()\n+        \n+        # The serialized operation should contain proper enum reference\n+        assert 'StatusEnum' in serialized\n+        assert 'BAD' in serialized\n+        assert 'StatusEnum(_(' not in serialized\n+\n+    def test_enum_in_field_choices(self):\n+        \"\"\"Test enum serialization when used in field choices.\"\"\"\n+        choices = [(StatusEnum.GOOD, 'Good Status'), (StatusEnum.BAD, 'Bad Status')]\n+        \n+        from django.db.migrations.serializer import serializer_factory\n+        serializer = serializer_factory(choices)\n+        serialized, imports = serializer.serialize()\n+        \n+        # Should serialize enum members by name\n+        assert 'StatusEnum.GOOD' in serialized or 'StatusEnum[\\'GOOD\\']' in serialized\n+        assert 'StatusEnum.BAD' in serialized or 'StatusEnum[\\'BAD\\']' in serialized\n+        \n+        # Should not serialize by value\n+        assert 'StatusEnum(_(' not in serialized\n+\n+    def test_complex_enum_migration_scenario(self):\n+        \"\"\"\n+        Test a complex scenario with multiple enum usages in a migration.\n+        \n+        This tests the real-world scenario where enums are used in multiple\n+        places within the same migration.\n+        \"\"\"\n+        from django.db.migrations.operations import CreateModel, AddField\n+        \n+        # Create model with enum default\n+        create_op = CreateModel(\n+            name='Document',\n+            fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('status', models.CharField(max_length=20, default=StatusEnum.GOOD)),\n+                ('priority', models.CharField(\n+                    max_length=20, \n+                    choices=[(StatusEnum.GOOD, 'High'), (StatusEnum.BAD, 'Low')],\n+                    default=StatusEnum.BAD\n+                )),\n+            ],\n+        )\n+        \n+        # Add field with enum default\n+        add_op = AddField(\n+            model_name='document',\n+            name='review_status',\n+            field=models.CharField(max_length=20, default=StatusEnum.GOOD),\n+        )\n+        \n+        operations = [create_op, add_op]\n+        \n+        # Serialize all operations\n+        from django.db.migrations.serializer import serializer_factory\n+        for operation in operations:\n+            serializer = serializer_factory(operation)\n+            serialized, imports = serializer.serialize()\n+            \n+            # All enum references should use name-based access\n+            if 'StatusEnum' in serialized:\n+                assert 'StatusEnum.GOOD' in serialized or 'StatusEnum[\\'GOOD\\']' in serialized\n+                assert 'StatusEnum.BAD' in serialized or 'StatusEnum[\\'BAD\\']' in serialized\n+                assert 'StatusEnum(_(' not in serialized\n+\n+    def test_enum_migration_file_generation(self):\n+        \"\"\"\n+        Test end-to-end migration file generation with enum defaults.\n+        \n+        This test ensures that the complete migration generation process\n+        produces correct enum serialization.\n+        \"\"\"\n+        # Mock a model state change that would trigger migration\n+        from django.db.migrations import Migration\n+        from django.db.migrations.operations import CreateModel\n+        \n+        fields = [\n+            ('id', models.AutoField(primary_key=True)),\n+            ('name', models.CharField(max_length=100)),\n+            ('status', models.CharField(max_length=20, default=StatusEnum.GOOD)),\n+        ]\n+        \n+        operation = CreateModel(name='TestDocument', fields=fields)\n+        migration = Migration('0001_initial', 'test_app')\n+        migration.operations = [operation]\n+        \n+        # Generate the migration file\n+        writer = MigrationWriter(migration)\n+        migration_content = writer.as_string()\n+        \n+        # Verify the generated content\n+        lines = migration_content.split('\\n')\n+        enum_lines = [line for line in lines if 'StatusEnum' in line]\n+        \n+        # Should have at least one line with enum reference\n+        assert len(enum_lines) > 0\n+        \n+        # All enum references should be name-based\n+        for line in enum_lines:\n+            if 'default=' in line:\n+                assert 'StatusEnum.GOOD' in line or 'StatusEnum[\\'GOOD\\']' in line\n+                assert 'StatusEnum(_(' not in line\n+                assert 'StatusEnum(\\'Good\\')' not in line\n+\n+    def test_enum_serialization_preserves_migration_validity(self):\n+        \"\"\"\n+        Test that enum serialization produces valid Python code for migrations.\n+        \n+        This ensures that the serialized enum references can be properly\n+        executed when the migration is applied.\n+        \"\"\"\n+        from django.db.migrations.serializer import serializer_factory\n+        \n+        # Test various enum values\n+        test_enums = [StatusEnum.GOOD, StatusEnum.BAD]\n+        \n+        for enum_value in test_enums:\n+            serializer = serializer_factory(enum_value)\n+            serialized, imports = serializer.serialize()\n+            \n+            # The serialized form should be valid Python syntax\n+            # that references the enum by name\n+            assert serialized.count('.') >= 1 or '[' in serialized  # Name-based access\n+            assert not serialized.startswith('StatusEnum(')  # Not constructor call\n+            \n+            # Should include proper import information\n+            assert len(imports) > 0\n+            assert any('StatusEnum' in imp for imp in imports)\n"
}