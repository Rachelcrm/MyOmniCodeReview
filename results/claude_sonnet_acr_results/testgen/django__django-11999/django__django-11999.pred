{
  "instance_id": "django__django-11999",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_fields/test_get_display_override.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models\nfrom django.test import TestCase\n\n\nclass TestGetDisplayOverride(TestCase):\n    \"\"\"Test that get_FOO_display() methods can be overridden in Django 2.2+.\"\"\"\n\n    def test_get_display_override_works(self):\n        \"\"\"Test that overriding get_FOO_display() method works correctly.\"\"\"\n        \n        class FooBar(models.Model):\n            foo_bar = models.CharField(\n                max_length=10,\n                choices=[(1, 'foo'), (2, 'bar')]\n            )\n            \n            def get_foo_bar_display(self):\n                return \"something\"\n            \n            class Meta:\n                app_label = 'test'\n        \n        # Create an instance\n        instance = FooBar(foo_bar=1)\n        \n        # The overridden method should be called, not the default one\n        assert instance.get_foo_bar_display() == \"something\"\n        \n        # Test with different value to ensure override always works\n        instance.foo_bar = 2\n        assert instance.get_foo_bar_display() == \"something\"\n\n    def test_get_display_default_behavior_preserved(self):\n        \"\"\"Test that default get_FOO_display() behavior works when not overridden.\"\"\"\n        \n        class DefaultModel(models.Model):\n            status = models.CharField(\n                max_length=10,\n                choices=[('active', 'Active'), ('inactive', 'Inactive')]\n            )\n            \n            class Meta:\n                app_label = 'test'\n        \n        # Create an instance\n        instance = DefaultModel(status='active')\n        \n        # Should return the display value from choices\n        assert instance.get_status_display() == \"Active\"\n        \n        instance.status = 'inactive'\n        assert instance.get_status_display() == \"Inactive\"\n        \n        # Test with value not in choices\n        instance.status = 'unknown'\n        assert instance.get_status_display() == \"unknown\"\n\n    def test_get_display_override_with_inheritance(self):\n        \"\"\"Test that get_FOO_display() override works with model inheritance.\"\"\"\n        \n        class BaseModel(models.Model):\n            status = models.CharField(\n                max_length=10,\n                choices=[('draft', 'Draft'), ('published', 'Published')]\n            )\n            \n            class Meta:\n                app_label = 'test'\n                abstract = True\n        \n        class ChildModel(BaseModel):\n            def get_status_display(self):\n                return \"Custom: \" + super().get_status_display()\n            \n            class Meta:\n                app_label = 'test'\n        \n        instance = ChildModel(status='draft')\n        assert instance.get_status_display() == \"Custom: Draft\"\n\n    def test_get_display_override_multiple_fields(self):\n        \"\"\"Test overriding get_FOO_display() for multiple fields.\"\"\"\n        \n        class MultiFieldModel(models.Model):\n            field1 = models.CharField(\n                max_length=10,\n                choices=[('a', 'A'), ('b', 'B')]\n            )\n            field2 = models.CharField(\n                max_length=10,\n                choices=[('x', 'X'), ('y', 'Y')]\n            )\n            \n            def get_field1_display(self):\n                return \"Override1\"\n            \n            def get_field2_display(self):\n                return \"Override2\"\n            \n            class Meta:\n                app_label = 'test'\n        \n        instance = MultiFieldModel(field1='a', field2='x')\n        assert instance.get_field1_display() == \"Override1\"\n        assert instance.get_field2_display() == \"Override2\"\n\n    def test_get_display_override_with_no_choices(self):\n        \"\"\"Test that fields without choices don't get get_FOO_display() methods.\"\"\"\n        \n        class NoChoicesModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test'\n        \n        instance = NoChoicesModel(name=\"test\")\n        \n        # Should not have get_name_display method\n        assert not hasattr(instance, 'get_name_display')\n\n    def test_get_display_override_edge_cases(self):\n        \"\"\"Test edge cases for get_FOO_display() override.\"\"\"\n        \n        class EdgeCaseModel(models.Model):\n            # Field with empty choices\n            empty_choices = models.CharField(\n                max_length=10,\n                choices=[]\n            )\n            \n            # Field with None value in choices\n            nullable_choice = models.CharField(\n                max_length=10,\n                choices=[(None, 'None Value'), ('value', 'Value')],\n                null=True,\n                blank=True\n            )\n            \n            def get_empty_choices_display(self):\n                return \"Empty Override\"\n            \n            def get_nullable_choice_display(self):\n                return \"Nullable Override\"\n            \n            class Meta:\n                app_label = 'test'\n        \n        instance = EdgeCaseModel()\n        assert instance.get_empty_choices_display() == \"Empty Override\"\n        assert instance.get_nullable_choice_display() == \"Nullable Override\"\n\n    def test_get_display_method_signature(self):\n        \"\"\"Test that overridden get_FOO_display() methods have correct signature.\"\"\"\n        \n        class SignatureModel(models.Model):\n            status = models.CharField(\n                max_length=10,\n                choices=[('active', 'Active')]\n            )\n            \n            def get_status_display(self):\n                # Should be able to access self and field value\n                return f\"Status: {self.status}\"\n            \n            class Meta:\n                app_label = 'test'\n        \n        instance = SignatureModel(status='active')\n        assert instance.get_status_display() == \"Status: active\"\n\n    def test_get_display_override_fails_before_fix(self):\n        \"\"\"Test that demonstrates the bug - this should fail before the fix is applied.\"\"\"\n        \n        class BugDemonstrationModel(models.Model):\n            choice_field = models.CharField(\n                max_length=10,\n                choices=[('value1', 'Display1'), ('value2', 'Display2')]\n            )\n            \n            def get_choice_field_display(self):\n                return \"This should be returned but won't be in Django 2.2+ without fix\"\n            \n            class Meta:\n                app_label = 'test'\n        \n        instance = BugDemonstrationModel(choice_field='value1')\n        \n        # Before fix: this would return \"Display1\" (from choices)\n        # After fix: this should return the overridden value\n        result = instance.get_choice_field_display()\n        \n        # This assertion will fail before the fix is applied\n        # demonstrating the bug exists\n        assert result == \"This should be returned but won't be in Django 2.2+ without fix\"\n\n    def test_get_display_override_with_property(self):\n        \"\"\"Test that get_FOO_display() can be overridden as a property.\"\"\"\n        \n        class PropertyModel(models.Model):\n            status = models.CharField(\n                max_length=10,\n                choices=[('active', 'Active'), ('inactive', 'Inactive')]\n            )\n            \n            @property\n            def get_status_display(self):\n                return f\"Property: {dict(self._meta.get_field('status').choices).get(self.status, self.status)}\"\n            \n            class Meta:\n                app_label = 'test'\n        \n        instance = PropertyModel(status='active')\n        assert instance.get_status_display == \"Property: Active\"\n\n    def test_get_display_override_with_classmethod(self):\n        \"\"\"Test interaction between get_FOO_display() override and classmethods.\"\"\"\n        \n        class ClassMethodModel(models.Model):\n            type_field = models.CharField(\n                max_length=10,\n                choices=[('type1', 'Type 1'), ('type2', 'Type 2')]\n            )\n            \n            def get_type_field_display(self):\n                return \"Instance method override\"\n            \n            @classmethod\n            def get_default_type_display(cls):\n                return \"Class method\"\n            \n            class Meta:\n                app_label = 'test'\n        \n        instance = ClassMethodModel(type_field='type1')\n        assert instance.get_type_field_display() == \"Instance method override\"\n        assert ClassMethodModel.get_default_type_display() == \"Class method\"\n</patched>\n```",
  "patch": "--- a/tests/model_fields/test_get_display_override.py\n+++ b/tests/model_fields/test_get_display_override.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class TestGetDisplayOverride(TestCase):\n+    \"\"\"Test that get_FOO_display() methods can be overridden in Django 2.2+.\"\"\"\n+\n+    def test_get_display_override_works(self):\n+        \"\"\"Test that overriding get_FOO_display() method works correctly.\"\"\"\n+        \n+        class FooBar(models.Model):\n+            foo_bar = models.CharField(\n+                max_length=10,\n+                choices=[(1, 'foo'), (2, 'bar')]\n+            )\n+            \n+            def get_foo_bar_display(self):\n+                return \"something\"\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        # Create an instance\n+        instance = FooBar(foo_bar=1)\n+        \n+        # The overridden method should be called, not the default one\n+        assert instance.get_foo_bar_display() == \"something\"\n+        \n+        # Test with different value to ensure override always works\n+        instance.foo_bar = 2\n+        assert instance.get_foo_bar_display() == \"something\"\n+\n+    def test_get_display_default_behavior_preserved(self):\n+        \"\"\"Test that default get_FOO_display() behavior works when not overridden.\"\"\"\n+        \n+        class DefaultModel(models.Model):\n+            status = models.CharField(\n+                max_length=10,\n+                choices=[('active', 'Active'), ('inactive', 'Inactive')]\n+            )\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        # Create an instance\n+        instance = DefaultModel(status='active')\n+        \n+        # Should return the display value from choices\n+        assert instance.get_status_display() == \"Active\"\n+        \n+        instance.status = 'inactive'\n+        assert instance.get_status_display() == \"Inactive\"\n+        \n+        # Test with value not in choices\n+        instance.status = 'unknown'\n+        assert instance.get_status_display() == \"unknown\"\n+\n+    def test_get_display_override_with_inheritance(self):\n+        \"\"\"Test that get_FOO_display() override works with model inheritance.\"\"\"\n+        \n+        class BaseModel(models.Model):\n+            status = models.CharField(\n+                max_length=10,\n+                choices=[('draft', 'Draft'), ('published', 'Published')]\n+            )\n+            \n+            class Meta:\n+                app_label = 'test'\n+                abstract = True\n+        \n+        class ChildModel(BaseModel):\n+            def get_status_display(self):\n+                return \"Custom: \" + super().get_status_display()\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        instance = ChildModel(status='draft')\n+        assert instance.get_status_display() == \"Custom: Draft\"\n+\n+    def test_get_display_override_multiple_fields(self):\n+        \"\"\"Test overriding get_FOO_display() for multiple fields.\"\"\"\n+        \n+        class MultiFieldModel(models.Model):\n+            field1 = models.CharField(\n+                max_length=10,\n+                choices=[('a', 'A'), ('b', 'B')]\n+            )\n+            field2 = models.CharField(\n+                max_length=10,\n+                choices=[('x', 'X'), ('y', 'Y')]\n+            )\n+            \n+            def get_field1_display(self):\n+                return \"Override1\"\n+            \n+            def get_field2_display(self):\n+                return \"Override2\"\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        instance = MultiFieldModel(field1='a', field2='x')\n+        assert instance.get_field1_display() == \"Override1\"\n+        assert instance.get_field2_display() == \"Override2\"\n+\n+    def test_get_display_override_with_no_choices(self):\n+        \"\"\"Test that fields without choices don't get get_FOO_display() methods.\"\"\"\n+        \n+        class NoChoicesModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        instance = NoChoicesModel(name=\"test\")\n+        \n+        # Should not have get_name_display method\n+        assert not hasattr(instance, 'get_name_display')\n+\n+    def test_get_display_override_edge_cases(self):\n+        \"\"\"Test edge cases for get_FOO_display() override.\"\"\"\n+        \n+        class EdgeCaseModel(models.Model):\n+            # Field with empty choices\n+            empty_choices = models.CharField(\n+                max_length=10,\n+                choices=[]\n+            )\n+            \n+            # Field with None value in choices\n+            nullable_choice = models.CharField(\n+                max_length=10,\n+                choices=[(None, 'None Value'), ('value', 'Value')],\n+                null=True,\n+                blank=True\n+            )\n+            \n+            def get_empty_choices_display(self):\n+                return \"Empty Override\"\n+            \n+            def get_nullable_choice_display(self):\n+                return \"Nullable Override\"\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        instance = EdgeCaseModel()\n+        assert instance.get_empty_choices_display() == \"Empty Override\"\n+        assert instance.get_nullable_choice_display() == \"Nullable Override\"\n+\n+    def test_get_display_method_signature(self):\n+        \"\"\"Test that overridden get_FOO_display() methods have correct signature.\"\"\"\n+        \n+        class SignatureModel(models.Model):\n+            status = models.CharField(\n+                max_length=10,\n+                choices=[('active', 'Active')]\n+            )\n+            \n+            def get_status_display(self):\n+                # Should be able to access self and field value\n+                return f\"Status: {self.status}\"\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        instance = SignatureModel(status='active')\n+        assert instance.get_status_display() == \"Status: active\"\n+\n+    def test_get_display_override_fails_before_fix(self):\n+        \"\"\"Test that demonstrates the bug - this should fail before the fix is applied.\"\"\"\n+        \n+        class BugDemonstrationModel(models.Model):\n+            choice_field = models.CharField(\n+                max_length=10,\n+                choices=[('value1', 'Display1'), ('value2', 'Display2')]\n+            )\n+            \n+            def get_choice_field_display(self):\n+                return \"This should be returned but won't be in Django 2.2+ without fix\"\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        instance = BugDemonstrationModel(choice_field='value1')\n+        \n+        # Before fix: this would return \"Display1\" (from choices)\n+        # After fix: this should return the overridden value\n+        result = instance.get_choice_field_display()\n+        \n+        # This assertion will fail before the fix is applied\n+        # demonstrating the bug exists\n+        assert result == \"This should be returned but won't be in Django 2.2+ without fix\"\n+\n+    def test_get_display_override_with_property(self):\n+        \"\"\"Test that get_FOO_display() can be overridden as a property.\"\"\"\n+        \n+        class PropertyModel(models.Model):\n+            status = models.CharField(\n+                max_length=10,\n+                choices=[('active', 'Active'), ('inactive', 'Inactive')]\n+            )\n+            \n+            @property\n+            def get_status_display(self):\n+                return f\"Property: {dict(self._meta.get_field('status').choices).get(self.status, self.status)}\"\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        instance = PropertyModel(status='active')\n+        assert instance.get_status_display == \"Property: Active\"\n+\n+    def test_get_display_override_with_classmethod(self):\n+        \"\"\"Test interaction between get_FOO_display() override and classmethods.\"\"\"\n+        \n+        class ClassMethodModel(models.Model):\n+            type_field = models.CharField(\n+                max_length=10,\n+                choices=[('type1', 'Type 1'), ('type2', 'Type 2')]\n+            )\n+            \n+            def get_type_field_display(self):\n+                return \"Instance method override\"\n+            \n+            @classmethod\n+            def get_default_type_display(cls):\n+                return \"Class method\"\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        instance = ClassMethodModel(type_field='type1')\n+        assert instance.get_type_field_display() == \"Instance method override\"\n+        assert ClassMethodModel.get_default_type_display() == \"Class method\"\n"
}