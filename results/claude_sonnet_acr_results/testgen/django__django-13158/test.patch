--- a/tests/forms_tests/test_models.py
+++ b/tests/forms_tests/test_models.py
-# Empty if creating new file
+import pytest
+from django.core.exceptions import ValidationError
+from django.db import models
+from django.forms import ModelMultipleChoiceField
+from django.test import TestCase
+
+
+class Publication(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'forms_tests'
+
+
+class Article(models.Model):
+    title = models.CharField(max_length=100)
+    publications = models.ManyToManyField(Publication, blank=True)
+    
+    class Meta:
+        app_label = 'forms_tests'
+
+
+class QuerySetNoneUnionTestCase(TestCase):
+    """Test that QuerySet.none() works correctly with combined queries."""
+    
+    @classmethod
+    def setUpTestData(cls):
+        # Create test publications with IDs 1-10
+        cls.publications = []
+        for i in range(1, 11):
+            pub = Publication.objects.create(name=f'Publication {i}')
+            cls.publications.append(pub)
+    
+    def test_queryset_none_with_or_operator(self):
+        """Test that queryset.none() works correctly with OR operator (|)."""
+        # Create a queryset using OR operator
+        queryset = Publication.objects.filter(id__lt=2) | Publication.objects.filter(id__gt=5)
+        
+        # Verify the queryset has the expected objects
+        self.assertEqual(queryset.count(), 6)  # ID 1 + IDs 6-10
+        
+        # Test that none() returns empty queryset
+        none_qs = queryset.none()
+        self.assertEqual(none_qs.count(), 0)
+        self.assertEqual(list(none_qs), [])
+    
+    def test_queryset_none_with_union_operator(self):
+        """Test that queryset.none() works correctly with union() operator."""
+        # Create a queryset using union operator
+        queryset = Publication.objects.filter(id__lt=2).union(
+            Publication.objects.filter(id__gt=5)
+        )
+        
+        # Verify the queryset has the expected objects
+        self.assertEqual(queryset.count(), 6)  # ID 1 + IDs 6-10
+        
+        # Test that none() returns empty queryset - THIS SHOULD FAIL BEFORE FIX
+        none_qs = queryset.none()
+        self.assertEqual(none_qs.count(), 0)
+        self.assertEqual(list(none_qs), [])
+    
+    def test_model_multiple_choice_field_with_or_operator_empty_value(self):
+        """Test ModelMultipleChoiceField with OR operator returns empty when no value selected."""
+        queryset = Publication.objects.filter(id__lt=2) | Publication.objects.filter(id__gt=5)
+        field = ModelMultipleChoiceField(queryset=queryset, required=False)
+        
+        # Test with empty value (simulating form submission with no selections)
+        result = field.clean([])
+        self.assertEqual(result.count(), 0)
+        self.assertEqual(list(result), [])
+    
+    def test_model_multiple_choice_field_with_union_operator_empty_value(self):
+        """Test ModelMultipleChoiceField with union() operator returns empty when no value selected."""
+        queryset = Publication.objects.filter(id__lt=2).union(
+            Publication.objects.filter(id__gt=5)
+        )
+        field = ModelMultipleChoiceField(queryset=queryset, required=False)
+        
+        # Test with empty value (simulating form submission with no selections)
+        # THIS SHOULD FAIL BEFORE FIX - it returns all objects instead of none
+        result = field.clean([])
+        self.assertEqual(result.count(), 0)
+        self.assertEqual(list(result), [])
+    
+    def test_model_multiple_choice_field_with_union_operator_with_values(self):
+        """Test ModelMultipleChoiceField with union() operator works correctly with actual values."""
+        queryset = Publication.objects.filter(id__lt=2).union(
+            Publication.objects.filter(id__gt=5)
+        )
+        field = ModelMultipleChoiceField(queryset=queryset, required=False)
+        
+        # Test with actual values - this should work correctly
+        pub1 = self.publications[0]  # ID 1
+        pub6 = self.publications[5]  # ID 6
+        result = field.clean([pub1.pk, pub6.pk])
+        self.assertEqual(result.count(), 2)
+        self.assertIn(pub1, result)
+        self.assertIn(pub6, result)
+    
+    def test_model_multiple_choice_field_with_or_operator_with_values(self):
+        """Test ModelMultipleChoiceField with OR operator works correctly with actual values."""
+        queryset = Publication.objects.filter(id__lt=2) | Publication.objects.filter(id__gt=5)
+        field = ModelMultipleChoiceField(queryset=queryset, required=False)
+        
+        # Test with actual values - this should work correctly
+        pub1 = self.publications[0]  # ID 1
+        pub6 = self.publications[5]  # ID 6
+        result = field.clean([pub1.pk, pub6.pk])
+        self.assertEqual(result.count(), 2)
+        self.assertIn(pub1, result)
+        self.assertIn(pub6, result)
+    
+    def test_queryset_none_with_intersection_operator(self):
+        """Test that queryset.none() works correctly with intersection() operator."""
+        # Create a queryset using intersection operator
+        queryset = Publication.objects.filter(id__lt=5).intersection(
+            Publication.objects.filter(id__gt=2)
+        )
+        
+        # Verify the queryset has the expected objects (IDs 3, 4)
+        self.assertEqual(queryset.count(), 2)
+        
+        # Test that none() returns empty queryset
+        none_qs = queryset.none()
+        self.assertEqual(none_qs.count(), 0)
+        self.assertEqual(list(none_qs), [])
+    
+    def test_queryset_none_with_difference_operator(self):
+        """Test that queryset.none() works correctly with difference() operator."""
+        # Create a queryset using difference operator
+        queryset = Publication.objects.filter(id__lt=5).difference(
+            Publication.objects.filter(id__gt=2)
+        )
+        
+        # Verify the queryset has the expected objects (IDs 1, 2)
+        self.assertEqual(queryset.count(), 2)
+        
+        # Test that none() returns empty queryset
+        none_qs = queryset.none()
+        self.assertEqual(none_qs.count(), 0)
+        self.assertEqual(list(none_qs), [])
+    
+    def test_queryset_none_chained_operations_with_union(self):
+        """Test that queryset.none() works with chained operations after union."""
+        # Create a queryset using union and then apply additional operations
+        queryset = Publication.objects.filter(id__lt=2).union(
+            Publication.objects.filter(id__gt=5)
+        ).filter(name__icontains='Publication')
+        
+        # Verify the queryset has the expected objects
+        self.assertEqual(queryset.count(), 6)
+        
+        # Test that none() returns empty queryset
+        none_qs = queryset.none()
+        self.assertEqual(none_qs.count(), 0)
+        self.assertEqual(list(none_qs), [])
+    
+    def test_queryset_none_preserves_model_type(self):
+        """Test that queryset.none() preserves the model type for combined queries."""
+        # Test with union
+        queryset = Publication.objects.filter(id__lt=2).union(
+            Publication.objects.filter(id__gt=5)
+        )
+        none_qs = queryset.none()
+        
+        # The none queryset should still be for the Publication model
+        self.assertEqual(none_qs.model, Publication)
+        
+        # Should be able to perform model-specific operations
+        self.assertEqual(none_qs.filter(name__icontains='test').count(), 0)
+    
+    def test_multiple_union_operations_with_none(self):
+        """Test queryset.none() with multiple union operations."""
+        queryset = Publication.objects.filter(id=1).union(
+            Publication.objects.filter(id=2)
+        ).union(
+            Publication.objects.filter(id=3)
+        )
+        
+        # Verify the queryset has the expected objects
+        self.assertEqual(queryset.count(), 3)
+        
+        # Test that none() returns empty queryset
+        none_qs = queryset.none()
+        self.assertEqual(none_qs.count(), 0)
+        self.assertEqual(list(none_qs), [])
