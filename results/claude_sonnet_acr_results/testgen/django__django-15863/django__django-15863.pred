{
  "instance_id": "django__django-15863",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/template_tests/filter_tests/test_floatformat.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom decimal import Decimal\nfrom django.template import Context, Template\nfrom django.template.defaultfilters import floatformat\nfrom django.test import SimpleTestCase\n\n\nclass FloatformatDecimalTests(SimpleTestCase):\n    \"\"\"Test floatformat filter with Decimal inputs to ensure precision is preserved.\"\"\"\n\n    def test_floatformat_decimal_high_precision_reproduces_bug(self):\n        \"\"\"\n        Test that demonstrates the bug where floatformat drops precision \n        with Decimal numbers. This test should fail before the fix.\n        \"\"\"\n        # This is the exact example from the issue\n        decimal_value = Decimal('42.12345678901234567890')\n        result = floatformat(decimal_value, 20)\n        \n        # Before fix: this will be '42.12345678901234400000' (precision lost)\n        # After fix: this should be '42.12345678901234567890' (precision preserved)\n        expected = '42.12345678901234567890'\n        self.assertEqual(result, expected, \n                        \"floatformat should preserve full Decimal precision\")\n\n    def test_floatformat_decimal_template_filter_reproduces_bug(self):\n        \"\"\"\n        Test the bug using template syntax as shown in the issue.\n        This test should fail before the fix.\n        \"\"\"\n        template = Template('{{ value|floatformat:20 }}')\n        context = Context({'value': Decimal('42.12345678901234567890')})\n        result = template.render(context)\n        \n        # Before fix: this will be '42.12345678901234400000' (precision lost)\n        # After fix: this should be '42.12345678901234567890' (precision preserved)\n        expected = '42.12345678901234567890'\n        self.assertEqual(result, expected,\n                        \"Template floatformat should preserve full Decimal precision\")\n\n    def test_floatformat_decimal_various_precisions(self):\n        \"\"\"Test floatformat with Decimal inputs at various precision levels.\"\"\"\n        decimal_value = Decimal('123.456789012345678901234567890')\n        \n        # Test different precision arguments\n        test_cases = [\n            (5, '123.45679'),\n            (10, '123.4567890123'),\n            (15, '123.456789012345679'),\n            (25, '123.4567890123456789012345679'),\n        ]\n        \n        for precision, expected in test_cases:\n            with self.subTest(precision=precision):\n                result = floatformat(decimal_value, precision)\n                self.assertEqual(result, expected,\n                               f\"Decimal precision {precision} should be preserved\")\n\n    def test_floatformat_decimal_negative_precision(self):\n        \"\"\"Test floatformat with Decimal inputs using negative precision.\"\"\"\n        # Negative precision means \"only show decimals if needed\"\n        test_cases = [\n            (Decimal('123.000'), -3, '123'),\n            (Decimal('123.100'), -3, '123.1'),\n            (Decimal('123.456'), -3, '123.456'),\n            (Decimal('123.456789'), -3, '123.457'),  # Rounded to 3 places\n        ]\n        \n        for decimal_value, precision, expected in test_cases:\n            with self.subTest(value=decimal_value, precision=precision):\n                result = floatformat(decimal_value, precision)\n                self.assertEqual(result, expected)\n\n    def test_floatformat_decimal_zero_precision(self):\n        \"\"\"Test floatformat with Decimal inputs using zero precision.\"\"\"\n        test_cases = [\n            (Decimal('123.456'), 0, '123'),\n            (Decimal('123.789'), 0, '124'),  # Rounded\n            (Decimal('123.000'), 0, '123'),\n        ]\n        \n        for decimal_value, precision, expected in test_cases:\n            with self.subTest(value=decimal_value, precision=precision):\n                result = floatformat(decimal_value, precision)\n                self.assertEqual(result, expected)\n\n    def test_floatformat_decimal_edge_cases(self):\n        \"\"\"Test floatformat with Decimal edge cases.\"\"\"\n        test_cases = [\n            # Very small decimals\n            (Decimal('0.000000000000000001'), 20, '0.00000000000000000100'),\n            # Very large decimals\n            (Decimal('999999999999999999.123456789'), 10, '999999999999999999.1234567890'),\n            # Zero\n            (Decimal('0'), 5, '0.00000'),\n            (Decimal('0.0'), 5, '0.00000'),\n            # Negative decimals\n            (Decimal('-123.456789'), 6, '-123.456789'),\n        ]\n        \n        for decimal_value, precision, expected in test_cases:\n            with self.subTest(value=decimal_value, precision=precision):\n                result = floatformat(decimal_value, precision)\n                self.assertEqual(result, expected)\n\n    def test_floatformat_decimal_vs_float_precision_difference(self):\n        \"\"\"\n        Test that demonstrates the precision difference between Decimal and float inputs.\n        This shows why the bug matters.\n        \"\"\"\n        # Same numeric value as Decimal and float\n        decimal_value = Decimal('0.1234567890123456789')\n        float_value = 0.1234567890123456789  # This will lose precision due to float limitations\n        \n        decimal_result = floatformat(decimal_value, 20)\n        float_result = floatformat(float_value, 20)\n        \n        # Decimal should preserve more precision than float\n        # The exact values depend on the fix, but they should be different\n        self.assertNotEqual(decimal_result, float_result,\n                           \"Decimal should preserve more precision than float\")\n\n    def test_floatformat_backward_compatibility_non_decimal(self):\n        \"\"\"Test that the fix doesn't break existing functionality for non-Decimal inputs.\"\"\"\n        # Test with various non-Decimal types to ensure backward compatibility\n        test_cases = [\n            # Integers\n            (42, 2, '42.00'),\n            (0, 3, '0.000'),\n            \n            # Floats\n            (42.123, 2, '42.12'),\n            (42.789, 2, '42.79'),\n            \n            # String representations\n            ('42.123', 2, '42.12'),\n            ('0.456', 3, '0.456'),\n            \n            # Edge cases\n            (float('inf'), 2, 'inf'),\n            (float('-inf'), 2, '-inf'),\n        ]\n        \n        for value, precision, expected in test_cases:\n            with self.subTest(value=value, precision=precision, type=type(value).__name__):\n                result = floatformat(value, precision)\n                self.assertEqual(result, expected)\n\n    def test_floatformat_decimal_with_grouping_and_localization(self):\n        \"\"\"Test that Decimal precision is preserved with grouping and localization options.\"\"\"\n        decimal_value = Decimal('1234567.89012345678901234567890')\n        \n        # Test with grouping suffix 'g'\n        result_g = floatformat(decimal_value, '10g')\n        # Should preserve precision and add grouping\n        self.assertIn('1,234,567.8901234568', result_g)\n        \n        # Test with unlocalized suffix 'u'  \n        result_u = floatformat(decimal_value, '10u')\n        # Should preserve precision without localization\n        self.assertEqual(result_u, '1234567.8901234568')\n        \n        # Test with both suffixes 'gu'\n        result_gu = floatformat(decimal_value, '10gu')\n        self.assertIn('1,234,567.8901234568', result_gu)\n\n    def test_floatformat_decimal_invalid_inputs(self):\n        \"\"\"Test floatformat behavior with invalid Decimal-related inputs.\"\"\"\n        # Test with invalid Decimal strings - should return empty string\n        result = floatformat('not_a_number', 2)\n        self.assertEqual(result, '')\n        \n        # Test with None\n        result = floatformat(None, 2)\n        self.assertEqual(result, '')\n        \n        # Test with invalid precision argument\n        decimal_value = Decimal('123.456')\n        result = floatformat(decimal_value, 'invalid')\n        # Should return the repr of the input when precision is invalid\n        self.assertIn('123.456', result)\n</patched>\n```",
  "patch": "--- a/tests/template_tests/filter_tests/test_floatformat.py\n+++ b/tests/template_tests/filter_tests/test_floatformat.py\n-# Empty if creating new file\n+import pytest\n+from decimal import Decimal\n+from django.template import Context, Template\n+from django.template.defaultfilters import floatformat\n+from django.test import SimpleTestCase\n+\n+\n+class FloatformatDecimalTests(SimpleTestCase):\n+    \"\"\"Test floatformat filter with Decimal inputs to ensure precision is preserved.\"\"\"\n+\n+    def test_floatformat_decimal_high_precision_reproduces_bug(self):\n+        \"\"\"\n+        Test that demonstrates the bug where floatformat drops precision \n+        with Decimal numbers. This test should fail before the fix.\n+        \"\"\"\n+        # This is the exact example from the issue\n+        decimal_value = Decimal('42.12345678901234567890')\n+        result = floatformat(decimal_value, 20)\n+        \n+        # Before fix: this will be '42.12345678901234400000' (precision lost)\n+        # After fix: this should be '42.12345678901234567890' (precision preserved)\n+        expected = '42.12345678901234567890'\n+        self.assertEqual(result, expected, \n+                        \"floatformat should preserve full Decimal precision\")\n+\n+    def test_floatformat_decimal_template_filter_reproduces_bug(self):\n+        \"\"\"\n+        Test the bug using template syntax as shown in the issue.\n+        This test should fail before the fix.\n+        \"\"\"\n+        template = Template('{{ value|floatformat:20 }}')\n+        context = Context({'value': Decimal('42.12345678901234567890')})\n+        result = template.render(context)\n+        \n+        # Before fix: this will be '42.12345678901234400000' (precision lost)\n+        # After fix: this should be '42.12345678901234567890' (precision preserved)\n+        expected = '42.12345678901234567890'\n+        self.assertEqual(result, expected,\n+                        \"Template floatformat should preserve full Decimal precision\")\n+\n+    def test_floatformat_decimal_various_precisions(self):\n+        \"\"\"Test floatformat with Decimal inputs at various precision levels.\"\"\"\n+        decimal_value = Decimal('123.456789012345678901234567890')\n+        \n+        # Test different precision arguments\n+        test_cases = [\n+            (5, '123.45679'),\n+            (10, '123.4567890123'),\n+            (15, '123.456789012345679'),\n+            (25, '123.4567890123456789012345679'),\n+        ]\n+        \n+        for precision, expected in test_cases:\n+            with self.subTest(precision=precision):\n+                result = floatformat(decimal_value, precision)\n+                self.assertEqual(result, expected,\n+                               f\"Decimal precision {precision} should be preserved\")\n+\n+    def test_floatformat_decimal_negative_precision(self):\n+        \"\"\"Test floatformat with Decimal inputs using negative precision.\"\"\"\n+        # Negative precision means \"only show decimals if needed\"\n+        test_cases = [\n+            (Decimal('123.000'), -3, '123'),\n+            (Decimal('123.100'), -3, '123.1'),\n+            (Decimal('123.456'), -3, '123.456'),\n+            (Decimal('123.456789'), -3, '123.457'),  # Rounded to 3 places\n+        ]\n+        \n+        for decimal_value, precision, expected in test_cases:\n+            with self.subTest(value=decimal_value, precision=precision):\n+                result = floatformat(decimal_value, precision)\n+                self.assertEqual(result, expected)\n+\n+    def test_floatformat_decimal_zero_precision(self):\n+        \"\"\"Test floatformat with Decimal inputs using zero precision.\"\"\"\n+        test_cases = [\n+            (Decimal('123.456'), 0, '123'),\n+            (Decimal('123.789'), 0, '124'),  # Rounded\n+            (Decimal('123.000'), 0, '123'),\n+        ]\n+        \n+        for decimal_value, precision, expected in test_cases:\n+            with self.subTest(value=decimal_value, precision=precision):\n+                result = floatformat(decimal_value, precision)\n+                self.assertEqual(result, expected)\n+\n+    def test_floatformat_decimal_edge_cases(self):\n+        \"\"\"Test floatformat with Decimal edge cases.\"\"\"\n+        test_cases = [\n+            # Very small decimals\n+            (Decimal('0.000000000000000001'), 20, '0.00000000000000000100'),\n+            # Very large decimals\n+            (Decimal('999999999999999999.123456789'), 10, '999999999999999999.1234567890'),\n+            # Zero\n+            (Decimal('0'), 5, '0.00000'),\n+            (Decimal('0.0'), 5, '0.00000'),\n+            # Negative decimals\n+            (Decimal('-123.456789'), 6, '-123.456789'),\n+        ]\n+        \n+        for decimal_value, precision, expected in test_cases:\n+            with self.subTest(value=decimal_value, precision=precision):\n+                result = floatformat(decimal_value, precision)\n+                self.assertEqual(result, expected)\n+\n+    def test_floatformat_decimal_vs_float_precision_difference(self):\n+        \"\"\"\n+        Test that demonstrates the precision difference between Decimal and float inputs.\n+        This shows why the bug matters.\n+        \"\"\"\n+        # Same numeric value as Decimal and float\n+        decimal_value = Decimal('0.1234567890123456789')\n+        float_value = 0.1234567890123456789  # This will lose precision due to float limitations\n+        \n+        decimal_result = floatformat(decimal_value, 20)\n+        float_result = floatformat(float_value, 20)\n+        \n+        # Decimal should preserve more precision than float\n+        # The exact values depend on the fix, but they should be different\n+        self.assertNotEqual(decimal_result, float_result,\n+                           \"Decimal should preserve more precision than float\")\n+\n+    def test_floatformat_backward_compatibility_non_decimal(self):\n+        \"\"\"Test that the fix doesn't break existing functionality for non-Decimal inputs.\"\"\"\n+        # Test with various non-Decimal types to ensure backward compatibility\n+        test_cases = [\n+            # Integers\n+            (42, 2, '42.00'),\n+            (0, 3, '0.000'),\n+            \n+            # Floats\n+            (42.123, 2, '42.12'),\n+            (42.789, 2, '42.79'),\n+            \n+            # String representations\n+            ('42.123', 2, '42.12'),\n+            ('0.456', 3, '0.456'),\n+            \n+            # Edge cases\n+            (float('inf'), 2, 'inf'),\n+            (float('-inf'), 2, '-inf'),\n+        ]\n+        \n+        for value, precision, expected in test_cases:\n+            with self.subTest(value=value, precision=precision, type=type(value).__name__):\n+                result = floatformat(value, precision)\n+                self.assertEqual(result, expected)\n+\n+    def test_floatformat_decimal_with_grouping_and_localization(self):\n+        \"\"\"Test that Decimal precision is preserved with grouping and localization options.\"\"\"\n+        decimal_value = Decimal('1234567.89012345678901234567890')\n+        \n+        # Test with grouping suffix 'g'\n+        result_g = floatformat(decimal_value, '10g')\n+        # Should preserve precision and add grouping\n+        self.assertIn('1,234,567.8901234568', result_g)\n+        \n+        # Test with unlocalized suffix 'u'  \n+        result_u = floatformat(decimal_value, '10u')\n+        # Should preserve precision without localization\n+        self.assertEqual(result_u, '1234567.8901234568')\n+        \n+        # Test with both suffixes 'gu'\n+        result_gu = floatformat(decimal_value, '10gu')\n+        self.assertIn('1,234,567.8901234568', result_gu)\n+\n+    def test_floatformat_decimal_invalid_inputs(self):\n+        \"\"\"Test floatformat behavior with invalid Decimal-related inputs.\"\"\"\n+        # Test with invalid Decimal strings - should return empty string\n+        result = floatformat('not_a_number', 2)\n+        self.assertEqual(result, '')\n+        \n+        # Test with None\n+        result = floatformat(None, 2)\n+        self.assertEqual(result, '')\n+        \n+        # Test with invalid precision argument\n+        decimal_value = Decimal('123.456')\n+        result = floatformat(decimal_value, 'invalid')\n+        # Should return the repr of the input when precision is invalid\n+        self.assertIn('123.456', result)\n"
}