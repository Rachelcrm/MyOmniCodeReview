{
  "instance_id": "sphinx-doc__sphinx-10449",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_ext_autodoc_typehints.py</file>\n<original>\n</original>\n<patched>\n\"\"\"Test autodoc typehints functionality.\"\"\"\n\nimport pytest\nfrom docutils import nodes\nfrom docutils.parsers.rst import directives\n\nfrom sphinx import addnodes\nfrom sphinx.ext.autodoc import ClassDocumenter\nfrom sphinx.ext.autodoc.typehints import record_typehints, merge_typehints\nfrom sphinx.util.docutils import docutils_namespace\n\n\n@pytest.fixture\ndef sample_class():\n    \"\"\"Sample class for testing.\"\"\"\n    class Square:\n        \"\"\"A class representing a square figure.\"\"\"\n\n        def __init__(self, width: int, height: int) -> None:\n            self.width = width\n            self.height = height\n\n        def area(self) -> int:\n            \"\"\"Calculate the area of the square.\"\"\"\n            return self.width * self.height\n\n    return Square\n\n\n@pytest.fixture\ndef sample_function():\n    \"\"\"Sample function for testing.\"\"\"\n    def calculate_area(width: int, height: int) -> int:\n        \"\"\"Calculate area of a rectangle.\"\"\"\n        return width * height\n\n    return calculate_area\n\n\ndef test_record_typehints_class_no_return_type(app, sample_class):\n    \"\"\"Test that record_typehints does not record return type for classes.\"\"\"\n    # Configure autodoc_typehints to description mode\n    app.config.autodoc_typehints = 'description'\n    app.config.autodoc_typehints_format = 'short'\n    \n    # Clear any existing annotations\n    app.env.temp_data.pop('annotations', None)\n    \n    # Record typehints for the class\n    record_typehints(app, 'class', 'Square', sample_class, {}, '', '')\n    \n    # Check that annotations were recorded\n    annotations = app.env.temp_data.get('annotations', {})\n    assert 'Square' in annotations\n    \n    # Check that return type was NOT recorded for the class\n    class_annotations = annotations['Square']\n    assert 'return' not in class_annotations\n    \n    # Check that parameter types were recorded for __init__\n    assert 'width' in class_annotations\n    assert 'height' in class_annotations\n    assert class_annotations['width'] == 'int'\n    assert class_annotations['height'] == 'int'\n\n\ndef test_record_typehints_function_with_return_type(app, sample_function):\n    \"\"\"Test that record_typehints records return type for functions.\"\"\"\n    # Configure autodoc_typehints to description mode\n    app.config.autodoc_typehints = 'description'\n    app.config.autodoc_typehints_format = 'short'\n    \n    # Clear any existing annotations\n    app.env.temp_data.pop('annotations', None)\n    \n    # Record typehints for the function\n    record_typehints(app, 'function', 'calculate_area', sample_function, {}, '', '')\n    \n    # Check that annotations were recorded\n    annotations = app.env.temp_data.get('annotations', {})\n    assert 'calculate_area' in annotations\n    \n    # Check that return type WAS recorded for the function\n    func_annotations = annotations['calculate_area']\n    assert 'return' in func_annotations\n    assert func_annotations['return'] == 'int'\n    \n    # Check that parameter types were also recorded\n    assert 'width' in func_annotations\n    assert 'height' in func_annotations\n    assert func_annotations['width'] == 'int'\n    assert func_annotations['height'] == 'int'\n\n\ndef test_record_typehints_method_with_return_type(app, sample_class):\n    \"\"\"Test that record_typehints records return type for methods.\"\"\"\n    # Configure autodoc_typehints to description mode\n    app.config.autodoc_typehints = 'description'\n    app.config.autodoc_typehints_format = 'short'\n    \n    # Clear any existing annotations\n    app.env.temp_data.pop('annotations', None)\n    \n    # Get the area method from the class\n    area_method = sample_class.area\n    \n    # Record typehints for the method\n    record_typehints(app, 'method', 'Square.area', area_method, {}, '', '')\n    \n    # Check that annotations were recorded\n    annotations = app.env.temp_data.get('annotations', {})\n    assert 'Square.area' in annotations\n    \n    # Check that return type WAS recorded for the method\n    method_annotations = annotations['Square.area']\n    assert 'return' in method_annotations\n    assert method_annotations['return'] == 'int'\n\n\ndef test_record_typehints_class_with_signature_mode(app, sample_class):\n    \"\"\"Test that record_typehints works normally when autodoc_typehints is 'signature'.\"\"\"\n    # Configure autodoc_typehints to signature mode (default)\n    app.config.autodoc_typehints = 'signature'\n    app.config.autodoc_typehints_format = 'short'\n    \n    # Clear any existing annotations\n    app.env.temp_data.pop('annotations', None)\n    \n    # Record typehints for the class\n    record_typehints(app, 'class', 'Square', sample_class, {}, '', '')\n    \n    # Check that annotations were recorded\n    annotations = app.env.temp_data.get('annotations', {})\n    assert 'Square' in annotations\n    \n    # Even in signature mode, return type should not be recorded for classes\n    class_annotations = annotations['Square']\n    assert 'return' not in class_annotations\n\n\ndef test_record_typehints_class_edge_cases(app):\n    \"\"\"Test edge cases for class typehint recording.\"\"\"\n    # Configure autodoc_typehints to description mode\n    app.config.autodoc_typehints = 'description'\n    app.config.autodoc_typehints_format = 'short'\n    \n    # Clear any existing annotations\n    app.env.temp_data.pop('annotations', None)\n    \n    # Test with a class that has no __init__ method\n    class SimpleClass:\n        \"\"\"A simple class with no __init__.\"\"\"\n        pass\n    \n    # Record typehints for the class\n    record_typehints(app, 'class', 'SimpleClass', SimpleClass, {}, '', '')\n    \n    # Check that annotations were recorded (even if empty)\n    annotations = app.env.temp_data.get('annotations', {})\n    assert 'SimpleClass' in annotations\n    \n    # Check that return type was NOT recorded\n    class_annotations = annotations['SimpleClass']\n    assert 'return' not in class_annotations\n\n\ndef test_record_typehints_non_callable_object(app):\n    \"\"\"Test that record_typehints handles non-callable objects gracefully.\"\"\"\n    # Configure autodoc_typehints to description mode\n    app.config.autodoc_typehints = 'description'\n    app.config.autodoc_typehints_format = 'short'\n    \n    # Clear any existing annotations\n    app.env.temp_data.pop('annotations', None)\n    \n    # Test with a non-callable object\n    non_callable = \"not a function or class\"\n    \n    # Record typehints for the non-callable object\n    record_typehints(app, 'data', 'some_string', non_callable, {}, '', '')\n    \n    # Check that no annotations were recorded for non-callable objects\n    annotations = app.env.temp_data.get('annotations', {})\n    assert 'some_string' not in annotations\n\n\ndef test_autoclass_with_description_typehints_integration(app, sample_class):\n    \"\"\"Integration test for autoclass with autodoc_typehints='description'.\"\"\"\n    # Configure autodoc_typehints to description mode\n    app.config.autodoc_typehints = 'description'\n    app.config.autodoc_typehints_format = 'short'\n    app.config.autodoc_typehints_description_target = 'all'\n    \n    # Clear any existing annotations\n    app.env.temp_data.pop('annotations', None)\n    \n    # Simulate the autodoc process for a class\n    # First, record typehints (this is what happens during autodoc processing)\n    record_typehints(app, 'class', 'Square', sample_class, {}, '', '')\n    \n    # Verify that no return type was recorded for the class\n    annotations = app.env.temp_data.get('annotations', {})\n    assert 'Square' in annotations\n    class_annotations = annotations['Square']\n    assert 'return' not in class_annotations\n    \n    # Verify that parameter types were recorded\n    assert 'width' in class_annotations\n    assert 'height' in class_annotations\n\n\ndef test_record_typehints_preserves_existing_functionality(app):\n    \"\"\"Test that the fix preserves existing functionality for non-class objects.\"\"\"\n    # Configure autodoc_typehints to description mode\n    app.config.autodoc_typehints = 'description'\n    app.config.autodoc_typehints_format = 'short'\n    \n    # Clear any existing annotations\n    app.env.temp_data.pop('annotations', None)\n    \n    # Test various object types to ensure they still work correctly\n    \n    # Function with return type\n    def test_func(x: int) -> str:\n        return str(x)\n    \n    record_typehints(app, 'function', 'test_func', test_func, {}, '', '')\n    \n    # Method with return type\n    class TestClass:\n        def test_method(self, x: int) -> str:\n            return str(x)\n    \n    record_typehints(app, 'method', 'TestClass.test_method', TestClass.test_method, {}, '', '')\n    \n    # Check annotations\n    annotations = app.env.temp_data.get('annotations', {})\n    \n    # Function should have return type recorded\n    assert 'test_func' in annotations\n    assert 'return' in annotations['test_func']\n    assert annotations['test_func']['return'] == 'str'\n    \n    # Method should have return type recorded\n    assert 'TestClass.test_method' in annotations\n    assert 'return' in annotations['TestClass.test_method']\n    assert annotations['TestClass.test_method']['return'] == 'str'\n\n\ndef test_record_typehints_class_with_complex_init(app):\n    \"\"\"Test class with complex __init__ signature.\"\"\"\n    # Configure autodoc_typehints to description mode\n    app.config.autodoc_typehints = 'description'\n    app.config.autodoc_typehints_format = 'short'\n    \n    # Clear any existing annotations\n    app.env.temp_data.pop('annotations', None)\n    \n    from typing import Optional, List\n    \n    class ComplexClass:\n        \"\"\"A class with complex __init__ signature.\"\"\"\n        \n        def __init__(self, name: str, values: List[int], optional: Optional[str] = None) -> None:\n            self.name = name\n            self.values = values\n            self.optional = optional\n    \n    # Record typehints for the class\n    record_typehints(app, 'class', 'ComplexClass', ComplexClass, {}, '', '')\n    \n    # Check that annotations were recorded\n    annotations = app.env.temp_data.get('annotations', {})\n    assert 'ComplexClass' in annotations\n    \n    # Check that return type was NOT recorded for the class\n    class_annotations = annotations['ComplexClass']\n    assert 'return' not in class_annotations\n    \n    # Check that all parameter types were recorded correctly\n    assert 'name' in class_annotations\n    assert 'values' in class_annotations\n    assert 'optional' in class_annotations\n    assert class_annotations['name'] == 'str'\n    assert class_annotations['values'] == 'List[int]'\n    assert class_annotations['optional'] == 'Optional[str]'\n</patched>\n</file>\n```",
  "patch": "--- a/tests/test_ext_autodoc_typehints.py\n+++ b/tests/test_ext_autodoc_typehints.py\n+\"\"\"Test autodoc typehints functionality.\"\"\"\n+\n+import pytest\n+from docutils import nodes\n+from docutils.parsers.rst import directives\n+\n+from sphinx import addnodes\n+from sphinx.ext.autodoc import ClassDocumenter\n+from sphinx.ext.autodoc.typehints import record_typehints, merge_typehints\n+from sphinx.util.docutils import docutils_namespace\n+\n+\n+@pytest.fixture\n+def sample_class():\n+    \"\"\"Sample class for testing.\"\"\"\n+    class Square:\n+        \"\"\"A class representing a square figure.\"\"\"\n+\n+        def __init__(self, width: int, height: int) -> None:\n+            self.width = width\n+            self.height = height\n+\n+        def area(self) -> int:\n+            \"\"\"Calculate the area of the square.\"\"\"\n+            return self.width * self.height\n+\n+    return Square\n+\n+\n+@pytest.fixture\n+def sample_function():\n+    \"\"\"Sample function for testing.\"\"\"\n+    def calculate_area(width: int, height: int) -> int:\n+        \"\"\"Calculate area of a rectangle.\"\"\"\n+        return width * height\n+\n+    return calculate_area\n+\n+\n+def test_record_typehints_class_no_return_type(app, sample_class):\n+    \"\"\"Test that record_typehints does not record return type for classes.\"\"\"\n+    # Configure autodoc_typehints to description mode\n+    app.config.autodoc_typehints = 'description'\n+    app.config.autodoc_typehints_format = 'short'\n+    \n+    # Clear any existing annotations\n+    app.env.temp_data.pop('annotations', None)\n+    \n+    # Record typehints for the class\n+    record_typehints(app, 'class', 'Square', sample_class, {}, '', '')\n+    \n+    # Check that annotations were recorded\n+    annotations = app.env.temp_data.get('annotations', {})\n+    assert 'Square' in annotations\n+    \n+    # Check that return type was NOT recorded for the class\n+    class_annotations = annotations['Square']\n+    assert 'return' not in class_annotations\n+    \n+    # Check that parameter types were recorded for __init__\n+    assert 'width' in class_annotations\n+    assert 'height' in class_annotations\n+    assert class_annotations['width'] == 'int'\n+    assert class_annotations['height'] == 'int'\n+\n+\n+def test_record_typehints_function_with_return_type(app, sample_function):\n+    \"\"\"Test that record_typehints records return type for functions.\"\"\"\n+    # Configure autodoc_typehints to description mode\n+    app.config.autodoc_typehints = 'description'\n+    app.config.autodoc_typehints_format = 'short'\n+    \n+    # Clear any existing annotations\n+    app.env.temp_data.pop('annotations', None)\n+    \n+    # Record typehints for the function\n+    record_typehints(app, 'function', 'calculate_area', sample_function, {}, '', '')\n+    \n+    # Check that annotations were recorded\n+    annotations = app.env.temp_data.get('annotations', {})\n+    assert 'calculate_area' in annotations\n+    \n+    # Check that return type WAS recorded for the function\n+    func_annotations = annotations['calculate_area']\n+    assert 'return' in func_annotations\n+    assert func_annotations['return'] == 'int'\n+    \n+    # Check that parameter types were also recorded\n+    assert 'width' in func_annotations\n+    assert 'height' in func_annotations\n+    assert func_annotations['width'] == 'int'\n+    assert func_annotations['height'] == 'int'\n+\n+\n+def test_record_typehints_method_with_return_type(app, sample_class):\n+    \"\"\"Test that record_typehints records return type for methods.\"\"\"\n+    # Configure autodoc_typehints to description mode\n+    app.config.autodoc_typehints = 'description'\n+    app.config.autodoc_typehints_format = 'short'\n+    \n+    # Clear any existing annotations\n+    app.env.temp_data.pop('annotations', None)\n+    \n+    # Get the area method from the class\n+    area_method = sample_class.area\n+    \n+    # Record typehints for the method\n+    record_typehints(app, 'method', 'Square.area', area_method, {}, '', '')\n+    \n+    # Check that annotations were recorded\n+    annotations = app.env.temp_data.get('annotations', {})\n+    assert 'Square.area' in annotations\n+    \n+    # Check that return type WAS recorded for the method\n+    method_annotations = annotations['Square.area']\n+    assert 'return' in method_annotations\n+    assert method_annotations['return'] == 'int'\n+\n+\n+def test_record_typehints_class_with_signature_mode(app, sample_class):\n+    \"\"\"Test that record_typehints works normally when autodoc_typehints is 'signature'.\"\"\"\n+    # Configure autodoc_typehints to signature mode (default)\n+    app.config.autodoc_typehints = 'signature'\n+    app.config.autodoc_typehints_format = 'short'\n+    \n+    # Clear any existing annotations\n+    app.env.temp_data.pop('annotations', None)\n+    \n+    # Record typehints for the class\n+    record_typehints(app, 'class', 'Square', sample_class, {}, '', '')\n+    \n+    # Check that annotations were recorded\n+    annotations = app.env.temp_data.get('annotations', {})\n+    assert 'Square' in annotations\n+    \n+    # Even in signature mode, return type should not be recorded for classes\n+    class_annotations = annotations['Square']\n+    assert 'return' not in class_annotations\n+\n+\n+def test_record_typehints_class_edge_cases(app):\n+    \"\"\"Test edge cases for class typehint recording.\"\"\"\n+    # Configure autodoc_typehints to description mode\n+    app.config.autodoc_typehints = 'description'\n+    app.config.autodoc_typehints_format = 'short'\n+    \n+    # Clear any existing annotations\n+    app.env.temp_data.pop('annotations', None)\n+    \n+    # Test with a class that has no __init__ method\n+    class SimpleClass:\n+        \"\"\"A simple class with no __init__.\"\"\"\n+        pass\n+    \n+    # Record typehints for the class\n+    record_typehints(app, 'class', 'SimpleClass', SimpleClass, {}, '', '')\n+    \n+    # Check that annotations were recorded (even if empty)\n+    annotations = app.env.temp_data.get('annotations', {})\n+    assert 'SimpleClass' in annotations\n+    \n+    # Check that return type was NOT recorded\n+    class_annotations = annotations['SimpleClass']\n+    assert 'return' not in class_annotations\n+\n+\n+def test_record_typehints_non_callable_object(app):\n+    \"\"\"Test that record_typehints handles non-callable objects gracefully.\"\"\"\n+    # Configure autodoc_typehints to description mode\n+    app.config.autodoc_typehints = 'description'\n+    app.config.autodoc_typehints_format = 'short'\n+    \n+    # Clear any existing annotations\n+    app.env.temp_data.pop('annotations', None)\n+    \n+    # Test with a non-callable object\n+    non_callable = \"not a function or class\"\n+    \n+    # Record typehints for the non-callable object\n+    record_typehints(app, 'data', 'some_string', non_callable, {}, '', '')\n+    \n+    # Check that no annotations were recorded for non-callable objects\n+    annotations = app.env.temp_data.get('annotations', {})\n+    assert 'some_string' not in annotations\n+\n+\n+def test_autoclass_with_description_typehints_integration(app, sample_class):\n+    \"\"\"Integration test for autoclass with autodoc_typehints='description'.\"\"\"\n+    # Configure autodoc_typehints to description mode\n+    app.config.autodoc_typehints = 'description'\n+    app.config.autodoc_typehints_format = 'short'\n+    app.config.autodoc_typehints_description_target = 'all'\n+    \n+    # Clear any existing annotations\n+    app.env.temp_data.pop('annotations', None)\n+    \n+    # Simulate the autodoc process for a class\n+    # First, record typehints (this is what happens during autodoc processing)\n+    record_typehints(app, 'class', 'Square', sample_class, {}, '', '')\n+    \n+    # Verify that no return type was recorded for the class\n+    annotations = app.env.temp_data.get('annotations', {})\n+    assert 'Square' in annotations\n+    class_annotations = annotations['Square']\n+    assert 'return' not in class_annotations\n+    \n+    # Verify that parameter types were recorded\n+    assert 'width' in class_annotations\n+    assert 'height' in class_annotations\n+\n+\n+def test_record_typehints_preserves_existing_functionality(app):\n+    \"\"\"Test that the fix preserves existing functionality for non-class objects.\"\"\"\n+    # Configure autodoc_typehints to description mode\n+    app.config.autodoc_typehints = 'description'\n+    app.config.autodoc_typehints_format = 'short'\n+    \n+    # Clear any existing annotations\n+    app.env.temp_data.pop('annotations', None)\n+    \n+    # Test various object types to ensure they still work correctly\n+    \n+    # Function with return type\n+    def test_func(x: int) -> str:\n+        return str(x)\n+    \n+    record_typehints(app, 'function', 'test_func', test_func, {}, '', '')\n+    \n+    # Method with return type\n+    class TestClass:\n+        def test_method(self, x: int) -> str:\n+            return str(x)\n+    \n+    record_typehints(app, 'method', 'TestClass.test_method', TestClass.test_method, {}, '', '')\n+    \n+    # Check annotations\n+    annotations = app.env.temp_data.get('annotations', {})\n+    \n+    # Function should have return type recorded\n+    assert 'test_func' in annotations\n+    assert 'return' in annotations['test_func']\n+    assert annotations['test_func']['return'] == 'str'\n+    \n+    # Method should have return type recorded\n+    assert 'TestClass.test_method' in annotations\n+    assert 'return' in annotations['TestClass.test_method']\n+    assert annotations['TestClass.test_method']['return'] == 'str'\n+\n+\n+def test_record_typehints_class_with_complex_init(app):\n+    \"\"\"Test class with complex __init__ signature.\"\"\"\n+    # Configure autodoc_typehints to description mode\n+    app.config.autodoc_typehints = 'description'\n+    app.config.autodoc_typehints_format = 'short'\n+    \n+    # Clear any existing annotations\n+    app.env.temp_data.pop('annotations', None)\n+    \n+    from typing import Optional, List\n+    \n+    class ComplexClass:\n+        \"\"\"A class with complex __init__ signature.\"\"\"\n+        \n+        def __init__(self, name: str, values: List[int], optional: Optional[str] = None) -> None:\n+            self.name = name\n+            self.values = values\n+            self.optional = optional\n+    \n+    # Record typehints for the class\n+    record_typehints(app, 'class', 'ComplexClass', ComplexClass, {}, '', '')\n+    \n+    # Check that annotations were recorded\n+    annotations = app.env.temp_data.get('annotations', {})\n+    assert 'ComplexClass' in annotations\n+    \n+    # Check that return type was NOT recorded for the class\n+    class_annotations = annotations['ComplexClass']\n+    assert 'return' not in class_annotations\n+    \n+    # Check that all parameter types were recorded correctly\n+    assert 'name' in class_annotations\n+    assert 'values' in class_annotations\n+    assert 'optional' in class_annotations\n+    assert class_annotations['name'] == 'str'\n+    assert class_annotations['values'] == 'List[int]'\n+    assert class_annotations['optional'] == 'Optional[str]'\n"
}