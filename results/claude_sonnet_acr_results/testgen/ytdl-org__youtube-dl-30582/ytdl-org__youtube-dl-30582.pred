{
  "instance_id": "ytdl-org__youtube-dl-30582",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>test/test_youtube_throttling.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nimport re\nfrom unittest.mock import Mock, patch, MagicMock\nfrom youtube_dl.extractor.youtube import YoutubeIE\nfrom youtube_dl.utils import ExtractorError\n\n\nclass TestYouTubeThrottling:\n    \"\"\"Test suite for YouTube throttling/n-parameter functionality.\"\"\"\n    \n    @pytest.fixture\n    def youtube_ie(self):\n        \"\"\"Create a YoutubeIE instance for testing.\"\"\"\n        ie = YoutubeIE()\n        ie._downloader = Mock()\n        ie._downloader.params = {}\n        ie._downloader.cache = Mock()\n        ie._downloader.cache.load = Mock(return_value=None)\n        ie._downloader.cache.store = Mock()\n        ie._player_cache = {}\n        return ie\n    \n    @pytest.fixture\n    def mock_player_code_old(self):\n        \"\"\"Mock old-style YouTube player code that should work.\"\"\"\n        return '''\n        var a = function(b) {\n            return b.split('').reverse().join('');\n        };\n        if (c.get(\"n\")) && (b = xyz(c)) {\n            // old pattern that works\n        }\n        '''\n    \n    @pytest.fixture\n    def mock_player_code_new(self):\n        \"\"\"Mock new-style YouTube player code that fails with current regex.\"\"\"\n        return '''\n        var a = function(b) {\n            return b.split('').reverse().join('');\n        };\n        if (c.get(\"n\")) && (b = abc123(c.get(\"n\"))) {\n            // new pattern that current regex doesn't match\n        }\n        '''\n    \n    @pytest.fixture\n    def mock_player_code_alternative(self):\n        \"\"\"Mock alternative YouTube player code pattern.\"\"\"\n        return '''\n        var a = function(b) {\n            return b.split('').reverse().join('');\n        };\n        c.get(\"n\")&&(d=def456(c.get(\"n\")),c.set(\"n\",d))\n        '''\n\n    def test_extract_n_function_name_current_pattern(self, youtube_ie):\n        \"\"\"Test that _extract_n_function_name works with current pattern.\"\"\"\n        jscode = 'if(c.get(\"n\"))&&(b=xyz(a)){return b;}'\n        \n        result = youtube_ie._extract_n_function_name(jscode)\n        assert result == 'xyz'\n    \n    def test_extract_n_function_name_fails_with_new_pattern(self, youtube_ie):\n        \"\"\"Test that current implementation fails with new YouTube patterns.\"\"\"\n        # This test demonstrates the bug - new patterns aren't matched\n        jscode = 'if(c.get(\"n\"))&&(b=abc123(c.get(\"n\"))){return b;}'\n        \n        with pytest.raises(ExtractorError):\n            youtube_ie._extract_n_function_name(jscode)\n    \n    def test_extract_n_function_name_should_handle_multiple_patterns(self, youtube_ie):\n        \"\"\"Test that _extract_n_function_name should handle multiple patterns.\"\"\"\n        # This test shows what the intended behavior should be\n        test_cases = [\n            ('if(c.get(\"n\"))&&(b=xyz(a)){return b;}', 'xyz'),\n            ('c.get(\"n\")&&(d=abc123(c.get(\"n\")),c.set(\"n\",d))', 'abc123'),\n            ('var n=c.get(\"n\");if(n){b=def456(n);c.set(\"n\",b)}', 'def456'),\n            ('.get(\"n\"))&&(b=ghi789([a-zA-Z0-9])', 'ghi789'),\n        ]\n        \n        # Current implementation will fail on most of these\n        # This test documents the expected behavior after fix\n        for jscode, expected in test_cases:\n            try:\n                result = youtube_ie._extract_n_function_name(jscode)\n                # If it works, verify it's correct\n                assert result == expected\n            except ExtractorError:\n                # Expected to fail with current implementation\n                # After fix, this should pass\n                pass\n    \n    def test_n_descramble_handles_extraction_failure(self, youtube_ie):\n        \"\"\"Test that _n_descramble handles n-function extraction failures gracefully.\"\"\"\n        n_param = \"test_n_param\"\n        player_url = \"https://www.youtube.com/s/player/test.js\"\n        video_id = \"test_video_id\"\n        \n        # Mock _extract_n_function to raise an exception\n        with patch.object(youtube_ie, '_extract_n_function', side_effect=Exception(\"Extraction failed\")):\n            # Current implementation raises ExtractorError, causing download failure\n            with pytest.raises(ExtractorError):\n                youtube_ie._n_descramble(n_param, player_url, video_id)\n    \n    def test_n_descramble_should_retry_on_failure(self, youtube_ie):\n        \"\"\"Test that _n_descramble should implement retry logic.\"\"\"\n        n_param = \"test_n_param\"\n        player_url = \"https://www.youtube.com/s/player/test.js\"\n        video_id = \"test_video_id\"\n        \n        # This test documents intended behavior - should retry and recover\n        # Current implementation doesn't do this, causing the 50kb/s issue\n        \n        call_count = 0\n        def mock_extract_n_function(vid, url):\n            nonlocal call_count\n            call_count += 1\n            if call_count == 1:\n                raise Exception(\"First attempt fails\")\n            # Second attempt should succeed\n            return lambda x: x + \"_transformed\"\n        \n        with patch.object(youtube_ie, '_extract_n_function', side_effect=mock_extract_n_function):\n            # After fix, this should retry and succeed instead of failing\n            try:\n                result = youtube_ie._n_descramble(n_param, player_url, video_id)\n                # Should eventually succeed with retry logic\n                assert result == n_param + \"_transformed\"\n            except ExtractorError:\n                # Current implementation fails here - this is the bug\n                pass\n    \n    def test_n_descramble_caching_behavior(self, youtube_ie):\n        \"\"\"Test n-parameter caching behavior.\"\"\"\n        n_param = \"test_n_param\"\n        player_url = \"https://www.youtube.com/s/player/test.js\"\n        video_id = \"test_video_id\"\n        \n        # Mock successful function\n        mock_func = Mock(return_value=\"transformed_\" + n_param)\n        \n        with patch.object(youtube_ie, '_extract_n_function', return_value=mock_func):\n            # First call should extract and cache\n            result1 = youtube_ie._n_descramble(n_param, player_url, video_id)\n            \n            # Second call should use cache\n            result2 = youtube_ie._n_descramble(n_param, player_url, video_id)\n            \n            assert result1 == result2 == \"transformed_\" + n_param\n            \n            # Should have cached both the function and the result\n            assert ('nsig', player_url) in youtube_ie._player_cache\n            assert ('nsig_value', n_param) in youtube_ie._player_cache\n    \n    def test_unthrottle_format_urls_processes_all_formats(self, youtube_ie):\n        \"\"\"Test that _unthrottle_format_urls processes all video formats.\"\"\"\n        video_id = \"test_video\"\n        player_url = \"https://www.youtube.com/s/player/test.js\"\n        \n        # Mock formats with n parameters\n        formats = [\n            {'url': 'https://example.com/video1.mp4?n=param1&other=value'},\n            {'url': 'https://example.com/video2.mp4?n=param2&other=value'},\n            {'url': 'https://example.com/video3.mp4?other=value'},  # no n param\n        ]\n        \n        # Mock successful n-parameter processing\n        def mock_n_descramble(n_param, player_url, video_id):\n            return \"unthrottled_\" + n_param\n        \n        with patch.object(youtube_ie, '_n_descramble', side_effect=mock_n_descramble):\n            youtube_ie._unthrottle_format_urls(video_id, player_url, formats)\n            \n            # All formats with n parameters should be processed\n            assert 'n=unthrottled_param1' in formats[0]['url']\n            assert 'n=unthrottled_param2' in formats[1]['url']\n            # Format without n param should be unchanged\n            assert formats[2]['url'] == 'https://example.com/video3.mp4?other=value'\n    \n    def test_unthrottle_format_urls_handles_processing_failure(self, youtube_ie):\n        \"\"\"Test _unthrottle_format_urls behavior when n-parameter processing fails.\"\"\"\n        video_id = \"test_video\"\n        player_url = \"https://www.youtube.com/s/player/test.js\"\n        \n        formats = [\n            {'url': 'https://example.com/video1.mp4?n=param1&other=value'},\n        ]\n        \n        # Mock n-parameter processing failure\n        with patch.object(youtube_ie, '_n_descramble', side_effect=ExtractorError(\"Processing failed\")):\n            # Current implementation may let this fail silently or crash\n            # After fix, should handle gracefully\n            try:\n                youtube_ie._unthrottle_format_urls(video_id, player_url, formats)\n                # Should either succeed with fallback or handle gracefully\n            except ExtractorError:\n                # Current behavior - this causes the 50kb/s issue\n                pass\n    \n    def test_unthrottle_format_urls_validates_success(self, youtube_ie):\n        \"\"\"Test that _unthrottle_format_urls should validate successful processing.\"\"\"\n        video_id = \"test_video\"\n        player_url = \"https://www.youtube.com/s/player/test.js\"\n        \n        formats = [\n            {'url': 'https://example.com/video1.mp4?n=param1&other=value'},\n        ]\n        \n        # Mock n-parameter processing that returns same value (indicating failure)\n        def mock_n_descramble(n_param, player_url, video_id):\n            return n_param  # No transformation - should be detected as failure\n        \n        with patch.object(youtube_ie, '_n_descramble', side_effect=mock_n_descramble):\n            youtube_ie._unthrottle_format_urls(video_id, player_url, formats)\n            \n            # After fix, should detect that n-parameter wasn't actually transformed\n            # and either retry or log warning\n            # Current implementation doesn't validate this\n    \n    def test_mainstream_vs_regular_video_processing(self, youtube_ie):\n        \"\"\"Test that demonstrates the difference between mainstream and regular video processing.\"\"\"\n        video_id = \"test_video\"\n        player_url = \"https://www.youtube.com/s/player/test.js\"\n        \n        # Simulate the reported issue: some videos get full speed, others get throttled\n        mainstream_formats = [\n            {'url': 'https://example.com/mainstream.mp4?n=working_param&other=value'},\n        ]\n        \n        regular_formats = [\n            {'url': 'https://example.com/regular.mp4?n=failing_param&other=value'},\n        ]\n        \n        def mock_n_descramble_selective(n_param, player_url, video_id):\n            if n_param == \"working_param\":\n                return \"unthrottled_\" + n_param  # Mainstream videos work\n            else:\n                raise ExtractorError(\"Failed for regular videos\")  # Regular videos fail\n        \n        with patch.object(youtube_ie, '_n_descramble', side_effect=mock_n_descramble_selective):\n            # Mainstream video should work\n            try:\n                youtube_ie._unthrottle_format_urls(video_id, player_url, mainstream_formats)\n                # Should succeed\n            except ExtractorError:\n                pytest.fail(\"Mainstream video processing should not fail\")\n            \n            # Regular video should fail (demonstrating the bug)\n            with pytest.raises(ExtractorError):\n                youtube_ie._unthrottle_format_urls(video_id, player_url, regular_formats)\n    \n    def test_speed_measurement_integration(self, youtube_ie):\n        \"\"\"Test integration with download speed measurement.\"\"\"\n        # This test documents how the throttling issue affects download speeds\n        \n        # Mock a throttled URL (what happens when n-parameter processing fails)\n        throttled_url = \"https://example.com/video.mp4?n=original_param\"\n        \n        # Mock an unthrottled URL (what happens when n-parameter processing succeeds)  \n        unthrottled_url = \"https://example.com/video.mp4?n=transformed_param\"\n        \n        # The issue is that throttled URLs result in ~50kb/s speeds\n        # while unthrottled URLs get full speed\n        \n        # This test documents the expected behavior:\n        # All URLs should be unthrottled to prevent the 50kb/s issue\n        assert \"transformed\" in unthrottled_url or \"unthrottled\" in unthrottled_url\n    \n    def test_error_recovery_mechanisms(self, youtube_ie):\n        \"\"\"Test error recovery mechanisms for n-parameter processing.\"\"\"\n        n_param = \"test_param\"\n        player_url = \"https://www.youtube.com/s/player/test.js\"\n        video_id = \"test_video\"\n        \n        # Test various failure scenarios and recovery\n        failure_scenarios = [\n            Exception(\"Network error\"),\n            ExtractorError(\"Regex match failed\"),\n            ValueError(\"Invalid JavaScript\"),\n            KeyError(\"Missing function\"),\n        ]\n        \n        for exception in failure_scenarios:\n            with patch.object(youtube_ie, '_extract_n_function', side_effect=exception):\n                # Current implementation fails completely\n                # After fix, should implement recovery mechanisms\n                try:\n                    result = youtube_ie._n_descramble(n_param, player_url, video_id)\n                    # Should recover gracefully\n                except ExtractorError:\n                    # Current behavior - causes 50kb/s downloads\n                    pass\n    \n    def test_player_code_pattern_evolution(self, youtube_ie):\n        \"\"\"Test handling of evolving YouTube player code patterns.\"\"\"\n        # Document various patterns seen in YouTube player code over time\n        patterns = [\n            # Current pattern (works)\n            'if(c.get(\"n\"))&&(b=abc(d)){',\n            \n            # Newer patterns (fail with current implementation)\n            'c.get(\"n\")&&(b=def(c.get(\"n\")),c.set(\"n\",b))',\n            'var n=c.get(\"n\");if(n){b=ghi(n);c.set(\"n\",b)}',\n            'c.has(\"n\")&&(b=jkl(c.get(\"n\")))',\n            \n            # Obfuscated patterns\n            'c[\"get\"](\"n\")&&(b=mno(c[\"get\"](\"n\")))',\n            'c[a](\"n\")&&(b=pqr(c[a](\"n\")))',\n        ]\n        \n        # Current implementation only handles the first pattern\n        # After fix, should handle multiple patterns to prevent throttling\n        \n        for pattern in patterns:\n            try:\n                # Try to extract function name from pattern\n                match = re.search(r'([a-zA-Z0-9$_]+)\\(', pattern)\n                if match:\n                    func_name = match.group(1)\n                    # Should be able to extract function names from all patterns\n                    assert len(func_name) > 0\n            except:\n                # Current implementation fails on newer patterns\n                pass\n</patched>\n```\n\n```\n<file>test/test_youtube_throttling_integration.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom unittest.mock import Mock, patch, MagicMock",
  "patch": "--- a/test/test_youtube_throttling.py\n+++ b/test/test_youtube_throttling.py\n-# Empty if creating new file\n+import pytest\n+import re\n+from unittest.mock import Mock, patch, MagicMock\n+from youtube_dl.extractor.youtube import YoutubeIE\n+from youtube_dl.utils import ExtractorError\n+\n+\n+class TestYouTubeThrottling:\n+    \"\"\"Test suite for YouTube throttling/n-parameter functionality.\"\"\"\n+    \n+    @pytest.fixture\n+    def youtube_ie(self):\n+        \"\"\"Create a YoutubeIE instance for testing.\"\"\"\n+        ie = YoutubeIE()\n+        ie._downloader = Mock()\n+        ie._downloader.params = {}\n+        ie._downloader.cache = Mock()\n+        ie._downloader.cache.load = Mock(return_value=None)\n+        ie._downloader.cache.store = Mock()\n+        ie._player_cache = {}\n+        return ie\n+    \n+    @pytest.fixture\n+    def mock_player_code_old(self):\n+        \"\"\"Mock old-style YouTube player code that should work.\"\"\"\n+        return '''\n+        var a = function(b) {\n+            return b.split('').reverse().join('');\n+        };\n+        if (c.get(\"n\")) && (b = xyz(c)) {\n+            // old pattern that works\n+        }\n+        '''\n+    \n+    @pytest.fixture\n+    def mock_player_code_new(self):\n+        \"\"\"Mock new-style YouTube player code that fails with current regex.\"\"\"\n+        return '''\n+        var a = function(b) {\n+            return b.split('').reverse().join('');\n+        };\n+        if (c.get(\"n\")) && (b = abc123(c.get(\"n\"))) {\n+            // new pattern that current regex doesn't match\n+        }\n+        '''\n+    \n+    @pytest.fixture\n+    def mock_player_code_alternative(self):\n+        \"\"\"Mock alternative YouTube player code pattern.\"\"\"\n+        return '''\n+        var a = function(b) {\n+            return b.split('').reverse().join('');\n+        };\n+        c.get(\"n\")&&(d=def456(c.get(\"n\")),c.set(\"n\",d))\n+        '''\n+\n+    def test_extract_n_function_name_current_pattern(self, youtube_ie):\n+        \"\"\"Test that _extract_n_function_name works with current pattern.\"\"\"\n+        jscode = 'if(c.get(\"n\"))&&(b=xyz(a)){return b;}'\n+        \n+        result = youtube_ie._extract_n_function_name(jscode)\n+        assert result == 'xyz'\n+    \n+    def test_extract_n_function_name_fails_with_new_pattern(self, youtube_ie):\n+        \"\"\"Test that current implementation fails with new YouTube patterns.\"\"\"\n+        # This test demonstrates the bug - new patterns aren't matched\n+        jscode = 'if(c.get(\"n\"))&&(b=abc123(c.get(\"n\"))){return b;}'\n+        \n+        with pytest.raises(ExtractorError):\n+            youtube_ie._extract_n_function_name(jscode)\n+    \n+    def test_extract_n_function_name_should_handle_multiple_patterns(self, youtube_ie):\n+        \"\"\"Test that _extract_n_function_name should handle multiple patterns.\"\"\"\n+        # This test shows what the intended behavior should be\n+        test_cases = [\n+            ('if(c.get(\"n\"))&&(b=xyz(a)){return b;}', 'xyz'),\n+            ('c.get(\"n\")&&(d=abc123(c.get(\"n\")),c.set(\"n\",d))', 'abc123'),\n+            ('var n=c.get(\"n\");if(n){b=def456(n);c.set(\"n\",b)}', 'def456'),\n+            ('.get(\"n\"))&&(b=ghi789([a-zA-Z0-9])', 'ghi789'),\n+        ]\n+        \n+        # Current implementation will fail on most of these\n+        # This test documents the expected behavior after fix\n+        for jscode, expected in test_cases:\n+            try:\n+                result = youtube_ie._extract_n_function_name(jscode)\n+                # If it works, verify it's correct\n+                assert result == expected\n+            except ExtractorError:\n+                # Expected to fail with current implementation\n+                # After fix, this should pass\n+                pass\n+    \n+    def test_n_descramble_handles_extraction_failure(self, youtube_ie):\n+        \"\"\"Test that _n_descramble handles n-function extraction failures gracefully.\"\"\"\n+        n_param = \"test_n_param\"\n+        player_url = \"https://www.youtube.com/s/player/test.js\"\n+        video_id = \"test_video_id\"\n+        \n+        # Mock _extract_n_function to raise an exception\n+        with patch.object(youtube_ie, '_extract_n_function', side_effect=Exception(\"Extraction failed\")):\n+            # Current implementation raises ExtractorError, causing download failure\n+            with pytest.raises(ExtractorError):\n+                youtube_ie._n_descramble(n_param, player_url, video_id)\n+    \n+    def test_n_descramble_should_retry_on_failure(self, youtube_ie):\n+        \"\"\"Test that _n_descramble should implement retry logic.\"\"\"\n+        n_param = \"test_n_param\"\n+        player_url = \"https://www.youtube.com/s/player/test.js\"\n+        video_id = \"test_video_id\"\n+        \n+        # This test documents intended behavior - should retry and recover\n+        # Current implementation doesn't do this, causing the 50kb/s issue\n+        \n+        call_count = 0\n+        def mock_extract_n_function(vid, url):\n+            nonlocal call_count\n+            call_count += 1\n+            if call_count == 1:\n+                raise Exception(\"First attempt fails\")\n+            # Second attempt should succeed\n+            return lambda x: x + \"_transformed\"\n+        \n+        with patch.object(youtube_ie, '_extract_n_function', side_effect=mock_extract_n_function):\n+            # After fix, this should retry and succeed instead of failing\n+            try:\n+                result = youtube_ie._n_descramble(n_param, player_url, video_id)\n+                # Should eventually succeed with retry logic\n+                assert result == n_param + \"_transformed\"\n+            except ExtractorError:\n+                # Current implementation fails here - this is the bug\n+                pass\n+    \n+    def test_n_descramble_caching_behavior(self, youtube_ie):\n+        \"\"\"Test n-parameter caching behavior.\"\"\"\n+        n_param = \"test_n_param\"\n+        player_url = \"https://www.youtube.com/s/player/test.js\"\n+        video_id = \"test_video_id\"\n+        \n+        # Mock successful function\n+        mock_func = Mock(return_value=\"transformed_\" + n_param)\n+        \n+        with patch.object(youtube_ie, '_extract_n_function', return_value=mock_func):\n+            # First call should extract and cache\n+            result1 = youtube_ie._n_descramble(n_param, player_url, video_id)\n+            \n+            # Second call should use cache\n+            result2 = youtube_ie._n_descramble(n_param, player_url, video_id)\n+            \n+            assert result1 == result2 == \"transformed_\" + n_param\n+            \n+            # Should have cached both the function and the result\n+            assert ('nsig', player_url) in youtube_ie._player_cache\n+            assert ('nsig_value', n_param) in youtube_ie._player_cache\n+    \n+    def test_unthrottle_format_urls_processes_all_formats(self, youtube_ie):\n+        \"\"\"Test that _unthrottle_format_urls processes all video formats.\"\"\"\n+        video_id = \"test_video\"\n+        player_url = \"https://www.youtube.com/s/player/test.js\"\n+        \n+        # Mock formats with n parameters\n+        formats = [\n+            {'url': 'https://example.com/video1.mp4?n=param1&other=value'},\n+            {'url': 'https://example.com/video2.mp4?n=param2&other=value'},\n+            {'url': 'https://example.com/video3.mp4?other=value'},  # no n param\n+        ]\n+        \n+        # Mock successful n-parameter processing\n+        def mock_n_descramble(n_param, player_url, video_id):\n+            return \"unthrottled_\" + n_param\n+        \n+        with patch.object(youtube_ie, '_n_descramble', side_effect=mock_n_descramble):\n+            youtube_ie._unthrottle_format_urls(video_id, player_url, formats)\n+            \n+            # All formats with n parameters should be processed\n+            assert 'n=unthrottled_param1' in formats[0]['url']\n+            assert 'n=unthrottled_param2' in formats[1]['url']\n+            # Format without n param should be unchanged\n+            assert formats[2]['url'] == 'https://example.com/video3.mp4?other=value'\n+    \n+    def test_unthrottle_format_urls_handles_processing_failure(self, youtube_ie):\n+        \"\"\"Test _unthrottle_format_urls behavior when n-parameter processing fails.\"\"\"\n+        video_id = \"test_video\"\n+        player_url = \"https://www.youtube.com/s/player/test.js\"\n+        \n+        formats = [\n+            {'url': 'https://example.com/video1.mp4?n=param1&other=value'},\n+        ]\n+        \n+        # Mock n-parameter processing failure\n+        with patch.object(youtube_ie, '_n_descramble', side_effect=ExtractorError(\"Processing failed\")):\n+            # Current implementation may let this fail silently or crash\n+            # After fix, should handle gracefully\n+            try:\n+                youtube_ie._unthrottle_format_urls(video_id, player_url, formats)\n+                # Should either succeed with fallback or handle gracefully\n+            except ExtractorError:\n+                # Current behavior - this causes the 50kb/s issue\n+                pass\n+    \n+    def test_unthrottle_format_urls_validates_success(self, youtube_ie):\n+        \"\"\"Test that _unthrottle_format_urls should validate successful processing.\"\"\"\n+        video_id = \"test_video\"\n+        player_url = \"https://www.youtube.com/s/player/test.js\"\n+        \n+        formats = [\n+            {'url': 'https://example.com/video1.mp4?n=param1&other=value'},\n+        ]\n+        \n+        # Mock n-parameter processing that returns same value (indicating failure)\n+        def mock_n_descramble(n_param, player_url, video_id):\n+            return n_param  # No transformation - should be detected as failure\n+        \n+        with patch.object(youtube_ie, '_n_descramble', side_effect=mock_n_descramble):\n+            youtube_ie._unthrottle_format_urls(video_id, player_url, formats)\n+            \n+            # After fix, should detect that n-parameter wasn't actually transformed\n+            # and either retry or log warning\n+            # Current implementation doesn't validate this\n+    \n+    def test_mainstream_vs_regular_video_processing(self, youtube_ie):\n+        \"\"\"Test that demonstrates the difference between mainstream and regular video processing.\"\"\"\n+        video_id = \"test_video\"\n+        player_url = \"https://www.youtube.com/s/player/test.js\"\n+        \n+        # Simulate the reported issue: some videos get full speed, others get throttled\n+        mainstream_formats = [\n+            {'url': 'https://example.com/mainstream.mp4?n=working_param&other=value'},\n+        ]\n+        \n+        regular_formats = [\n+            {'url': 'https://example.com/regular.mp4?n=failing_param&other=value'},\n+        ]\n+        \n+        def mock_n_descramble_selective(n_param, player_url, video_id):\n+            if n_param == \"working_param\":\n+                return \"unthrottled_\" + n_param  # Mainstream videos work\n+            else:\n+                raise ExtractorError(\"Failed for regular videos\")  # Regular videos fail\n+        \n+        with patch.object(youtube_ie, '_n_descramble', side_effect=mock_n_descramble_selective):\n+            # Mainstream video should work\n+            try:\n+                youtube_ie._unthrottle_format_urls(video_id, player_url, mainstream_formats)\n+                # Should succeed\n+            except ExtractorError:\n+                pytest.fail(\"Mainstream video processing should not fail\")\n+            \n+            # Regular video should fail (demonstrating the bug)\n+            with pytest.raises(ExtractorError):\n+                youtube_ie._unthrottle_format_urls(video_id, player_url, regular_formats)\n+    \n+    def test_speed_measurement_integration(self, youtube_ie):\n+        \"\"\"Test integration with download speed measurement.\"\"\"\n+        # This test documents how the throttling issue affects download speeds\n+        \n+        # Mock a throttled URL (what happens when n-parameter processing fails)\n+        throttled_url = \"https://example.com/video.mp4?n=original_param\"\n+        \n+        # Mock an unthrottled URL (what happens when n-parameter processing succeeds)  \n+        unthrottled_url = \"https://example.com/video.mp4?n=transformed_param\"\n+        \n+        # The issue is that throttled URLs result in ~50kb/s speeds\n+        # while unthrottled URLs get full speed\n+        \n+        # This test documents the expected behavior:\n+        # All URLs should be unthrottled to prevent the 50kb/s issue\n+        assert \"transformed\" in unthrottled_url or \"unthrottled\" in unthrottled_url\n+    \n+    def test_error_recovery_mechanisms(self, youtube_ie):\n+        \"\"\"Test error recovery mechanisms for n-parameter processing.\"\"\"\n+        n_param = \"test_param\"\n+        player_url = \"https://www.youtube.com/s/player/test.js\"\n+        video_id = \"test_video\"\n+        \n+        # Test various failure scenarios and recovery\n+        failure_scenarios = [\n+            Exception(\"Network error\"),\n+            ExtractorError(\"Regex match failed\"),\n+            ValueError(\"Invalid JavaScript\"),\n+            KeyError(\"Missing function\"),\n+        ]\n+        \n+        for exception in failure_scenarios:\n+            with patch.object(youtube_ie, '_extract_n_function', side_effect=exception):\n+                # Current implementation fails completely\n+                # After fix, should implement recovery mechanisms\n+                try:\n+                    result = youtube_ie._n_descramble(n_param, player_url, video_id)\n+                    # Should recover gracefully\n+                except ExtractorError:\n+                    # Current behavior - causes 50kb/s downloads\n+                    pass\n+    \n+    def test_player_code_pattern_evolution(self, youtube_ie):\n+        \"\"\"Test handling of evolving YouTube player code patterns.\"\"\"\n+        # Document various patterns seen in YouTube player code over time\n+        patterns = [\n+            # Current pattern (works)\n+            'if(c.get(\"n\"))&&(b=abc(d)){',\n+            \n+            # Newer patterns (fail with current implementation)\n+            'c.get(\"n\")&&(b=def(c.get(\"n\")),c.set(\"n\",b))',\n+            'var n=c.get(\"n\");if(n){b=ghi(n);c.set(\"n\",b)}',\n+            'c.has(\"n\")&&(b=jkl(c.get(\"n\")))',\n+            \n+            # Obfuscated patterns\n+            'c[\"get\"](\"n\")&&(b=mno(c[\"get\"](\"n\")))',\n+            'c[a](\"n\")&&(b=pqr(c[a](\"n\")))',\n+        ]\n+        \n+        # Current implementation only handles the first pattern\n+        # After fix, should handle multiple patterns to prevent throttling\n+        \n+        for pattern in patterns:\n+            try:\n+                # Try to extract function name from pattern\n+                match = re.search(r'([a-zA-Z0-9$_]+)\\(', pattern)\n+                if match:\n+                    func_name = match.group(1)\n+                    # Should be able to extract function names from all patterns\n+                    assert len(func_name) > 0\n+            except:\n+                # Current implementation fails on newer patterns\n+                pass\n"
}