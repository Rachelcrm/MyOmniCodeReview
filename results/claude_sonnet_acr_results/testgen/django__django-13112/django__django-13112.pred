{
  "instance_id": "django__django-13112",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/migrations/test_utils.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db.migrations.operations.utils import resolve_relation\nfrom django.db import models\nfrom django.apps import AppConfig\nfrom django.test import TestCase\n\n\nclass TestResolveRelation(TestCase):\n    \"\"\"Test cases for the resolve_relation function with mixed-case app names.\"\"\"\n\n    def test_resolve_relation_with_mixed_case_app_name(self):\n        \"\"\"\n        Test that resolve_relation preserves the original case of app labels\n        when resolving model references with mixed-case app names.\n        \n        This test reproduces the bug where 'DJ_RegLogin.Category' gets\n        converted to 'dj_reglogin.category' instead of 'DJ_RegLogin.category'.\n        \"\"\"\n        # Test with mixed-case app name and model name\n        result = resolve_relation('DJ_RegLogin.Category')\n        expected = ('DJ_RegLogin', 'category')\n        self.assertEqual(result, expected)\n\n    def test_resolve_relation_preserves_app_case_various_formats(self):\n        \"\"\"\n        Test that resolve_relation preserves app label case for various\n        mixed-case formats while converting model names to lowercase.\n        \"\"\"\n        test_cases = [\n            ('DJ_RegLogin.Category', ('DJ_RegLogin', 'category')),\n            ('MyApp.MyModel', ('MyApp', 'mymodel')),\n            ('UPPERCASE_APP.SomeModel', ('UPPERCASE_APP', 'somemodel')),\n            ('lowercase_app.AnotherModel', ('lowercase_app', 'anothermodel')),\n            ('Mixed_Case_App.TestModel', ('Mixed_Case_App', 'testmodel')),\n        ]\n        \n        for model_ref, expected in test_cases:\n            with self.subTest(model_ref=model_ref):\n                result = resolve_relation(model_ref)\n                self.assertEqual(result, expected)\n\n    def test_resolve_relation_without_dot_preserves_app_label_case(self):\n        \"\"\"\n        Test that resolve_relation preserves app_label case when provided\n        separately and only converts model name to lowercase.\n        \"\"\"\n        result = resolve_relation('Category', app_label='DJ_RegLogin')\n        expected = ('DJ_RegLogin', 'category')\n        self.assertEqual(result, expected)\n\n    def test_resolve_relation_with_model_instance(self):\n        \"\"\"\n        Test that resolve_relation works correctly with actual model instances.\n        \"\"\"\n        # Create a mock model with meta attributes\n        class MockMeta:\n            app_label = 'DJ_RegLogin'\n            model_name = 'category'\n        \n        class MockModel:\n            _meta = MockMeta()\n        \n        model = MockModel()\n        result = resolve_relation(model)\n        expected = ('DJ_RegLogin', 'category')\n        self.assertEqual(result, expected)\n\n    def test_resolve_relation_recursive_relationship(self):\n        \"\"\"\n        Test that resolve_relation handles recursive relationships correctly\n        while preserving app label case.\n        \"\"\"\n        result = resolve_relation('self', app_label='DJ_RegLogin', model_name='Category')\n        expected = ('DJ_RegLogin', 'Category')\n        self.assertEqual(result, expected)\n\n    def test_resolve_relation_raises_error_for_missing_app_label(self):\n        \"\"\"\n        Test that resolve_relation raises TypeError when app_label is missing\n        for unscoped model relationships.\n        \"\"\"\n        with self.assertRaises(TypeError) as cm:\n            resolve_relation('Category')\n        \n        self.assertIn('app_label must be provided', str(cm.exception))\n\n    def test_resolve_relation_raises_error_for_recursive_without_params(self):\n        \"\"\"\n        Test that resolve_relation raises TypeError when recursive relationship\n        is used without required parameters.\n        \"\"\"\n        with self.assertRaises(TypeError) as cm:\n            resolve_relation('self')\n        \n        self.assertIn('app_label and model_name must be provided', str(cm.exception))\n\n    def test_resolve_relation_edge_cases(self):\n        \"\"\"\n        Test edge cases for resolve_relation function.\n        \"\"\"\n        # Test with numbers in app name\n        result = resolve_relation('App123.Model456')\n        expected = ('App123', 'model456')\n        self.assertEqual(result, expected)\n        \n        # Test with underscores and hyphens (though hyphens aren't valid in Python identifiers)\n        result = resolve_relation('my_app_name.MyModelName')\n        expected = ('my_app_name', 'mymodelname')\n        self.assertEqual(result, expected)\n        \n        # Test with single character app and model names\n        result = resolve_relation('A.B')\n        expected = ('A', 'b')\n        self.assertEqual(result, expected)\n\n\nclass TestMixedCaseAppNameIntegration(TestCase):\n    \"\"\"\n    Integration tests that simulate the actual Django migration scenario\n    with mixed-case app names.\n    \"\"\"\n\n    def test_foreign_key_reference_with_mixed_case_app(self):\n        \"\"\"\n        Test that ForeignKey references work correctly with mixed-case app names.\n        This simulates the actual bug scenario described in the issue.\n        \"\"\"\n        # Test the specific case from the bug report\n        model_reference = 'DJ_RegLogin.Category'\n        app_label, model_name = resolve_relation(model_reference)\n        \n        # The app label should preserve original case\n        self.assertEqual(app_label, 'DJ_RegLogin')\n        # The model name should be lowercase\n        self.assertEqual(model_name, 'category')\n        \n        # This should match what Django expects when looking up the app\n        # The bug was that 'dj_reglogin' was being generated instead of 'DJ_RegLogin'\n        self.assertNotEqual(app_label, 'dj_reglogin')\n\n    def test_multiple_foreign_key_references_same_app(self):\n        \"\"\"\n        Test multiple model references from the same mixed-case app.\n        \"\"\"\n        references = [\n            'DJ_RegLogin.Category',\n            'DJ_RegLogin.Content', \n            'DJ_RegLogin.User'\n        ]\n        \n        for ref in references:\n            app_label, model_name = resolve_relation(ref)\n            # All should preserve the same app label case\n            self.assertEqual(app_label, 'DJ_RegLogin')\n            # All model names should be lowercase\n            self.assertTrue(model_name.islower())\n\n    def test_cross_app_references_with_mixed_case(self):\n        \"\"\"\n        Test references between apps with different case patterns.\n        \"\"\"\n        test_cases = [\n            ('DJ_RegLogin.Category', 'DJ_RegLogin', 'category'),\n            ('auth.User', 'auth', 'user'),\n            ('MyOtherApp.SomeModel', 'MyOtherApp', 'somemodel'),\n        ]\n        \n        for ref, expected_app, expected_model in test_cases:\n            app_label, model_name = resolve_relation(ref)\n            self.assertEqual(app_label, expected_app)\n            self.assertEqual(model_name, expected_model)\n</patched>\n```",
  "patch": "--- a/tests/migrations/test_utils.py\n+++ b/tests/migrations/test_utils.py\n-# Empty if creating new file\n+import pytest\n+from django.db.migrations.operations.utils import resolve_relation\n+from django.db import models\n+from django.apps import AppConfig\n+from django.test import TestCase\n+\n+\n+class TestResolveRelation(TestCase):\n+    \"\"\"Test cases for the resolve_relation function with mixed-case app names.\"\"\"\n+\n+    def test_resolve_relation_with_mixed_case_app_name(self):\n+        \"\"\"\n+        Test that resolve_relation preserves the original case of app labels\n+        when resolving model references with mixed-case app names.\n+        \n+        This test reproduces the bug where 'DJ_RegLogin.Category' gets\n+        converted to 'dj_reglogin.category' instead of 'DJ_RegLogin.category'.\n+        \"\"\"\n+        # Test with mixed-case app name and model name\n+        result = resolve_relation('DJ_RegLogin.Category')\n+        expected = ('DJ_RegLogin', 'category')\n+        self.assertEqual(result, expected)\n+\n+    def test_resolve_relation_preserves_app_case_various_formats(self):\n+        \"\"\"\n+        Test that resolve_relation preserves app label case for various\n+        mixed-case formats while converting model names to lowercase.\n+        \"\"\"\n+        test_cases = [\n+            ('DJ_RegLogin.Category', ('DJ_RegLogin', 'category')),\n+            ('MyApp.MyModel', ('MyApp', 'mymodel')),\n+            ('UPPERCASE_APP.SomeModel', ('UPPERCASE_APP', 'somemodel')),\n+            ('lowercase_app.AnotherModel', ('lowercase_app', 'anothermodel')),\n+            ('Mixed_Case_App.TestModel', ('Mixed_Case_App', 'testmodel')),\n+        ]\n+        \n+        for model_ref, expected in test_cases:\n+            with self.subTest(model_ref=model_ref):\n+                result = resolve_relation(model_ref)\n+                self.assertEqual(result, expected)\n+\n+    def test_resolve_relation_without_dot_preserves_app_label_case(self):\n+        \"\"\"\n+        Test that resolve_relation preserves app_label case when provided\n+        separately and only converts model name to lowercase.\n+        \"\"\"\n+        result = resolve_relation('Category', app_label='DJ_RegLogin')\n+        expected = ('DJ_RegLogin', 'category')\n+        self.assertEqual(result, expected)\n+\n+    def test_resolve_relation_with_model_instance(self):\n+        \"\"\"\n+        Test that resolve_relation works correctly with actual model instances.\n+        \"\"\"\n+        # Create a mock model with meta attributes\n+        class MockMeta:\n+            app_label = 'DJ_RegLogin'\n+            model_name = 'category'\n+        \n+        class MockModel:\n+            _meta = MockMeta()\n+        \n+        model = MockModel()\n+        result = resolve_relation(model)\n+        expected = ('DJ_RegLogin', 'category')\n+        self.assertEqual(result, expected)\n+\n+    def test_resolve_relation_recursive_relationship(self):\n+        \"\"\"\n+        Test that resolve_relation handles recursive relationships correctly\n+        while preserving app label case.\n+        \"\"\"\n+        result = resolve_relation('self', app_label='DJ_RegLogin', model_name='Category')\n+        expected = ('DJ_RegLogin', 'Category')\n+        self.assertEqual(result, expected)\n+\n+    def test_resolve_relation_raises_error_for_missing_app_label(self):\n+        \"\"\"\n+        Test that resolve_relation raises TypeError when app_label is missing\n+        for unscoped model relationships.\n+        \"\"\"\n+        with self.assertRaises(TypeError) as cm:\n+            resolve_relation('Category')\n+        \n+        self.assertIn('app_label must be provided', str(cm.exception))\n+\n+    def test_resolve_relation_raises_error_for_recursive_without_params(self):\n+        \"\"\"\n+        Test that resolve_relation raises TypeError when recursive relationship\n+        is used without required parameters.\n+        \"\"\"\n+        with self.assertRaises(TypeError) as cm:\n+            resolve_relation('self')\n+        \n+        self.assertIn('app_label and model_name must be provided', str(cm.exception))\n+\n+    def test_resolve_relation_edge_cases(self):\n+        \"\"\"\n+        Test edge cases for resolve_relation function.\n+        \"\"\"\n+        # Test with numbers in app name\n+        result = resolve_relation('App123.Model456')\n+        expected = ('App123', 'model456')\n+        self.assertEqual(result, expected)\n+        \n+        # Test with underscores and hyphens (though hyphens aren't valid in Python identifiers)\n+        result = resolve_relation('my_app_name.MyModelName')\n+        expected = ('my_app_name', 'mymodelname')\n+        self.assertEqual(result, expected)\n+        \n+        # Test with single character app and model names\n+        result = resolve_relation('A.B')\n+        expected = ('A', 'b')\n+        self.assertEqual(result, expected)\n+\n+\n+class TestMixedCaseAppNameIntegration(TestCase):\n+    \"\"\"\n+    Integration tests that simulate the actual Django migration scenario\n+    with mixed-case app names.\n+    \"\"\"\n+\n+    def test_foreign_key_reference_with_mixed_case_app(self):\n+        \"\"\"\n+        Test that ForeignKey references work correctly with mixed-case app names.\n+        This simulates the actual bug scenario described in the issue.\n+        \"\"\"\n+        # Test the specific case from the bug report\n+        model_reference = 'DJ_RegLogin.Category'\n+        app_label, model_name = resolve_relation(model_reference)\n+        \n+        # The app label should preserve original case\n+        self.assertEqual(app_label, 'DJ_RegLogin')\n+        # The model name should be lowercase\n+        self.assertEqual(model_name, 'category')\n+        \n+        # This should match what Django expects when looking up the app\n+        # The bug was that 'dj_reglogin' was being generated instead of 'DJ_RegLogin'\n+        self.assertNotEqual(app_label, 'dj_reglogin')\n+\n+    def test_multiple_foreign_key_references_same_app(self):\n+        \"\"\"\n+        Test multiple model references from the same mixed-case app.\n+        \"\"\"\n+        references = [\n+            'DJ_RegLogin.Category',\n+            'DJ_RegLogin.Content', \n+            'DJ_RegLogin.User'\n+        ]\n+        \n+        for ref in references:\n+            app_label, model_name = resolve_relation(ref)\n+            # All should preserve the same app label case\n+            self.assertEqual(app_label, 'DJ_RegLogin')\n+            # All model names should be lowercase\n+            self.assertTrue(model_name.islower())\n+\n+    def test_cross_app_references_with_mixed_case(self):\n+        \"\"\"\n+        Test references between apps with different case patterns.\n+        \"\"\"\n+        test_cases = [\n+            ('DJ_RegLogin.Category', 'DJ_RegLogin', 'category'),\n+            ('auth.User', 'auth', 'user'),\n+            ('MyOtherApp.SomeModel', 'MyOtherApp', 'somemodel'),\n+        ]\n+        \n+        for ref, expected_app, expected_model in test_cases:\n+            app_label, model_name = resolve_relation(ref)\n+            self.assertEqual(app_label, expected_app)\n+            self.assertEqual(model_name, expected_model)\n"
}