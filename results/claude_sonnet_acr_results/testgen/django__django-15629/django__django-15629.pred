{
  "instance_id": "django__django-15629",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/schema/test_db_collation_foreign_keys.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models, connection\nfrom django.db.migrations.state import ProjectState\nfrom django.db.migrations.autodetector import MigrationAutodetector\nfrom django.test import TestCase, TransactionTestCase, skipUnlessDBFeature\nfrom django.test.utils import isolate_apps\nfrom django.db.backends.base.schema import BaseDatabaseSchemaEditor\n\n\nclass TestDbCollationForeignKeys(TransactionTestCase):\n    \"\"\"\n    Test that db_collation is properly propagated from primary keys to foreign keys.\n    This addresses the issue where foreign key constraint creation fails in MySQL\n    when the primary key has a db_collation but the foreign key doesn't inherit it.\n    \"\"\"\n    \n    available_apps = ['tests.schema']\n    \n    def setUp(self):\n        self.schema_editor = connection.schema_editor()\n    \n    def tearDown(self):\n        # Clean up any tables created during tests\n        with connection.schema_editor() as editor:\n            try:\n                editor.execute(\"DROP TABLE IF EXISTS test_profile\")\n                editor.execute(\"DROP TABLE IF EXISTS test_address\") \n                editor.execute(\"DROP TABLE IF EXISTS test_account\")\n            except:\n                pass\n    \n    @skipUnlessDBFeature('supports_collation_on_charfield')\n    def test_foreign_key_inherits_target_field_collation(self):\n        \"\"\"\n        Test that a ForeignKey field inherits the db_collation from its target field.\n        This is the core functionality needed to fix the MySQL constraint issue.\n        \"\"\"\n        # Create a model with a primary key that has db_collation\n        class Account(models.Model):\n            id = models.CharField(\n                primary_key=True, \n                max_length=22, \n                db_collation='utf8_bin'\n            )\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_account'\n        \n        # Create a model with a foreign key to the above model\n        class Profile(models.Model):\n            id = models.CharField(\n                primary_key=True,\n                max_length=22,\n                db_collation='utf8_bin'\n            )\n            account = models.ForeignKey(\n                Account, \n                on_delete=models.CASCADE\n            )\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_profile'\n        \n        # Test that the foreign key field gets the target field's db_parameters\n        account_field = Account._meta.get_field('id')\n        profile_account_field = Profile._meta.get_field('account')\n        \n        # Get db_parameters for both fields\n        account_params = account_field.db_parameters(connection)\n        fk_params = profile_account_field.db_parameters(connection)\n        \n        # The foreign key should inherit the collation from the target field\n        self.assertEqual(\n            account_params.get('collation'), \n            fk_params.get('collation'),\n            \"Foreign key field should inherit collation from target field\"\n        )\n        \n        # Verify the collation is actually set\n        if connection.vendor == 'mysql':\n            self.assertEqual(fk_params.get('collation'), 'utf8_bin')\n    \n    @skipUnlessDBFeature('supports_collation_on_charfield')\n    def test_foreign_key_db_type_includes_collation(self):\n        \"\"\"\n        Test that the db_type of a foreign key includes collation information\n        when the target field has db_collation set.\n        \"\"\"\n        class Account(models.Model):\n            id = models.CharField(\n                primary_key=True,\n                max_length=22, \n                db_collation='utf8_bin'\n            )\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_account'\n        \n        class Address(models.Model):\n            account = models.OneToOneField(\n                Account,\n                on_delete=models.CASCADE\n            )\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_address'\n        \n        address_account_field = Address._meta.get_field('account')\n        \n        # Get the db_type for the foreign key field\n        db_type = address_account_field.db_type(connection)\n        \n        # The db_type should match the target field's db_type\n        target_db_type = Account._meta.get_field('id').db_type(connection)\n        self.assertEqual(\n            db_type, \n            target_db_type,\n            \"Foreign key db_type should match target field db_type\"\n        )\n    \n    @skipUnlessDBFeature('supports_collation_on_charfield')\n    def test_migration_sql_includes_collation_for_foreign_keys(self):\n        \"\"\"\n        Test that migration SQL includes COLLATE clause for foreign key fields\n        when altering a primary key field that has foreign key references.\n        This is the specific scenario described in the bug report.\n        \"\"\"\n        # Create initial models without collation\n        class Account(models.Model):\n            id = models.CharField(primary_key=True, max_length=22)\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_account'\n        \n        class Profile(models.Model):\n            account = models.ForeignKey(Account, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_profile'\n        \n        # Create the tables first\n        with self.schema_editor:\n            self.schema_editor.create_model(Account)\n            self.schema_editor.create_model(Profile)\n        \n        # Now create models with collation (simulating the migration)\n        class AccountWithCollation(models.Model):\n            id = models.CharField(\n                primary_key=True, \n                max_length=22, \n                db_collation='utf8_bin'\n            )\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_account'\n        \n        class ProfileWithCollation(models.Model):\n            account = models.ForeignKey(AccountWithCollation, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_profile'\n        \n        # Test the field alteration\n        old_account_field = Account._meta.get_field('id')\n        new_account_field = AccountWithCollation._meta.get_field('id')\n        \n        old_profile_field = Profile._meta.get_field('account')\n        new_profile_field = ProfileWithCollation._meta.get_field('account')\n        \n        # The new foreign key field should have the same db_parameters as the new target field\n        new_account_params = new_account_field.db_parameters(connection)\n        new_fk_params = new_profile_field.db_parameters(connection)\n        \n        self.assertEqual(\n            new_account_params.get('collation'),\n            new_fk_params.get('collation'),\n            \"After migration, foreign key should have same collation as target field\"\n        )\n    \n    def test_foreign_key_without_target_collation(self):\n        \"\"\"\n        Test that foreign keys work normally when target field has no db_collation.\n        This ensures we don't break existing functionality.\n        \"\"\"\n        class SimpleAccount(models.Model):\n            id = models.CharField(primary_key=True, max_length=22)\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_simple_account'\n        \n        class SimpleProfile(models.Model):\n            account = models.ForeignKey(SimpleAccount, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_simple_profile'\n        \n        # Test that db_parameters work without collation\n        account_field = SimpleAccount._meta.get_field('id')\n        profile_field = SimpleProfile._meta.get_field('account')\n        \n        account_params = account_field.db_parameters(connection)\n        fk_params = profile_field.db_parameters(connection)\n        \n        # Both should have no collation\n        self.assertIsNone(account_params.get('collation'))\n        self.assertIsNone(fk_params.get('collation'))\n        \n        # db_type should still work\n        self.assertIsNotNone(profile_field.db_type(connection))\n    \n    @skipUnlessDBFeature('supports_collation_on_charfield')\n    def test_multiple_foreign_keys_same_target(self):\n        \"\"\"\n        Test that multiple foreign keys to the same target all inherit the collation.\n        \"\"\"\n        class Account(models.Model):\n            id = models.CharField(\n                primary_key=True,\n                max_length=22,\n                db_collation='utf8_bin'\n            )\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_account'\n        \n        class Profile(models.Model):\n            account = models.ForeignKey(Account, on_delete=models.CASCADE, related_name='profiles')\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_profile'\n        \n        class Address(models.Model):\n            account = models.ForeignKey(Account, on_delete=models.CASCADE, related_name='addresses')\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_address'\n        \n        # Both foreign keys should inherit the same collation\n        profile_fk = Profile._meta.get_field('account')\n        address_fk = Address._meta.get_field('account')\n        \n        profile_params = profile_fk.db_parameters(connection)\n        address_params = address_fk.db_parameters(connection)\n        \n        self.assertEqual(\n            profile_params.get('collation'),\n            address_params.get('collation'),\n            \"All foreign keys to same target should have same collation\"\n        )\n        \n        if connection.vendor == 'mysql':\n            self.assertEqual(profile_params.get('collation'), 'utf8_bin')\n            self.assertEqual(address_params.get('collation'), 'utf8_bin')\n    \n    @skipUnlessDBFeature('supports_collation_on_charfield')\n    def test_foreign_key_to_non_primary_key_with_collation(self):\n        \"\"\"\n        Test foreign key to a non-primary key field that has db_collation.\n        \"\"\"\n        class Account(models.Model):\n            id = models.AutoField(primary_key=True)\n            code = models.CharField(\n                max_length=22,\n                unique=True,\n                db_collation='utf8_bin'\n            )\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_account'\n        \n        class Profile(models.Model):\n            account = models.ForeignKey(\n                Account,\n                to_field='code',\n                on_delete=models.CASCADE\n            )\n            \n            class Meta:\n                app_label = 'tests'\n                db_table = 'test_profile'\n        \n        # Foreign key should inherit collation from the target field (code)\n        account_code_field = Account._meta.get_field('code')\n        profile_fk_field = Profile._meta.get_field('account')\n        \n        code_params = account_code_field.db_parameters(connection)\n        fk_params = profile_fk_field.db_parameters(connection)\n        \n        self.assertEqual(\n            code_params.get('collation'),\n            fk_params.get('collation'),\n            \"Foreign key should inherit collation from non-primary target field\"\n        )\n\n\n@isolate_apps('tests.schema')\nclass TestDbCollationMigrationGeneration(TestCase):\n    \"\"\"\n    Test that migration generation properly handles db_collation propagation.\n    \"\"\"\n    \n    def test_migration_detects_collation_changes(self):\n        \"\"\"\n        Test that the migration autodetector properly handles collation changes\n        that affect foreign key fields.\n        \"\"\"\n        # This test ensures that when we change a primary key's collation,\n        # the migration system understands that related foreign keys also need updating\n        \n        # Create initial state\n        class Account(models.Model):\n            id = models.CharField(primary_key=True, max_length=22)\n            \n            class Meta:\n                app_label = 'tests'\n        \n        class Profile(models.Model):\n            account = models.ForeignKey(Account, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'tests'\n        \n        # Create new state with collation\n        class AccountWithCollation(models.Model):\n            id = models.CharField(\n                primary_key=True,\n                max_length=22,\n                db_collation='utf8_bin'\n            )\n            \n            class Meta:\n                app_label = 'tests'\n        \n        class ProfileWithCollation(models.Model):\n            account = models.ForeignKey(AccountWithCollation, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'tests'\n        \n        # Test that the foreign key field properly reflects the target field's properties\n        old_fk_field = Profile._meta.get_field('account')\n        new_fk_field = ProfileWithCollation._meta.get_field('account')\n        \n        # The target field should be different\n        old_target = old_fk_field.target_field\n        new_target = new_fk_field.target_field\n        \n        old_target_params = old_target.db_parameters(connection)\n        new_target_params = new_target.db_parameters(connection)\n        \n        # Verify the target field collation changed\n        self.assertNotEqual(\n            old_target_params.get('collation'),\n            new_target_params.get('collation')\n        )\n        \n        # Verify the foreign key field reflects this change\n        old_fk_params = old_fk_field.db_parameters(connection)\n        new_fk_params = new_fk_field.db_parameters(connection)\n        \n        self.assertEqual(\n            new_target_params.get('collation'),\n            new_fk_params.get('collation'),\n            \"Foreign key should inherit new target field collation\"\n        )\n</patched>\n```",
  "patch": "--- a/tests/schema/test_db_collation_foreign_keys.py\n+++ b/tests/schema/test_db_collation_foreign_keys.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models, connection\n+from django.db.migrations.state import ProjectState\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.test import TestCase, TransactionTestCase, skipUnlessDBFeature\n+from django.test.utils import isolate_apps\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+\n+\n+class TestDbCollationForeignKeys(TransactionTestCase):\n+    \"\"\"\n+    Test that db_collation is properly propagated from primary keys to foreign keys.\n+    This addresses the issue where foreign key constraint creation fails in MySQL\n+    when the primary key has a db_collation but the foreign key doesn't inherit it.\n+    \"\"\"\n+    \n+    available_apps = ['tests.schema']\n+    \n+    def setUp(self):\n+        self.schema_editor = connection.schema_editor()\n+    \n+    def tearDown(self):\n+        # Clean up any tables created during tests\n+        with connection.schema_editor() as editor:\n+            try:\n+                editor.execute(\"DROP TABLE IF EXISTS test_profile\")\n+                editor.execute(\"DROP TABLE IF EXISTS test_address\") \n+                editor.execute(\"DROP TABLE IF EXISTS test_account\")\n+            except:\n+                pass\n+    \n+    @skipUnlessDBFeature('supports_collation_on_charfield')\n+    def test_foreign_key_inherits_target_field_collation(self):\n+        \"\"\"\n+        Test that a ForeignKey field inherits the db_collation from its target field.\n+        This is the core functionality needed to fix the MySQL constraint issue.\n+        \"\"\"\n+        # Create a model with a primary key that has db_collation\n+        class Account(models.Model):\n+            id = models.CharField(\n+                primary_key=True, \n+                max_length=22, \n+                db_collation='utf8_bin'\n+            )\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_account'\n+        \n+        # Create a model with a foreign key to the above model\n+        class Profile(models.Model):\n+            id = models.CharField(\n+                primary_key=True,\n+                max_length=22,\n+                db_collation='utf8_bin'\n+            )\n+            account = models.ForeignKey(\n+                Account, \n+                on_delete=models.CASCADE\n+            )\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_profile'\n+        \n+        # Test that the foreign key field gets the target field's db_parameters\n+        account_field = Account._meta.get_field('id')\n+        profile_account_field = Profile._meta.get_field('account')\n+        \n+        # Get db_parameters for both fields\n+        account_params = account_field.db_parameters(connection)\n+        fk_params = profile_account_field.db_parameters(connection)\n+        \n+        # The foreign key should inherit the collation from the target field\n+        self.assertEqual(\n+            account_params.get('collation'), \n+            fk_params.get('collation'),\n+            \"Foreign key field should inherit collation from target field\"\n+        )\n+        \n+        # Verify the collation is actually set\n+        if connection.vendor == 'mysql':\n+            self.assertEqual(fk_params.get('collation'), 'utf8_bin')\n+    \n+    @skipUnlessDBFeature('supports_collation_on_charfield')\n+    def test_foreign_key_db_type_includes_collation(self):\n+        \"\"\"\n+        Test that the db_type of a foreign key includes collation information\n+        when the target field has db_collation set.\n+        \"\"\"\n+        class Account(models.Model):\n+            id = models.CharField(\n+                primary_key=True,\n+                max_length=22, \n+                db_collation='utf8_bin'\n+            )\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_account'\n+        \n+        class Address(models.Model):\n+            account = models.OneToOneField(\n+                Account,\n+                on_delete=models.CASCADE\n+            )\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_address'\n+        \n+        address_account_field = Address._meta.get_field('account')\n+        \n+        # Get the db_type for the foreign key field\n+        db_type = address_account_field.db_type(connection)\n+        \n+        # The db_type should match the target field's db_type\n+        target_db_type = Account._meta.get_field('id').db_type(connection)\n+        self.assertEqual(\n+            db_type, \n+            target_db_type,\n+            \"Foreign key db_type should match target field db_type\"\n+        )\n+    \n+    @skipUnlessDBFeature('supports_collation_on_charfield')\n+    def test_migration_sql_includes_collation_for_foreign_keys(self):\n+        \"\"\"\n+        Test that migration SQL includes COLLATE clause for foreign key fields\n+        when altering a primary key field that has foreign key references.\n+        This is the specific scenario described in the bug report.\n+        \"\"\"\n+        # Create initial models without collation\n+        class Account(models.Model):\n+            id = models.CharField(primary_key=True, max_length=22)\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_account'\n+        \n+        class Profile(models.Model):\n+            account = models.ForeignKey(Account, on_delete=models.CASCADE)\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_profile'\n+        \n+        # Create the tables first\n+        with self.schema_editor:\n+            self.schema_editor.create_model(Account)\n+            self.schema_editor.create_model(Profile)\n+        \n+        # Now create models with collation (simulating the migration)\n+        class AccountWithCollation(models.Model):\n+            id = models.CharField(\n+                primary_key=True, \n+                max_length=22, \n+                db_collation='utf8_bin'\n+            )\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_account'\n+        \n+        class ProfileWithCollation(models.Model):\n+            account = models.ForeignKey(AccountWithCollation, on_delete=models.CASCADE)\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_profile'\n+        \n+        # Test the field alteration\n+        old_account_field = Account._meta.get_field('id')\n+        new_account_field = AccountWithCollation._meta.get_field('id')\n+        \n+        old_profile_field = Profile._meta.get_field('account')\n+        new_profile_field = ProfileWithCollation._meta.get_field('account')\n+        \n+        # The new foreign key field should have the same db_parameters as the new target field\n+        new_account_params = new_account_field.db_parameters(connection)\n+        new_fk_params = new_profile_field.db_parameters(connection)\n+        \n+        self.assertEqual(\n+            new_account_params.get('collation'),\n+            new_fk_params.get('collation'),\n+            \"After migration, foreign key should have same collation as target field\"\n+        )\n+    \n+    def test_foreign_key_without_target_collation(self):\n+        \"\"\"\n+        Test that foreign keys work normally when target field has no db_collation.\n+        This ensures we don't break existing functionality.\n+        \"\"\"\n+        class SimpleAccount(models.Model):\n+            id = models.CharField(primary_key=True, max_length=22)\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_simple_account'\n+        \n+        class SimpleProfile(models.Model):\n+            account = models.ForeignKey(SimpleAccount, on_delete=models.CASCADE)\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_simple_profile'\n+        \n+        # Test that db_parameters work without collation\n+        account_field = SimpleAccount._meta.get_field('id')\n+        profile_field = SimpleProfile._meta.get_field('account')\n+        \n+        account_params = account_field.db_parameters(connection)\n+        fk_params = profile_field.db_parameters(connection)\n+        \n+        # Both should have no collation\n+        self.assertIsNone(account_params.get('collation'))\n+        self.assertIsNone(fk_params.get('collation'))\n+        \n+        # db_type should still work\n+        self.assertIsNotNone(profile_field.db_type(connection))\n+    \n+    @skipUnlessDBFeature('supports_collation_on_charfield')\n+    def test_multiple_foreign_keys_same_target(self):\n+        \"\"\"\n+        Test that multiple foreign keys to the same target all inherit the collation.\n+        \"\"\"\n+        class Account(models.Model):\n+            id = models.CharField(\n+                primary_key=True,\n+                max_length=22,\n+                db_collation='utf8_bin'\n+            )\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_account'\n+        \n+        class Profile(models.Model):\n+            account = models.ForeignKey(Account, on_delete=models.CASCADE, related_name='profiles')\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_profile'\n+        \n+        class Address(models.Model):\n+            account = models.ForeignKey(Account, on_delete=models.CASCADE, related_name='addresses')\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_address'\n+        \n+        # Both foreign keys should inherit the same collation\n+        profile_fk = Profile._meta.get_field('account')\n+        address_fk = Address._meta.get_field('account')\n+        \n+        profile_params = profile_fk.db_parameters(connection)\n+        address_params = address_fk.db_parameters(connection)\n+        \n+        self.assertEqual(\n+            profile_params.get('collation'),\n+            address_params.get('collation'),\n+            \"All foreign keys to same target should have same collation\"\n+        )\n+        \n+        if connection.vendor == 'mysql':\n+            self.assertEqual(profile_params.get('collation'), 'utf8_bin')\n+            self.assertEqual(address_params.get('collation'), 'utf8_bin')\n+    \n+    @skipUnlessDBFeature('supports_collation_on_charfield')\n+    def test_foreign_key_to_non_primary_key_with_collation(self):\n+        \"\"\"\n+        Test foreign key to a non-primary key field that has db_collation.\n+        \"\"\"\n+        class Account(models.Model):\n+            id = models.AutoField(primary_key=True)\n+            code = models.CharField(\n+                max_length=22,\n+                unique=True,\n+                db_collation='utf8_bin'\n+            )\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_account'\n+        \n+        class Profile(models.Model):\n+            account = models.ForeignKey(\n+                Account,\n+                to_field='code',\n+                on_delete=models.CASCADE\n+            )\n+            \n+            class Meta:\n+                app_label = 'tests'\n+                db_table = 'test_profile'\n+        \n+        # Foreign key should inherit collation from the target field (code)\n+        account_code_field = Account._meta.get_field('code')\n+        profile_fk_field = Profile._meta.get_field('account')\n+        \n+        code_params = account_code_field.db_parameters(connection)\n+        fk_params = profile_fk_field.db_parameters(connection)\n+        \n+        self.assertEqual(\n+            code_params.get('collation'),\n+            fk_params.get('collation'),\n+            \"Foreign key should inherit collation from non-primary target field\"\n+        )\n+\n+\n+@isolate_apps('tests.schema')\n+class TestDbCollationMigrationGeneration(TestCase):\n+    \"\"\"\n+    Test that migration generation properly handles db_collation propagation.\n+    \"\"\"\n+    \n+    def test_migration_detects_collation_changes(self):\n+        \"\"\"\n+        Test that the migration autodetector properly handles collation changes\n+        that affect foreign key fields.\n+        \"\"\"\n+        # This test ensures that when we change a primary key's collation,\n+        # the migration system understands that related foreign keys also need updating\n+        \n+        # Create initial state\n+        class Account(models.Model):\n+            id = models.CharField(primary_key=True, max_length=22)\n+            \n+            class Meta:\n+                app_label = 'tests'\n+        \n+        class Profile(models.Model):\n+            account = models.ForeignKey(Account, on_delete=models.CASCADE)\n+            \n+            class Meta:\n+                app_label = 'tests'\n+        \n+        # Create new state with collation\n+        class AccountWithCollation(models.Model):\n+            id = models.CharField(\n+                primary_key=True,\n+                max_length=22,\n+                db_collation='utf8_bin'\n+            )\n+            \n+            class Meta:\n+                app_label = 'tests'\n+        \n+        class ProfileWithCollation(models.Model):\n+            account = models.ForeignKey(AccountWithCollation, on_delete=models.CASCADE)\n+            \n+            class Meta:\n+                app_label = 'tests'\n+        \n+        # Test that the foreign key field properly reflects the target field's properties\n+        old_fk_field = Profile._meta.get_field('account')\n+        new_fk_field = ProfileWithCollation._meta.get_field('account')\n+        \n+        # The target field should be different\n+        old_target = old_fk_field.target_field\n+        new_target = new_fk_field.target_field\n+        \n+        old_target_params = old_target.db_parameters(connection)\n+        new_target_params = new_target.db_parameters(connection)\n+        \n+        # Verify the target field collation changed\n+        self.assertNotEqual(\n+            old_target_params.get('collation'),\n+            new_target_params.get('collation')\n+        )\n+        \n+        # Verify the foreign key field reflects this change\n+        old_fk_params = old_fk_field.db_parameters(connection)\n+        new_fk_params = new_fk_field.db_parameters(connection)\n+        \n+        self.assertEqual(\n+            new_target_params.get('collation'),\n+            new_fk_params.get('collation'),\n+            \"Foreign key should inherit new target field collation\"\n+        )\n"
}