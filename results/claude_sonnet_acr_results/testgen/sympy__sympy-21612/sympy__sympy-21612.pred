{
  "instance_id": "sympy__sympy-21612",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>sympy/parsing/latex/tests/test_latex_fraction_parsing.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom sympy.parsing.latex import parse_latex\nfrom sympy import symbols, Mul, Pow, Add\nfrom sympy.testing.pytest import XFAIL\n\n\ndef test_nested_fraction_parsing_basic():\n    \"\"\"Test basic nested fraction parsing to reproduce the bug.\"\"\"\n    # This is the problematic case from the issue\n    latex_expr = r\"\\frac{\\frac{a^3+b}{c}}{\\frac{1}{c^2}}\"\n    result = parse_latex(latex_expr)\n    \n    # The current buggy result would be: ((a**3 + b)/c)/1/(c**2)\n    # The expected correct result should be: ((a**3 + b)/c)/(1/(c**2))\n    \n    # Let's verify the structure - this test will fail before the fix\n    a, b, c = symbols('a b c')\n    \n    # Expected structure: ((a**3 + b)/c) / (1/c**2)\n    # Which should be equivalent to: ((a**3 + b)/c) * (c**2/1) = (a**3 + b) * c\n    expected = (a**3 + b) * c\n    \n    # The result should simplify to the expected form\n    simplified_result = result.simplify()\n    assert simplified_result == expected, f\"Expected {expected}, got {simplified_result}\"\n\n\ndef test_nested_fraction_parsing_structure():\n    \"\"\"Test that nested fractions maintain proper structure before simplification.\"\"\"\n    latex_expr = r\"\\frac{\\frac{a^3+b}{c}}{\\frac{1}{c^2}}\"\n    result = parse_latex(latex_expr)\n    \n    a, b, c = symbols('a b c')\n    \n    # Check that the result has the correct structure\n    # It should be a Mul with the numerator and the inverse of the denominator\n    assert isinstance(result, Mul), f\"Expected Mul, got {type(result)}\"\n    \n    # The string representation should show proper parenthesization\n    result_str = str(result)\n    \n    # This test documents the current buggy behavior\n    # Before fix: \"((a**3 + b)/c)/1/(c**2)\"\n    # After fix should be: \"((a**3 + b)/c)/(1/(c**2))\" or equivalent\n    \n    # For now, let's just ensure we can parse it without errors\n    assert result is not None\n\n\ndef test_simple_fraction_parsing():\n    \"\"\"Test that simple fractions still work correctly.\"\"\"\n    latex_expr = r\"\\frac{a}{b}\"\n    result = parse_latex(latex_expr)\n    \n    a, b = symbols('a b')\n    expected = a / b\n    \n    assert result.equals(expected), f\"Expected {expected}, got {result}\"\n\n\ndef test_fraction_with_complex_numerator():\n    \"\"\"Test fractions with complex numerators work correctly.\"\"\"\n    latex_expr = r\"\\frac{a^2 + b^2}{c}\"\n    result = parse_latex(latex_expr)\n    \n    a, b, c = symbols('a b c')\n    expected = (a**2 + b**2) / c\n    \n    assert result.equals(expected), f\"Expected {expected}, got {result}\"\n\n\ndef test_fraction_with_complex_denominator():\n    \"\"\"Test fractions with complex denominators work correctly.\"\"\"\n    latex_expr = r\"\\frac{a}{b + c}\"\n    result = parse_latex(latex_expr)\n    \n    a, b, c = symbols('a b c')\n    expected = a / (b + c)\n    \n    assert result.equals(expected), f\"Expected {expected}, got {result}\"\n\n\ndef test_multiple_nested_fractions():\n    \"\"\"Test more complex nested fraction scenarios.\"\"\"\n    latex_expr = r\"\\frac{\\frac{a}{b}}{\\frac{c}{d}}\"\n    result = parse_latex(latex_expr)\n    \n    a, b, c, d = symbols('a b c d')\n    # This should be (a/b) / (c/d) = (a/b) * (d/c) = a*d/(b*c)\n    expected = (a * d) / (b * c)\n    \n    simplified_result = result.simplify()\n    assert simplified_result.equals(expected), f\"Expected {expected}, got {simplified_result}\"\n\n\ndef test_triple_nested_fractions():\n    \"\"\"Test even more complex nested fractions.\"\"\"\n    latex_expr = r\"\\frac{a}{\\frac{\\frac{b}{c}}{d}}\"\n    result = parse_latex(latex_expr)\n    \n    a, b, c, d = symbols('a b c d')\n    # This should be a / ((b/c)/d) = a / (b/(c*d)) = a * (c*d)/b = a*c*d/b\n    expected = (a * c * d) / b\n    \n    simplified_result = result.simplify()\n    assert simplified_result.equals(expected), f\"Expected {expected}, got {simplified_result}\"\n\n\n@XFAIL\ndef test_nested_fraction_string_representation():\n    \"\"\"Test that the string representation of nested fractions is correct.\n    \n    This test is expected to fail before the fix is applied.\n    \"\"\"\n    latex_expr = r\"\\frac{\\frac{a^3+b}{c}}{\\frac{1}{c^2}}\"\n    result = parse_latex(latex_expr)\n    \n    result_str = str(result)\n    \n    # The correct representation should have proper parentheses\n    # It should NOT be: \"((a**3 + b)/c)/1/(c**2)\"\n    # It should be something like: \"((a**3 + b)/c)/(1/(c**2))\" or equivalent\n    \n    # Check that we don't have the buggy pattern\n    assert \")/1/(\" not in result_str, f\"Found buggy pattern in: {result_str}\"\n\n\ndef test_fraction_parsing_edge_cases():\n    \"\"\"Test various edge cases for fraction parsing.\"\"\"\n    test_cases = [\n        (r\"\\frac{1}{2}\", \"1/2\"),\n        (r\"\\frac{x}{y}\", \"x/y\"),\n        (r\"\\frac{x+1}{y-1}\", \"(x+1)/(y-1)\"),\n        (r\"\\frac{\\frac{1}{2}}{3}\", \"1/6\"),  # Should be (1/2)/3 = 1/6\n        (r\"\\frac{1}{\\frac{2}{3}}\", \"3/2\"),  # Should be 1/(2/3) = 3/2\n    ]\n    \n    for latex_expr, expected_simplified in test_cases:\n        result = parse_latex(latex_expr)\n        # Just ensure parsing doesn't crash\n        assert result is not None, f\"Failed to parse: {latex_expr}\"\n\n\ndef test_nested_fraction_mathematical_correctness():\n    \"\"\"Test that nested fractions produce mathematically correct results.\"\"\"\n    # Test case: (2/3) / (4/5) should equal (2/3) * (5/4) = 10/12 = 5/6\n    latex_expr = r\"\\frac{\\frac{2}{3}}{\\frac{4}{5}}\"\n    result = parse_latex(latex_expr)\n    \n    from sympy import Rational\n    expected = Rational(5, 6)\n    \n    simplified_result = result.simplify()\n    assert simplified_result == expected, f\"Expected {expected}, got {simplified_result}\"\n\n\ndef test_nested_fraction_with_variables_and_numbers():\n    \"\"\"Test nested fractions mixing variables and numbers.\"\"\"\n    latex_expr = r\"\\frac{\\frac{x}{2}}{\\frac{3}{y}}\"\n    result = parse_latex(latex_expr)\n    \n    x, y = symbols('x y')\n    # This should be (x/2) / (3/y) = (x/2) * (y/3) = x*y/6\n    expected = (x * y) / 6\n    \n    simplified_result = result.simplify()\n    assert simplified_result.equals(expected), f\"Expected {expected}, got {simplified_result}\"\n</patched>\n```",
  "patch": "--- a/sympy/parsing/latex/tests/test_latex_fraction_parsing.py\n+++ b/sympy/parsing/latex/tests/test_latex_fraction_parsing.py\n-# Empty if creating new file\n+import pytest\n+from sympy.parsing.latex import parse_latex\n+from sympy import symbols, Mul, Pow, Add\n+from sympy.testing.pytest import XFAIL\n+\n+\n+def test_nested_fraction_parsing_basic():\n+    \"\"\"Test basic nested fraction parsing to reproduce the bug.\"\"\"\n+    # This is the problematic case from the issue\n+    latex_expr = r\"\\frac{\\frac{a^3+b}{c}}{\\frac{1}{c^2}}\"\n+    result = parse_latex(latex_expr)\n+    \n+    # The current buggy result would be: ((a**3 + b)/c)/1/(c**2)\n+    # The expected correct result should be: ((a**3 + b)/c)/(1/(c**2))\n+    \n+    # Let's verify the structure - this test will fail before the fix\n+    a, b, c = symbols('a b c')\n+    \n+    # Expected structure: ((a**3 + b)/c) / (1/c**2)\n+    # Which should be equivalent to: ((a**3 + b)/c) * (c**2/1) = (a**3 + b) * c\n+    expected = (a**3 + b) * c\n+    \n+    # The result should simplify to the expected form\n+    simplified_result = result.simplify()\n+    assert simplified_result == expected, f\"Expected {expected}, got {simplified_result}\"\n+\n+\n+def test_nested_fraction_parsing_structure():\n+    \"\"\"Test that nested fractions maintain proper structure before simplification.\"\"\"\n+    latex_expr = r\"\\frac{\\frac{a^3+b}{c}}{\\frac{1}{c^2}}\"\n+    result = parse_latex(latex_expr)\n+    \n+    a, b, c = symbols('a b c')\n+    \n+    # Check that the result has the correct structure\n+    # It should be a Mul with the numerator and the inverse of the denominator\n+    assert isinstance(result, Mul), f\"Expected Mul, got {type(result)}\"\n+    \n+    # The string representation should show proper parenthesization\n+    result_str = str(result)\n+    \n+    # This test documents the current buggy behavior\n+    # Before fix: \"((a**3 + b)/c)/1/(c**2)\"\n+    # After fix should be: \"((a**3 + b)/c)/(1/(c**2))\" or equivalent\n+    \n+    # For now, let's just ensure we can parse it without errors\n+    assert result is not None\n+\n+\n+def test_simple_fraction_parsing():\n+    \"\"\"Test that simple fractions still work correctly.\"\"\"\n+    latex_expr = r\"\\frac{a}{b}\"\n+    result = parse_latex(latex_expr)\n+    \n+    a, b = symbols('a b')\n+    expected = a / b\n+    \n+    assert result.equals(expected), f\"Expected {expected}, got {result}\"\n+\n+\n+def test_fraction_with_complex_numerator():\n+    \"\"\"Test fractions with complex numerators work correctly.\"\"\"\n+    latex_expr = r\"\\frac{a^2 + b^2}{c}\"\n+    result = parse_latex(latex_expr)\n+    \n+    a, b, c = symbols('a b c')\n+    expected = (a**2 + b**2) / c\n+    \n+    assert result.equals(expected), f\"Expected {expected}, got {result}\"\n+\n+\n+def test_fraction_with_complex_denominator():\n+    \"\"\"Test fractions with complex denominators work correctly.\"\"\"\n+    latex_expr = r\"\\frac{a}{b + c}\"\n+    result = parse_latex(latex_expr)\n+    \n+    a, b, c = symbols('a b c')\n+    expected = a / (b + c)\n+    \n+    assert result.equals(expected), f\"Expected {expected}, got {result}\"\n+\n+\n+def test_multiple_nested_fractions():\n+    \"\"\"Test more complex nested fraction scenarios.\"\"\"\n+    latex_expr = r\"\\frac{\\frac{a}{b}}{\\frac{c}{d}}\"\n+    result = parse_latex(latex_expr)\n+    \n+    a, b, c, d = symbols('a b c d')\n+    # This should be (a/b) / (c/d) = (a/b) * (d/c) = a*d/(b*c)\n+    expected = (a * d) / (b * c)\n+    \n+    simplified_result = result.simplify()\n+    assert simplified_result.equals(expected), f\"Expected {expected}, got {simplified_result}\"\n+\n+\n+def test_triple_nested_fractions():\n+    \"\"\"Test even more complex nested fractions.\"\"\"\n+    latex_expr = r\"\\frac{a}{\\frac{\\frac{b}{c}}{d}}\"\n+    result = parse_latex(latex_expr)\n+    \n+    a, b, c, d = symbols('a b c d')\n+    # This should be a / ((b/c)/d) = a / (b/(c*d)) = a * (c*d)/b = a*c*d/b\n+    expected = (a * c * d) / b\n+    \n+    simplified_result = result.simplify()\n+    assert simplified_result.equals(expected), f\"Expected {expected}, got {simplified_result}\"\n+\n+\n+@XFAIL\n+def test_nested_fraction_string_representation():\n+    \"\"\"Test that the string representation of nested fractions is correct.\n+    \n+    This test is expected to fail before the fix is applied.\n+    \"\"\"\n+    latex_expr = r\"\\frac{\\frac{a^3+b}{c}}{\\frac{1}{c^2}}\"\n+    result = parse_latex(latex_expr)\n+    \n+    result_str = str(result)\n+    \n+    # The correct representation should have proper parentheses\n+    # It should NOT be: \"((a**3 + b)/c)/1/(c**2)\"\n+    # It should be something like: \"((a**3 + b)/c)/(1/(c**2))\" or equivalent\n+    \n+    # Check that we don't have the buggy pattern\n+    assert \")/1/(\" not in result_str, f\"Found buggy pattern in: {result_str}\"\n+\n+\n+def test_fraction_parsing_edge_cases():\n+    \"\"\"Test various edge cases for fraction parsing.\"\"\"\n+    test_cases = [\n+        (r\"\\frac{1}{2}\", \"1/2\"),\n+        (r\"\\frac{x}{y}\", \"x/y\"),\n+        (r\"\\frac{x+1}{y-1}\", \"(x+1)/(y-1)\"),\n+        (r\"\\frac{\\frac{1}{2}}{3}\", \"1/6\"),  # Should be (1/2)/3 = 1/6\n+        (r\"\\frac{1}{\\frac{2}{3}}\", \"3/2\"),  # Should be 1/(2/3) = 3/2\n+    ]\n+    \n+    for latex_expr, expected_simplified in test_cases:\n+        result = parse_latex(latex_expr)\n+        # Just ensure parsing doesn't crash\n+        assert result is not None, f\"Failed to parse: {latex_expr}\"\n+\n+\n+def test_nested_fraction_mathematical_correctness():\n+    \"\"\"Test that nested fractions produce mathematically correct results.\"\"\"\n+    # Test case: (2/3) / (4/5) should equal (2/3) * (5/4) = 10/12 = 5/6\n+    latex_expr = r\"\\frac{\\frac{2}{3}}{\\frac{4}{5}}\"\n+    result = parse_latex(latex_expr)\n+    \n+    from sympy import Rational\n+    expected = Rational(5, 6)\n+    \n+    simplified_result = result.simplify()\n+    assert simplified_result == expected, f\"Expected {expected}, got {simplified_result}\"\n+\n+\n+def test_nested_fraction_with_variables_and_numbers():\n+    \"\"\"Test nested fractions mixing variables and numbers.\"\"\"\n+    latex_expr = r\"\\frac{\\frac{x}{2}}{\\frac{3}{y}}\"\n+    result = parse_latex(latex_expr)\n+    \n+    x, y = symbols('x y')\n+    # This should be (x/2) / (3/y) = (x/2) * (y/3) = x*y/6\n+    expected = (x * y) / 6\n+    \n+    simplified_result = result.simplify()\n+    assert simplified_result.equals(expected), f\"Expected {expected}, got {simplified_result}\"\n"
}