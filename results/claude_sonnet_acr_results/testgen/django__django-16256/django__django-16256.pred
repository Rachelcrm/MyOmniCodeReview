{
  "instance_id": "django__django-16256",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_related_managers_async.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom asgiref.sync import sync_to_async\nfrom django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.db import models\nfrom django.test import TestCase, TransactionTestCase\n\n\n# Test models for related managers\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'test_related_managers_async'\n\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')\n    \n    class Meta:\n        app_label = 'test_related_managers_async'\n\n\nclass Category(models.Model):\n    name = models.CharField(max_length=100)\n    books = models.ManyToManyField(Book, related_name='categories')\n    \n    class Meta:\n        app_label = 'test_related_managers_async'\n\n\nclass Tag(models.Model):\n    name = models.CharField(max_length=100)\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    content_object = GenericForeignKey('content_type', 'object_id')\n    \n    class Meta:\n        app_label = 'test_related_managers_async'\n\n\nclass TaggedItem(models.Model):\n    name = models.CharField(max_length=100)\n    tags = GenericRelation(Tag)\n    \n    class Meta:\n        app_label = 'test_related_managers_async'\n\n\n@pytest.mark.django_db\nclass TestRelatedManagersAsync:\n    \"\"\"Test async methods on related managers work correctly.\"\"\"\n    \n    @pytest.fixture\n    def author(self):\n        return Author.objects.create(name=\"Test Author\")\n    \n    @pytest.fixture\n    def book(self, author):\n        return Book.objects.create(title=\"Test Book\", author=author)\n    \n    @pytest.fixture\n    def category(self):\n        return Category.objects.create(name=\"Test Category\")\n    \n    @pytest.fixture\n    def tagged_item(self):\n        return TaggedItem.objects.create(name=\"Test Item\")\n\n    @pytest.mark.asyncio\n    async def test_reverse_foreign_key_acreate_calls_manager_create(self, author):\n        \"\"\"Test that acreate on reverse FK manager calls the manager's create method.\"\"\"\n        # This should call the related manager's create method, not QuerySet's\n        book = await author.books.acreate(title=\"Async Book\")\n        \n        # Verify the book was created with the correct foreign key\n        assert book.title == \"Async Book\"\n        assert book.author == author\n        assert book.author_id == author.id\n        \n        # Verify it was actually saved to the database\n        saved_book = await sync_to_async(Book.objects.get)(id=book.id)\n        assert saved_book.title == \"Async Book\"\n        assert saved_book.author == author\n\n    @pytest.mark.asyncio\n    async def test_reverse_foreign_key_aget_or_create_calls_manager_method(self, author):\n        \"\"\"Test that aget_or_create on reverse FK manager calls the manager's method.\"\"\"\n        # Create a book first\n        existing_book = await author.books.acreate(title=\"Existing Book\")\n        \n        # Test get_or_create with existing object\n        book, created = await author.books.aget_or_create(title=\"Existing Book\")\n        assert not created\n        assert book.id == existing_book.id\n        assert book.author == author\n        \n        # Test get_or_create with new object\n        new_book, created = await author.books.aget_or_create(title=\"New Book\")\n        assert created\n        assert new_book.title == \"New Book\"\n        assert new_book.author == author\n        assert new_book.author_id == author.id\n\n    @pytest.mark.asyncio\n    async def test_reverse_foreign_key_aupdate_or_create_calls_manager_method(self, author):\n        \"\"\"Test that aupdate_or_create on reverse FK manager calls the manager's method.\"\"\"\n        # Test update_or_create with new object\n        book, created = await author.books.aupdate_or_create(\n            title=\"Test Book\",\n            defaults={'title': 'Updated Book'}\n        )\n        assert created\n        assert book.title == \"Test Book\"  # defaults not used when creating\n        assert book.author == author\n        assert book.author_id == author.id\n        \n        # Test update_or_create with existing object\n        updated_book, created = await author.books.aupdate_or_create(\n            title=\"Test Book\",\n            defaults={'title': 'Updated Book'}\n        )\n        assert not created\n        assert updated_book.id == book.id\n        assert updated_book.title == \"Updated Book\"  # defaults used when updating\n        assert updated_book.author == author\n\n    @pytest.mark.asyncio\n    async def test_many_to_many_acreate_calls_manager_create(self, category):\n        \"\"\"Test that acreate on M2M manager calls the manager's create method.\"\"\"\n        # This should call the related manager's create method, not QuerySet's\n        book = await category.books.acreate(title=\"M2M Book\", author_id=1)\n        \n        # Verify the book was created\n        assert book.title == \"M2M Book\"\n        \n        # Verify the M2M relationship was established\n        books_in_category = await sync_to_async(list)(category.books.all())\n        assert book in books_in_category\n\n    @pytest.mark.asyncio\n    async def test_many_to_many_aget_or_create_calls_manager_method(self, category, author):\n        \"\"\"Test that aget_or_create on M2M manager calls the manager's method.\"\"\"\n        # Create a book first and add to category\n        existing_book = await sync_to_async(Book.objects.create)(title=\"Existing M2M Book\", author=author)\n        await sync_to_async(category.books.add)(existing_book)\n        \n        # Test get_or_create with existing object\n        book, created = await category.books.aget_or_create(title=\"Existing M2M Book\", author=author)\n        assert not created\n        assert book.id == existing_book.id\n        \n        # Verify the M2M relationship exists\n        books_in_category = await sync_to_async(list)(category.books.all())\n        assert book in books_in_category\n        \n        # Test get_or_create with new object\n        new_book, created = await category.books.aget_or_create(title=\"New M2M Book\", author=author)\n        assert created\n        assert new_book.title == \"New M2M Book\"\n        \n        # Verify the M2M relationship was established\n        books_in_category = await sync_to_async(list)(category.books.all())\n        assert new_book in books_in_category\n\n    @pytest.mark.asyncio\n    async def test_many_to_many_aupdate_or_create_calls_manager_method(self, category, author):\n        \"\"\"Test that aupdate_or_create on M2M manager calls the manager's method.\"\"\"\n        # Test update_or_create with new object\n        book, created = await category.books.aupdate_or_create(\n            title=\"M2M Test Book\",\n            author=author,\n            defaults={'title': 'M2M Updated Book'}\n        )\n        assert created\n        assert book.title == \"M2M Test Book\"  # defaults not used when creating\n        \n        # Verify the M2M relationship was established\n        books_in_category = await sync_to_async(list)(category.books.all())\n        assert book in books_in_category\n        \n        # Test update_or_create with existing object\n        updated_book, created = await category.books.aupdate_or_create(\n            title=\"M2M Test Book\",\n            author=author,\n            defaults={'title': 'M2M Updated Book'}\n        )\n        assert not created\n        assert updated_book.id == book.id\n        assert updated_book.title == \"M2M Updated Book\"  # defaults used when updating\n\n    @pytest.mark.asyncio\n    async def test_generic_foreign_key_acreate_calls_manager_create(self, tagged_item):\n        \"\"\"Test that acreate on generic FK manager calls the manager's create method.\"\"\"\n        # This should call the related manager's create method, not QuerySet's\n        tag = await tagged_item.tags.acreate(name=\"Async Tag\")\n        \n        # Verify the tag was created with correct generic FK fields\n        assert tag.name == \"Async Tag\"\n        assert tag.content_object == tagged_item\n        assert tag.object_id == tagged_item.id\n        assert tag.content_type == ContentType.objects.get_for_model(TaggedItem)\n\n    @pytest.mark.asyncio\n    async def test_generic_foreign_key_aget_or_create_calls_manager_method(self, tagged_item):\n        \"\"\"Test that aget_or_create on generic FK manager calls the manager's method.\"\"\"\n        # Create a tag first\n        existing_tag = await tagged_item.tags.acreate(name=\"Existing Tag\")\n        \n        # Test get_or_create with existing object\n        tag, created = await tagged_item.tags.aget_or_create(name=\"Existing Tag\")\n        assert not created\n        assert tag.id == existing_tag.id\n        assert tag.content_object == tagged_item\n        \n        # Test get_or_create with new object\n        new_tag, created = await tagged_item.tags.aget_or_create(name=\"New Tag\")\n        assert created\n        assert new_tag.name == \"New Tag\"\n        assert new_tag.content_object == tagged_item\n        assert new_tag.object_id == tagged_item.id\n\n    @pytest.mark.asyncio\n    async def test_generic_foreign_key_aupdate_or_create_calls_manager_method(self, tagged_item):\n        \"\"\"Test that aupdate_or_create on generic FK manager calls the manager's method.\"\"\"\n        # Test update_or_create with new object\n        tag, created = await tagged_item.tags.aupdate_or_create(\n            name=\"Generic Test Tag\",\n            defaults={'name': 'Generic Updated Tag'}\n        )\n        assert created\n        assert tag.name == \"Generic Test Tag\"  # defaults not used when creating\n        assert tag.content_object == tagged_item\n        assert tag.object_id == tagged_item.id\n        \n        # Test update_or_create with existing object\n        updated_tag, created = await tagged_item.tags.aupdate_or_create(\n            name=\"Generic Test Tag\",\n            defaults={'name': 'Generic Updated Tag'}\n        )\n        assert not created\n        assert updated_tag.id == tag.id\n        assert updated_tag.name == \"Generic Updated Tag\"  # defaults used when updating\n        assert updated_tag.content_object == tagged_item\n\n    @pytest.mark.asyncio\n    async def test_async_methods_preserve_database_routing(self, author):\n        \"\"\"Test that async methods on related managers preserve database routing.\"\"\"\n        # This test ensures that the database routing logic in related managers\n        # is preserved when using async methods\n        book = await author.books.acreate(title=\"DB Routing Test\")\n        \n        # The book should be created with the correct database routing\n        # (in this case, default database, but the routing logic should be called)\n        assert book.title == \"DB Routing Test\"\n        assert book.author == author\n\n    @pytest.mark.asyncio\n    async def test_async_methods_with_through_defaults(self, category, author):\n        \"\"\"Test that async methods work with through_defaults for M2M relationships.\"\"\"\n        # Create a book and test through_defaults functionality\n        book, created = await category.books.aget_or_create(\n            title=\"Through Defaults Book\",\n            author=author,\n            through_defaults={}  # Empty through_defaults should work\n        )\n        assert created\n        assert book.title == \"Through Defaults Book\"\n        \n        # Verify the M2M relationship was established\n        books_in_category = await sync_to_async(list)(category.books.all())\n        assert book in books_in_category\n\n\n@pytest.mark.django_db\nclass TestAsyncMethodsBugReproduction:\n    \"\"\"Test cases that reproduce the original bug before the fix.\"\"\"\n    \n    @pytest.fixture\n    def author(self):\n        return Author.objects.create(name=\"Bug Test Author\")\n\n    @pytest.mark.asyncio\n    async def test_acreate_without_fix_would_fail_foreign_key_assignment(self, author):\n        \"\"\"\n        This test demonstrates the bug: without the fix, acreate would call\n        QuerySet.create() instead of the related manager's create(), which\n        would not set the foreign key properly.\n        \"\"\"\n        # With the fix, this should work correctly\n        book = await author.books.acreate(title=\"Bug Test Book\")\n        \n        # The foreign key should be set correctly\n        assert book.author == author\n        assert book.author_id == author.id\n        \n        # Verify it was saved to the database with the correct FK\n        saved_book = await sync_to_async(Book.objects.get)(id=book.id)\n        assert saved_book.author_id == author.id\n\n    @pytest.mark.asyncio\n    async def test_aget_or_create_without_fix_would_fail_foreign_key_assignment(self, author):\n        \"\"\"\n        This test demonstrates the bug: without the fix, aget_or_create would call\n        QuerySet.get_or_create() instead of the related manager's get_or_create(),\n        which would not set the foreign key properly.\n        \"\"\"\n        # With the fix, this should work correctly\n        book, created = await author.books.aget_or_create(title=\"Bug Test Book 2\")\n        \n        assert created\n        # The foreign key should be set correctly\n        assert book.author == author\n        assert book.author_id == author.id\n\n    @pytest.mark.asyncio\n    async def test_aupdate_or_create_without_fix_would_fail_foreign_key_assignment(self, author):\n        \"\"\"\n        This test demonstrates the bug: without the fix, aupdate_or_create would call\n        QuerySet.update_or_create() instead of the related manager's update_or_create(),\n        which would not set the foreign key properly.\n        \"\"\"\n        # With the fix, this should work correctly\n        book, created = await author.books.aupdate_or_create(\n            title=\"Bug Test Book 3\",\n            defaults={'title': 'Updated Bug Test Book 3'}\n        )\n        \n        assert created\n        # The foreign key should be set correctly\n        assert book.author == author\n        assert book.author_id == author.id\n</patched>\n```",
  "patch": "--- a/tests/test_related_managers_async.py\n+++ b/tests/test_related_managers_async.py\n-# Empty if creating new file\n+import pytest\n+from asgiref.sync import sync_to_async\n+from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation\n+from django.contrib.contenttypes.models import ContentType\n+from django.db import models\n+from django.test import TestCase, TransactionTestCase\n+\n+\n+# Test models for related managers\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_related_managers_async'\n+\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')\n+    \n+    class Meta:\n+        app_label = 'test_related_managers_async'\n+\n+\n+class Category(models.Model):\n+    name = models.CharField(max_length=100)\n+    books = models.ManyToManyField(Book, related_name='categories')\n+    \n+    class Meta:\n+        app_label = 'test_related_managers_async'\n+\n+\n+class Tag(models.Model):\n+    name = models.CharField(max_length=100)\n+    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n+    object_id = models.PositiveIntegerField()\n+    content_object = GenericForeignKey('content_type', 'object_id')\n+    \n+    class Meta:\n+        app_label = 'test_related_managers_async'\n+\n+\n+class TaggedItem(models.Model):\n+    name = models.CharField(max_length=100)\n+    tags = GenericRelation(Tag)\n+    \n+    class Meta:\n+        app_label = 'test_related_managers_async'\n+\n+\n+@pytest.mark.django_db\n+class TestRelatedManagersAsync:\n+    \"\"\"Test async methods on related managers work correctly.\"\"\"\n+    \n+    @pytest.fixture\n+    def author(self):\n+        return Author.objects.create(name=\"Test Author\")\n+    \n+    @pytest.fixture\n+    def book(self, author):\n+        return Book.objects.create(title=\"Test Book\", author=author)\n+    \n+    @pytest.fixture\n+    def category(self):\n+        return Category.objects.create(name=\"Test Category\")\n+    \n+    @pytest.fixture\n+    def tagged_item(self):\n+        return TaggedItem.objects.create(name=\"Test Item\")\n+\n+    @pytest.mark.asyncio\n+    async def test_reverse_foreign_key_acreate_calls_manager_create(self, author):\n+        \"\"\"Test that acreate on reverse FK manager calls the manager's create method.\"\"\"\n+        # This should call the related manager's create method, not QuerySet's\n+        book = await author.books.acreate(title=\"Async Book\")\n+        \n+        # Verify the book was created with the correct foreign key\n+        assert book.title == \"Async Book\"\n+        assert book.author == author\n+        assert book.author_id == author.id\n+        \n+        # Verify it was actually saved to the database\n+        saved_book = await sync_to_async(Book.objects.get)(id=book.id)\n+        assert saved_book.title == \"Async Book\"\n+        assert saved_book.author == author\n+\n+    @pytest.mark.asyncio\n+    async def test_reverse_foreign_key_aget_or_create_calls_manager_method(self, author):\n+        \"\"\"Test that aget_or_create on reverse FK manager calls the manager's method.\"\"\"\n+        # Create a book first\n+        existing_book = await author.books.acreate(title=\"Existing Book\")\n+        \n+        # Test get_or_create with existing object\n+        book, created = await author.books.aget_or_create(title=\"Existing Book\")\n+        assert not created\n+        assert book.id == existing_book.id\n+        assert book.author == author\n+        \n+        # Test get_or_create with new object\n+        new_book, created = await author.books.aget_or_create(title=\"New Book\")\n+        assert created\n+        assert new_book.title == \"New Book\"\n+        assert new_book.author == author\n+        assert new_book.author_id == author.id\n+\n+    @pytest.mark.asyncio\n+    async def test_reverse_foreign_key_aupdate_or_create_calls_manager_method(self, author):\n+        \"\"\"Test that aupdate_or_create on reverse FK manager calls the manager's method.\"\"\"\n+        # Test update_or_create with new object\n+        book, created = await author.books.aupdate_or_create(\n+            title=\"Test Book\",\n+            defaults={'title': 'Updated Book'}\n+        )\n+        assert created\n+        assert book.title == \"Test Book\"  # defaults not used when creating\n+        assert book.author == author\n+        assert book.author_id == author.id\n+        \n+        # Test update_or_create with existing object\n+        updated_book, created = await author.books.aupdate_or_create(\n+            title=\"Test Book\",\n+            defaults={'title': 'Updated Book'}\n+        )\n+        assert not created\n+        assert updated_book.id == book.id\n+        assert updated_book.title == \"Updated Book\"  # defaults used when updating\n+        assert updated_book.author == author\n+\n+    @pytest.mark.asyncio\n+    async def test_many_to_many_acreate_calls_manager_create(self, category):\n+        \"\"\"Test that acreate on M2M manager calls the manager's create method.\"\"\"\n+        # This should call the related manager's create method, not QuerySet's\n+        book = await category.books.acreate(title=\"M2M Book\", author_id=1)\n+        \n+        # Verify the book was created\n+        assert book.title == \"M2M Book\"\n+        \n+        # Verify the M2M relationship was established\n+        books_in_category = await sync_to_async(list)(category.books.all())\n+        assert book in books_in_category\n+\n+    @pytest.mark.asyncio\n+    async def test_many_to_many_aget_or_create_calls_manager_method(self, category, author):\n+        \"\"\"Test that aget_or_create on M2M manager calls the manager's method.\"\"\"\n+        # Create a book first and add to category\n+        existing_book = await sync_to_async(Book.objects.create)(title=\"Existing M2M Book\", author=author)\n+        await sync_to_async(category.books.add)(existing_book)\n+        \n+        # Test get_or_create with existing object\n+        book, created = await category.books.aget_or_create(title=\"Existing M2M Book\", author=author)\n+        assert not created\n+        assert book.id == existing_book.id\n+        \n+        # Verify the M2M relationship exists\n+        books_in_category = await sync_to_async(list)(category.books.all())\n+        assert book in books_in_category\n+        \n+        # Test get_or_create with new object\n+        new_book, created = await category.books.aget_or_create(title=\"New M2M Book\", author=author)\n+        assert created\n+        assert new_book.title == \"New M2M Book\"\n+        \n+        # Verify the M2M relationship was established\n+        books_in_category = await sync_to_async(list)(category.books.all())\n+        assert new_book in books_in_category\n+\n+    @pytest.mark.asyncio\n+    async def test_many_to_many_aupdate_or_create_calls_manager_method(self, category, author):\n+        \"\"\"Test that aupdate_or_create on M2M manager calls the manager's method.\"\"\"\n+        # Test update_or_create with new object\n+        book, created = await category.books.aupdate_or_create(\n+            title=\"M2M Test Book\",\n+            author=author,\n+            defaults={'title': 'M2M Updated Book'}\n+        )\n+        assert created\n+        assert book.title == \"M2M Test Book\"  # defaults not used when creating\n+        \n+        # Verify the M2M relationship was established\n+        books_in_category = await sync_to_async(list)(category.books.all())\n+        assert book in books_in_category\n+        \n+        # Test update_or_create with existing object\n+        updated_book, created = await category.books.aupdate_or_create(\n+            title=\"M2M Test Book\",\n+            author=author,\n+            defaults={'title': 'M2M Updated Book'}\n+        )\n+        assert not created\n+        assert updated_book.id == book.id\n+        assert updated_book.title == \"M2M Updated Book\"  # defaults used when updating\n+\n+    @pytest.mark.asyncio\n+    async def test_generic_foreign_key_acreate_calls_manager_create(self, tagged_item):\n+        \"\"\"Test that acreate on generic FK manager calls the manager's create method.\"\"\"\n+        # This should call the related manager's create method, not QuerySet's\n+        tag = await tagged_item.tags.acreate(name=\"Async Tag\")\n+        \n+        # Verify the tag was created with correct generic FK fields\n+        assert tag.name == \"Async Tag\"\n+        assert tag.content_object == tagged_item\n+        assert tag.object_id == tagged_item.id\n+        assert tag.content_type == ContentType.objects.get_for_model(TaggedItem)\n+\n+    @pytest.mark.asyncio\n+    async def test_generic_foreign_key_aget_or_create_calls_manager_method(self, tagged_item):\n+        \"\"\"Test that aget_or_create on generic FK manager calls the manager's method.\"\"\"\n+        # Create a tag first\n+        existing_tag = await tagged_item.tags.acreate(name=\"Existing Tag\")\n+        \n+        # Test get_or_create with existing object\n+        tag, created = await tagged_item.tags.aget_or_create(name=\"Existing Tag\")\n+        assert not created\n+        assert tag.id == existing_tag.id\n+        assert tag.content_object == tagged_item\n+        \n+        # Test get_or_create with new object\n+        new_tag, created = await tagged_item.tags.aget_or_create(name=\"New Tag\")\n+        assert created\n+        assert new_tag.name == \"New Tag\"\n+        assert new_tag.content_object == tagged_item\n+        assert new_tag.object_id == tagged_item.id\n+\n+    @pytest.mark.asyncio\n+    async def test_generic_foreign_key_aupdate_or_create_calls_manager_method(self, tagged_item):\n+        \"\"\"Test that aupdate_or_create on generic FK manager calls the manager's method.\"\"\"\n+        # Test update_or_create with new object\n+        tag, created = await tagged_item.tags.aupdate_or_create(\n+            name=\"Generic Test Tag\",\n+            defaults={'name': 'Generic Updated Tag'}\n+        )\n+        assert created\n+        assert tag.name == \"Generic Test Tag\"  # defaults not used when creating\n+        assert tag.content_object == tagged_item\n+        assert tag.object_id == tagged_item.id\n+        \n+        # Test update_or_create with existing object\n+        updated_tag, created = await tagged_item.tags.aupdate_or_create(\n+            name=\"Generic Test Tag\",\n+            defaults={'name': 'Generic Updated Tag'}\n+        )\n+        assert not created\n+        assert updated_tag.id == tag.id\n+        assert updated_tag.name == \"Generic Updated Tag\"  # defaults used when updating\n+        assert updated_tag.content_object == tagged_item\n+\n+    @pytest.mark.asyncio\n+    async def test_async_methods_preserve_database_routing(self, author):\n+        \"\"\"Test that async methods on related managers preserve database routing.\"\"\"\n+        # This test ensures that the database routing logic in related managers\n+        # is preserved when using async methods\n+        book = await author.books.acreate(title=\"DB Routing Test\")\n+        \n+        # The book should be created with the correct database routing\n+        # (in this case, default database, but the routing logic should be called)\n+        assert book.title == \"DB Routing Test\"\n+        assert book.author == author\n+\n+    @pytest.mark.asyncio\n+    async def test_async_methods_with_through_defaults(self, category, author):\n+        \"\"\"Test that async methods work with through_defaults for M2M relationships.\"\"\"\n+        # Create a book and test through_defaults functionality\n+        book, created = await category.books.aget_or_create(\n+            title=\"Through Defaults Book\",\n+            author=author,\n+            through_defaults={}  # Empty through_defaults should work\n+        )\n+        assert created\n+        assert book.title == \"Through Defaults Book\"\n+        \n+        # Verify the M2M relationship was established\n+        books_in_category = await sync_to_async(list)(category.books.all())\n+        assert book in books_in_category\n+\n+\n+@pytest.mark.django_db\n+class TestAsyncMethodsBugReproduction:\n+    \"\"\"Test cases that reproduce the original bug before the fix.\"\"\"\n+    \n+    @pytest.fixture\n+    def author(self):\n+        return Author.objects.create(name=\"Bug Test Author\")\n+\n+    @pytest.mark.asyncio\n+    async def test_acreate_without_fix_would_fail_foreign_key_assignment(self, author):\n+        \"\"\"\n+        This test demonstrates the bug: without the fix, acreate would call\n+        QuerySet.create() instead of the related manager's create(), which\n+        would not set the foreign key properly.\n+        \"\"\"\n+        # With the fix, this should work correctly\n+        book = await author.books.acreate(title=\"Bug Test Book\")\n+        \n+        # The foreign key should be set correctly\n+        assert book.author == author\n+        assert book.author_id == author.id\n+        \n+        # Verify it was saved to the database with the correct FK\n+        saved_book = await sync_to_async(Book.objects.get)(id=book.id)\n+        assert saved_book.author_id == author.id\n+\n+    @pytest.mark.asyncio\n+    async def test_aget_or_create_without_fix_would_fail_foreign_key_assignment(self, author):\n+        \"\"\"\n+        This test demonstrates the bug: without the fix, aget_or_create would call\n+        QuerySet.get_or_create() instead of the related manager's get_or_create(),\n+        which would not set the foreign key properly.\n+        \"\"\"\n+        # With the fix, this should work correctly\n+        book, created = await author.books.aget_or_create(title=\"Bug Test Book 2\")\n+        \n+        assert created\n+        # The foreign key should be set correctly\n+        assert book.author == author\n+        assert book.author_id == author.id\n+\n+    @pytest.mark.asyncio\n+    async def test_aupdate_or_create_without_fix_would_fail_foreign_key_assignment(self, author):\n+        \"\"\"\n+        This test demonstrates the bug: without the fix, aupdate_or_create would call\n+        QuerySet.update_or_create() instead of the related manager's update_or_create(),\n+        which would not set the foreign key properly.\n+        \"\"\"\n+        # With the fix, this should work correctly\n+        book, created = await author.books.aupdate_or_create(\n+            title=\"Bug Test Book 3\",\n+            defaults={'title': 'Updated Bug Test Book 3'}\n+        )\n+        \n+        assert created\n+        # The foreign key should be set correctly\n+        assert book.author == author\n+        assert book.author_id == author.id\n"
}