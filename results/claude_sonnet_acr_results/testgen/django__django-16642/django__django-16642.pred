{
  "instance_id": "django__django-16642",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/responses/test_fileresponse.py</file>\n<original>\n</original>\n<patched>\nimport io\nimport mimetypes\nimport os\nimport tempfile\nfrom unittest import mock\n\nimport pytest\n\nfrom django.http import FileResponse\n\n\nclass TestFileResponseMimeTypes:\n    \"\"\"Test FileResponse MIME type detection for various file extensions.\"\"\"\n\n    def test_fileresponse_br_extension_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: .br files incorrectly get text/html content type.\n        This test should fail before the fix is applied.\n        \"\"\"\n        # Create a temporary file with .br extension\n        with tempfile.NamedTemporaryFile(suffix='.html.br', delete=False) as tmp_file:\n            tmp_file.write(b'<html><body>Test content</body></html>')\n            tmp_file.flush()\n            \n            try:\n                # Open the file and create FileResponse\n                with open(tmp_file.name, 'rb') as f:\n                    response = FileResponse(f)\n                    \n                # Before fix: this will be 'text/html' (incorrect)\n                # After fix: this should be 'application/x-br' (correct)\n                assert response.headers['Content-Type'] != 'text/html', (\n                    \"FileResponse should not return text/html for .br files\"\n                )\n            finally:\n                os.unlink(tmp_file.name)\n\n    def test_fileresponse_z_extension_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: .Z files incorrectly get text/html content type.\n        This test should fail before the fix is applied.\n        \"\"\"\n        # Create a temporary file with .Z extension\n        with tempfile.NamedTemporaryFile(suffix='.html.Z', delete=False) as tmp_file:\n            tmp_file.write(b'<html><body>Test content</body></html>')\n            tmp_file.flush()\n            \n            try:\n                # Open the file and create FileResponse\n                with open(tmp_file.name, 'rb') as f:\n                    response = FileResponse(f)\n                    \n                # Before fix: this will be 'text/html' (incorrect)\n                # After fix: this should be 'application/x-compress' (correct)\n                assert response.headers['Content-Type'] != 'text/html', (\n                    \"FileResponse should not return text/html for .Z files\"\n                )\n            finally:\n                os.unlink(tmp_file.name)\n\n    def test_fileresponse_br_extension_after_fix(self):\n        \"\"\"\n        Test that .br files get the correct content type after the fix.\n        This test should pass after the fix is applied.\n        \"\"\"\n        # Mock mimetypes.guess_type to return what it actually returns for .br files\n        with mock.patch('mimetypes.guess_type') as mock_guess_type:\n            mock_guess_type.return_value = ('text/html', 'br')\n            \n            # Create a file-like object\n            file_content = b'<html><body>Test content</body></html>'\n            file_obj = io.BytesIO(file_content)\n            file_obj.name = 'test.html.br'\n            \n            response = FileResponse(file_obj)\n            \n            # After fix: should be 'application/x-br'\n            assert response.headers['Content-Type'] == 'application/x-br'\n\n    def test_fileresponse_z_extension_after_fix(self):\n        \"\"\"\n        Test that .Z files get the correct content type after the fix.\n        This test should pass after the fix is applied.\n        \"\"\"\n        # Mock mimetypes.guess_type to return what it actually returns for .Z files\n        with mock.patch('mimetypes.guess_type') as mock_guess_type:\n            mock_guess_type.return_value = ('text/html', 'compress')\n            \n            # Create a file-like object\n            file_content = b'<html><body>Test content</body></html>'\n            file_obj = io.BytesIO(file_content)\n            file_obj.name = 'test.html.Z'\n            \n            response = FileResponse(file_obj)\n            \n            # After fix: should be 'application/x-compress'\n            assert response.headers['Content-Type'] == 'application/x-compress'\n\n    def test_fileresponse_existing_compression_types_still_work(self):\n        \"\"\"\n        Test that existing compression types (gzip, bzip2, xz) still work correctly.\n        This ensures the fix doesn't break existing functionality.\n        \"\"\"\n        test_cases = [\n            ('text/html', 'gzip', 'application/gzip'),\n            ('text/html', 'bzip2', 'application/x-bzip'),\n            ('text/html', 'xz', 'application/x-xz'),\n        ]\n        \n        for content_type, encoding, expected_content_type in test_cases:\n            with mock.patch('mimetypes.guess_type') as mock_guess_type:\n                mock_guess_type.return_value = (content_type, encoding)\n                \n                file_obj = io.BytesIO(b'test content')\n                file_obj.name = f'test.html.{encoding}'\n                \n                response = FileResponse(file_obj)\n                \n                assert response.headers['Content-Type'] == expected_content_type\n\n    def test_fileresponse_no_encoding_preserves_content_type(self):\n        \"\"\"\n        Test that files without compression encoding preserve their original content type.\n        \"\"\"\n        with mock.patch('mimetypes.guess_type') as mock_guess_type:\n            mock_guess_type.return_value = ('text/html', None)\n            \n            file_obj = io.BytesIO(b'<html><body>Test</body></html>')\n            file_obj.name = 'test.html'\n            \n            response = FileResponse(file_obj)\n            \n            assert response.headers['Content-Type'] == 'text/html'\n\n    def test_fileresponse_unknown_encoding_preserves_content_type(self):\n        \"\"\"\n        Test that files with unknown encoding preserve their original content type.\n        \"\"\"\n        with mock.patch('mimetypes.guess_type') as mock_guess_type:\n            mock_guess_type.return_value = ('text/html', 'unknown_encoding')\n            \n            file_obj = io.BytesIO(b'<html><body>Test</body></html>')\n            file_obj.name = 'test.html.unknown'\n            \n            response = FileResponse(file_obj)\n            \n            assert response.headers['Content-Type'] == 'text/html'\n\n    def test_fileresponse_explicit_content_type_not_overridden(self):\n        \"\"\"\n        Test that explicitly set content types are not overridden by the encoding logic.\n        \"\"\"\n        file_obj = io.BytesIO(b'test content')\n        file_obj.name = 'test.html.br'\n        \n        # Explicitly set content type\n        response = FileResponse(file_obj, content_type='application/custom')\n        \n        # Should preserve the explicitly set content type\n        assert response.headers['Content-Type'] == 'application/custom'\n\n    def test_fileresponse_real_file_extensions(self):\n        \"\"\"\n        Test with real file extensions to ensure mimetypes.guess_type behavior is correct.\n        \"\"\"\n        # Test cases with real file extensions and their expected behavior\n        test_cases = [\n            ('test.txt.br', 'application/x-br'),\n            ('test.js.br', 'application/x-br'),\n            ('test.css.br', 'application/x-br'),\n            ('test.html.Z', 'application/x-compress'),\n            ('test.txt.Z', 'application/x-compress'),\n            ('test.js.Z', 'application/x-compress'),\n        ]\n        \n        for filename, expected_content_type in test_cases:\n            file_obj = io.BytesIO(b'test content')\n            file_obj.name = filename\n            \n            response = FileResponse(file_obj)\n            \n            # This test will pass after the fix is applied\n            assert response.headers['Content-Type'] == expected_content_type, (\n                f\"Expected {expected_content_type} for {filename}, \"\n                f\"got {response.headers['Content-Type']}\"\n            )\n\n    def test_fileresponse_edge_cases(self):\n        \"\"\"\n        Test edge cases for the MIME type detection.\n        \"\"\"\n        # Test file without extension\n        file_obj = io.BytesIO(b'test content')\n        file_obj.name = 'test'\n        response = FileResponse(file_obj)\n        assert response.headers['Content-Type'] == 'application/octet-stream'\n        \n        # Test file with only compression extension\n        file_obj = io.BytesIO(b'test content')\n        file_obj.name = 'test.br'\n        response = FileResponse(file_obj)\n        # Should get the content type for .br files after fix\n        assert response.headers['Content-Type'] == 'application/x-br'\n        \n        # Test file with only compression extension (.Z)\n        file_obj = io.BytesIO(b'test content')\n        file_obj.name = 'test.Z'\n        response = FileResponse(file_obj)\n        # Should get the content type for .Z files after fix\n        assert response.headers['Content-Type'] == 'application/x-compress'\n\n    def test_fileresponse_filename_parameter_override(self):\n        \"\"\"\n        Test that the filename parameter in FileResponse constructor affects MIME type detection.\n        \"\"\"\n        # File object without a name\n        file_obj = io.BytesIO(b'test content')\n        \n        # Use filename parameter to specify a .br file\n        response = FileResponse(file_obj, filename='custom.html.br')\n        \n        # Should detect MIME type based on the filename parameter\n        assert response.headers['Content-Type'] == 'application/x-br'\n        \n        # Use filename parameter to specify a .Z file\n        response = FileResponse(file_obj, filename='custom.html.Z')\n        \n        # Should detect MIME type based on the filename parameter\n        assert response.headers['Content-Type'] == 'application/x-compress'\n</patched>\n</file>\n```",
  "patch": "--- a/tests/responses/test_fileresponse.py\n+++ b/tests/responses/test_fileresponse.py\n+import io\n+import mimetypes\n+import os\n+import tempfile\n+from unittest import mock\n+\n+import pytest\n+\n+from django.http import FileResponse\n+\n+\n+class TestFileResponseMimeTypes:\n+    \"\"\"Test FileResponse MIME type detection for various file extensions.\"\"\"\n+\n+    def test_fileresponse_br_extension_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: .br files incorrectly get text/html content type.\n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        # Create a temporary file with .br extension\n+        with tempfile.NamedTemporaryFile(suffix='.html.br', delete=False) as tmp_file:\n+            tmp_file.write(b'<html><body>Test content</body></html>')\n+            tmp_file.flush()\n+            \n+            try:\n+                # Open the file and create FileResponse\n+                with open(tmp_file.name, 'rb') as f:\n+                    response = FileResponse(f)\n+                    \n+                # Before fix: this will be 'text/html' (incorrect)\n+                # After fix: this should be 'application/x-br' (correct)\n+                assert response.headers['Content-Type'] != 'text/html', (\n+                    \"FileResponse should not return text/html for .br files\"\n+                )\n+            finally:\n+                os.unlink(tmp_file.name)\n+\n+    def test_fileresponse_z_extension_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: .Z files incorrectly get text/html content type.\n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        # Create a temporary file with .Z extension\n+        with tempfile.NamedTemporaryFile(suffix='.html.Z', delete=False) as tmp_file:\n+            tmp_file.write(b'<html><body>Test content</body></html>')\n+            tmp_file.flush()\n+            \n+            try:\n+                # Open the file and create FileResponse\n+                with open(tmp_file.name, 'rb') as f:\n+                    response = FileResponse(f)\n+                    \n+                # Before fix: this will be 'text/html' (incorrect)\n+                # After fix: this should be 'application/x-compress' (correct)\n+                assert response.headers['Content-Type'] != 'text/html', (\n+                    \"FileResponse should not return text/html for .Z files\"\n+                )\n+            finally:\n+                os.unlink(tmp_file.name)\n+\n+    def test_fileresponse_br_extension_after_fix(self):\n+        \"\"\"\n+        Test that .br files get the correct content type after the fix.\n+        This test should pass after the fix is applied.\n+        \"\"\"\n+        # Mock mimetypes.guess_type to return what it actually returns for .br files\n+        with mock.patch('mimetypes.guess_type') as mock_guess_type:\n+            mock_guess_type.return_value = ('text/html', 'br')\n+            \n+            # Create a file-like object\n+            file_content = b'<html><body>Test content</body></html>'\n+            file_obj = io.BytesIO(file_content)\n+            file_obj.name = 'test.html.br'\n+            \n+            response = FileResponse(file_obj)\n+            \n+            # After fix: should be 'application/x-br'\n+            assert response.headers['Content-Type'] == 'application/x-br'\n+\n+    def test_fileresponse_z_extension_after_fix(self):\n+        \"\"\"\n+        Test that .Z files get the correct content type after the fix.\n+        This test should pass after the fix is applied.\n+        \"\"\"\n+        # Mock mimetypes.guess_type to return what it actually returns for .Z files\n+        with mock.patch('mimetypes.guess_type') as mock_guess_type:\n+            mock_guess_type.return_value = ('text/html', 'compress')\n+            \n+            # Create a file-like object\n+            file_content = b'<html><body>Test content</body></html>'\n+            file_obj = io.BytesIO(file_content)\n+            file_obj.name = 'test.html.Z'\n+            \n+            response = FileResponse(file_obj)\n+            \n+            # After fix: should be 'application/x-compress'\n+            assert response.headers['Content-Type'] == 'application/x-compress'\n+\n+    def test_fileresponse_existing_compression_types_still_work(self):\n+        \"\"\"\n+        Test that existing compression types (gzip, bzip2, xz) still work correctly.\n+        This ensures the fix doesn't break existing functionality.\n+        \"\"\"\n+        test_cases = [\n+            ('text/html', 'gzip', 'application/gzip'),\n+            ('text/html', 'bzip2', 'application/x-bzip'),\n+            ('text/html', 'xz', 'application/x-xz'),\n+        ]\n+        \n+        for content_type, encoding, expected_content_type in test_cases:\n+            with mock.patch('mimetypes.guess_type') as mock_guess_type:\n+                mock_guess_type.return_value = (content_type, encoding)\n+                \n+                file_obj = io.BytesIO(b'test content')\n+                file_obj.name = f'test.html.{encoding}'\n+                \n+                response = FileResponse(file_obj)\n+                \n+                assert response.headers['Content-Type'] == expected_content_type\n+\n+    def test_fileresponse_no_encoding_preserves_content_type(self):\n+        \"\"\"\n+        Test that files without compression encoding preserve their original content type.\n+        \"\"\"\n+        with mock.patch('mimetypes.guess_type') as mock_guess_type:\n+            mock_guess_type.return_value = ('text/html', None)\n+            \n+            file_obj = io.BytesIO(b'<html><body>Test</body></html>')\n+            file_obj.name = 'test.html'\n+            \n+            response = FileResponse(file_obj)\n+            \n+            assert response.headers['Content-Type'] == 'text/html'\n+\n+    def test_fileresponse_unknown_encoding_preserves_content_type(self):\n+        \"\"\"\n+        Test that files with unknown encoding preserve their original content type.\n+        \"\"\"\n+        with mock.patch('mimetypes.guess_type') as mock_guess_type:\n+            mock_guess_type.return_value = ('text/html', 'unknown_encoding')\n+            \n+            file_obj = io.BytesIO(b'<html><body>Test</body></html>')\n+            file_obj.name = 'test.html.unknown'\n+            \n+            response = FileResponse(file_obj)\n+            \n+            assert response.headers['Content-Type'] == 'text/html'\n+\n+    def test_fileresponse_explicit_content_type_not_overridden(self):\n+        \"\"\"\n+        Test that explicitly set content types are not overridden by the encoding logic.\n+        \"\"\"\n+        file_obj = io.BytesIO(b'test content')\n+        file_obj.name = 'test.html.br'\n+        \n+        # Explicitly set content type\n+        response = FileResponse(file_obj, content_type='application/custom')\n+        \n+        # Should preserve the explicitly set content type\n+        assert response.headers['Content-Type'] == 'application/custom'\n+\n+    def test_fileresponse_real_file_extensions(self):\n+        \"\"\"\n+        Test with real file extensions to ensure mimetypes.guess_type behavior is correct.\n+        \"\"\"\n+        # Test cases with real file extensions and their expected behavior\n+        test_cases = [\n+            ('test.txt.br', 'application/x-br'),\n+            ('test.js.br', 'application/x-br'),\n+            ('test.css.br', 'application/x-br'),\n+            ('test.html.Z', 'application/x-compress'),\n+            ('test.txt.Z', 'application/x-compress'),\n+            ('test.js.Z', 'application/x-compress'),\n+        ]\n+        \n+        for filename, expected_content_type in test_cases:\n+            file_obj = io.BytesIO(b'test content')\n+            file_obj.name = filename\n+            \n+            response = FileResponse(file_obj)\n+            \n+            # This test will pass after the fix is applied\n+            assert response.headers['Content-Type'] == expected_content_type, (\n+                f\"Expected {expected_content_type} for {filename}, \"\n+                f\"got {response.headers['Content-Type']}\"\n+            )\n+\n+    def test_fileresponse_edge_cases(self):\n+        \"\"\"\n+        Test edge cases for the MIME type detection.\n+        \"\"\"\n+        # Test file without extension\n+        file_obj = io.BytesIO(b'test content')\n+        file_obj.name = 'test'\n+        response = FileResponse(file_obj)\n+        assert response.headers['Content-Type'] == 'application/octet-stream'\n+        \n+        # Test file with only compression extension\n+        file_obj = io.BytesIO(b'test content')\n+        file_obj.name = 'test.br'\n+        response = FileResponse(file_obj)\n+        # Should get the content type for .br files after fix\n+        assert response.headers['Content-Type'] == 'application/x-br'\n+        \n+        # Test file with only compression extension (.Z)\n+        file_obj = io.BytesIO(b'test content')\n+        file_obj.name = 'test.Z'\n+        response = FileResponse(file_obj)\n+        # Should get the content type for .Z files after fix\n+        assert response.headers['Content-Type'] == 'application/x-compress'\n+\n+    def test_fileresponse_filename_parameter_override(self):\n+        \"\"\"\n+        Test that the filename parameter in FileResponse constructor affects MIME type detection.\n+        \"\"\"\n+        # File object without a name\n+        file_obj = io.BytesIO(b'test content')\n+        \n+        # Use filename parameter to specify a .br file\n+        response = FileResponse(file_obj, filename='custom.html.br')\n+        \n+        # Should detect MIME type based on the filename parameter\n+        assert response.headers['Content-Type'] == 'application/x-br'\n+        \n+        # Use filename parameter to specify a .Z file\n+        response = FileResponse(file_obj, filename='custom.html.Z')\n+        \n+        # Should detect MIME type based on the filename parameter\n+        assert response.headers['Content-Type'] == 'application/x-compress'\n"
}