{
  "instance_id": "django__django-13128",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/expressions/test_temporal_subtraction.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport datetime\nimport pytest\nfrom django.core.exceptions import FieldError\nfrom django.db import models\nfrom django.db.models import F, Value, ExpressionWrapper\nfrom django.db.models.fields import DurationField, DateTimeField\nfrom django.test import TestCase\nfrom django.test.utils import isolate_apps\n\n\n@isolate_apps('expressions')\nclass TemporalSubtractionTests(TestCase):\n    \"\"\"Test temporal subtraction operations without requiring ExpressionWrapper.\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        \n        # Create test model\n        class Experiment(models.Model):\n            start = models.DateTimeField()\n            end = models.DateTimeField()\n            \n            class Meta:\n                app_label = 'expressions'\n        \n        cls.Experiment = Experiment\n        \n        # Create the table\n        with cls._get_connection().schema_editor() as schema_editor:\n            schema_editor.create_model(cls.Experiment)\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Drop the table\n        with cls._get_connection().schema_editor() as schema_editor:\n            schema_editor.delete_model(cls.Experiment)\n        super().tearDownClass()\n    \n    @classmethod\n    def _get_connection(cls):\n        from django.db import connection\n        return connection\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        self.start_time = datetime.datetime(2023, 1, 1, 10, 0, 0)\n        self.end_time = datetime.datetime(2023, 1, 1, 12, 30, 0)\n        \n        self.experiment = self.Experiment.objects.create(\n            start=self.start_time,\n            end=self.end_time\n        )\n    \n    def test_temporal_subtraction_fails_without_fix(self):\n        \"\"\"Test that temporal subtraction currently fails without ExpressionWrapper.\"\"\"\n        # This test demonstrates the bug - it should fail before the fix is applied\n        with self.assertRaises(FieldError) as cm:\n            list(self.Experiment.objects.annotate(\n                delta=F('end') - F('start') + Value(datetime.timedelta(), output_field=DurationField())\n            ))\n        \n        self.assertIn(\"Expression contains mixed types\", str(cm.exception))\n        self.assertIn(\"DateTimeField\", str(cm.exception))\n        self.assertIn(\"DurationField\", str(cm.exception))\n        self.assertIn(\"You must set output_field\", str(cm.exception))\n    \n    def test_temporal_subtraction_with_expression_wrapper_works(self):\n        \"\"\"Test that temporal subtraction works when wrapped in ExpressionWrapper.\"\"\"\n        # This should work even before the fix\n        queryset = self.Experiment.objects.annotate(\n            delta=ExpressionWrapper(\n                F('end') - F('start'), \n                output_field=DurationField()\n            )\n        )\n        \n        result = list(queryset)\n        self.assertEqual(len(result), 1)\n        \n        # The delta should be 2.5 hours\n        expected_delta = datetime.timedelta(hours=2, minutes=30)\n        self.assertEqual(result[0].delta, expected_delta)\n    \n    def test_simple_temporal_subtraction_should_work_after_fix(self):\n        \"\"\"Test that simple temporal subtraction should work without ExpressionWrapper after fix.\"\"\"\n        # This test should pass after the fix is applied\n        try:\n            queryset = self.Experiment.objects.annotate(\n                delta=F('end') - F('start')\n            )\n            \n            result = list(queryset)\n            self.assertEqual(len(result), 1)\n            \n            # The delta should be 2.5 hours\n            expected_delta = datetime.timedelta(hours=2, minutes=30)\n            self.assertEqual(result[0].delta, expected_delta)\n        except FieldError:\n            # If this fails, it means the fix hasn't been applied yet\n            self.fail(\"Temporal subtraction should work without ExpressionWrapper after fix\")\n    \n    def test_temporal_subtraction_with_duration_addition_should_work_after_fix(self):\n        \"\"\"Test that temporal subtraction combined with duration addition should work after fix.\"\"\"\n        # This is the exact case from the issue description\n        try:\n            queryset = self.Experiment.objects.annotate(\n                delta=F('end') - F('start') + Value(datetime.timedelta(), output_field=DurationField())\n            )\n            \n            result = list(queryset)\n            self.assertEqual(len(result), 1)\n            \n            # The delta should be 2.5 hours (plus zero timedelta)\n            expected_delta = datetime.timedelta(hours=2, minutes=30)\n            self.assertEqual(result[0].delta, expected_delta)\n        except FieldError:\n            # If this fails, it means the fix hasn't been applied yet\n            self.fail(\"Temporal subtraction with duration addition should work without ExpressionWrapper after fix\")\n    \n    def test_temporal_subtraction_with_timedelta_value(self):\n        \"\"\"Test temporal subtraction with timedelta Value objects.\"\"\"\n        try:\n            # Test subtracting a timedelta from datetime\n            queryset = self.Experiment.objects.annotate(\n                adjusted_start=F('start') - Value(datetime.timedelta(hours=1))\n            )\n            \n            result = list(queryset)\n            self.assertEqual(len(result), 1)\n            \n            expected_time = self.start_time - datetime.timedelta(hours=1)\n            self.assertEqual(result[0].adjusted_start, expected_time)\n        except FieldError:\n            self.fail(\"DateTime - timedelta should work without ExpressionWrapper after fix\")\n    \n    def test_temporal_addition_with_timedelta_value(self):\n        \"\"\"Test temporal addition with timedelta Value objects.\"\"\"\n        try:\n            # Test adding a timedelta to datetime\n            queryset = self.Experiment.objects.annotate(\n                adjusted_end=F('end') + Value(datetime.timedelta(hours=1))\n            )\n            \n            result = list(queryset)\n            self.assertEqual(len(result), 1)\n            \n            expected_time = self.end_time + datetime.timedelta(hours=1)\n            self.assertEqual(result[0].adjusted_end, expected_time)\n        except FieldError:\n            self.fail(\"DateTime + timedelta should work without ExpressionWrapper after fix\")\n    \n    def test_complex_temporal_expression(self):\n        \"\"\"Test complex temporal expressions involving multiple operations.\"\"\"\n        try:\n            # Test a more complex expression: (end - start) + 1 hour - 30 minutes\n            queryset = self.Experiment.objects.annotate(\n                complex_delta=(\n                    F('end') - F('start') + \n                    Value(datetime.timedelta(hours=1)) - \n                    Value(datetime.timedelta(minutes=30))\n                )\n            )\n            \n            result = list(queryset)\n            self.assertEqual(len(result), 1)\n            \n            # Original delta: 2.5 hours, +1 hour, -30 minutes = 3 hours\n            expected_delta = datetime.timedelta(hours=3)\n            self.assertEqual(result[0].complex_delta, expected_delta)\n        except FieldError:\n            self.fail(\"Complex temporal expressions should work without ExpressionWrapper after fix\")\n    \n    def test_non_temporal_operations_still_require_output_field(self):\n        \"\"\"Test that non-temporal operations still require explicit output_field.\"\"\"\n        # Create a model with numeric fields for testing\n        @isolate_apps('expressions')\n        class NumericModel(models.Model):\n            value1 = models.IntegerField()\n            value2 = models.DecimalField(max_digits=10, decimal_places=2)\n            \n            class Meta:\n                app_label = 'expressions'\n        \n        # This should still require ExpressionWrapper for mixed numeric types\n        with self.assertRaises(FieldError):\n            list(NumericModel.objects.annotate(\n                mixed_result=F('value1') + F('value2')\n            ))\n    \n    def test_temporal_subtraction_preserves_existing_functionality(self):\n        \"\"\"Test that the fix doesn't break existing ExpressionWrapper usage.\"\"\"\n        # Existing code using ExpressionWrapper should continue to work\n        queryset = self.Experiment.objects.annotate(\n            delta_explicit=ExpressionWrapper(\n                F('end') - F('start'), \n                output_field=DurationField()\n            ),\n            # After fix, this should also work without wrapper\n            delta_implicit=F('end') - F('start')\n        )\n        \n        try:\n            result = list(queryset)\n            self.assertEqual(len(result), 1)\n            \n            # Both should give the same result\n            expected_delta = datetime.timedelta(hours=2, minutes=30)\n            self.assertEqual(result[0].delta_explicit, expected_delta)\n            self.assertEqual(result[0].delta_implicit, expected_delta)\n        except FieldError:\n            # If implicit fails, at least explicit should work\n            queryset_explicit = self.Experiment.objects.annotate(\n                delta_explicit=ExpressionWrapper(\n                    F('end') - F('start'), \n                    output_field=DurationField()\n                )\n            )\n            result = list(queryset_explicit)\n            self.assertEqual(len(result), 1)\n            \n            expected_delta = datetime.timedelta(hours=2, minutes=30)\n            self.assertEqual(result[0].delta_explicit, expected_delta)\n\n\n@isolate_apps('expressions')  \nclass TemporalSubtractionEdgeCaseTests(TestCase):\n    \"\"\"Test edge cases for temporal subtraction operations.\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        \n        # Create test model with different temporal field types\n        class TemporalModel(models.Model):\n            datetime_field = models.DateTimeField()\n            date_field = models.DateField()\n            time_field = models.TimeField()\n            \n            class Meta:\n                app_label = 'expressions'\n        \n        cls.TemporalModel = TemporalModel\n        \n        # Create the table\n        with cls._get_connection().schema_editor() as schema_editor:\n            schema_editor.create_model(cls.TemporalModel)\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Drop the table\n        with cls._get_connection().schema_editor() as schema_editor:\n            schema_editor.delete_model(cls.TemporalModel)\n        super().tearDownClass()\n    \n    @classmethod\n    def _get_connection(cls):\n        from django.db import connection\n        return connection\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        self.temporal_obj = self.TemporalModel.objects.create(\n            datetime_field=datetime.datetime(2023, 1, 2, 15, 30, 0),\n            date_field=datetime.date(2023, 1, 2),\n            time_field=datetime.time(15, 30, 0)\n        )\n    \n    def test_date_field_subtraction(self):\n        \"\"\"Test that date field subtraction works.\"\"\"\n        try:\n            queryset = self.TemporalModel.objects.annotate(\n                date_delta=F('date_field') - Value(datetime.date(2023, 1, 1))\n            )\n            \n            result = list(queryset)\n            self.assertEqual(len(result), 1)\n            \n            # Should be 1 day difference\n            expected_delta = datetime.timedelta(days=1)\n            self.assertEqual(result[0].date_delta, expected_delta)\n        except FieldError:\n            self.fail(\"Date field subtraction should work after fix\")\n    \n    def test_time_field_subtraction(self):\n        \"\"\"Test that time field subtraction works.\"\"\"\n        try:\n            queryset = self.TemporalModel.objects.annotate(\n                time_delta=F('time_field') - Value(datetime.time(14, 0, 0))\n            )\n            \n            result = list(queryset)\n            self.assertEqual(len(result), 1)\n            \n            # Should be 1.5 hours difference\n            expected_delta = datetime.timedelta(hours=1, minutes=30)\n            self.assertEqual(result[0].time_delta, expected_delta)\n        except FieldError:\n            self.fail(\"Time field subtraction should work after fix\")\n    \n    def test_mixed_temporal_types_still_require_output_field(self):\n        \"\"\"Test that mixing different temporal field types still requires explicit output_field.\"\"\"\n        # Mixing DateTimeField and DateField should still require ExpressionWrapper\n        # since the result type is ambiguous\n        with self.assertRaises(FieldError):\n            list(self.TemporalModel.objects.annotate(\n                mixed_temporal=F('datetime_field') - F('date_field')\n            ))\n    \n    def test_null_temporal_values(self):\n        \"\"\"Test temporal subtraction with null values.\"\"\"\n        # Create object with null datetime\n        null_obj = self.TemporalModel.objects.create(\n            datetime_field=None,\n            date_field=datetime.date(2023, 1, 1),\n            time_field=datetime.time(12, 0, 0)\n        )\n        \n        try:\n            queryset = self.TemporalModel.objects.annotate(\n                delta_with_null=F('datetime_field') - Value(datetime.datetime(2023, 1, 1, 12, 0, 0))\n            ).filter(pk=null_obj.pk)\n            \n            result = list(queryset)\n            self.assertEqual(len(result), 1)\n            self.assertIsNone(result[0].delta_with_null)\n        except FieldError:\n            self.fail(\"Temporal subtraction with null values should work after fix\")\n</patched>\n```",
  "patch": "--- a/tests/expressions/test_temporal_subtraction.py\n+++ b/tests/expressions/test_temporal_subtraction.py\n-# Empty if creating new file\n+import datetime\n+import pytest\n+from django.core.exceptions import FieldError\n+from django.db import models\n+from django.db.models import F, Value, ExpressionWrapper\n+from django.db.models.fields import DurationField, DateTimeField\n+from django.test import TestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps('expressions')\n+class TemporalSubtractionTests(TestCase):\n+    \"\"\"Test temporal subtraction operations without requiring ExpressionWrapper.\"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        \n+        # Create test model\n+        class Experiment(models.Model):\n+            start = models.DateTimeField()\n+            end = models.DateTimeField()\n+            \n+            class Meta:\n+                app_label = 'expressions'\n+        \n+        cls.Experiment = Experiment\n+        \n+        # Create the table\n+        with cls._get_connection().schema_editor() as schema_editor:\n+            schema_editor.create_model(cls.Experiment)\n+    \n+    @classmethod\n+    def tearDownClass(cls):\n+        # Drop the table\n+        with cls._get_connection().schema_editor() as schema_editor:\n+            schema_editor.delete_model(cls.Experiment)\n+        super().tearDownClass()\n+    \n+    @classmethod\n+    def _get_connection(cls):\n+        from django.db import connection\n+        return connection\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        self.start_time = datetime.datetime(2023, 1, 1, 10, 0, 0)\n+        self.end_time = datetime.datetime(2023, 1, 1, 12, 30, 0)\n+        \n+        self.experiment = self.Experiment.objects.create(\n+            start=self.start_time,\n+            end=self.end_time\n+        )\n+    \n+    def test_temporal_subtraction_fails_without_fix(self):\n+        \"\"\"Test that temporal subtraction currently fails without ExpressionWrapper.\"\"\"\n+        # This test demonstrates the bug - it should fail before the fix is applied\n+        with self.assertRaises(FieldError) as cm:\n+            list(self.Experiment.objects.annotate(\n+                delta=F('end') - F('start') + Value(datetime.timedelta(), output_field=DurationField())\n+            ))\n+        \n+        self.assertIn(\"Expression contains mixed types\", str(cm.exception))\n+        self.assertIn(\"DateTimeField\", str(cm.exception))\n+        self.assertIn(\"DurationField\", str(cm.exception))\n+        self.assertIn(\"You must set output_field\", str(cm.exception))\n+    \n+    def test_temporal_subtraction_with_expression_wrapper_works(self):\n+        \"\"\"Test that temporal subtraction works when wrapped in ExpressionWrapper.\"\"\"\n+        # This should work even before the fix\n+        queryset = self.Experiment.objects.annotate(\n+            delta=ExpressionWrapper(\n+                F('end') - F('start'), \n+                output_field=DurationField()\n+            )\n+        )\n+        \n+        result = list(queryset)\n+        self.assertEqual(len(result), 1)\n+        \n+        # The delta should be 2.5 hours\n+        expected_delta = datetime.timedelta(hours=2, minutes=30)\n+        self.assertEqual(result[0].delta, expected_delta)\n+    \n+    def test_simple_temporal_subtraction_should_work_after_fix(self):\n+        \"\"\"Test that simple temporal subtraction should work without ExpressionWrapper after fix.\"\"\"\n+        # This test should pass after the fix is applied\n+        try:\n+            queryset = self.Experiment.objects.annotate(\n+                delta=F('end') - F('start')\n+            )\n+            \n+            result = list(queryset)\n+            self.assertEqual(len(result), 1)\n+            \n+            # The delta should be 2.5 hours\n+            expected_delta = datetime.timedelta(hours=2, minutes=30)\n+            self.assertEqual(result[0].delta, expected_delta)\n+        except FieldError:\n+            # If this fails, it means the fix hasn't been applied yet\n+            self.fail(\"Temporal subtraction should work without ExpressionWrapper after fix\")\n+    \n+    def test_temporal_subtraction_with_duration_addition_should_work_after_fix(self):\n+        \"\"\"Test that temporal subtraction combined with duration addition should work after fix.\"\"\"\n+        # This is the exact case from the issue description\n+        try:\n+            queryset = self.Experiment.objects.annotate(\n+                delta=F('end') - F('start') + Value(datetime.timedelta(), output_field=DurationField())\n+            )\n+            \n+            result = list(queryset)\n+            self.assertEqual(len(result), 1)\n+            \n+            # The delta should be 2.5 hours (plus zero timedelta)\n+            expected_delta = datetime.timedelta(hours=2, minutes=30)\n+            self.assertEqual(result[0].delta, expected_delta)\n+        except FieldError:\n+            # If this fails, it means the fix hasn't been applied yet\n+            self.fail(\"Temporal subtraction with duration addition should work without ExpressionWrapper after fix\")\n+    \n+    def test_temporal_subtraction_with_timedelta_value(self):\n+        \"\"\"Test temporal subtraction with timedelta Value objects.\"\"\"\n+        try:\n+            # Test subtracting a timedelta from datetime\n+            queryset = self.Experiment.objects.annotate(\n+                adjusted_start=F('start') - Value(datetime.timedelta(hours=1))\n+            )\n+            \n+            result = list(queryset)\n+            self.assertEqual(len(result), 1)\n+            \n+            expected_time = self.start_time - datetime.timedelta(hours=1)\n+            self.assertEqual(result[0].adjusted_start, expected_time)\n+        except FieldError:\n+            self.fail(\"DateTime - timedelta should work without ExpressionWrapper after fix\")\n+    \n+    def test_temporal_addition_with_timedelta_value(self):\n+        \"\"\"Test temporal addition with timedelta Value objects.\"\"\"\n+        try:\n+            # Test adding a timedelta to datetime\n+            queryset = self.Experiment.objects.annotate(\n+                adjusted_end=F('end') + Value(datetime.timedelta(hours=1))\n+            )\n+            \n+            result = list(queryset)\n+            self.assertEqual(len(result), 1)\n+            \n+            expected_time = self.end_time + datetime.timedelta(hours=1)\n+            self.assertEqual(result[0].adjusted_end, expected_time)\n+        except FieldError:\n+            self.fail(\"DateTime + timedelta should work without ExpressionWrapper after fix\")\n+    \n+    def test_complex_temporal_expression(self):\n+        \"\"\"Test complex temporal expressions involving multiple operations.\"\"\"\n+        try:\n+            # Test a more complex expression: (end - start) + 1 hour - 30 minutes\n+            queryset = self.Experiment.objects.annotate(\n+                complex_delta=(\n+                    F('end') - F('start') + \n+                    Value(datetime.timedelta(hours=1)) - \n+                    Value(datetime.timedelta(minutes=30))\n+                )\n+            )\n+            \n+            result = list(queryset)\n+            self.assertEqual(len(result), 1)\n+            \n+            # Original delta: 2.5 hours, +1 hour, -30 minutes = 3 hours\n+            expected_delta = datetime.timedelta(hours=3)\n+            self.assertEqual(result[0].complex_delta, expected_delta)\n+        except FieldError:\n+            self.fail(\"Complex temporal expressions should work without ExpressionWrapper after fix\")\n+    \n+    def test_non_temporal_operations_still_require_output_field(self):\n+        \"\"\"Test that non-temporal operations still require explicit output_field.\"\"\"\n+        # Create a model with numeric fields for testing\n+        @isolate_apps('expressions')\n+        class NumericModel(models.Model):\n+            value1 = models.IntegerField()\n+            value2 = models.DecimalField(max_digits=10, decimal_places=2)\n+            \n+            class Meta:\n+                app_label = 'expressions'\n+        \n+        # This should still require ExpressionWrapper for mixed numeric types\n+        with self.assertRaises(FieldError):\n+            list(NumericModel.objects.annotate(\n+                mixed_result=F('value1') + F('value2')\n+            ))\n+    \n+    def test_temporal_subtraction_preserves_existing_functionality(self):\n+        \"\"\"Test that the fix doesn't break existing ExpressionWrapper usage.\"\"\"\n+        # Existing code using ExpressionWrapper should continue to work\n+        queryset = self.Experiment.objects.annotate(\n+            delta_explicit=ExpressionWrapper(\n+                F('end') - F('start'), \n+                output_field=DurationField()\n+            ),\n+            # After fix, this should also work without wrapper\n+            delta_implicit=F('end') - F('start')\n+        )\n+        \n+        try:\n+            result = list(queryset)\n+            self.assertEqual(len(result), 1)\n+            \n+            # Both should give the same result\n+            expected_delta = datetime.timedelta(hours=2, minutes=30)\n+            self.assertEqual(result[0].delta_explicit, expected_delta)\n+            self.assertEqual(result[0].delta_implicit, expected_delta)\n+        except FieldError:\n+            # If implicit fails, at least explicit should work\n+            queryset_explicit = self.Experiment.objects.annotate(\n+                delta_explicit=ExpressionWrapper(\n+                    F('end') - F('start'), \n+                    output_field=DurationField()\n+                )\n+            )\n+            result = list(queryset_explicit)\n+            self.assertEqual(len(result), 1)\n+            \n+            expected_delta = datetime.timedelta(hours=2, minutes=30)\n+            self.assertEqual(result[0].delta_explicit, expected_delta)\n+\n+\n+@isolate_apps('expressions')  \n+class TemporalSubtractionEdgeCaseTests(TestCase):\n+    \"\"\"Test edge cases for temporal subtraction operations.\"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        \n+        # Create test model with different temporal field types\n+        class TemporalModel(models.Model):\n+            datetime_field = models.DateTimeField()\n+            date_field = models.DateField()\n+            time_field = models.TimeField()\n+            \n+            class Meta:\n+                app_label = 'expressions'\n+        \n+        cls.TemporalModel = TemporalModel\n+        \n+        # Create the table\n+        with cls._get_connection().schema_editor() as schema_editor:\n+            schema_editor.create_model(cls.TemporalModel)\n+    \n+    @classmethod\n+    def tearDownClass(cls):\n+        # Drop the table\n+        with cls._get_connection().schema_editor() as schema_editor:\n+            schema_editor.delete_model(cls.TemporalModel)\n+        super().tearDownClass()\n+    \n+    @classmethod\n+    def _get_connection(cls):\n+        from django.db import connection\n+        return connection\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        self.temporal_obj = self.TemporalModel.objects.create(\n+            datetime_field=datetime.datetime(2023, 1, 2, 15, 30, 0),\n+            date_field=datetime.date(2023, 1, 2),\n+            time_field=datetime.time(15, 30, 0)\n+        )\n+    \n+    def test_date_field_subtraction(self):\n+        \"\"\"Test that date field subtraction works.\"\"\"\n+        try:\n+            queryset = self.TemporalModel.objects.annotate(\n+                date_delta=F('date_field') - Value(datetime.date(2023, 1, 1))\n+            )\n+            \n+            result = list(queryset)\n+            self.assertEqual(len(result), 1)\n+            \n+            # Should be 1 day difference\n+            expected_delta = datetime.timedelta(days=1)\n+            self.assertEqual(result[0].date_delta, expected_delta)\n+        except FieldError:\n+            self.fail(\"Date field subtraction should work after fix\")\n+    \n+    def test_time_field_subtraction(self):\n+        \"\"\"Test that time field subtraction works.\"\"\"\n+        try:\n+            queryset = self.TemporalModel.objects.annotate(\n+                time_delta=F('time_field') - Value(datetime.time(14, 0, 0))\n+            )\n+            \n+            result = list(queryset)\n+            self.assertEqual(len(result), 1)\n+            \n+            # Should be 1.5 hours difference\n+            expected_delta = datetime.timedelta(hours=1, minutes=30)\n+            self.assertEqual(result[0].time_delta, expected_delta)\n+        except FieldError:\n+            self.fail(\"Time field subtraction should work after fix\")\n+    \n+    def test_mixed_temporal_types_still_require_output_field(self):\n+        \"\"\"Test that mixing different temporal field types still requires explicit output_field.\"\"\"\n+        # Mixing DateTimeField and DateField should still require ExpressionWrapper\n+        # since the result type is ambiguous\n+        with self.assertRaises(FieldError):\n+            list(self.TemporalModel.objects.annotate(\n+                mixed_temporal=F('datetime_field') - F('date_field')\n+            ))\n+    \n+    def test_null_temporal_values(self):\n+        \"\"\"Test temporal subtraction with null values.\"\"\"\n+        # Create object with null datetime\n+        null_obj = self.TemporalModel.objects.create(\n+            datetime_field=None,\n+            date_field=datetime.date(2023, 1, 1),\n+            time_field=datetime.time(12, 0, 0)\n+        )\n+        \n+        try:\n+            queryset = self.TemporalModel.objects.annotate(\n+                delta_with_null=F('datetime_field') - Value(datetime.datetime(2023, 1, 1, 12, 0, 0))\n+            ).filter(pk=null_obj.pk)\n+            \n+            result = list(queryset)\n+            self.assertEqual(len(result), 1)\n+            self.assertIsNone(result[0].delta_with_null)\n+        except FieldError:\n+            self.fail(\"Temporal subtraction with null values should work after fix\")\n"
}