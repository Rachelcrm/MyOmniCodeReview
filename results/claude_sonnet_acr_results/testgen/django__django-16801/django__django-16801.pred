{
  "instance_id": "django__django-16801",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_fields/test_imagefield_signal_optimization.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom django.db import models\nfrom django.db.models import signals\nfrom django.test import TestCase\nfrom django.core.files.uploadedfile import SimpleUploadedFile\nfrom PIL import Image\nimport io\n\n\nclass TestImageFieldSignalOptimization(TestCase):\n    \"\"\"\n    Test that ImageField only connects post_init signal when dimension fields are used.\n    This addresses the performance issue where unnecessary signal handlers are called.\n    \"\"\"\n\n    def setUp(self):\n        \"\"\"Create a simple test image for use in tests.\"\"\"\n        # Create a simple 10x10 red image\n        image = Image.new('RGB', (10, 10), color='red')\n        image_io = io.BytesIO()\n        image.save(image_io, format='JPEG')\n        image_io.seek(0)\n        self.test_image = SimpleUploadedFile(\n            name='test.jpg',\n            content=image_io.getvalue(),\n            content_type='image/jpeg'\n        )\n\n    def test_imagefield_without_dimension_fields_no_signal_connection(self):\n        \"\"\"\n        Test that ImageField without width_field/height_field does NOT connect post_init signal.\n        This is the main bug fix - unnecessary signal handlers should not be connected.\n        \"\"\"\n        # Track signal connections\n        original_connect = signals.post_init.connect\n        connect_calls = []\n        \n        def mock_connect(receiver, sender=None, **kwargs):\n            connect_calls.append((receiver, sender))\n            return original_connect(receiver, sender, **kwargs)\n        \n        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n            # Create a model with ImageField but no dimension fields\n            class TestModelNoDimensions(models.Model):\n                image = models.ImageField(upload_to='test/')\n                \n                class Meta:\n                    app_label = 'test'\n        \n        # Check that no signal was connected for the ImageField\n        image_field_connections = [\n            call for call in connect_calls \n            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n        ]\n        \n        # Should be empty - no signal connections for ImageField without dimension fields\n        self.assertEqual(len(image_field_connections), 0, \n                        \"ImageField without dimension fields should not connect post_init signal\")\n\n    def test_imagefield_with_width_field_connects_signal(self):\n        \"\"\"\n        Test that ImageField WITH width_field DOES connect post_init signal.\n        This ensures existing functionality is preserved.\n        \"\"\"\n        # Track signal connections\n        original_connect = signals.post_init.connect\n        connect_calls = []\n        \n        def mock_connect(receiver, sender=None, **kwargs):\n            connect_calls.append((receiver, sender))\n            return original_connect(receiver, sender, **kwargs)\n        \n        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n            # Create a model with ImageField and width_field\n            class TestModelWithWidth(models.Model):\n                image = models.ImageField(upload_to='test/', width_field='image_width')\n                image_width = models.IntegerField(null=True, blank=True)\n                \n                class Meta:\n                    app_label = 'test'\n        \n        # Check that signal was connected for the ImageField\n        image_field_connections = [\n            call for call in connect_calls \n            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n        ]\n        \n        # Should have one connection for ImageField with width_field\n        self.assertEqual(len(image_field_connections), 1, \n                        \"ImageField with width_field should connect post_init signal\")\n\n    def test_imagefield_with_height_field_connects_signal(self):\n        \"\"\"\n        Test that ImageField WITH height_field DOES connect post_init signal.\n        This ensures existing functionality is preserved.\n        \"\"\"\n        # Track signal connections\n        original_connect = signals.post_init.connect\n        connect_calls = []\n        \n        def mock_connect(receiver, sender=None, **kwargs):\n            connect_calls.append((receiver, sender))\n            return original_connect(receiver, sender, **kwargs)\n        \n        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n            # Create a model with ImageField and height_field\n            class TestModelWithHeight(models.Model):\n                image = models.ImageField(upload_to='test/', height_field='image_height')\n                image_height = models.IntegerField(null=True, blank=True)\n                \n                class Meta:\n                    app_label = 'test'\n        \n        # Check that signal was connected for the ImageField\n        image_field_connections = [\n            call for call in connect_calls \n            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n        ]\n        \n        # Should have one connection for ImageField with height_field\n        self.assertEqual(len(image_field_connections), 1, \n                        \"ImageField with height_field should connect post_init signal\")\n\n    def test_imagefield_with_both_dimension_fields_connects_signal(self):\n        \"\"\"\n        Test that ImageField WITH both width_field and height_field DOES connect post_init signal.\n        This ensures existing functionality is preserved.\n        \"\"\"\n        # Track signal connections\n        original_connect = signals.post_init.connect\n        connect_calls = []\n        \n        def mock_connect(receiver, sender=None, **kwargs):\n            connect_calls.append((receiver, sender))\n            return original_connect(receiver, sender, **kwargs)\n        \n        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n            # Create a model with ImageField and both dimension fields\n            class TestModelWithBothDimensions(models.Model):\n                image = models.ImageField(upload_to='test/', \n                                        width_field='image_width', \n                                        height_field='image_height')\n                image_width = models.IntegerField(null=True, blank=True)\n                image_height = models.IntegerField(null=True, blank=True)\n                \n                class Meta:\n                    app_label = 'test'\n        \n        # Check that signal was connected for the ImageField\n        image_field_connections = [\n            call for call in connect_calls \n            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n        ]\n        \n        # Should have one connection for ImageField with both dimension fields\n        self.assertEqual(len(image_field_connections), 1, \n                        \"ImageField with both dimension fields should connect post_init signal\")\n\n    def test_performance_improvement_no_signal_calls_without_dimension_fields(self):\n        \"\"\"\n        Test that post_init signal is not called when ImageField has no dimension fields.\n        This demonstrates the performance improvement.\n        \"\"\"\n        # Create a model without dimension fields\n        class TestModelNoDimensions(models.Model):\n            image = models.ImageField(upload_to='test/')\n            \n            class Meta:\n                app_label = 'test'\n        \n        # Mock the update_dimension_fields method to track calls\n        with patch.object(TestModelNoDimensions._meta.get_field('image'), 'update_dimension_fields') as mock_update:\n            # Create an instance - this should NOT trigger the signal\n            instance = TestModelNoDimensions()\n            \n            # The update_dimension_fields should not have been called\n            mock_update.assert_not_called()\n\n    def test_existing_functionality_preserved_with_dimension_fields(self):\n        \"\"\"\n        Test that existing functionality is preserved when dimension fields are used.\n        The signal should still be called and dimension fields should be updated.\n        \"\"\"\n        # Create a model with dimension fields\n        class TestModelWithDimensions(models.Model):\n            image = models.ImageField(upload_to='test/', \n                                    width_field='image_width', \n                                    height_field='image_height')\n            image_width = models.IntegerField(null=True, blank=True)\n            image_height = models.IntegerField(null=True, blank=True)\n            \n            class Meta:\n                app_label = 'test'\n        \n        # Create an instance with an image\n        instance = TestModelWithDimensions()\n        instance.image = self.test_image\n        \n        # The dimension fields should be updated (this would happen via signal in real scenario)\n        field = TestModelWithDimensions._meta.get_field('image')\n        field.update_dimension_fields(instance, force=True)\n        \n        # Check that dimensions were set\n        self.assertEqual(instance.image_width, 10)\n        self.assertEqual(instance.image_height, 10)\n\n    def test_update_dimension_fields_early_return_without_dimension_fields(self):\n        \"\"\"\n        Test that update_dimension_fields returns early when no dimension fields are set.\n        This verifies the existing early return logic works correctly.\n        \"\"\"\n        # Create a model without dimension fields\n        class TestModelNoDimensions(models.Model):\n            image = models.ImageField(upload_to='test/')\n            \n            class Meta:\n                app_label = 'test'\n        \n        instance = TestModelNoDimensions()\n        instance.image = self.test_image\n        \n        field = TestModelNoDimensions._meta.get_field('image')\n        \n        # Mock the expensive operations to ensure they're not called\n        with patch.object(instance.image, 'width', side_effect=Exception(\"Should not be called\")) as mock_width, \\\n             patch.object(instance.image, 'height', side_effect=Exception(\"Should not be called\")) as mock_height:\n            \n            # This should return early and not access width/height\n            field.update_dimension_fields(instance)\n            \n            # Width and height should not have been accessed\n            mock_width.assert_not_called()\n            mock_height.assert_not_called()\n\n    def test_multiple_imagefields_signal_optimization(self):\n        \"\"\"\n        Test that optimization works correctly with multiple ImageFields in the same model.\n        Only ImageFields with dimension fields should connect signals.\n        \"\"\"\n        # Track signal connections\n        original_connect = signals.post_init.connect\n        connect_calls = []\n        \n        def mock_connect(receiver, sender=None, **kwargs):\n            connect_calls.append((receiver, sender))\n            return original_connect(receiver, sender, **kwargs)\n        \n        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n            # Create a model with multiple ImageFields\n            class TestModelMultipleImages(models.Model):\n                # This should NOT connect signal\n                image1 = models.ImageField(upload_to='test1/')\n                # This should connect signal\n                image2 = models.ImageField(upload_to='test2/', width_field='image2_width')\n                # This should NOT connect signal\n                image3 = models.ImageField(upload_to='test3/')\n                # This should connect signal\n                image4 = models.ImageField(upload_to='test4/', height_field='image4_height')\n                \n                image2_width = models.IntegerField(null=True, blank=True)\n                image4_height = models.IntegerField(null=True, blank=True)\n                \n                class Meta:\n                    app_label = 'test'\n        \n        # Check signal connections for ImageFields\n        image_field_connections = [\n            call for call in connect_calls \n            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n        ]\n        \n        # Should have exactly 2 connections (for image2 and image4)\n        self.assertEqual(len(image_field_connections), 2, \n                        \"Only ImageFields with dimension fields should connect post_init signal\")\n</patched>\n</file>\n```",
  "patch": "--- a/tests/model_fields/test_imagefield_signal_optimization.py\n+++ b/tests/model_fields/test_imagefield_signal_optimization.py\n-# Empty if creating new file\n+import pytest\n+from unittest.mock import Mock, patch\n+from django.db import models\n+from django.db.models import signals\n+from django.test import TestCase\n+from django.core.files.uploadedfile import SimpleUploadedFile\n+from PIL import Image\n+import io\n+\n+\n+class TestImageFieldSignalOptimization(TestCase):\n+    \"\"\"\n+    Test that ImageField only connects post_init signal when dimension fields are used.\n+    This addresses the performance issue where unnecessary signal handlers are called.\n+    \"\"\"\n+\n+    def setUp(self):\n+        \"\"\"Create a simple test image for use in tests.\"\"\"\n+        # Create a simple 10x10 red image\n+        image = Image.new('RGB', (10, 10), color='red')\n+        image_io = io.BytesIO()\n+        image.save(image_io, format='JPEG')\n+        image_io.seek(0)\n+        self.test_image = SimpleUploadedFile(\n+            name='test.jpg',\n+            content=image_io.getvalue(),\n+            content_type='image/jpeg'\n+        )\n+\n+    def test_imagefield_without_dimension_fields_no_signal_connection(self):\n+        \"\"\"\n+        Test that ImageField without width_field/height_field does NOT connect post_init signal.\n+        This is the main bug fix - unnecessary signal handlers should not be connected.\n+        \"\"\"\n+        # Track signal connections\n+        original_connect = signals.post_init.connect\n+        connect_calls = []\n+        \n+        def mock_connect(receiver, sender=None, **kwargs):\n+            connect_calls.append((receiver, sender))\n+            return original_connect(receiver, sender, **kwargs)\n+        \n+        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n+            # Create a model with ImageField but no dimension fields\n+            class TestModelNoDimensions(models.Model):\n+                image = models.ImageField(upload_to='test/')\n+                \n+                class Meta:\n+                    app_label = 'test'\n+        \n+        # Check that no signal was connected for the ImageField\n+        image_field_connections = [\n+            call for call in connect_calls \n+            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n+        ]\n+        \n+        # Should be empty - no signal connections for ImageField without dimension fields\n+        self.assertEqual(len(image_field_connections), 0, \n+                        \"ImageField without dimension fields should not connect post_init signal\")\n+\n+    def test_imagefield_with_width_field_connects_signal(self):\n+        \"\"\"\n+        Test that ImageField WITH width_field DOES connect post_init signal.\n+        This ensures existing functionality is preserved.\n+        \"\"\"\n+        # Track signal connections\n+        original_connect = signals.post_init.connect\n+        connect_calls = []\n+        \n+        def mock_connect(receiver, sender=None, **kwargs):\n+            connect_calls.append((receiver, sender))\n+            return original_connect(receiver, sender, **kwargs)\n+        \n+        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n+            # Create a model with ImageField and width_field\n+            class TestModelWithWidth(models.Model):\n+                image = models.ImageField(upload_to='test/', width_field='image_width')\n+                image_width = models.IntegerField(null=True, blank=True)\n+                \n+                class Meta:\n+                    app_label = 'test'\n+        \n+        # Check that signal was connected for the ImageField\n+        image_field_connections = [\n+            call for call in connect_calls \n+            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n+        ]\n+        \n+        # Should have one connection for ImageField with width_field\n+        self.assertEqual(len(image_field_connections), 1, \n+                        \"ImageField with width_field should connect post_init signal\")\n+\n+    def test_imagefield_with_height_field_connects_signal(self):\n+        \"\"\"\n+        Test that ImageField WITH height_field DOES connect post_init signal.\n+        This ensures existing functionality is preserved.\n+        \"\"\"\n+        # Track signal connections\n+        original_connect = signals.post_init.connect\n+        connect_calls = []\n+        \n+        def mock_connect(receiver, sender=None, **kwargs):\n+            connect_calls.append((receiver, sender))\n+            return original_connect(receiver, sender, **kwargs)\n+        \n+        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n+            # Create a model with ImageField and height_field\n+            class TestModelWithHeight(models.Model):\n+                image = models.ImageField(upload_to='test/', height_field='image_height')\n+                image_height = models.IntegerField(null=True, blank=True)\n+                \n+                class Meta:\n+                    app_label = 'test'\n+        \n+        # Check that signal was connected for the ImageField\n+        image_field_connections = [\n+            call for call in connect_calls \n+            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n+        ]\n+        \n+        # Should have one connection for ImageField with height_field\n+        self.assertEqual(len(image_field_connections), 1, \n+                        \"ImageField with height_field should connect post_init signal\")\n+\n+    def test_imagefield_with_both_dimension_fields_connects_signal(self):\n+        \"\"\"\n+        Test that ImageField WITH both width_field and height_field DOES connect post_init signal.\n+        This ensures existing functionality is preserved.\n+        \"\"\"\n+        # Track signal connections\n+        original_connect = signals.post_init.connect\n+        connect_calls = []\n+        \n+        def mock_connect(receiver, sender=None, **kwargs):\n+            connect_calls.append((receiver, sender))\n+            return original_connect(receiver, sender, **kwargs)\n+        \n+        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n+            # Create a model with ImageField and both dimension fields\n+            class TestModelWithBothDimensions(models.Model):\n+                image = models.ImageField(upload_to='test/', \n+                                        width_field='image_width', \n+                                        height_field='image_height')\n+                image_width = models.IntegerField(null=True, blank=True)\n+                image_height = models.IntegerField(null=True, blank=True)\n+                \n+                class Meta:\n+                    app_label = 'test'\n+        \n+        # Check that signal was connected for the ImageField\n+        image_field_connections = [\n+            call for call in connect_calls \n+            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n+        ]\n+        \n+        # Should have one connection for ImageField with both dimension fields\n+        self.assertEqual(len(image_field_connections), 1, \n+                        \"ImageField with both dimension fields should connect post_init signal\")\n+\n+    def test_performance_improvement_no_signal_calls_without_dimension_fields(self):\n+        \"\"\"\n+        Test that post_init signal is not called when ImageField has no dimension fields.\n+        This demonstrates the performance improvement.\n+        \"\"\"\n+        # Create a model without dimension fields\n+        class TestModelNoDimensions(models.Model):\n+            image = models.ImageField(upload_to='test/')\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        # Mock the update_dimension_fields method to track calls\n+        with patch.object(TestModelNoDimensions._meta.get_field('image'), 'update_dimension_fields') as mock_update:\n+            # Create an instance - this should NOT trigger the signal\n+            instance = TestModelNoDimensions()\n+            \n+            # The update_dimension_fields should not have been called\n+            mock_update.assert_not_called()\n+\n+    def test_existing_functionality_preserved_with_dimension_fields(self):\n+        \"\"\"\n+        Test that existing functionality is preserved when dimension fields are used.\n+        The signal should still be called and dimension fields should be updated.\n+        \"\"\"\n+        # Create a model with dimension fields\n+        class TestModelWithDimensions(models.Model):\n+            image = models.ImageField(upload_to='test/', \n+                                    width_field='image_width', \n+                                    height_field='image_height')\n+            image_width = models.IntegerField(null=True, blank=True)\n+            image_height = models.IntegerField(null=True, blank=True)\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        # Create an instance with an image\n+        instance = TestModelWithDimensions()\n+        instance.image = self.test_image\n+        \n+        # The dimension fields should be updated (this would happen via signal in real scenario)\n+        field = TestModelWithDimensions._meta.get_field('image')\n+        field.update_dimension_fields(instance, force=True)\n+        \n+        # Check that dimensions were set\n+        self.assertEqual(instance.image_width, 10)\n+        self.assertEqual(instance.image_height, 10)\n+\n+    def test_update_dimension_fields_early_return_without_dimension_fields(self):\n+        \"\"\"\n+        Test that update_dimension_fields returns early when no dimension fields are set.\n+        This verifies the existing early return logic works correctly.\n+        \"\"\"\n+        # Create a model without dimension fields\n+        class TestModelNoDimensions(models.Model):\n+            image = models.ImageField(upload_to='test/')\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        instance = TestModelNoDimensions()\n+        instance.image = self.test_image\n+        \n+        field = TestModelNoDimensions._meta.get_field('image')\n+        \n+        # Mock the expensive operations to ensure they're not called\n+        with patch.object(instance.image, 'width', side_effect=Exception(\"Should not be called\")) as mock_width, \\\n+             patch.object(instance.image, 'height', side_effect=Exception(\"Should not be called\")) as mock_height:\n+            \n+            # This should return early and not access width/height\n+            field.update_dimension_fields(instance)\n+            \n+            # Width and height should not have been accessed\n+            mock_width.assert_not_called()\n+            mock_height.assert_not_called()\n+\n+    def test_multiple_imagefields_signal_optimization(self):\n+        \"\"\"\n+        Test that optimization works correctly with multiple ImageFields in the same model.\n+        Only ImageFields with dimension fields should connect signals.\n+        \"\"\"\n+        # Track signal connections\n+        original_connect = signals.post_init.connect\n+        connect_calls = []\n+        \n+        def mock_connect(receiver, sender=None, **kwargs):\n+            connect_calls.append((receiver, sender))\n+            return original_connect(receiver, sender, **kwargs)\n+        \n+        with patch.object(signals.post_init, 'connect', side_effect=mock_connect):\n+            # Create a model with multiple ImageFields\n+            class TestModelMultipleImages(models.Model):\n+                # This should NOT connect signal\n+                image1 = models.ImageField(upload_to='test1/')\n+                # This should connect signal\n+                image2 = models.ImageField(upload_to='test2/', width_field='image2_width')\n+                # This should NOT connect signal\n+                image3 = models.ImageField(upload_to='test3/')\n+                # This should connect signal\n+                image4 = models.ImageField(upload_to='test4/', height_field='image4_height')\n+                \n+                image2_width = models.IntegerField(null=True, blank=True)\n+                image4_height = models.IntegerField(null=True, blank=True)\n+                \n+                class Meta:\n+                    app_label = 'test'\n+        \n+        # Check signal connections for ImageFields\n+        image_field_connections = [\n+            call for call in connect_calls \n+            if hasattr(call[0], '__self__') and isinstance(call[0].__self__, models.ImageField)\n+        ]\n+        \n+        # Should have exactly 2 connections (for image2 and image4)\n+        self.assertEqual(len(image_field_connections), 2, \n+                        \"Only ImageFields with dimension fields should connect post_init signal\")\n"
}