{
  "instance_id": "django__django-15104",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/migrations/test_autodetector.py</file>\n<original>\n# This file already exists, we'll add our tests to it\n</original>\n<patched>\nimport pytest\nfrom django.db import models\nfrom django.db.migrations.autodetector import MigrationAutodetector\nfrom django.db.migrations.state import ModelState, ProjectState\nfrom django.test import TestCase\n\n\nclass CustomFKFieldWithoutTo(models.ForeignKey):\n    \"\"\"\n    Custom ForeignKey field that hardcodes its 'to' argument and removes it\n    from deconstructed kwargs. This reproduces the issue where the autodetector\n    fails with KeyError when trying to delete the 'to' key that doesn't exist.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        kwargs['to'] = 'testapp.HardcodedModel'\n        super().__init__(*args, **kwargs)\n\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        # Remove 'to' from kwargs - this causes the KeyError in the autodetector\n        del kwargs[\"to\"]\n        return name, path, args, kwargs\n\n\nclass CustomFKFieldWithTo(models.ForeignKey):\n    \"\"\"\n    Custom ForeignKey field that keeps the 'to' argument in deconstructed kwargs.\n    This represents the normal case that should continue to work.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        kwargs['to'] = 'testapp.HardcodedModel'\n        super().__init__(*args, **kwargs)\n\n    def deconstruct(self):\n        # Keep 'to' in kwargs - this is the normal case\n        return super().deconstruct()\n\n\nclass AutodetectorCustomFKTests(TestCase):\n    \"\"\"\n    Test cases for the migration autodetector with custom ForeignKey fields\n    that may or may not include the 'to' parameter in their deconstructed kwargs.\n    \"\"\"\n\n    def test_custom_fk_field_without_to_parameter_fails_before_fix(self):\n        \"\"\"\n        Test that reproduces the KeyError bug when a custom ForeignKey field\n        removes the 'to' parameter from its deconstructed kwargs.\n        \n        This test should fail before the fix is applied and pass after.\n        \"\"\"\n        before = ProjectState()\n        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n        \n        after = ProjectState()\n        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n        after.add_model(ModelState('testapp', 'TestModel', [\n            ('custom', CustomFKFieldWithoutTo(on_delete=models.CASCADE))\n        ]))\n        \n        # This should not raise a KeyError after the fix\n        autodetector = MigrationAutodetector(before, after)\n        changes = autodetector._detect_changes()\n        \n        # Verify that the migration was detected correctly\n        self.assertEqual(len(changes['testapp']), 1)\n        self.assertEqual(changes['testapp'][0].__class__.__name__, 'CreateModel')\n\n    def test_custom_fk_field_with_to_parameter_continues_to_work(self):\n        \"\"\"\n        Test that custom ForeignKey fields that keep the 'to' parameter\n        in their deconstructed kwargs continue to work as expected.\n        \n        This ensures the fix doesn't break existing functionality.\n        \"\"\"\n        before = ProjectState()\n        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n        \n        after = ProjectState()\n        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n        after.add_model(ModelState('testapp', 'TestModel', [\n            ('custom', CustomFKFieldWithTo(on_delete=models.CASCADE))\n        ]))\n        \n        # This should work both before and after the fix\n        autodetector = MigrationAutodetector(before, after)\n        changes = autodetector._detect_changes()\n        \n        # Verify that the migration was detected correctly\n        self.assertEqual(len(changes['testapp']), 1)\n        self.assertEqual(changes['testapp'][0].__class__.__name__, 'CreateModel')\n\n    def test_only_relation_agnostic_fields_with_missing_to_key(self):\n        \"\"\"\n        Test the only_relation_agnostic_fields method directly with a field\n        that doesn't have a 'to' key in its deconstructed kwargs.\n        \"\"\"\n        autodetector = MigrationAutodetector(ProjectState(), ProjectState())\n        \n        # Create a field that will have 'to' removed from its kwargs\n        field = CustomFKFieldWithoutTo(on_delete=models.CASCADE)\n        fields = {'custom_field': field}\n        \n        # This should not raise a KeyError after the fix\n        result = autodetector.only_relation_agnostic_fields(fields)\n        \n        # Verify that we get a result (the exact content is less important\n        # than not getting a KeyError)\n        self.assertEqual(len(result), 1)\n        self.assertIsInstance(result[0], tuple)\n\n    def test_only_relation_agnostic_fields_with_existing_to_key(self):\n        \"\"\"\n        Test the only_relation_agnostic_fields method with a field that\n        has a 'to' key in its deconstructed kwargs (normal case).\n        \"\"\"\n        autodetector = MigrationAutodetector(ProjectState(), ProjectState())\n        \n        # Create a normal ForeignKey field\n        field = models.ForeignKey('testapp.SomeModel', on_delete=models.CASCADE)\n        fields = {'normal_field': field}\n        \n        # This should work both before and after the fix\n        result = autodetector.only_relation_agnostic_fields(fields)\n        \n        # Verify that we get a result and the 'to' key was removed\n        self.assertEqual(len(result), 1)\n        self.assertIsInstance(result[0], tuple)\n        # The 'to' key should have been removed from kwargs (index 2)\n        kwargs = result[0][2]\n        self.assertNotIn('to', kwargs)\n\n    def test_model_rename_detection_with_custom_fk_field(self):\n        \"\"\"\n        Test that model rename detection works correctly when models contain\n        custom ForeignKey fields that remove the 'to' parameter.\n        \n        This tests the specific scenario mentioned in the bug report where\n        generate_renamed_models calls only_relation_agnostic_fields.\n        \"\"\"\n        # Create initial state with a model\n        before = ProjectState()\n        before.add_model(ModelState('testapp', 'OldModel', [\n            ('custom', CustomFKFieldWithoutTo(on_delete=models.CASCADE))\n        ]))\n        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n        \n        # Create new state with renamed model\n        after = ProjectState()\n        after.add_model(ModelState('testapp', 'NewModel', [\n            ('custom', CustomFKFieldWithoutTo(on_delete=models.CASCADE))\n        ]))\n        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n        \n        # Mock the questioner to always answer \"yes\" to rename questions\n        class MockQuestioner:\n            def ask_rename_model(self, old_model, new_model):\n                return True\n        \n        autodetector = MigrationAutodetector(before, after, MockQuestioner())\n        \n        # This should not raise a KeyError after the fix\n        changes = autodetector._detect_changes()\n        \n        # Verify that a rename operation was detected\n        self.assertIn('testapp', changes)\n        self.assertTrue(len(changes['testapp']) > 0)\n\n    def test_edge_case_multiple_custom_fk_fields(self):\n        \"\"\"\n        Test edge case with multiple custom ForeignKey fields, some with\n        and some without the 'to' parameter in their kwargs.\n        \"\"\"\n        before = ProjectState()\n        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n        before.add_model(ModelState('testapp', 'OtherModel', []))\n        \n        after = ProjectState()\n        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n        after.add_model(ModelState('testapp', 'OtherModel', []))\n        after.add_model(ModelState('testapp', 'TestModel', [\n            ('custom_without_to', CustomFKFieldWithoutTo(on_delete=models.CASCADE)),\n            ('custom_with_to', CustomFKFieldWithTo(on_delete=models.CASCADE)),\n            ('normal_fk', models.ForeignKey('testapp.OtherModel', on_delete=models.CASCADE))\n        ]))\n        \n        autodetector = MigrationAutodetector(before, after)\n        \n        # This should not raise a KeyError after the fix\n        changes = autodetector._detect_changes()\n        \n        # Verify that the migration was detected correctly\n        self.assertEqual(len(changes['testapp']), 1)\n        self.assertEqual(changes['testapp'][0].__class__.__name__, 'CreateModel')\n\n    def test_empty_fields_dict(self):\n        \"\"\"\n        Test edge case with empty fields dictionary.\n        \"\"\"\n        autodetector = MigrationAutodetector(ProjectState(), ProjectState())\n        \n        # This should work without issues\n        result = autodetector.only_relation_agnostic_fields({})\n        \n        self.assertEqual(result, [])\n\n    def test_non_relation_fields_unaffected(self):\n        \"\"\"\n        Test that non-relation fields are not affected by the fix.\n        \"\"\"\n        autodetector = MigrationAutodetector(ProjectState(), ProjectState())\n        \n        fields = {\n            'char_field': models.CharField(max_length=100),\n            'int_field': models.IntegerField(),\n            'bool_field': models.BooleanField(default=False)\n        }\n        \n        result = autodetector.only_relation_agnostic_fields(fields)\n        \n        # Should have 3 field definitions\n        self.assertEqual(len(result), 3)\n        \n        # All should be tuples (field deconstructions)\n        for field_def in result:\n            self.assertIsInstance(field_def, tuple)\n</patched>\n```",
  "patch": "--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n-# This file already exists, we'll add our tests to it\n+import pytest\n+from django.db import models\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ModelState, ProjectState\n+from django.test import TestCase\n+\n+\n+class CustomFKFieldWithoutTo(models.ForeignKey):\n+    \"\"\"\n+    Custom ForeignKey field that hardcodes its 'to' argument and removes it\n+    from deconstructed kwargs. This reproduces the issue where the autodetector\n+    fails with KeyError when trying to delete the 'to' key that doesn't exist.\n+    \"\"\"\n+    def __init__(self, *args, **kwargs):\n+        kwargs['to'] = 'testapp.HardcodedModel'\n+        super().__init__(*args, **kwargs)\n+\n+    def deconstruct(self):\n+        name, path, args, kwargs = super().deconstruct()\n+        # Remove 'to' from kwargs - this causes the KeyError in the autodetector\n+        del kwargs[\"to\"]\n+        return name, path, args, kwargs\n+\n+\n+class CustomFKFieldWithTo(models.ForeignKey):\n+    \"\"\"\n+    Custom ForeignKey field that keeps the 'to' argument in deconstructed kwargs.\n+    This represents the normal case that should continue to work.\n+    \"\"\"\n+    def __init__(self, *args, **kwargs):\n+        kwargs['to'] = 'testapp.HardcodedModel'\n+        super().__init__(*args, **kwargs)\n+\n+    def deconstruct(self):\n+        # Keep 'to' in kwargs - this is the normal case\n+        return super().deconstruct()\n+\n+\n+class AutodetectorCustomFKTests(TestCase):\n+    \"\"\"\n+    Test cases for the migration autodetector with custom ForeignKey fields\n+    that may or may not include the 'to' parameter in their deconstructed kwargs.\n+    \"\"\"\n+\n+    def test_custom_fk_field_without_to_parameter_fails_before_fix(self):\n+        \"\"\"\n+        Test that reproduces the KeyError bug when a custom ForeignKey field\n+        removes the 'to' parameter from its deconstructed kwargs.\n+        \n+        This test should fail before the fix is applied and pass after.\n+        \"\"\"\n+        before = ProjectState()\n+        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        \n+        after = ProjectState()\n+        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        after.add_model(ModelState('testapp', 'TestModel', [\n+            ('custom', CustomFKFieldWithoutTo(on_delete=models.CASCADE))\n+        ]))\n+        \n+        # This should not raise a KeyError after the fix\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+        \n+        # Verify that the migration was detected correctly\n+        self.assertEqual(len(changes['testapp']), 1)\n+        self.assertEqual(changes['testapp'][0].__class__.__name__, 'CreateModel')\n+\n+    def test_custom_fk_field_with_to_parameter_continues_to_work(self):\n+        \"\"\"\n+        Test that custom ForeignKey fields that keep the 'to' parameter\n+        in their deconstructed kwargs continue to work as expected.\n+        \n+        This ensures the fix doesn't break existing functionality.\n+        \"\"\"\n+        before = ProjectState()\n+        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        \n+        after = ProjectState()\n+        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        after.add_model(ModelState('testapp', 'TestModel', [\n+            ('custom', CustomFKFieldWithTo(on_delete=models.CASCADE))\n+        ]))\n+        \n+        # This should work both before and after the fix\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+        \n+        # Verify that the migration was detected correctly\n+        self.assertEqual(len(changes['testapp']), 1)\n+        self.assertEqual(changes['testapp'][0].__class__.__name__, 'CreateModel')\n+\n+    def test_only_relation_agnostic_fields_with_missing_to_key(self):\n+        \"\"\"\n+        Test the only_relation_agnostic_fields method directly with a field\n+        that doesn't have a 'to' key in its deconstructed kwargs.\n+        \"\"\"\n+        autodetector = MigrationAutodetector(ProjectState(), ProjectState())\n+        \n+        # Create a field that will have 'to' removed from its kwargs\n+        field = CustomFKFieldWithoutTo(on_delete=models.CASCADE)\n+        fields = {'custom_field': field}\n+        \n+        # This should not raise a KeyError after the fix\n+        result = autodetector.only_relation_agnostic_fields(fields)\n+        \n+        # Verify that we get a result (the exact content is less important\n+        # than not getting a KeyError)\n+        self.assertEqual(len(result), 1)\n+        self.assertIsInstance(result[0], tuple)\n+\n+    def test_only_relation_agnostic_fields_with_existing_to_key(self):\n+        \"\"\"\n+        Test the only_relation_agnostic_fields method with a field that\n+        has a 'to' key in its deconstructed kwargs (normal case).\n+        \"\"\"\n+        autodetector = MigrationAutodetector(ProjectState(), ProjectState())\n+        \n+        # Create a normal ForeignKey field\n+        field = models.ForeignKey('testapp.SomeModel', on_delete=models.CASCADE)\n+        fields = {'normal_field': field}\n+        \n+        # This should work both before and after the fix\n+        result = autodetector.only_relation_agnostic_fields(fields)\n+        \n+        # Verify that we get a result and the 'to' key was removed\n+        self.assertEqual(len(result), 1)\n+        self.assertIsInstance(result[0], tuple)\n+        # The 'to' key should have been removed from kwargs (index 2)\n+        kwargs = result[0][2]\n+        self.assertNotIn('to', kwargs)\n+\n+    def test_model_rename_detection_with_custom_fk_field(self):\n+        \"\"\"\n+        Test that model rename detection works correctly when models contain\n+        custom ForeignKey fields that remove the 'to' parameter.\n+        \n+        This tests the specific scenario mentioned in the bug report where\n+        generate_renamed_models calls only_relation_agnostic_fields.\n+        \"\"\"\n+        # Create initial state with a model\n+        before = ProjectState()\n+        before.add_model(ModelState('testapp', 'OldModel', [\n+            ('custom', CustomFKFieldWithoutTo(on_delete=models.CASCADE))\n+        ]))\n+        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        \n+        # Create new state with renamed model\n+        after = ProjectState()\n+        after.add_model(ModelState('testapp', 'NewModel', [\n+            ('custom', CustomFKFieldWithoutTo(on_delete=models.CASCADE))\n+        ]))\n+        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        \n+        # Mock the questioner to always answer \"yes\" to rename questions\n+        class MockQuestioner:\n+            def ask_rename_model(self, old_model, new_model):\n+                return True\n+        \n+        autodetector = MigrationAutodetector(before, after, MockQuestioner())\n+        \n+        # This should not raise a KeyError after the fix\n+        changes = autodetector._detect_changes()\n+        \n+        # Verify that a rename operation was detected\n+        self.assertIn('testapp', changes)\n+        self.assertTrue(len(changes['testapp']) > 0)\n+\n+    def test_edge_case_multiple_custom_fk_fields(self):\n+        \"\"\"\n+        Test edge case with multiple custom ForeignKey fields, some with\n+        and some without the 'to' parameter in their kwargs.\n+        \"\"\"\n+        before = ProjectState()\n+        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        before.add_model(ModelState('testapp', 'OtherModel', []))\n+        \n+        after = ProjectState()\n+        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        after.add_model(ModelState('testapp', 'OtherModel', []))\n+        after.add_model(ModelState('testapp', 'TestModel', [\n+            ('custom_without_to', CustomFKFieldWithoutTo(on_delete=models.CASCADE)),\n+            ('custom_with_to', CustomFKFieldWithTo(on_delete=models.CASCADE)),\n+            ('normal_fk', models.ForeignKey('testapp.OtherModel', on_delete=models.CASCADE))\n+        ]))\n+        \n+        autodetector = MigrationAutodetector(before, after)\n+        \n+        # This should not raise a KeyError after the fix\n+        changes = autodetector._detect_changes()\n+        \n+        # Verify that the migration was detected correctly\n+        self.assertEqual(len(changes['testapp']), 1)\n+        self.assertEqual(changes['testapp'][0].__class__.__name__, 'CreateModel')\n+\n+    def test_empty_fields_dict(self):\n+        \"\"\"\n+        Test edge case with empty fields dictionary.\n+        \"\"\"\n+        autodetector = MigrationAutodetector(ProjectState(), ProjectState())\n+        \n+        # This should work without issues\n+        result = autodetector.only_relation_agnostic_fields({})\n+        \n+        self.assertEqual(result, [])\n+\n+    def test_non_relation_fields_unaffected(self):\n+        \"\"\"\n+        Test that non-relation fields are not affected by the fix.\n+        \"\"\"\n+        autodetector = MigrationAutodetector(ProjectState(), ProjectState())\n+        \n+        fields = {\n+            'char_field': models.CharField(max_length=100),\n+            'int_field': models.IntegerField(),\n+            'bool_field': models.BooleanField(default=False)\n+        }\n+        \n+        result = autodetector.only_relation_agnostic_fields(fields)\n+        \n+        # Should have 3 field definitions\n+        self.assertEqual(len(result), 3)\n+        \n+        # All should be tuples (field deconstructions)\n+        for field_def in result:\n+            self.assertIsInstance(field_def, tuple)\n"
}