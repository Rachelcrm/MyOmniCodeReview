{
  "instance_id": "django__django-11400",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/admin_filters/test_related_field_ordering.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib.admin import ModelAdmin, site\nfrom django.contrib.admin.filters import RelatedFieldListFilter, RelatedOnlyFieldListFilter\nfrom django.contrib.auth.models import User\nfrom django.db import models\nfrom django.test import RequestFactory, TestCase\n\n\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n    \n    class Meta:\n        ordering = ['name']  # Default ordering by name\n        app_label = 'admin_filters'\n\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n    \n    class Meta:\n        app_label = 'admin_filters'\n\n\nclass AuthorAdmin(ModelAdmin):\n    ordering = ['name']  # Explicit admin ordering\n\n\nclass AuthorAdminWithCustomOrdering(ModelAdmin):\n    ordering = ['-name']  # Reverse ordering in admin\n\n\nclass BookAdmin(ModelAdmin):\n    list_filter = ['author']\n\n\nclass BookAdminWithRelatedOnly(ModelAdmin):\n    list_filter = [('author', RelatedOnlyFieldListFilter)]\n\n\n@pytest.mark.django_db\nclass TestRelatedFieldListFilterOrdering:\n    \"\"\"Test ordering behavior in RelatedFieldListFilter.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test data and request factory.\"\"\"\n        self.factory = RequestFactory()\n        self.request = self.factory.get('/')\n        self.request.user = User.objects.create_superuser('admin', 'admin@test.com', 'password')\n        \n        # Create test authors with names that will show ordering differences\n        self.author_z = Author.objects.create(name='Zoe Author')\n        self.author_a = Author.objects.create(name='Alice Author')\n        self.author_m = Author.objects.create(name='Mike Author')\n        \n        # Create books\n        self.book1 = Book.objects.create(title='Book 1', author=self.author_z)\n        self.book2 = Book.objects.create(title='Book 2', author=self.author_a)\n        self.book3 = Book.objects.create(title='Book 3', author=self.author_m)\n    \n    def test_related_field_filter_uses_model_meta_ordering_when_no_admin(self):\n        \"\"\"Test that RelatedFieldListFilter falls back to Model._meta.ordering when no ModelAdmin is registered.\"\"\"\n        # Don't register any ModelAdmin for Author\n        book_admin = BookAdmin(Book, site)\n        \n        # Get the author field from Book model\n        author_field = Book._meta.get_field('author')\n        \n        # Create the filter\n        filter_instance = RelatedFieldListFilter(\n            field=author_field,\n            request=self.request,\n            params={},\n            model=Book,\n            model_admin=book_admin,\n            field_path='author'\n        )\n        \n        # Get the field choices\n        choices = filter_instance.field_choices(author_field, self.request, book_admin)\n        choice_values = [choice[1] for choice in choices]\n        \n        # Should be ordered by name (Model._meta.ordering = ['name'])\n        expected_order = ['Alice Author', 'Mike Author', 'Zoe Author']\n        assert choice_values == expected_order, f\"Expected {expected_order}, got {choice_values}\"\n    \n    def test_related_field_filter_uses_admin_ordering_when_available(self):\n        \"\"\"Test that RelatedFieldListFilter uses ModelAdmin ordering when available.\"\"\"\n        # Register AuthorAdmin with custom ordering\n        site.register(Author, AuthorAdminWithCustomOrdering)\n        \n        try:\n            book_admin = BookAdmin(Book, site)\n            author_field = Book._meta.get_field('author')\n            \n            filter_instance = RelatedFieldListFilter(\n                field=author_field,\n                request=self.request,\n                params={},\n                model=Book,\n                model_admin=book_admin,\n                field_path='author'\n            )\n            \n            choices = filter_instance.field_choices(author_field, self.request, book_admin)\n            choice_values = [choice[1] for choice in choices]\n            \n            # Should be ordered by -name (AuthorAdminWithCustomOrdering.ordering = ['-name'])\n            expected_order = ['Zoe Author', 'Mike Author', 'Alice Author']\n            assert choice_values == expected_order, f\"Expected {expected_order}, got {choice_values}\"\n        \n        finally:\n            # Clean up registration\n            site.unregister(Author)\n    \n    def test_related_field_filter_empty_ordering_fallback_before_fix(self):\n        \"\"\"Test that demonstrates the bug: empty ordering when no admin is registered.\"\"\"\n        # This test should fail before the fix is applied\n        book_admin = BookAdmin(Book, site)\n        author_field = Book._meta.get_field('author')\n        \n        filter_instance = RelatedFieldListFilter(\n            field=author_field,\n            request=self.request,\n            params={},\n            model=Book,\n            model_admin=book_admin,\n            field_path='author'\n        )\n        \n        # Directly test the current buggy behavior\n        ordering = ()\n        related_admin = book_admin.admin_site._registry.get(author_field.remote_field.model)\n        if related_admin is not None:\n            ordering = related_admin.get_ordering(self.request)\n        \n        # This should be empty tuple in the buggy version\n        # After fix, it should fall back to model ordering\n        if not ordering:  # This is the bug - should check model._meta.ordering\n            # In the buggy version, this stays empty\n            assert ordering == (), \"Bug reproduced: ordering stays empty when no admin registered\"\n\n\n@pytest.mark.django_db\nclass TestRelatedOnlyFieldListFilterOrdering:\n    \"\"\"Test ordering behavior in RelatedOnlyFieldListFilter.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test data and request factory.\"\"\"\n        self.factory = RequestFactory()\n        self.request = self.factory.get('/')\n        self.request.user = User.objects.create_superuser('admin', 'admin@test.com', 'password')\n        \n        # Create test authors\n        self.author_z = Author.objects.create(name='Zoe Author')\n        self.author_a = Author.objects.create(name='Alice Author')\n        self.author_m = Author.objects.create(name='Mike Author')\n        \n        # Create books - only some authors will have books (for RelatedOnly filter)\n        self.book1 = Book.objects.create(title='Book 1', author=self.author_z)\n        self.book2 = Book.objects.create(title='Book 2', author=self.author_a)\n        # Note: author_m has no books\n    \n    def test_related_only_filter_ignores_ordering_before_fix(self):\n        \"\"\"Test that demonstrates the bug: RelatedOnlyFieldListFilter ignores ordering completely.\"\"\"\n        book_admin = BookAdminWithRelatedOnly(Book, site)\n        author_field = Book._meta.get_field('author')\n        \n        # Create filter instance\n        filter_instance = RelatedOnlyFieldListFilter(\n            field=author_field,\n            request=self.request,\n            params={},\n            model=Book,\n            model_admin=book_admin,\n            field_path='author'\n        )\n        \n        # Get choices using the current buggy implementation\n        choices = filter_instance.field_choices(author_field, self.request, book_admin)\n        choice_values = [choice[1] for choice in choices]\n        \n        # The bug: choices are not ordered at all, they come in whatever order the database returns\n        # This test documents the current buggy behavior\n        # After fix, they should be ordered according to Model._meta.ordering or admin ordering\n        assert len(choice_values) == 2, \"Should only include authors with books\"\n        assert 'Alice Author' in choice_values\n        assert 'Zoe Author' in choice_values\n        assert 'Mike Author' not in choice_values, \"Should not include authors without books\"\n    \n    def test_related_only_filter_should_use_model_ordering_after_fix(self):\n        \"\"\"Test that RelatedOnlyFieldListFilter should use model ordering after fix.\"\"\"\n        book_admin = BookAdminWithRelatedOnly(Book, site)\n        author_field = Book._meta.get_field('author')\n        \n        filter_instance = RelatedOnlyFieldListFilter(\n            field=author_field,\n            request=self.request,\n            params={},\n            model=Book,\n            model_admin=book_admin,\n            field_path='author'\n        )\n        \n        choices = filter_instance.field_choices(author_field, self.request, book_admin)\n        choice_values = [choice[1] for choice in choices]\n        \n        # After fix: should be ordered by name (Model._meta.ordering = ['name'])\n        # and only include authors with books\n        expected_order = ['Alice Author', 'Zoe Author']  # Alphabetical order, only authors with books\n        assert choice_values == expected_order, f\"Expected {expected_order}, got {choice_values}\"\n    \n    def test_related_only_filter_should_use_admin_ordering_after_fix(self):\n        \"\"\"Test that RelatedOnlyFieldListFilter should use admin ordering when available after fix.\"\"\"\n        # Register AuthorAdmin with custom ordering\n        site.register(Author, AuthorAdminWithCustomOrdering)\n        \n        try:\n            book_admin = BookAdminWithRelatedOnly(Book, site)\n            author_field = Book._meta.get_field('author')\n            \n            filter_instance = RelatedOnlyFieldListFilter(\n                field=author_field,\n                request=self.request,\n                params={},\n                model=Book,\n                model_admin=book_admin,\n                field_path='author'\n            )\n            \n            choices = filter_instance.field_choices(author_field, self.request, book_admin)\n            choice_values = [choice[1] for choice in choices]\n            \n            # After fix: should be ordered by -name (AuthorAdminWithCustomOrdering.ordering = ['-name'])\n            # and only include authors with books\n            expected_order = ['Zoe Author', 'Alice Author']  # Reverse alphabetical, only authors with books\n            assert choice_values == expected_order, f\"Expected {expected_order}, got {choice_values}\"\n        \n        finally:\n            # Clean up registration\n            site.unregister(Author)\n\n\n@pytest.mark.django_db\nclass TestFilterOrderingEdgeCases:\n    \"\"\"Test edge cases for filter ordering.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test data and request factory.\"\"\"\n        self.factory = RequestFactory()\n        self.request = self.factory.get('/')\n        self.request.user = User.objects.create_superuser('admin', 'admin@test.com', 'password')\n    \n    def test_empty_model_meta_ordering(self):\n        \"\"\"Test behavior when Model._meta.ordering is empty.\"\"\"\n        # Create a model with no ordering\n        class UnorderedModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                ordering = []  # Empty ordering\n                app_label = 'admin_filters'\n        \n        class RelatedModel(models.Model):\n            title = models.CharField(max_length=100)\n            related = models.ForeignKey(UnorderedModel, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'admin_filters'\n        \n        # Test should handle empty model ordering gracefully\n        # This is an edge case that should not break the filter\n        pass\n    \n    def test_none_model_meta_ordering(self):\n        \"\"\"Test behavior when Model._meta.ordering is None.\"\"\"\n        # Some models might have ordering = None\n        # The filter should handle this gracefully\n        pass\n</patched>\n</file>\n```\n\n```\n<file>tests/admin_filters/test_related_field_ordering_integration.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib.admin import ModelAdmin, site\nfrom django.contrib.admin.filters import RelatedFieldListFilter, RelatedOnlyFieldListFilter\nfrom django.contrib.auth.models import User\nfrom django.db import models\nfrom django.test import RequestFactory, TestCase, override_settings\n\n\nclass Category(models.Model):\n    name = models.CharField(max_length=100)\n    priority = models.IntegerField(default=0)\n    \n    class Meta:\n        ordering = ['priority', 'name']  # Multi-field ordering\n        app_label = 'admin_filters'\n    \n    def __str__(self):\n        return self.name\n\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    category = models.ForeignKey(Category, on_delete=models.CASCADE)\n    \n    class Meta:\n        app_label = 'admin_filters'\n\n\nclass CategoryAdmin(ModelAdmin):\n    ordering = ['-priority', 'name']  # Different ordering in admin\n\n\nclass ProductAdmin(ModelAdmin):\n    list_filter = ['category']\n\n\n@pytest.mark.django_db\nclass TestRelatedFieldFilterIntegration:\n    \"\"\"Integration tests for RelatedFieldListFilter ordering fixes.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test data.\"\"\"\n        self.factory = RequestFactory()\n        self.request = self.factory.get('/')\n        self.request.user = User.objects.create_superuser('admin', 'admin@test.com', 'password')\n        \n        # Create categories with different priorities to test multi-field ordering\n        self.cat_high_z = Category.objects.create(name='Z Category', priority=10)\n        self.cat_high_a = Category.objects.create(name='A Category', priority=10)\n        self.cat_low_m = Category.objects.create(name='M Category', priority=1)\n        self.cat_low_b = Category.objects.create(name='B Category', priority=1)\n        \n        # Create products\n        Product.objects.create(name='Product 1', category=self.cat_high_z)\n        Product.objects.create(name='Product 2', category=self.cat_high_a)\n        Product.objects.create(name='Product 3', category=self.cat_low_m)\n        Product.objects.create(name='Product 4', category=self.cat_low_b)\n    \n    def test_multi_field_model_ordering_fallback(self):\n        \"\"\"Test that multi-field Model._meta.ordering works as fallback.\"\"\"\n        product_admin = ProductAdmin(Product, site)\n        category_field = Product._meta.get_field('category')\n        \n        filter_instance = RelatedFieldListFilter(\n            field=category_field,\n            request=self.request,\n            params={},\n            model=Product,\n            model_admin=product_admin,\n            field_path='category'\n        )\n        \n        choices = filter_instance.field_choices(category_field, self.request, product_admin)\n        choice_values = [choice[1] for choice in choices]\n        \n        # Should be ordered by priority first, then name (Model._meta.ordering = ['priority', 'name'])\n        expected_order = ['B Category', 'M Category', 'A Category', 'Z Category']\n        assert choice_values == expected_order, f\"Expected {expected_order}, got {choice_values}\"\n    \n    def test_admin_ordering_overrides_model_ordering(self):\n        \"\"\"Test that admin ordering takes precedence over model ordering.\"\"\"\n        site.register(Category, CategoryAdmin)\n        \n        try:\n            product_admin = ProductAdmin(Product, site)\n            category_field = Product._meta.get_field('category')\n            \n            filter_instance = RelatedFieldListFilter(\n                field=category_field,\n                request=self.request,\n                params={},\n                model=Product,\n                model_admin=product_admin,\n                field_path='category'\n            )\n            \n            choices = filter_instance.field_choices(category_field, self.request,",
  "patch": "--- a/tests/admin_filters/test_related_field_ordering.py\n+++ b/tests/admin_filters/test_related_field_ordering.py\n-# Empty if creating new file\n+import pytest\n+from django.contrib.admin import ModelAdmin, site\n+from django.contrib.admin.filters import RelatedFieldListFilter, RelatedOnlyFieldListFilter\n+from django.contrib.auth.models import User\n+from django.db import models\n+from django.test import RequestFactory, TestCase\n+\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        ordering = ['name']  # Default ordering by name\n+        app_label = 'admin_filters'\n+\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'admin_filters'\n+\n+\n+class AuthorAdmin(ModelAdmin):\n+    ordering = ['name']  # Explicit admin ordering\n+\n+\n+class AuthorAdminWithCustomOrdering(ModelAdmin):\n+    ordering = ['-name']  # Reverse ordering in admin\n+\n+\n+class BookAdmin(ModelAdmin):\n+    list_filter = ['author']\n+\n+\n+class BookAdminWithRelatedOnly(ModelAdmin):\n+    list_filter = [('author', RelatedOnlyFieldListFilter)]\n+\n+\n+@pytest.mark.django_db\n+class TestRelatedFieldListFilterOrdering:\n+    \"\"\"Test ordering behavior in RelatedFieldListFilter.\"\"\"\n+    \n+    def setup_method(self):\n+        \"\"\"Set up test data and request factory.\"\"\"\n+        self.factory = RequestFactory()\n+        self.request = self.factory.get('/')\n+        self.request.user = User.objects.create_superuser('admin', 'admin@test.com', 'password')\n+        \n+        # Create test authors with names that will show ordering differences\n+        self.author_z = Author.objects.create(name='Zoe Author')\n+        self.author_a = Author.objects.create(name='Alice Author')\n+        self.author_m = Author.objects.create(name='Mike Author')\n+        \n+        # Create books\n+        self.book1 = Book.objects.create(title='Book 1', author=self.author_z)\n+        self.book2 = Book.objects.create(title='Book 2', author=self.author_a)\n+        self.book3 = Book.objects.create(title='Book 3', author=self.author_m)\n+    \n+    def test_related_field_filter_uses_model_meta_ordering_when_no_admin(self):\n+        \"\"\"Test that RelatedFieldListFilter falls back to Model._meta.ordering when no ModelAdmin is registered.\"\"\"\n+        # Don't register any ModelAdmin for Author\n+        book_admin = BookAdmin(Book, site)\n+        \n+        # Get the author field from Book model\n+        author_field = Book._meta.get_field('author')\n+        \n+        # Create the filter\n+        filter_instance = RelatedFieldListFilter(\n+            field=author_field,\n+            request=self.request,\n+            params={},\n+            model=Book,\n+            model_admin=book_admin,\n+            field_path='author'\n+        )\n+        \n+        # Get the field choices\n+        choices = filter_instance.field_choices(author_field, self.request, book_admin)\n+        choice_values = [choice[1] for choice in choices]\n+        \n+        # Should be ordered by name (Model._meta.ordering = ['name'])\n+        expected_order = ['Alice Author', 'Mike Author', 'Zoe Author']\n+        assert choice_values == expected_order, f\"Expected {expected_order}, got {choice_values}\"\n+    \n+    def test_related_field_filter_uses_admin_ordering_when_available(self):\n+        \"\"\"Test that RelatedFieldListFilter uses ModelAdmin ordering when available.\"\"\"\n+        # Register AuthorAdmin with custom ordering\n+        site.register(Author, AuthorAdminWithCustomOrdering)\n+        \n+        try:\n+            book_admin = BookAdmin(Book, site)\n+            author_field = Book._meta.get_field('author')\n+            \n+            filter_instance = RelatedFieldListFilter(\n+                field=author_field,\n+                request=self.request,\n+                params={},\n+                model=Book,\n+                model_admin=book_admin,\n+                field_path='author'\n+            )\n+            \n+            choices = filter_instance.field_choices(author_field, self.request, book_admin)\n+            choice_values = [choice[1] for choice in choices]\n+            \n+            # Should be ordered by -name (AuthorAdminWithCustomOrdering.ordering = ['-name'])\n+            expected_order = ['Zoe Author', 'Mike Author', 'Alice Author']\n+            assert choice_values == expected_order, f\"Expected {expected_order}, got {choice_values}\"\n+        \n+        finally:\n+            # Clean up registration\n+            site.unregister(Author)\n+    \n+    def test_related_field_filter_empty_ordering_fallback_before_fix(self):\n+        \"\"\"Test that demonstrates the bug: empty ordering when no admin is registered.\"\"\"\n+        # This test should fail before the fix is applied\n+        book_admin = BookAdmin(Book, site)\n+        author_field = Book._meta.get_field('author')\n+        \n+        filter_instance = RelatedFieldListFilter(\n+            field=author_field,\n+            request=self.request,\n+            params={},\n+            model=Book,\n+            model_admin=book_admin,\n+            field_path='author'\n+        )\n+        \n+        # Directly test the current buggy behavior\n+        ordering = ()\n+        related_admin = book_admin.admin_site._registry.get(author_field.remote_field.model)\n+        if related_admin is not None:\n+            ordering = related_admin.get_ordering(self.request)\n+        \n+        # This should be empty tuple in the buggy version\n+        # After fix, it should fall back to model ordering\n+        if not ordering:  # This is the bug - should check model._meta.ordering\n+            # In the buggy version, this stays empty\n+            assert ordering == (), \"Bug reproduced: ordering stays empty when no admin registered\"\n+\n+\n+@pytest.mark.django_db\n+class TestRelatedOnlyFieldListFilterOrdering:\n+    \"\"\"Test ordering behavior in RelatedOnlyFieldListFilter.\"\"\"\n+    \n+    def setup_method(self):\n+        \"\"\"Set up test data and request factory.\"\"\"\n+        self.factory = RequestFactory()\n+        self.request = self.factory.get('/')\n+        self.request.user = User.objects.create_superuser('admin', 'admin@test.com', 'password')\n+        \n+        # Create test authors\n+        self.author_z = Author.objects.create(name='Zoe Author')\n+        self.author_a = Author.objects.create(name='Alice Author')\n+        self.author_m = Author.objects.create(name='Mike Author')\n+        \n+        # Create books - only some authors will have books (for RelatedOnly filter)\n+        self.book1 = Book.objects.create(title='Book 1', author=self.author_z)\n+        self.book2 = Book.objects.create(title='Book 2', author=self.author_a)\n+        # Note: author_m has no books\n+    \n+    def test_related_only_filter_ignores_ordering_before_fix(self):\n+        \"\"\"Test that demonstrates the bug: RelatedOnlyFieldListFilter ignores ordering completely.\"\"\"\n+        book_admin = BookAdminWithRelatedOnly(Book, site)\n+        author_field = Book._meta.get_field('author')\n+        \n+        # Create filter instance\n+        filter_instance = RelatedOnlyFieldListFilter(\n+            field=author_field,\n+            request=self.request,\n+            params={},\n+            model=Book,\n+            model_admin=book_admin,\n+            field_path='author'\n+        )\n+        \n+        # Get choices using the current buggy implementation\n+        choices = filter_instance.field_choices(author_field, self.request, book_admin)\n+        choice_values = [choice[1] for choice in choices]\n+        \n+        # The bug: choices are not ordered at all, they come in whatever order the database returns\n+        # This test documents the current buggy behavior\n+        # After fix, they should be ordered according to Model._meta.ordering or admin ordering\n+        assert len(choice_values) == 2, \"Should only include authors with books\"\n+        assert 'Alice Author' in choice_values\n+        assert 'Zoe Author' in choice_values\n+        assert 'Mike Author' not in choice_values, \"Should not include authors without books\"\n+    \n+    def test_related_only_filter_should_use_model_ordering_after_fix(self):\n+        \"\"\"Test that RelatedOnlyFieldListFilter should use model ordering after fix.\"\"\"\n+        book_admin = BookAdminWithRelatedOnly(Book, site)\n+        author_field = Book._meta.get_field('author')\n+        \n+        filter_instance = RelatedOnlyFieldListFilter(\n+            field=author_field,\n+            request=self.request,\n+            params={},\n+            model=Book,\n+            model_admin=book_admin,\n+            field_path='author'\n+        )\n+        \n+        choices = filter_instance.field_choices(author_field, self.request, book_admin)\n+        choice_values = [choice[1] for choice in choices]\n+        \n+        # After fix: should be ordered by name (Model._meta.ordering = ['name'])\n+        # and only include authors with books\n+        expected_order = ['Alice Author', 'Zoe Author']  # Alphabetical order, only authors with books\n+        assert choice_values == expected_order, f\"Expected {expected_order}, got {choice_values}\"\n+    \n+    def test_related_only_filter_should_use_admin_ordering_after_fix(self):\n+        \"\"\"Test that RelatedOnlyFieldListFilter should use admin ordering when available after fix.\"\"\"\n+        # Register AuthorAdmin with custom ordering\n+        site.register(Author, AuthorAdminWithCustomOrdering)\n+        \n+        try:\n+            book_admin = BookAdminWithRelatedOnly(Book, site)\n+            author_field = Book._meta.get_field('author')\n+            \n+            filter_instance = RelatedOnlyFieldListFilter(\n+                field=author_field,\n+                request=self.request,\n+                params={},\n+                model=Book,\n+                model_admin=book_admin,\n+                field_path='author'\n+            )\n+            \n+            choices = filter_instance.field_choices(author_field, self.request, book_admin)\n+            choice_values = [choice[1] for choice in choices]\n+            \n+            # After fix: should be ordered by -name (AuthorAdminWithCustomOrdering.ordering = ['-name'])\n+            # and only include authors with books\n+            expected_order = ['Zoe Author', 'Alice Author']  # Reverse alphabetical, only authors with books\n+            assert choice_values == expected_order, f\"Expected {expected_order}, got {choice_values}\"\n+        \n+        finally:\n+            # Clean up registration\n+            site.unregister(Author)\n+\n+\n+@pytest.mark.django_db\n+class TestFilterOrderingEdgeCases:\n+    \"\"\"Test edge cases for filter ordering.\"\"\"\n+    \n+    def setup_method(self):\n+        \"\"\"Set up test data and request factory.\"\"\"\n+        self.factory = RequestFactory()\n+        self.request = self.factory.get('/')\n+        self.request.user = User.objects.create_superuser('admin', 'admin@test.com', 'password')\n+    \n+    def test_empty_model_meta_ordering(self):\n+        \"\"\"Test behavior when Model._meta.ordering is empty.\"\"\"\n+        # Create a model with no ordering\n+        class UnorderedModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                ordering = []  # Empty ordering\n+                app_label = 'admin_filters'\n+        \n+        class RelatedModel(models.Model):\n+            title = models.CharField(max_length=100)\n+            related = models.ForeignKey(UnorderedModel, on_delete=models.CASCADE)\n+            \n+            class Meta:\n+                app_label = 'admin_filters'\n+        \n+        # Test should handle empty model ordering gracefully\n+        # This is an edge case that should not break the filter\n+        pass\n+    \n+    def test_none_model_meta_ordering(self):\n+        \"\"\"Test behavior when Model._meta.ordering is None.\"\"\"\n+        # Some models might have ordering = None\n+        # The filter should handle this gracefully\n+        pass\n"
}