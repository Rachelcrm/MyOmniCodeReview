--- a/sklearn/preprocessing/tests/test_discretization.py
+++ b/sklearn/preprocessing/tests/test_discretization.py
-# Empty if creating new file
+import numpy as np
+import pytest
+from sklearn.preprocessing import KBinsDiscretizer
+from sklearn.utils.testing import assert_array_equal, assert_raises
+
+
+def test_kbins_discretizer_kmeans_unsorted_bin_edges():
+    """Test that KBinsDiscretizer with kmeans strategy handles unsorted cluster centers.
+    
+    This test reproduces the bug where kmeans strategy fails due to unsorted bin_edges
+    when the number of bins is close to the number of data points.
+    """
+    # This is the exact example from the issue that causes the bug
+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)
+    
+    # This should not raise an error after the fix
+    est = KBinsDiscretizer(n_bins=5, strategy='kmeans', encode='ordinal')
+    Xt = est.fit_transform(X)
+    
+    # Verify that the transformation produces valid results
+    assert Xt.shape == (6, 1)
+    assert np.all(Xt >= 0)
+    assert np.all(Xt < 5)  # Should be in range [0, n_bins)
+    
+    # Verify that bin edges are monotonically increasing
+    bin_edges = est.bin_edges_[0]
+    assert np.all(bin_edges[1:] >= bin_edges[:-1]), "Bin edges should be monotonically increasing"
+
+
+def test_kbins_discretizer_kmeans_various_n_bins():
+    """Test KBinsDiscretizer with kmeans strategy for various numbers of bins.
+    
+    This tests edge cases where n_bins is close to the number of unique data points,
+    which is more likely to trigger the unsorted centers issue.
+    """
+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)
+    
+    # Test with different numbers of bins that could trigger the issue
+    for n_bins in [2, 3, 4, 5, 6]:
+        est = KBinsDiscretizer(n_bins=n_bins, strategy='kmeans', encode='ordinal')
+        Xt = est.fit_transform(X)
+        
+        # Verify basic properties
+        assert Xt.shape == (6, 1)
+        assert np.all(Xt >= 0)
+        assert np.all(Xt < n_bins)
+        
+        # Verify that bin edges are monotonically increasing
+        bin_edges = est.bin_edges_[0]
+        assert np.all(bin_edges[1:] >= bin_edges[:-1]), f"Bin edges should be monotonically increasing for n_bins={n_bins}"
+
+
+def test_kbins_discretizer_kmeans_random_data():
+    """Test KBinsDiscretizer with kmeans strategy on random data.
+    
+    This test uses random data to catch potential issues with unsorted centers
+    that might not appear with carefully crafted data.
+    """
+    np.random.seed(42)
+    X = np.random.rand(20, 1) * 100  # Random data in [0, 100]
+    
+    for n_bins in [3, 5, 8, 10]:
+        est = KBinsDiscretizer(n_bins=n_bins, strategy='kmeans', encode='ordinal')
+        Xt = est.fit_transform(X)
+        
+        # Verify basic properties
+        assert Xt.shape == (20, 1)
+        assert np.all(Xt >= 0)
+        assert np.all(Xt < n_bins)
+        
+        # Verify that bin edges are monotonically increasing
+        bin_edges = est.bin_edges_[0]
+        assert np.all(bin_edges[1:] >= bin_edges[:-1]), f"Bin edges should be monotonically increasing for n_bins={n_bins}"
+
+
+def test_kbins_discretizer_kmeans_multifeature():
+    """Test KBinsDiscretizer with kmeans strategy on multi-feature data.
+    
+    This ensures the fix works correctly when there are multiple features.
+    """
+    X = np.array([[0, 1], [0.5, 2], [2, 3], [3, 4], [9, 5], [10, 6]])
+    
+    est = KBinsDiscretizer(n_bins=4, strategy='kmeans', encode='ordinal')
+    Xt = est.fit_transform(X)
+    
+    # Verify basic properties
+    assert Xt.shape == (6, 2)
+    assert np.all(Xt >= 0)
+    assert np.all(Xt < 4)
+    
+    # Verify that bin edges are monotonically increasing for each feature
+    for feature_idx in range(2):
+        bin_edges = est.bin_edges_[feature_idx]
+        assert np.all(bin_edges[1:] >= bin_edges[:-1]), f"Bin edges should be monotonically increasing for feature {feature_idx}"
+
+
+def test_kbins_discretizer_kmeans_edge_case_high_bins():
+    """Test KBinsDiscretizer with kmeans strategy when n_bins equals number of samples.
+    
+    This is an edge case that's more likely to trigger unsorted centers.
+    """
+    X = np.array([1, 3, 2, 8, 5, 7]).reshape(-1, 1)
+    n_samples = X.shape[0]
+    
+    # When n_bins equals n_samples, each point could potentially be its own cluster
+    est = KBinsDiscretizer(n_bins=n_samples, strategy='kmeans', encode='ordinal')
+    Xt = est.fit_transform(X)
+    
+    # Verify basic properties
+    assert Xt.shape == (n_samples, 1)
+    assert np.all(Xt >= 0)
+    assert np.all(Xt < n_samples)
+    
+    # Verify that bin edges are monotonically increasing
+    bin_edges = est.bin_edges_[0]
+    assert np.all(bin_edges[1:] >= bin_edges[:-1]), "Bin edges should be monotonically increasing"
+
+
+def test_kbins_discretizer_kmeans_consistency_with_other_strategies():
+    """Test that kmeans strategy produces consistent results with other strategies.
+    
+    While the exact bin edges will differ, the basic properties should be the same.
+    """
+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)
+    n_bins = 3
+    
+    strategies = ['uniform', 'quantile', 'kmeans']
+    results = {}
+    
+    for strategy in strategies:
+        est = KBinsDiscretizer(n_bins=n_bins, strategy=strategy, encode='ordinal')
+        Xt = est.fit_transform(X)
+        results[strategy] = Xt
+        
+        # All strategies should produce the same shape and range
+        assert Xt.shape == (6, 1)
+        assert np.all(Xt >= 0)
+        assert np.all(Xt < n_bins)
+        
+        # All strategies should have monotonically increasing bin edges
+        bin_edges = est.bin_edges_[0]
+        assert np.all(bin_edges[1:] >= bin_edges[:-1]), f"Bin edges should be monotonically increasing for strategy={strategy}"
+
+
+def test_kbins_discretizer_kmeans_transform_consistency():
+    """Test that transform method works consistently after fit with kmeans strategy.
+    
+    This ensures that the fix doesn't break the transform functionality.
+    """
+    X_train = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)
+    X_test = np.array([1, 4, 8]).reshape(-1, 1)
+    
+    est = KBinsDiscretizer(n_bins=4, strategy='kmeans', encode='ordinal')
+    est.fit(X_train)
+    
+    # Transform both training and test data
+    Xt_train = est.transform(X_train)
+    Xt_test = est.transform(X_test)
+    
+    # Verify properties
+    assert Xt_train.shape == (6, 1)
+    assert Xt_test.shape == (3, 1)
+    assert np.all(Xt_train >= 0) and np.all(Xt_train < 4)
+    assert np.all(Xt_test >= 0) and np.all(Xt_test < 4)
+    
+    # Verify that bin edges are monotonically increasing
+    bin_edges = est.bin_edges_[0]
+    assert np.all(bin_edges[1:] >= bin_edges[:-1]), "Bin edges should be monotonically increasing"
+
+
+def test_kbins_discretizer_kmeans_inverse_transform():
+    """Test that inverse_transform works correctly with kmeans strategy.
+    
+    This ensures the fix doesn't break inverse transformation.
+    """
+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)
+    
+    est = KBinsDiscretizer(n_bins=4, strategy='kmeans', encode='ordinal')
+    Xt = est.fit_transform(X)
+    X_inv = est.inverse_transform(Xt)
+    
+    # Verify that inverse transform produces reasonable results
+    assert X_inv.shape == X.shape
+    assert np.all(np.isfinite(X_inv))
+    
+    # The inverse should be within the original data range
+    assert np.all(X_inv >= X.min())
+    assert np.all(X_inv <= X.max())
+
+
+def test_kbins_discretizer_kmeans_reproducibility():
+    """Test that kmeans strategy produces reproducible results.
+    
+    Since we use n_init=1 and deterministic initialization, results should be reproducible.
+    """
+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)
+    
+    # Fit twice and compare results
+    est1 = KBinsDiscretizer(n_bins=4, strategy='kmeans', encode='ordinal')
+    est2 = KBinsDiscretizer(n_bins=4, strategy='kmeans', encode='ordinal')
+    
+    Xt1 = est1.fit_transform(X)
+    Xt2 = est2.fit_transform(X)
+    
+    # Results should be identical due to deterministic initialization
+    assert_array_equal(Xt1, Xt2)
+    assert_array_equal(est1.bin_edges_[0], est2.bin_edges_[0])
+
+
+def test_kbins_discretizer_kmeans_failure_before_fix():
+    """Test that demonstrates the original bug (this test should fail before the fix).
+    
+    This test is designed to fail with the original code and pass after the fix.
+    It uses a specific data configuration that's likely to produce unsorted centers.
+    """
+    # This specific configuration is designed to trigger unsorted centers
+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)
+    
+    # Before the fix, this would raise: ValueError: bins must be monotonically increasing or decreasing
+    est = KBinsDiscretizer(n_bins=5, strategy='kmeans', encode='ordinal')
+    
+    # This should not raise any exception after the fix
+    try:
+        Xt = est.fit_transform(X)
+        # If we get here, the fix is working
+        assert Xt.shape == (6, 1)
+        assert np.all(Xt >= 0)
+        assert np.all(Xt < 5)
+        
+        # Verify bin edges are sorted
+        bin_edges = est.bin_edges_[0]
+        assert np.all(bin_edges[1:] >= bin_edges[:-1]), "Bin edges should be monotonically increasing"
+        
+    except ValueError as e:
+        if "bins must be monotonically increasing" in str(e):
+            pytest.fail("The bug is not fixed: bin edges are still unsorted")
+        else:
+            # Re-raise if it's a different ValueError
+            raise
+
+
+def test_kbins_discretizer_kmeans_with_different_encodings():
+    """Test that kmeans strategy works with different encoding options.
+    
+    This ensures the fix works regardless of the encoding method.
+    """
+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)
+    
+    encodings = ['ordinal', 'onehot', 'onehot-dense']
+    
+    for encode in encodings:
+        est = KBinsDiscretizer(n_bins=4, strategy='kmeans', encode=encode)
+        Xt = est.fit_transform(X)
+        
+        # Verify basic properties (shape will differ for onehot encodings)
+        assert Xt.shape[0] == 6  # Same number of samples
+        
+        if encode == 'ordinal':
+            assert Xt.shape[1] == 1
+            assert np.all(Xt >= 0) and np.all(Xt < 4)
+        else:  # onehot variants
+            assert Xt.shape[1] == 4  # One column per bin
+            assert np.all((Xt == 0) | (Xt == 1))  # Binary values only
+        
+        # Verify that bin edges are monotonically increasing
+        bin_edges = est.bin_edges_[0]
+        assert np.all(bin_edges[1:] >= bin_edges[:-1]), f"Bin edges should be monotonically increasing for encode={encode}"
