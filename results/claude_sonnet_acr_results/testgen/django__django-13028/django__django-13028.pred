{
  "instance_id": "django__django-13028",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/queries/test_filterable_bug.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models, NotSupportedError\nfrom django.test import TestCase\nfrom django.db.models.expressions import Value\nfrom django.db.models.sql.query import Query\n\n\nclass ProductMetaDataType(models.Model):\n    \"\"\"Test model with a field named 'filterable' to reproduce the bug.\"\"\"\n    label = models.CharField(max_length=255, unique=True, blank=False, null=False)\n    filterable = models.BooleanField(default=False, verbose_name=\"filterable\")\n    \n    class Meta:\n        app_label = \"test_app\"\n        \n    def __str__(self):\n        return self.label\n\n\nclass ProductMetaData(models.Model):\n    \"\"\"Test model that references ProductMetaDataType.\"\"\"\n    id = models.BigAutoField(primary_key=True)\n    value = models.TextField(null=False, blank=False)\n    metadata_type = models.ForeignKey(\n        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE\n    )\n    \n    class Meta:\n        app_label = \"test_app\"\n\n\nclass NonFilterableExpression(Value):\n    \"\"\"Test expression with filterable=False to verify the fix preserves existing functionality.\"\"\"\n    filterable = False\n\n\nclass FilterableExpressionTest(TestCase):\n    \"\"\"Test suite for the filterable attribute bug fix.\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        # Create test data\n        cls.metadata_type = ProductMetaDataType.objects.create(\n            label=\"test_type\", \n            filterable=False  # This should NOT cause issues in filtering\n        )\n        cls.product_metadata = ProductMetaData.objects.create(\n            value=\"test_value\",\n            metadata_type=cls.metadata_type\n        )\n    \n    def test_filter_with_model_instance_having_filterable_field_false(self):\n        \"\"\"\n        Test that filtering with a model instance that has filterable=False works.\n        This reproduces the original bug where NotSupportedError was raised.\n        \"\"\"\n        # This should NOT raise NotSupportedError\n        queryset = ProductMetaData.objects.filter(metadata_type=self.metadata_type)\n        self.assertEqual(queryset.count(), 1)\n        self.assertEqual(queryset.first().value, \"test_value\")\n    \n    def test_filter_with_model_instance_having_filterable_field_true(self):\n        \"\"\"\n        Test that filtering with a model instance that has filterable=True works.\n        \"\"\"\n        metadata_type_true = ProductMetaDataType.objects.create(\n            label=\"test_type_true\", \n            filterable=True\n        )\n        product_metadata_true = ProductMetaData.objects.create(\n            value=\"test_value_true\",\n            metadata_type=metadata_type_true\n        )\n        \n        # This should work without issues\n        queryset = ProductMetaData.objects.filter(metadata_type=metadata_type_true)\n        self.assertEqual(queryset.count(), 1)\n        self.assertEqual(queryset.first().value, \"test_value_true\")\n    \n    def test_filter_with_multiple_conditions_including_filterable_model(self):\n        \"\"\"\n        Test filtering with multiple conditions where one involves a model with filterable field.\n        \"\"\"\n        # This should work without issues\n        queryset = ProductMetaData.objects.filter(\n            value=\"test_value\", \n            metadata_type=self.metadata_type\n        )\n        self.assertEqual(queryset.count(), 1)\n    \n    def test_non_filterable_expression_still_raises_error(self):\n        \"\"\"\n        Test that Django expressions with filterable=False still raise NotSupportedError.\n        This ensures the fix preserves the existing functionality for expressions.\n        \"\"\"\n        from django.db.models.sql.query import Query\n        from django.db.models import Model\n        \n        query = Query(ProductMetaData)\n        non_filterable_expr = NonFilterableExpression(\"test\")\n        \n        # This should still raise NotSupportedError for expressions\n        with self.assertRaises(NotSupportedError) as cm:\n            query.check_filterable(non_filterable_expr)\n        \n        self.assertIn(\"is disallowed in the filter clause\", str(cm.exception))\n    \n    def test_filterable_expression_works(self):\n        \"\"\"\n        Test that Django expressions with filterable=True (default) work normally.\n        \"\"\"\n        from django.db.models.sql.query import Query\n        \n        query = Query(ProductMetaData)\n        filterable_expr = Value(\"test\")  # Default filterable=True\n        \n        # This should not raise any exception\n        try:\n            query.check_filterable(filterable_expr)\n        except NotSupportedError:\n            self.fail(\"check_filterable raised NotSupportedError unexpectedly\")\n    \n    def test_model_instance_without_filterable_field_works(self):\n        \"\"\"\n        Test that model instances without a filterable field work normally.\n        \"\"\"\n        # Create a simple model without filterable field\n        class SimpleModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = \"test_app\"\n        \n        simple_instance = SimpleModel(name=\"test\")\n        \n        from django.db.models.sql.query import Query\n        query = Query(SimpleModel)\n        \n        # This should not raise any exception\n        try:\n            query.check_filterable(simple_instance)\n        except NotSupportedError:\n            self.fail(\"check_filterable raised NotSupportedError unexpectedly\")\n    \n    def test_edge_case_filterable_field_with_none_value(self):\n        \"\"\"\n        Test edge case where filterable field has None value.\n        \"\"\"\n        # Create instance with filterable=None (should be treated as falsy)\n        metadata_type_none = ProductMetaDataType.objects.create(\n            label=\"test_type_none\", \n            filterable=None\n        )\n        \n        # This should work without issues\n        queryset = ProductMetaData.objects.filter(metadata_type=metadata_type_none)\n        self.assertEqual(queryset.count(), 0)  # No matching records expected\n    \n    def test_complex_query_with_filterable_model_instances(self):\n        \"\"\"\n        Test complex queries involving multiple model instances with filterable fields.\n        \"\"\"\n        # Create additional test data\n        metadata_type2 = ProductMetaDataType.objects.create(\n            label=\"test_type2\", \n            filterable=True\n        )\n        product_metadata2 = ProductMetaData.objects.create(\n            value=\"test_value2\",\n            metadata_type=metadata_type2\n        )\n        \n        # Test OR query with both instances\n        from django.db.models import Q\n        queryset = ProductMetaData.objects.filter(\n            Q(metadata_type=self.metadata_type) | Q(metadata_type=metadata_type2)\n        )\n        self.assertEqual(queryset.count(), 2)\n    \n    def test_check_filterable_with_expression_having_get_source_expressions(self):\n        \"\"\"\n        Test that check_filterable properly handles expressions with get_source_expressions.\n        \"\"\"\n        from django.db.models.expressions import Case, When\n        from django.db.models.sql.query import Query\n        \n        query = Query(ProductMetaData)\n        \n        # Create a complex expression\n        case_expr = Case(\n            When(value=\"test\", then=Value(\"result\")),\n            default=Value(\"default\")\n        )\n        \n        # This should not raise any exception\n        try:\n            query.check_filterable(case_expr)\n        except NotSupportedError:\n            self.fail(\"check_filterable raised NotSupportedError unexpectedly\")\n\n\nclass FilterableBugReproductionTest(TestCase):\n    \"\"\"\n    Test that specifically reproduces the original bug scenario.\n    This test should fail before the fix and pass after the fix.\n    \"\"\"\n    \n    def setUp(self):\n        self.brand_metadata = ProductMetaDataType.objects.create(\n            label=\"Brand\", \n            filterable=False  # This is the key - filterable=False\n        )\n    \n    def test_original_bug_scenario(self):\n        \"\"\"\n        Reproduce the exact scenario from the bug report.\n        Before fix: This should raise NotSupportedError\n        After fix: This should work normally\n        \"\"\"\n        # This is the exact line that was failing in the bug report\n        try:\n            queryset = ProductMetaData.objects.filter(\n                value=\"Dark Vador\", \n                metadata_type=self.brand_metadata\n            )\n            # If we get here, the bug is fixed\n            self.assertEqual(queryset.count(), 0)  # No matching records expected\n        except NotSupportedError as e:\n            # If we get this exception, the bug still exists\n            self.fail(f\"Bug still exists: {e}\")\n</patched>\n```",
  "patch": "--- a/tests/queries/test_filterable_bug.py\n+++ b/tests/queries/test_filterable_bug.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models, NotSupportedError\n+from django.test import TestCase\n+from django.db.models.expressions import Value\n+from django.db.models.sql.query import Query\n+\n+\n+class ProductMetaDataType(models.Model):\n+    \"\"\"Test model with a field named 'filterable' to reproduce the bug.\"\"\"\n+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)\n+    filterable = models.BooleanField(default=False, verbose_name=\"filterable\")\n+    \n+    class Meta:\n+        app_label = \"test_app\"\n+        \n+    def __str__(self):\n+        return self.label\n+\n+\n+class ProductMetaData(models.Model):\n+    \"\"\"Test model that references ProductMetaDataType.\"\"\"\n+    id = models.BigAutoField(primary_key=True)\n+    value = models.TextField(null=False, blank=False)\n+    metadata_type = models.ForeignKey(\n+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE\n+    )\n+    \n+    class Meta:\n+        app_label = \"test_app\"\n+\n+\n+class NonFilterableExpression(Value):\n+    \"\"\"Test expression with filterable=False to verify the fix preserves existing functionality.\"\"\"\n+    filterable = False\n+\n+\n+class FilterableExpressionTest(TestCase):\n+    \"\"\"Test suite for the filterable attribute bug fix.\"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        # Create test data\n+        cls.metadata_type = ProductMetaDataType.objects.create(\n+            label=\"test_type\", \n+            filterable=False  # This should NOT cause issues in filtering\n+        )\n+        cls.product_metadata = ProductMetaData.objects.create(\n+            value=\"test_value\",\n+            metadata_type=cls.metadata_type\n+        )\n+    \n+    def test_filter_with_model_instance_having_filterable_field_false(self):\n+        \"\"\"\n+        Test that filtering with a model instance that has filterable=False works.\n+        This reproduces the original bug where NotSupportedError was raised.\n+        \"\"\"\n+        # This should NOT raise NotSupportedError\n+        queryset = ProductMetaData.objects.filter(metadata_type=self.metadata_type)\n+        self.assertEqual(queryset.count(), 1)\n+        self.assertEqual(queryset.first().value, \"test_value\")\n+    \n+    def test_filter_with_model_instance_having_filterable_field_true(self):\n+        \"\"\"\n+        Test that filtering with a model instance that has filterable=True works.\n+        \"\"\"\n+        metadata_type_true = ProductMetaDataType.objects.create(\n+            label=\"test_type_true\", \n+            filterable=True\n+        )\n+        product_metadata_true = ProductMetaData.objects.create(\n+            value=\"test_value_true\",\n+            metadata_type=metadata_type_true\n+        )\n+        \n+        # This should work without issues\n+        queryset = ProductMetaData.objects.filter(metadata_type=metadata_type_true)\n+        self.assertEqual(queryset.count(), 1)\n+        self.assertEqual(queryset.first().value, \"test_value_true\")\n+    \n+    def test_filter_with_multiple_conditions_including_filterable_model(self):\n+        \"\"\"\n+        Test filtering with multiple conditions where one involves a model with filterable field.\n+        \"\"\"\n+        # This should work without issues\n+        queryset = ProductMetaData.objects.filter(\n+            value=\"test_value\", \n+            metadata_type=self.metadata_type\n+        )\n+        self.assertEqual(queryset.count(), 1)\n+    \n+    def test_non_filterable_expression_still_raises_error(self):\n+        \"\"\"\n+        Test that Django expressions with filterable=False still raise NotSupportedError.\n+        This ensures the fix preserves the existing functionality for expressions.\n+        \"\"\"\n+        from django.db.models.sql.query import Query\n+        from django.db.models import Model\n+        \n+        query = Query(ProductMetaData)\n+        non_filterable_expr = NonFilterableExpression(\"test\")\n+        \n+        # This should still raise NotSupportedError for expressions\n+        with self.assertRaises(NotSupportedError) as cm:\n+            query.check_filterable(non_filterable_expr)\n+        \n+        self.assertIn(\"is disallowed in the filter clause\", str(cm.exception))\n+    \n+    def test_filterable_expression_works(self):\n+        \"\"\"\n+        Test that Django expressions with filterable=True (default) work normally.\n+        \"\"\"\n+        from django.db.models.sql.query import Query\n+        \n+        query = Query(ProductMetaData)\n+        filterable_expr = Value(\"test\")  # Default filterable=True\n+        \n+        # This should not raise any exception\n+        try:\n+            query.check_filterable(filterable_expr)\n+        except NotSupportedError:\n+            self.fail(\"check_filterable raised NotSupportedError unexpectedly\")\n+    \n+    def test_model_instance_without_filterable_field_works(self):\n+        \"\"\"\n+        Test that model instances without a filterable field work normally.\n+        \"\"\"\n+        # Create a simple model without filterable field\n+        class SimpleModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = \"test_app\"\n+        \n+        simple_instance = SimpleModel(name=\"test\")\n+        \n+        from django.db.models.sql.query import Query\n+        query = Query(SimpleModel)\n+        \n+        # This should not raise any exception\n+        try:\n+            query.check_filterable(simple_instance)\n+        except NotSupportedError:\n+            self.fail(\"check_filterable raised NotSupportedError unexpectedly\")\n+    \n+    def test_edge_case_filterable_field_with_none_value(self):\n+        \"\"\"\n+        Test edge case where filterable field has None value.\n+        \"\"\"\n+        # Create instance with filterable=None (should be treated as falsy)\n+        metadata_type_none = ProductMetaDataType.objects.create(\n+            label=\"test_type_none\", \n+            filterable=None\n+        )\n+        \n+        # This should work without issues\n+        queryset = ProductMetaData.objects.filter(metadata_type=metadata_type_none)\n+        self.assertEqual(queryset.count(), 0)  # No matching records expected\n+    \n+    def test_complex_query_with_filterable_model_instances(self):\n+        \"\"\"\n+        Test complex queries involving multiple model instances with filterable fields.\n+        \"\"\"\n+        # Create additional test data\n+        metadata_type2 = ProductMetaDataType.objects.create(\n+            label=\"test_type2\", \n+            filterable=True\n+        )\n+        product_metadata2 = ProductMetaData.objects.create(\n+            value=\"test_value2\",\n+            metadata_type=metadata_type2\n+        )\n+        \n+        # Test OR query with both instances\n+        from django.db.models import Q\n+        queryset = ProductMetaData.objects.filter(\n+            Q(metadata_type=self.metadata_type) | Q(metadata_type=metadata_type2)\n+        )\n+        self.assertEqual(queryset.count(), 2)\n+    \n+    def test_check_filterable_with_expression_having_get_source_expressions(self):\n+        \"\"\"\n+        Test that check_filterable properly handles expressions with get_source_expressions.\n+        \"\"\"\n+        from django.db.models.expressions import Case, When\n+        from django.db.models.sql.query import Query\n+        \n+        query = Query(ProductMetaData)\n+        \n+        # Create a complex expression\n+        case_expr = Case(\n+            When(value=\"test\", then=Value(\"result\")),\n+            default=Value(\"default\")\n+        )\n+        \n+        # This should not raise any exception\n+        try:\n+            query.check_filterable(case_expr)\n+        except NotSupportedError:\n+            self.fail(\"check_filterable raised NotSupportedError unexpectedly\")\n+\n+\n+class FilterableBugReproductionTest(TestCase):\n+    \"\"\"\n+    Test that specifically reproduces the original bug scenario.\n+    This test should fail before the fix and pass after the fix.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        self.brand_metadata = ProductMetaDataType.objects.create(\n+            label=\"Brand\", \n+            filterable=False  # This is the key - filterable=False\n+        )\n+    \n+    def test_original_bug_scenario(self):\n+        \"\"\"\n+        Reproduce the exact scenario from the bug report.\n+        Before fix: This should raise NotSupportedError\n+        After fix: This should work normally\n+        \"\"\"\n+        # This is the exact line that was failing in the bug report\n+        try:\n+            queryset = ProductMetaData.objects.filter(\n+                value=\"Dark Vador\", \n+                metadata_type=self.brand_metadata\n+            )\n+            # If we get here, the bug is fixed\n+            self.assertEqual(queryset.count(), 0)  # No matching records expected\n+        except NotSupportedError as e:\n+            # If we get this exception, the bug still exists\n+            self.fail(f\"Bug still exists: {e}\")\n"
}