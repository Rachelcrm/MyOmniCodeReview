{
  "instance_id": "django__django-14534",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/forms_tests/test_boundfield.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django import forms\nfrom django.forms.boundfield import BoundWidget\nfrom django.forms.widgets import CheckboxSelectMultiple, RadioSelect\nfrom django.test import SimpleTestCase\n\n\nclass BoundWidgetIdForLabelTest(SimpleTestCase):\n    \"\"\"Test BoundWidget.id_for_label respects id set by ChoiceWidget.options\"\"\"\n\n    def test_bound_widget_id_for_label_uses_attrs_id(self):\n        \"\"\"\n        Test that BoundWidget.id_for_label returns the id from self.data['attrs']['id']\n        when it exists, instead of generating its own id format.\n        \"\"\"\n        # Create a form with CheckboxSelectMultiple widget\n        class TestForm(forms.Form):\n            choices = forms.MultipleChoiceField(\n                choices=[('option1', 'Option 1'), ('option2', 'Option 2')],\n                widget=CheckboxSelectMultiple()\n            )\n\n        form = TestForm()\n        bound_field = form['choices']\n        \n        # Get the first subwidget\n        subwidgets = bound_field.subwidgets\n        first_subwidget = subwidgets[0]\n        \n        # The subwidget should use the id from attrs, not generate its own\n        expected_id = first_subwidget.data['attrs']['id']\n        actual_id = first_subwidget.id_for_label\n        \n        self.assertEqual(actual_id, expected_id)\n        # Verify it's not using the old format\n        old_format_id = 'id_%s_%s' % (first_subwidget.data['name'], first_subwidget.data['index'])\n        self.assertNotEqual(actual_id, old_format_id)\n\n    def test_bound_widget_id_for_label_with_custom_auto_id(self):\n        \"\"\"\n        Test that BoundWidget.id_for_label respects custom auto_id format\n        when rendering CheckboxSelectMultiple subwidgets.\n        \"\"\"\n        # Create a form with custom auto_id format\n        class TestForm(forms.Form):\n            choices = forms.MultipleChoiceField(\n                choices=[('option1', 'Option 1'), ('option2', 'Option 2')],\n                widget=CheckboxSelectMultiple()\n            )\n\n        form = TestForm(auto_id='custom_%s')\n        bound_field = form['choices']\n        \n        # Get subwidgets\n        subwidgets = bound_field.subwidgets\n        first_subwidget = subwidgets[0]\n        \n        # The id_for_label should use the properly formatted id from attrs\n        actual_id = first_subwidget.id_for_label\n        expected_id = first_subwidget.data['attrs']['id']\n        \n        self.assertEqual(actual_id, expected_id)\n        # Verify the custom auto_id format is respected in the attrs id\n        self.assertTrue(actual_id.startswith('custom_'))\n\n    def test_bound_widget_id_for_label_with_radioselect(self):\n        \"\"\"\n        Test that BoundWidget.id_for_label works correctly with RadioSelect widget.\n        \"\"\"\n        class TestForm(forms.Form):\n            choice = forms.ChoiceField(\n                choices=[('option1', 'Option 1'), ('option2', 'Option 2')],\n                widget=RadioSelect()\n            )\n\n        form = TestForm(auto_id='radio_%s')\n        bound_field = form['choice']\n        \n        # Get subwidgets\n        subwidgets = bound_field.subwidgets\n        first_subwidget = subwidgets[0]\n        \n        # The id_for_label should use the id from attrs\n        actual_id = first_subwidget.id_for_label\n        expected_id = first_subwidget.data['attrs']['id']\n        \n        self.assertEqual(actual_id, expected_id)\n        self.assertTrue(actual_id.startswith('radio_'))\n\n    def test_bound_widget_id_for_label_fallback_when_no_attrs_id(self):\n        \"\"\"\n        Test that BoundWidget.id_for_label falls back to old behavior\n        when self.data['attrs']['id'] is not available.\n        \"\"\"\n        # Create a mock BoundWidget with data that doesn't have attrs.id\n        mock_data = {\n            'name': 'test_field',\n            'index': '0',\n            'attrs': {}  # No 'id' key\n        }\n        \n        bound_widget = BoundWidget(None, mock_data, None)\n        \n        # Should fall back to old format when no id in attrs\n        expected_id = 'id_%s_%s' % (mock_data['name'], mock_data['index'])\n        actual_id = bound_widget.id_for_label\n        \n        self.assertEqual(actual_id, expected_id)\n\n    def test_bound_widget_id_for_label_with_explicit_widget_id(self):\n        \"\"\"\n        Test that BoundWidget.id_for_label respects explicitly set widget id.\n        \"\"\"\n        class TestForm(forms.Form):\n            choices = forms.MultipleChoiceField(\n                choices=[('option1', 'Option 1'), ('option2', 'Option 2')],\n                widget=CheckboxSelectMultiple(attrs={'id': 'explicit_id'})\n            )\n\n        form = TestForm()\n        bound_field = form['choices']\n        \n        # Get subwidgets\n        subwidgets = bound_field.subwidgets\n        first_subwidget = subwidgets[0]\n        \n        # The id_for_label should use the id from attrs (which includes the explicit id)\n        actual_id = first_subwidget.id_for_label\n        expected_id = first_subwidget.data['attrs']['id']\n        \n        self.assertEqual(actual_id, expected_id)\n        # Should contain the explicit id as base\n        self.assertTrue('explicit_id' in actual_id)\n\n    def test_bound_widget_reproduces_bug_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: BoundWidget.id_for_label ignores\n        the id set by ChoiceWidget.options and generates its own.\n        \n        This test should fail before the fix is applied.\n        \"\"\"\n        class TestForm(forms.Form):\n            choices = forms.MultipleChoiceField(\n                choices=[('option1', 'Option 1')],\n                widget=CheckboxSelectMultiple()\n            )\n\n        form = TestForm(auto_id='custom_format_%s')\n        bound_field = form['choices']\n        subwidget = bound_field.subwidgets[0]\n        \n        # Before fix: id_for_label generates its own id instead of using attrs['id']\n        attrs_id = subwidget.data['attrs']['id']\n        id_for_label_result = subwidget.id_for_label\n        \n        # This assertion should fail before the fix - they should be equal but aren't\n        # After fix, this should pass\n        self.assertEqual(id_for_label_result, attrs_id,\n                        \"BoundWidget.id_for_label should use the id from attrs, not generate its own\")\n        \n        # Verify that the attrs id respects the custom auto_id format\n        self.assertTrue(attrs_id.startswith('custom_format_'),\n                       \"The attrs id should respect the custom auto_id format\")\n\n    def test_bound_widget_multiple_subwidgets_have_unique_ids(self):\n        \"\"\"\n        Test that multiple subwidgets have unique ids when using attrs['id'].\n        \"\"\"\n        class TestForm(forms.Form):\n            choices = forms.MultipleChoiceField(\n                choices=[('option1', 'Option 1'), ('option2', 'Option 2'), ('option3', 'Option 3')],\n                widget=CheckboxSelectMultiple()\n            )\n\n        form = TestForm()\n        bound_field = form['choices']\n        subwidgets = bound_field.subwidgets\n        \n        # Collect all ids\n        ids = [widget.id_for_label for widget in subwidgets]\n        \n        # All ids should be unique\n        self.assertEqual(len(ids), len(set(ids)), \"All subwidget ids should be unique\")\n        \n        # Each id should match its corresponding attrs id\n        for widget in subwidgets:\n            self.assertEqual(widget.id_for_label, widget.data['attrs']['id'])\n</patched>\n```",
  "patch": "--- a/tests/forms_tests/test_boundfield.py\n+++ b/tests/forms_tests/test_boundfield.py\n-# Empty if creating new file\n+import pytest\n+from django import forms\n+from django.forms.boundfield import BoundWidget\n+from django.forms.widgets import CheckboxSelectMultiple, RadioSelect\n+from django.test import SimpleTestCase\n+\n+\n+class BoundWidgetIdForLabelTest(SimpleTestCase):\n+    \"\"\"Test BoundWidget.id_for_label respects id set by ChoiceWidget.options\"\"\"\n+\n+    def test_bound_widget_id_for_label_uses_attrs_id(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label returns the id from self.data['attrs']['id']\n+        when it exists, instead of generating its own id format.\n+        \"\"\"\n+        # Create a form with CheckboxSelectMultiple widget\n+        class TestForm(forms.Form):\n+            choices = forms.MultipleChoiceField(\n+                choices=[('option1', 'Option 1'), ('option2', 'Option 2')],\n+                widget=CheckboxSelectMultiple()\n+            )\n+\n+        form = TestForm()\n+        bound_field = form['choices']\n+        \n+        # Get the first subwidget\n+        subwidgets = bound_field.subwidgets\n+        first_subwidget = subwidgets[0]\n+        \n+        # The subwidget should use the id from attrs, not generate its own\n+        expected_id = first_subwidget.data['attrs']['id']\n+        actual_id = first_subwidget.id_for_label\n+        \n+        self.assertEqual(actual_id, expected_id)\n+        # Verify it's not using the old format\n+        old_format_id = 'id_%s_%s' % (first_subwidget.data['name'], first_subwidget.data['index'])\n+        self.assertNotEqual(actual_id, old_format_id)\n+\n+    def test_bound_widget_id_for_label_with_custom_auto_id(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label respects custom auto_id format\n+        when rendering CheckboxSelectMultiple subwidgets.\n+        \"\"\"\n+        # Create a form with custom auto_id format\n+        class TestForm(forms.Form):\n+            choices = forms.MultipleChoiceField(\n+                choices=[('option1', 'Option 1'), ('option2', 'Option 2')],\n+                widget=CheckboxSelectMultiple()\n+            )\n+\n+        form = TestForm(auto_id='custom_%s')\n+        bound_field = form['choices']\n+        \n+        # Get subwidgets\n+        subwidgets = bound_field.subwidgets\n+        first_subwidget = subwidgets[0]\n+        \n+        # The id_for_label should use the properly formatted id from attrs\n+        actual_id = first_subwidget.id_for_label\n+        expected_id = first_subwidget.data['attrs']['id']\n+        \n+        self.assertEqual(actual_id, expected_id)\n+        # Verify the custom auto_id format is respected in the attrs id\n+        self.assertTrue(actual_id.startswith('custom_'))\n+\n+    def test_bound_widget_id_for_label_with_radioselect(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label works correctly with RadioSelect widget.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            choice = forms.ChoiceField(\n+                choices=[('option1', 'Option 1'), ('option2', 'Option 2')],\n+                widget=RadioSelect()\n+            )\n+\n+        form = TestForm(auto_id='radio_%s')\n+        bound_field = form['choice']\n+        \n+        # Get subwidgets\n+        subwidgets = bound_field.subwidgets\n+        first_subwidget = subwidgets[0]\n+        \n+        # The id_for_label should use the id from attrs\n+        actual_id = first_subwidget.id_for_label\n+        expected_id = first_subwidget.data['attrs']['id']\n+        \n+        self.assertEqual(actual_id, expected_id)\n+        self.assertTrue(actual_id.startswith('radio_'))\n+\n+    def test_bound_widget_id_for_label_fallback_when_no_attrs_id(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label falls back to old behavior\n+        when self.data['attrs']['id'] is not available.\n+        \"\"\"\n+        # Create a mock BoundWidget with data that doesn't have attrs.id\n+        mock_data = {\n+            'name': 'test_field',\n+            'index': '0',\n+            'attrs': {}  # No 'id' key\n+        }\n+        \n+        bound_widget = BoundWidget(None, mock_data, None)\n+        \n+        # Should fall back to old format when no id in attrs\n+        expected_id = 'id_%s_%s' % (mock_data['name'], mock_data['index'])\n+        actual_id = bound_widget.id_for_label\n+        \n+        self.assertEqual(actual_id, expected_id)\n+\n+    def test_bound_widget_id_for_label_with_explicit_widget_id(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label respects explicitly set widget id.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            choices = forms.MultipleChoiceField(\n+                choices=[('option1', 'Option 1'), ('option2', 'Option 2')],\n+                widget=CheckboxSelectMultiple(attrs={'id': 'explicit_id'})\n+            )\n+\n+        form = TestForm()\n+        bound_field = form['choices']\n+        \n+        # Get subwidgets\n+        subwidgets = bound_field.subwidgets\n+        first_subwidget = subwidgets[0]\n+        \n+        # The id_for_label should use the id from attrs (which includes the explicit id)\n+        actual_id = first_subwidget.id_for_label\n+        expected_id = first_subwidget.data['attrs']['id']\n+        \n+        self.assertEqual(actual_id, expected_id)\n+        # Should contain the explicit id as base\n+        self.assertTrue('explicit_id' in actual_id)\n+\n+    def test_bound_widget_reproduces_bug_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: BoundWidget.id_for_label ignores\n+        the id set by ChoiceWidget.options and generates its own.\n+        \n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            choices = forms.MultipleChoiceField(\n+                choices=[('option1', 'Option 1')],\n+                widget=CheckboxSelectMultiple()\n+            )\n+\n+        form = TestForm(auto_id='custom_format_%s')\n+        bound_field = form['choices']\n+        subwidget = bound_field.subwidgets[0]\n+        \n+        # Before fix: id_for_label generates its own id instead of using attrs['id']\n+        attrs_id = subwidget.data['attrs']['id']\n+        id_for_label_result = subwidget.id_for_label\n+        \n+        # This assertion should fail before the fix - they should be equal but aren't\n+        # After fix, this should pass\n+        self.assertEqual(id_for_label_result, attrs_id,\n+                        \"BoundWidget.id_for_label should use the id from attrs, not generate its own\")\n+        \n+        # Verify that the attrs id respects the custom auto_id format\n+        self.assertTrue(attrs_id.startswith('custom_format_'),\n+                       \"The attrs id should respect the custom auto_id format\")\n+\n+    def test_bound_widget_multiple_subwidgets_have_unique_ids(self):\n+        \"\"\"\n+        Test that multiple subwidgets have unique ids when using attrs['id'].\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            choices = forms.MultipleChoiceField(\n+                choices=[('option1', 'Option 1'), ('option2', 'Option 2'), ('option3', 'Option 3')],\n+                widget=CheckboxSelectMultiple()\n+            )\n+\n+        form = TestForm()\n+        bound_field = form['choices']\n+        subwidgets = bound_field.subwidgets\n+        \n+        # Collect all ids\n+        ids = [widget.id_for_label for widget in subwidgets]\n+        \n+        # All ids should be unique\n+        self.assertEqual(len(ids), len(set(ids)), \"All subwidget ids should be unique\")\n+        \n+        # Each id should match its corresponding attrs id\n+        for widget in subwidgets:\n+            self.assertEqual(widget.id_for_label, widget.data['attrs']['id'])\n"
}