{
  "instance_id": "django__django-15503",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_fields/test_jsonfield.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models\nfrom django.test import TestCase, override_settings\nfrom django.test.utils import isolate_apps\n\n\n@isolate_apps('model_fields')\nclass JSONFieldHasKeyTests(TestCase):\n    \"\"\"\n    Test suite for JSONField has_key, has_keys, and has_any_keys lookups\n    with numeric keys on different database backends.\n    \"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        \n        # Create test model\n        class JSONModel(models.Model):\n            data = models.JSONField()\n            \n            class Meta:\n                app_label = 'model_fields'\n        \n        cls.JSONModel = JSONModel\n    \n    def setUp(self):\n        \"\"\"Set up test data with various key types.\"\"\"\n        # Test data with string keys\n        self.JSONModel.objects.create(data={'foo': 'bar', 'nested': {'key': 'value'}})\n        \n        # Test data with numeric string keys (the problematic case)\n        self.JSONModel.objects.create(data={'1111': 'numeric_string_key', '42': 'another_numeric'})\n        \n        # Test data with mixed keys\n        self.JSONModel.objects.create(data={'string_key': 'value', '999': 'mixed_numeric', 'another': 'test'})\n        \n        # Test data with nested numeric keys\n        self.JSONModel.objects.create(data={'outer': {'123': 'nested_numeric', 'inner': 'value'}})\n        \n        # Test data with array (for contrast with object keys)\n        self.JSONModel.objects.create(data={'array': ['item0', 'item1', 'item2']})\n        \n        # Test data for has_keys and has_any_keys\n        self.JSONModel.objects.create(data={'100': 'first', '200': 'second', '300': 'third'})\n        self.JSONModel.objects.create(data={'100': 'exists', 'text': 'also_exists'})\n\n    def test_has_key_with_string_keys(self):\n        \"\"\"Test that has_key works correctly with regular string keys.\"\"\"\n        count = self.JSONModel.objects.filter(data__has_key='foo').count()\n        self.assertEqual(count, 1, \"Should find 1 entry with key 'foo'\")\n        \n        count = self.JSONModel.objects.filter(data__has_key='nonexistent').count()\n        self.assertEqual(count, 0, \"Should find 0 entries with nonexistent key\")\n\n    def test_has_key_with_numeric_string_keys(self):\n        \"\"\"\n        Test that has_key works correctly with numeric string keys.\n        This is the main bug being tested - numeric string keys should be\n        treated as object keys, not array indices.\n        \"\"\"\n        # Test single numeric string key\n        count = self.JSONModel.objects.filter(data__has_key='1111').count()\n        self.assertEqual(count, 1, \"Should find 1 entry with key '1111'\")\n        \n        # Test another numeric string key\n        count = self.JSONModel.objects.filter(data__has_key='42').count()\n        self.assertEqual(count, 1, \"Should find 1 entry with key '42'\")\n        \n        # Test numeric key in mixed data\n        count = self.JSONModel.objects.filter(data__has_key='999').count()\n        self.assertEqual(count, 1, \"Should find 1 entry with key '999'\")\n\n    def test_has_key_with_integer_keys(self):\n        \"\"\"Test that has_key works when passed integer values (should be converted to strings).\"\"\"\n        # Pass integer instead of string - should still work\n        count = self.JSONModel.objects.filter(data__has_key=1111).count()\n        self.assertEqual(count, 1, \"Should find 1 entry with integer key 1111\")\n        \n        count = self.JSONModel.objects.filter(data__has_key=42).count()\n        self.assertEqual(count, 1, \"Should find 1 entry with integer key 42\")\n\n    def test_has_key_nested_numeric_keys(self):\n        \"\"\"Test has_key with nested numeric string keys.\"\"\"\n        count = self.JSONModel.objects.filter(data__outer__has_key='123').count()\n        self.assertEqual(count, 1, \"Should find 1 entry with nested key '123'\")\n\n    def test_has_keys_with_numeric_string_keys(self):\n        \"\"\"Test that has_keys works correctly with numeric string keys.\"\"\"\n        # Test multiple numeric string keys - all must exist\n        count = self.JSONModel.objects.filter(data__has_keys=['100', '200']).count()\n        self.assertEqual(count, 1, \"Should find 1 entry with both keys '100' and '200'\")\n        \n        # Test with one missing key\n        count = self.JSONModel.objects.filter(data__has_keys=['100', '999']).count()\n        self.assertEqual(count, 0, \"Should find 0 entries when one key is missing\")\n        \n        # Test all three keys\n        count = self.JSONModel.objects.filter(data__has_keys=['100', '200', '300']).count()\n        self.assertEqual(count, 1, \"Should find 1 entry with all three keys\")\n\n    def test_has_keys_with_integer_keys(self):\n        \"\"\"Test that has_keys works when passed integer values.\"\"\"\n        count = self.JSONModel.objects.filter(data__has_keys=[100, 200]).count()\n        self.assertEqual(count, 1, \"Should find 1 entry with integer keys 100 and 200\")\n\n    def test_has_any_keys_with_numeric_string_keys(self):\n        \"\"\"Test that has_any_keys works correctly with numeric string keys.\"\"\"\n        # Test with multiple keys where at least one exists\n        count = self.JSONModel.objects.filter(data__has_any_keys=['100', '999']).count()\n        self.assertEqual(count, 2, \"Should find 2 entries with at least one of the keys\")\n        \n        # Test with keys that don't exist\n        count = self.JSONModel.objects.filter(data__has_any_keys=['777', '888']).count()\n        self.assertEqual(count, 0, \"Should find 0 entries when none of the keys exist\")\n        \n        # Test with mix of existing and non-existing keys\n        count = self.JSONModel.objects.filter(data__has_any_keys=['200', '777']).count()\n        self.assertEqual(count, 1, \"Should find 1 entry when at least one key exists\")\n\n    def test_has_any_keys_with_integer_keys(self):\n        \"\"\"Test that has_any_keys works when passed integer values.\"\"\"\n        count = self.JSONModel.objects.filter(data__has_any_keys=[100, 777]).count()\n        self.assertEqual(count, 2, \"Should find 2 entries with integer keys\")\n\n    def test_numeric_keys_vs_array_indices(self):\n        \"\"\"\n        Test that numeric object keys are not confused with array indices.\n        This ensures the fix doesn't break array access.\n        \"\"\"\n        # This should NOT match - we're looking for object key '0', not array index 0\n        count = self.JSONModel.objects.filter(data__array__has_key='0').count()\n        self.assertEqual(count, 0, \"Object key '0' should not match array index 0\")\n        \n        # Test actual array access (not has_key)\n        count = self.JSONModel.objects.filter(data__array__0='item0').count()\n        self.assertEqual(count, 1, \"Array index access should still work\")\n\n    def test_edge_cases_with_numeric_keys(self):\n        \"\"\"Test edge cases with numeric keys.\"\"\"\n        # Test with leading zeros\n        self.JSONModel.objects.create(data={'0123': 'leading_zero', '00': 'double_zero'})\n        \n        count = self.JSONModel.objects.filter(data__has_key='0123').count()\n        self.assertEqual(count, 1, \"Should find key with leading zeros\")\n        \n        count = self.JSONModel.objects.filter(data__has_key='00').count()\n        self.assertEqual(count, 1, \"Should find key '00'\")\n        \n        # Test with negative numbers as strings\n        self.JSONModel.objects.create(data={'-1': 'negative', '-999': 'large_negative'})\n        \n        count = self.JSONModel.objects.filter(data__has_key='-1').count()\n        self.assertEqual(count, 1, \"Should find negative numeric string key\")\n\n    def test_empty_and_special_numeric_keys(self):\n        \"\"\"Test special cases of numeric-like keys.\"\"\"\n        # Test with decimal numbers as strings\n        self.JSONModel.objects.create(data={'3.14': 'pi', '0.5': 'half'})\n        \n        count = self.JSONModel.objects.filter(data__has_key='3.14').count()\n        self.assertEqual(count, 1, \"Should find decimal string key\")\n        \n        # Test with scientific notation\n        self.JSONModel.objects.create(data={'1e5': 'scientific'})\n        \n        count = self.JSONModel.objects.filter(data__has_key='1e5').count()\n        self.assertEqual(count, 1, \"Should find scientific notation string key\")\n\n\n@pytest.mark.skipif(\n    not hasattr(models, 'JSONField'),\n    reason=\"JSONField not available in this Django version\"\n)\nclass TestJSONFieldNumericKeysRegression:\n    \"\"\"\n    Pytest-style tests for the numeric keys regression.\n    These tests specifically target the bug described in the issue.\n    \"\"\"\n    \n    @pytest.fixture\n    def json_model(self, db):\n        \"\"\"Create a test model with JSONField.\"\"\"\n        from django.db import models\n        \n        class TestModel(models.Model):\n            data = models.JSONField()\n            \n            class Meta:\n                app_label = 'test'\n        \n        # Create the table\n        from django.db import connection\n        with connection.schema_editor() as schema_editor:\n            schema_editor.create_model(TestModel)\n        \n        yield TestModel\n        \n        # Clean up\n        with connection.schema_editor() as schema_editor:\n            schema_editor.delete_model(TestModel)\n\n    def test_original_bug_reproduction(self, json_model):\n        \"\"\"\n        Reproduce the exact bug from the issue description.\n        This test should fail before the fix and pass after.\n        \"\"\"\n        # Create test data exactly as in the issue\n        test1 = json_model(data={'foo': 'bar'})\n        test2 = json_model(data={'1111': 'bar'})\n        test1.save()\n        test2.save()\n        \n        # Test the lookups\n        c1 = json_model.objects.filter(data__has_key='foo').count()\n        c2 = json_model.objects.filter(data__has_key='1111').count()\n        \n        assert c1 == 1, \"Should have found 1 entry with key 'foo'\"\n        assert c2 == 1, \"Should have found 1 entry with key '1111'\"\n\n    def test_multiple_numeric_keys(self, json_model):\n        \"\"\"Test has_keys with multiple numeric string keys.\"\"\"\n        json_model.objects.create(data={'1': 'one', '2': 'two', '3': 'three'})\n        json_model.objects.create(data={'1': 'uno', '4': 'four'})\n        \n        # Test has_keys - all keys must exist\n        count = json_model.objects.filter(data__has_keys=['1', '2']).count()\n        assert count == 1, \"Should find 1 entry with both keys '1' and '2'\"\n        \n        # Test has_any_keys - at least one key must exist\n        count = json_model.objects.filter(data__has_any_keys=['1', '5']).count()\n        assert count == 2, \"Should find 2 entries with at least key '1'\"\n\n    @pytest.mark.parametrize(\"key,expected_count\", [\n        ('123', 1),      # numeric string\n        (123, 1),        # integer (should be converted to string)\n        ('0', 1),        # zero as string\n        (0, 1),          # zero as integer\n        ('-1', 1),       # negative as string\n        (-1, 1),         # negative as integer\n    ])\n    def test_various_numeric_key_formats(self, json_model, key, expected_count):\n        \"\"\"Test that various numeric key formats work correctly.\"\"\"\n        json_model.objects.create(data={\n            '123': 'positive',\n            '0': 'zero', \n            '-1': 'negative'\n        })\n        \n        count = json_model.objects.filter(data__has_key=key).count()\n        assert count == expected_count, f\"Key {key} should find {expected_count} entries\"\n\n    def test_database_backend_compatibility(self, json_model, settings):\n        \"\"\"\n        Test that the fix works across different database backends.\n        This test focuses on the backends mentioned in the issue: SQLite, MySQL, Oracle.\n        \"\"\"\n        # Create test data\n        json_model.objects.create(data={'999': 'test_value'})\n        \n        # Test the lookup\n        count = json_model.objects.filter(data__has_key='999').count()\n        assert count == 1, f\"Numeric key lookup should work on {settings.DATABASES['default']['ENGINE']}\"\n        \n        # Also test with integer\n        count = json_model.objects.filter(data__has_key=999).count()\n        assert count == 1, f\"Integer key lookup should work on {settings.DATABASES['default']['ENGINE']}\"\n</patched>\n```",
  "patch": "--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models\n+from django.test import TestCase, override_settings\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps('model_fields')\n+class JSONFieldHasKeyTests(TestCase):\n+    \"\"\"\n+    Test suite for JSONField has_key, has_keys, and has_any_keys lookups\n+    with numeric keys on different database backends.\n+    \"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        \n+        # Create test model\n+        class JSONModel(models.Model):\n+            data = models.JSONField()\n+            \n+            class Meta:\n+                app_label = 'model_fields'\n+        \n+        cls.JSONModel = JSONModel\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data with various key types.\"\"\"\n+        # Test data with string keys\n+        self.JSONModel.objects.create(data={'foo': 'bar', 'nested': {'key': 'value'}})\n+        \n+        # Test data with numeric string keys (the problematic case)\n+        self.JSONModel.objects.create(data={'1111': 'numeric_string_key', '42': 'another_numeric'})\n+        \n+        # Test data with mixed keys\n+        self.JSONModel.objects.create(data={'string_key': 'value', '999': 'mixed_numeric', 'another': 'test'})\n+        \n+        # Test data with nested numeric keys\n+        self.JSONModel.objects.create(data={'outer': {'123': 'nested_numeric', 'inner': 'value'}})\n+        \n+        # Test data with array (for contrast with object keys)\n+        self.JSONModel.objects.create(data={'array': ['item0', 'item1', 'item2']})\n+        \n+        # Test data for has_keys and has_any_keys\n+        self.JSONModel.objects.create(data={'100': 'first', '200': 'second', '300': 'third'})\n+        self.JSONModel.objects.create(data={'100': 'exists', 'text': 'also_exists'})\n+\n+    def test_has_key_with_string_keys(self):\n+        \"\"\"Test that has_key works correctly with regular string keys.\"\"\"\n+        count = self.JSONModel.objects.filter(data__has_key='foo').count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with key 'foo'\")\n+        \n+        count = self.JSONModel.objects.filter(data__has_key='nonexistent').count()\n+        self.assertEqual(count, 0, \"Should find 0 entries with nonexistent key\")\n+\n+    def test_has_key_with_numeric_string_keys(self):\n+        \"\"\"\n+        Test that has_key works correctly with numeric string keys.\n+        This is the main bug being tested - numeric string keys should be\n+        treated as object keys, not array indices.\n+        \"\"\"\n+        # Test single numeric string key\n+        count = self.JSONModel.objects.filter(data__has_key='1111').count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with key '1111'\")\n+        \n+        # Test another numeric string key\n+        count = self.JSONModel.objects.filter(data__has_key='42').count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with key '42'\")\n+        \n+        # Test numeric key in mixed data\n+        count = self.JSONModel.objects.filter(data__has_key='999').count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with key '999'\")\n+\n+    def test_has_key_with_integer_keys(self):\n+        \"\"\"Test that has_key works when passed integer values (should be converted to strings).\"\"\"\n+        # Pass integer instead of string - should still work\n+        count = self.JSONModel.objects.filter(data__has_key=1111).count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with integer key 1111\")\n+        \n+        count = self.JSONModel.objects.filter(data__has_key=42).count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with integer key 42\")\n+\n+    def test_has_key_nested_numeric_keys(self):\n+        \"\"\"Test has_key with nested numeric string keys.\"\"\"\n+        count = self.JSONModel.objects.filter(data__outer__has_key='123').count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with nested key '123'\")\n+\n+    def test_has_keys_with_numeric_string_keys(self):\n+        \"\"\"Test that has_keys works correctly with numeric string keys.\"\"\"\n+        # Test multiple numeric string keys - all must exist\n+        count = self.JSONModel.objects.filter(data__has_keys=['100', '200']).count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with both keys '100' and '200'\")\n+        \n+        # Test with one missing key\n+        count = self.JSONModel.objects.filter(data__has_keys=['100', '999']).count()\n+        self.assertEqual(count, 0, \"Should find 0 entries when one key is missing\")\n+        \n+        # Test all three keys\n+        count = self.JSONModel.objects.filter(data__has_keys=['100', '200', '300']).count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with all three keys\")\n+\n+    def test_has_keys_with_integer_keys(self):\n+        \"\"\"Test that has_keys works when passed integer values.\"\"\"\n+        count = self.JSONModel.objects.filter(data__has_keys=[100, 200]).count()\n+        self.assertEqual(count, 1, \"Should find 1 entry with integer keys 100 and 200\")\n+\n+    def test_has_any_keys_with_numeric_string_keys(self):\n+        \"\"\"Test that has_any_keys works correctly with numeric string keys.\"\"\"\n+        # Test with multiple keys where at least one exists\n+        count = self.JSONModel.objects.filter(data__has_any_keys=['100', '999']).count()\n+        self.assertEqual(count, 2, \"Should find 2 entries with at least one of the keys\")\n+        \n+        # Test with keys that don't exist\n+        count = self.JSONModel.objects.filter(data__has_any_keys=['777', '888']).count()\n+        self.assertEqual(count, 0, \"Should find 0 entries when none of the keys exist\")\n+        \n+        # Test with mix of existing and non-existing keys\n+        count = self.JSONModel.objects.filter(data__has_any_keys=['200', '777']).count()\n+        self.assertEqual(count, 1, \"Should find 1 entry when at least one key exists\")\n+\n+    def test_has_any_keys_with_integer_keys(self):\n+        \"\"\"Test that has_any_keys works when passed integer values.\"\"\"\n+        count = self.JSONModel.objects.filter(data__has_any_keys=[100, 777]).count()\n+        self.assertEqual(count, 2, \"Should find 2 entries with integer keys\")\n+\n+    def test_numeric_keys_vs_array_indices(self):\n+        \"\"\"\n+        Test that numeric object keys are not confused with array indices.\n+        This ensures the fix doesn't break array access.\n+        \"\"\"\n+        # This should NOT match - we're looking for object key '0', not array index 0\n+        count = self.JSONModel.objects.filter(data__array__has_key='0').count()\n+        self.assertEqual(count, 0, \"Object key '0' should not match array index 0\")\n+        \n+        # Test actual array access (not has_key)\n+        count = self.JSONModel.objects.filter(data__array__0='item0').count()\n+        self.assertEqual(count, 1, \"Array index access should still work\")\n+\n+    def test_edge_cases_with_numeric_keys(self):\n+        \"\"\"Test edge cases with numeric keys.\"\"\"\n+        # Test with leading zeros\n+        self.JSONModel.objects.create(data={'0123': 'leading_zero', '00': 'double_zero'})\n+        \n+        count = self.JSONModel.objects.filter(data__has_key='0123').count()\n+        self.assertEqual(count, 1, \"Should find key with leading zeros\")\n+        \n+        count = self.JSONModel.objects.filter(data__has_key='00').count()\n+        self.assertEqual(count, 1, \"Should find key '00'\")\n+        \n+        # Test with negative numbers as strings\n+        self.JSONModel.objects.create(data={'-1': 'negative', '-999': 'large_negative'})\n+        \n+        count = self.JSONModel.objects.filter(data__has_key='-1').count()\n+        self.assertEqual(count, 1, \"Should find negative numeric string key\")\n+\n+    def test_empty_and_special_numeric_keys(self):\n+        \"\"\"Test special cases of numeric-like keys.\"\"\"\n+        # Test with decimal numbers as strings\n+        self.JSONModel.objects.create(data={'3.14': 'pi', '0.5': 'half'})\n+        \n+        count = self.JSONModel.objects.filter(data__has_key='3.14').count()\n+        self.assertEqual(count, 1, \"Should find decimal string key\")\n+        \n+        # Test with scientific notation\n+        self.JSONModel.objects.create(data={'1e5': 'scientific'})\n+        \n+        count = self.JSONModel.objects.filter(data__has_key='1e5').count()\n+        self.assertEqual(count, 1, \"Should find scientific notation string key\")\n+\n+\n+@pytest.mark.skipif(\n+    not hasattr(models, 'JSONField'),\n+    reason=\"JSONField not available in this Django version\"\n+)\n+class TestJSONFieldNumericKeysRegression:\n+    \"\"\"\n+    Pytest-style tests for the numeric keys regression.\n+    These tests specifically target the bug described in the issue.\n+    \"\"\"\n+    \n+    @pytest.fixture\n+    def json_model(self, db):\n+        \"\"\"Create a test model with JSONField.\"\"\"\n+        from django.db import models\n+        \n+        class TestModel(models.Model):\n+            data = models.JSONField()\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        # Create the table\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(TestModel)\n+        \n+        yield TestModel\n+        \n+        # Clean up\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.delete_model(TestModel)\n+\n+    def test_original_bug_reproduction(self, json_model):\n+        \"\"\"\n+        Reproduce the exact bug from the issue description.\n+        This test should fail before the fix and pass after.\n+        \"\"\"\n+        # Create test data exactly as in the issue\n+        test1 = json_model(data={'foo': 'bar'})\n+        test2 = json_model(data={'1111': 'bar'})\n+        test1.save()\n+        test2.save()\n+        \n+        # Test the lookups\n+        c1 = json_model.objects.filter(data__has_key='foo').count()\n+        c2 = json_model.objects.filter(data__has_key='1111').count()\n+        \n+        assert c1 == 1, \"Should have found 1 entry with key 'foo'\"\n+        assert c2 == 1, \"Should have found 1 entry with key '1111'\"\n+\n+    def test_multiple_numeric_keys(self, json_model):\n+        \"\"\"Test has_keys with multiple numeric string keys.\"\"\"\n+        json_model.objects.create(data={'1': 'one', '2': 'two', '3': 'three'})\n+        json_model.objects.create(data={'1': 'uno', '4': 'four'})\n+        \n+        # Test has_keys - all keys must exist\n+        count = json_model.objects.filter(data__has_keys=['1', '2']).count()\n+        assert count == 1, \"Should find 1 entry with both keys '1' and '2'\"\n+        \n+        # Test has_any_keys - at least one key must exist\n+        count = json_model.objects.filter(data__has_any_keys=['1', '5']).count()\n+        assert count == 2, \"Should find 2 entries with at least key '1'\"\n+\n+    @pytest.mark.parametrize(\"key,expected_count\", [\n+        ('123', 1),      # numeric string\n+        (123, 1),        # integer (should be converted to string)\n+        ('0', 1),        # zero as string\n+        (0, 1),          # zero as integer\n+        ('-1', 1),       # negative as string\n+        (-1, 1),         # negative as integer\n+    ])\n+    def test_various_numeric_key_formats(self, json_model, key, expected_count):\n+        \"\"\"Test that various numeric key formats work correctly.\"\"\"\n+        json_model.objects.create(data={\n+            '123': 'positive',\n+            '0': 'zero', \n+            '-1': 'negative'\n+        })\n+        \n+        count = json_model.objects.filter(data__has_key=key).count()\n+        assert count == expected_count, f\"Key {key} should find {expected_count} entries\"\n+\n+    def test_database_backend_compatibility(self, json_model, settings):\n+        \"\"\"\n+        Test that the fix works across different database backends.\n+        This test focuses on the backends mentioned in the issue: SQLite, MySQL, Oracle.\n+        \"\"\"\n+        # Create test data\n+        json_model.objects.create(data={'999': 'test_value'})\n+        \n+        # Test the lookup\n+        count = json_model.objects.filter(data__has_key='999').count()\n+        assert count == 1, f\"Numeric key lookup should work on {settings.DATABASES['default']['ENGINE']}\"\n+        \n+        # Also test with integer\n+        count = json_model.objects.filter(data__has_key=999).count()\n+        assert count == 1, f\"Integer key lookup should work on {settings.DATABASES['default']['ENGINE']}\"\n"
}