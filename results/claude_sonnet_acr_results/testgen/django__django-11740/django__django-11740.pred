{
  "instance_id": "django__django-11740",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/migrations/test_autodetector_uuid_to_fk.py</file>\n<original>\n</original>\n<patched>\nimport uuid\nfrom django.db import models\nfrom django.db.migrations.autodetector import MigrationAutodetector\nfrom django.db.migrations.state import ProjectState\nfrom django.test import TestCase\n\n\nclass UUIDToFKDependencyTests(TestCase):\n    \"\"\"\n    Tests for ensuring that changing a UUIDField to ForeignKey creates proper dependencies.\n    \"\"\"\n\n    def test_uuid_to_fk_creates_dependency(self):\n        \"\"\"\n        Test that changing a UUIDField to ForeignKey creates a dependency on the target model.\n        This test reproduces the bug where no dependency is created.\n        \"\"\"\n        # Create the initial state with UUIDField\n        before_state = ProjectState()\n        before_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n                ('text', models.CharField(max_length=100)),\n                ('another_app', models.UUIDField(null=True, blank=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n        before_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp2',\n            'name': 'App2',\n            'fields': [\n                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n                ('text', models.CharField(max_length=100)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Create the after state with ForeignKey\n        after_state = ProjectState()\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n                ('text', models.CharField(max_length=100)),\n                ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp2',\n            'name': 'App2',\n            'fields': [\n                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n                ('text', models.CharField(max_length=100)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Generate migrations\n        autodetector = MigrationAutodetector(before_state, after_state)\n        changes = autodetector.changes(graph=None)\n\n        # Check that we have changes for testapp1\n        self.assertIn('testapp1', changes)\n        self.assertEqual(len(changes['testapp1']), 1)\n\n        migration = changes['testapp1'][0]\n        self.assertEqual(len(migration.operations), 1)\n\n        # Check that the operation is AlterField\n        operation = migration.operations[0]\n        self.assertEqual(operation.__class__.__name__, 'AlterField')\n        self.assertEqual(operation.model_name, 'App1')\n        self.assertEqual(operation.name, 'another_app')\n\n        # This is the key test - the operation should have dependencies\n        # Before the fix, this would fail because no dependencies are created\n        self.assertTrue(hasattr(operation, '_auto_deps'))\n        self.assertIsNotNone(operation._auto_deps)\n        self.assertGreater(len(operation._auto_deps), 0)\n\n        # Check that the dependency is on testapp2.App2\n        dependency = operation._auto_deps[0]\n        self.assertEqual(dependency[0], 'testapp2')  # app_label\n        self.assertEqual(dependency[1], 'App2')     # model_name\n        self.assertEqual(dependency[2], None)       # field_name\n        self.assertTrue(dependency[3])              # create dependency\n\n    def test_uuid_to_fk_fails_without_dependency(self):\n        \"\"\"\n        Test that demonstrates the bug - without proper dependencies,\n        the migration would fail during execution.\n        \"\"\"\n        # Create the initial state with UUIDField\n        before_state = ProjectState()\n        before_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n                ('another_app', models.UUIDField(null=True, blank=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Create the after state with ForeignKey\n        after_state = ProjectState()\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n                ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp2',\n            'name': 'App2',\n            'fields': [\n                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Generate migrations\n        autodetector = MigrationAutodetector(before_state, after_state)\n        changes = autodetector.changes(graph=None)\n\n        # This test will fail before the fix is applied\n        # because the AlterField operation won't have dependencies\n        self.assertIn('testapp1', changes)\n        migration = changes['testapp1'][0]\n        operation = migration.operations[0]\n\n        # Before the fix, this assertion would fail\n        self.assertTrue(hasattr(operation, '_auto_deps'))\n        self.assertIsNotNone(operation._auto_deps)\n\n    def test_regular_field_to_fk_creates_dependency(self):\n        \"\"\"\n        Test that changing any regular field to ForeignKey creates proper dependencies.\n        \"\"\"\n        # Create the initial state with CharField\n        before_state = ProjectState()\n        before_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n                ('ref_field', models.CharField(max_length=100, null=True, blank=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n        before_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp2',\n            'name': 'App2',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Create the after state with ForeignKey\n        after_state = ProjectState()\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n                ('ref_field', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp2',\n            'name': 'App2',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Generate migrations\n        autodetector = MigrationAutodetector(before_state, after_state)\n        changes = autodetector.changes(graph=None)\n\n        # Check that dependencies are created\n        self.assertIn('testapp1', changes)\n        migration = changes['testapp1'][0]\n        operation = migration.operations[0]\n\n        self.assertEqual(operation.__class__.__name__, 'AlterField')\n        self.assertTrue(hasattr(operation, '_auto_deps'))\n        self.assertIsNotNone(operation._auto_deps)\n        self.assertGreater(len(operation._auto_deps), 0)\n\n    def test_fk_to_uuid_no_dependency_needed(self):\n        \"\"\"\n        Test that changing ForeignKey to UUIDField doesn't create unnecessary dependencies.\n        \"\"\"\n        # Create the initial state with ForeignKey\n        before_state = ProjectState()\n        before_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n                ('ref_field', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n        before_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp2',\n            'name': 'App2',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Create the after state with UUIDField\n        after_state = ProjectState()\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n                ('ref_field', models.UUIDField(null=True, blank=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp2',\n            'name': 'App2',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Generate migrations\n        autodetector = MigrationAutodetector(before_state, after_state)\n        changes = autodetector.changes(graph=None)\n\n        # Check that no dependencies are created when going from FK to UUID\n        self.assertIn('testapp1', changes)\n        migration = changes['testapp1'][0]\n        operation = migration.operations[0]\n\n        self.assertEqual(operation.__class__.__name__, 'AlterField')\n        # Should have empty or no dependencies since UUIDField doesn't reference other models\n        if hasattr(operation, '_auto_deps'):\n            self.assertEqual(len(operation._auto_deps), 0)\n\n    def test_uuid_to_onetoone_creates_dependency(self):\n        \"\"\"\n        Test that changing UUIDField to OneToOneField creates proper dependencies.\n        \"\"\"\n        # Create the initial state with UUIDField\n        before_state = ProjectState()\n        before_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n                ('ref_field', models.UUIDField(null=True, blank=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n        before_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp2',\n            'name': 'App2',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Create the after state with OneToOneField\n        after_state = ProjectState()\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp1',\n            'name': 'App1',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n                ('ref_field', models.OneToOneField('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n        after_state.add_model(models.Model.from_dict({\n            'app_label': 'testapp2',\n            'name': 'App2',\n            'fields': [\n                ('id', models.AutoField(primary_key=True)),\n            ],\n            'options': {},\n            'bases': (models.Model,),\n            'managers': [],\n        }))\n\n        # Generate migrations\n        autodetector = MigrationAutodetector(before_state, after_state)\n        changes = autodetector.changes(graph=None)\n\n        # Check that dependencies are created for OneToOneField\n        self.assertIn('testapp1', changes)\n        migration = changes['testapp1'][0]\n        operation = migration.operations[0]\n\n        self.assertEqual(operation.__class__.__name__, 'AlterField')\n        self.assertTrue(hasattr(operation, '_auto_deps'))\n        self.assertIsNotNone(operation._auto_deps)\n        self.assertGreater(len(operation._auto_deps), 0)\n\n        # Check that the dependency is on testapp2.App2\n        dependency = operation._auto_deps[0]\n        self.assertEqual(dependency[0], 'testapp2')  # app_label\n        self.assertEqual(dependency[1], 'App2')     # model_name\n</patched>\n```",
  "patch": "--- a/tests/migrations/test_autodetector_uuid_to_fk.py\n+++ b/tests/migrations/test_autodetector_uuid_to_fk.py\n+import uuid\n+from django.db import models\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState\n+from django.test import TestCase\n+\n+\n+class UUIDToFKDependencyTests(TestCase):\n+    \"\"\"\n+    Tests for ensuring that changing a UUIDField to ForeignKey creates proper dependencies.\n+    \"\"\"\n+\n+    def test_uuid_to_fk_creates_dependency(self):\n+        \"\"\"\n+        Test that changing a UUIDField to ForeignKey creates a dependency on the target model.\n+        This test reproduces the bug where no dependency is created.\n+        \"\"\"\n+        # Create the initial state with UUIDField\n+        before_state = ProjectState()\n+        before_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n+                ('text', models.CharField(max_length=100)),\n+                ('another_app', models.UUIDField(null=True, blank=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+        before_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp2',\n+            'name': 'App2',\n+            'fields': [\n+                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n+                ('text', models.CharField(max_length=100)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Create the after state with ForeignKey\n+        after_state = ProjectState()\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n+                ('text', models.CharField(max_length=100)),\n+                ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp2',\n+            'name': 'App2',\n+            'fields': [\n+                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n+                ('text', models.CharField(max_length=100)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Generate migrations\n+        autodetector = MigrationAutodetector(before_state, after_state)\n+        changes = autodetector.changes(graph=None)\n+\n+        # Check that we have changes for testapp1\n+        self.assertIn('testapp1', changes)\n+        self.assertEqual(len(changes['testapp1']), 1)\n+\n+        migration = changes['testapp1'][0]\n+        self.assertEqual(len(migration.operations), 1)\n+\n+        # Check that the operation is AlterField\n+        operation = migration.operations[0]\n+        self.assertEqual(operation.__class__.__name__, 'AlterField')\n+        self.assertEqual(operation.model_name, 'App1')\n+        self.assertEqual(operation.name, 'another_app')\n+\n+        # This is the key test - the operation should have dependencies\n+        # Before the fix, this would fail because no dependencies are created\n+        self.assertTrue(hasattr(operation, '_auto_deps'))\n+        self.assertIsNotNone(operation._auto_deps)\n+        self.assertGreater(len(operation._auto_deps), 0)\n+\n+        # Check that the dependency is on testapp2.App2\n+        dependency = operation._auto_deps[0]\n+        self.assertEqual(dependency[0], 'testapp2')  # app_label\n+        self.assertEqual(dependency[1], 'App2')     # model_name\n+        self.assertEqual(dependency[2], None)       # field_name\n+        self.assertTrue(dependency[3])              # create dependency\n+\n+    def test_uuid_to_fk_fails_without_dependency(self):\n+        \"\"\"\n+        Test that demonstrates the bug - without proper dependencies,\n+        the migration would fail during execution.\n+        \"\"\"\n+        # Create the initial state with UUIDField\n+        before_state = ProjectState()\n+        before_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n+                ('another_app', models.UUIDField(null=True, blank=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Create the after state with ForeignKey\n+        after_state = ProjectState()\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n+                ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp2',\n+            'name': 'App2',\n+            'fields': [\n+                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Generate migrations\n+        autodetector = MigrationAutodetector(before_state, after_state)\n+        changes = autodetector.changes(graph=None)\n+\n+        # This test will fail before the fix is applied\n+        # because the AlterField operation won't have dependencies\n+        self.assertIn('testapp1', changes)\n+        migration = changes['testapp1'][0]\n+        operation = migration.operations[0]\n+\n+        # Before the fix, this assertion would fail\n+        self.assertTrue(hasattr(operation, '_auto_deps'))\n+        self.assertIsNotNone(operation._auto_deps)\n+\n+    def test_regular_field_to_fk_creates_dependency(self):\n+        \"\"\"\n+        Test that changing any regular field to ForeignKey creates proper dependencies.\n+        \"\"\"\n+        # Create the initial state with CharField\n+        before_state = ProjectState()\n+        before_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('ref_field', models.CharField(max_length=100, null=True, blank=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+        before_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp2',\n+            'name': 'App2',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Create the after state with ForeignKey\n+        after_state = ProjectState()\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('ref_field', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp2',\n+            'name': 'App2',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Generate migrations\n+        autodetector = MigrationAutodetector(before_state, after_state)\n+        changes = autodetector.changes(graph=None)\n+\n+        # Check that dependencies are created\n+        self.assertIn('testapp1', changes)\n+        migration = changes['testapp1'][0]\n+        operation = migration.operations[0]\n+\n+        self.assertEqual(operation.__class__.__name__, 'AlterField')\n+        self.assertTrue(hasattr(operation, '_auto_deps'))\n+        self.assertIsNotNone(operation._auto_deps)\n+        self.assertGreater(len(operation._auto_deps), 0)\n+\n+    def test_fk_to_uuid_no_dependency_needed(self):\n+        \"\"\"\n+        Test that changing ForeignKey to UUIDField doesn't create unnecessary dependencies.\n+        \"\"\"\n+        # Create the initial state with ForeignKey\n+        before_state = ProjectState()\n+        before_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('ref_field', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+        before_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp2',\n+            'name': 'App2',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Create the after state with UUIDField\n+        after_state = ProjectState()\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('ref_field', models.UUIDField(null=True, blank=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp2',\n+            'name': 'App2',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Generate migrations\n+        autodetector = MigrationAutodetector(before_state, after_state)\n+        changes = autodetector.changes(graph=None)\n+\n+        # Check that no dependencies are created when going from FK to UUID\n+        self.assertIn('testapp1', changes)\n+        migration = changes['testapp1'][0]\n+        operation = migration.operations[0]\n+\n+        self.assertEqual(operation.__class__.__name__, 'AlterField')\n+        # Should have empty or no dependencies since UUIDField doesn't reference other models\n+        if hasattr(operation, '_auto_deps'):\n+            self.assertEqual(len(operation._auto_deps), 0)\n+\n+    def test_uuid_to_onetoone_creates_dependency(self):\n+        \"\"\"\n+        Test that changing UUIDField to OneToOneField creates proper dependencies.\n+        \"\"\"\n+        # Create the initial state with UUIDField\n+        before_state = ProjectState()\n+        before_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('ref_field', models.UUIDField(null=True, blank=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+        before_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp2',\n+            'name': 'App2',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Create the after state with OneToOneField\n+        after_state = ProjectState()\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp1',\n+            'name': 'App1',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('ref_field', models.OneToOneField('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+        after_state.add_model(models.Model.from_dict({\n+            'app_label': 'testapp2',\n+            'name': 'App2',\n+            'fields': [\n+                ('id', models.AutoField(primary_key=True)),\n+            ],\n+            'options': {},\n+            'bases': (models.Model,),\n+            'managers': [],\n+        }))\n+\n+        # Generate migrations\n+        autodetector = MigrationAutodetector(before_state, after_state)\n+        changes = autodetector.changes(graph=None)\n+\n+        # Check that dependencies are created for OneToOneField\n+        self.assertIn('testapp1', changes)\n+        migration = changes['testapp1'][0]\n+        operation = migration.operations[0]\n+\n+        self.assertEqual(operation.__class__.__name__, 'AlterField')\n+        self.assertTrue(hasattr(operation, '_auto_deps'))\n+        self.assertIsNotNone(operation._auto_deps)\n+        self.assertGreater(len(operation._auto_deps), 0)\n+\n+        # Check that the dependency is on testapp2.App2\n+        dependency = operation._auto_deps[0]\n+        self.assertEqual(dependency[0], 'testapp2')  # app_label\n+        self.assertEqual(dependency[1], 'App2')     # model_name\n"
}