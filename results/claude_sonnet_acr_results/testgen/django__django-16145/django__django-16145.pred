{
  "instance_id": "django__django-16145",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/management/commands/test_runserver.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nimport io\nimport sys\nfrom unittest.mock import patch, MagicMock\nfrom django.core.management import call_command\nfrom django.core.management.commands.runserver import Command\nfrom django.test import TestCase, override_settings\nfrom django.core.management.base import CommandError\n\n\nclass RunserverDisplayTests(TestCase):\n    \"\"\"Test cases for runserver command display output.\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.command = Command()\n        self.command.stdout = io.StringIO()\n        self.command.stderr = io.StringIO()\n\n    def test_runserver_zero_address_display_bug(self):\n        \"\"\"\n        Test that demonstrates the bug: when using '0:8000', \n        the output shows 'http://0:8000/' instead of 'http://0.0.0.0:8000/'.\n        This test should fail before the fix is applied.\n        \"\"\"\n        # Mock the run function to prevent actual server startup\n        with patch('django.core.management.commands.runserver.run') as mock_run:\n            # Mock autoreload to prevent actual reloading\n            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n                # Mock check_migrations to prevent migration checks\n                with patch.object(self.command, 'check_migrations'):\n                    # Mock check to prevent system checks\n                    with patch.object(self.command, 'check'):\n                        # Set up command state as if parsing \"0:8000\"\n                        self.command.addr = \"0\"\n                        self.command.port = \"8000\"\n                        self.command.protocol = \"http\"\n                        self.command._raw_ipv6 = False\n                        self.command.use_ipv6 = False\n                        \n                        # Call inner_run which contains the display logic\n                        options = {\n                            'use_threading': True,\n                            'skip_checks': True,\n                            'shutdown_message': ''\n                        }\n                        \n                        self.command.inner_run(None, **options)\n                        \n                        # Get the output\n                        output = self.command.stdout.getvalue()\n                        \n                        # This assertion should fail before the fix - demonstrates the bug\n                        # The output currently shows \"http://0:8000/\" but should show \"http://0.0.0.0:8000/\"\n                        self.assertIn(\"Starting development server at http://0.0.0.0:8000/\", output)\n                        self.assertNotIn(\"Starting development server at http://0:8000/\", output)\n\n    def test_runserver_zero_address_display_current_behavior(self):\n        \"\"\"\n        Test that shows the current buggy behavior.\n        This test passes before the fix and should fail after the fix.\n        \"\"\"\n        # Mock the run function to prevent actual server startup\n        with patch('django.core.management.commands.runserver.run') as mock_run:\n            # Mock autoreload to prevent actual reloading\n            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n                # Mock check_migrations to prevent migration checks\n                with patch.object(self.command, 'check_migrations'):\n                    # Mock check to prevent system checks\n                    with patch.object(self.command, 'check'):\n                        # Set up command state as if parsing \"0:8000\"\n                        self.command.addr = \"0\"\n                        self.command.port = \"8000\"\n                        self.command.protocol = \"http\"\n                        self.command._raw_ipv6 = False\n                        self.command.use_ipv6 = False\n                        \n                        # Call inner_run which contains the display logic\n                        options = {\n                            'use_threading': True,\n                            'skip_checks': True,\n                            'shutdown_message': ''\n                        }\n                        \n                        self.command.inner_run(None, **options)\n                        \n                        # Get the output\n                        output = self.command.stdout.getvalue()\n                        \n                        # This shows the current buggy behavior\n                        self.assertIn(\"Starting development server at http://0:8000/\", output)\n\n    def test_runserver_explicit_zero_address_display(self):\n        \"\"\"\n        Test that when using '0.0.0.0:8000' explicitly, \n        the output correctly shows 'http://0.0.0.0:8000/'.\n        This should pass both before and after the fix.\n        \"\"\"\n        # Mock the run function to prevent actual server startup\n        with patch('django.core.management.commands.runserver.run') as mock_run:\n            # Mock autoreload to prevent actual reloading\n            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n                # Mock check_migrations to prevent migration checks\n                with patch.object(self.command, 'check_migrations'):\n                    # Mock check to prevent system checks\n                    with patch.object(self.command, 'check'):\n                        # Set up command state as if parsing \"0.0.0.0:8000\"\n                        self.command.addr = \"0.0.0.0\"\n                        self.command.port = \"8000\"\n                        self.command.protocol = \"http\"\n                        self.command._raw_ipv6 = False\n                        self.command.use_ipv6 = False\n                        \n                        # Call inner_run which contains the display logic\n                        options = {\n                            'use_threading': True,\n                            'skip_checks': True,\n                            'shutdown_message': ''\n                        }\n                        \n                        self.command.inner_run(None, **options)\n                        \n                        # Get the output\n                        output = self.command.stdout.getvalue()\n                        \n                        # This should work correctly both before and after the fix\n                        self.assertIn(\"Starting development server at http://0.0.0.0:8000/\", output)\n\n    def test_runserver_localhost_address_display(self):\n        \"\"\"\n        Test that localhost addresses are displayed correctly.\n        This should pass both before and after the fix.\n        \"\"\"\n        # Mock the run function to prevent actual server startup\n        with patch('django.core.management.commands.runserver.run') as mock_run:\n            # Mock autoreload to prevent actual reloading\n            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n                # Mock check_migrations to prevent migration checks\n                with patch.object(self.command, 'check_migrations'):\n                    # Mock check to prevent system checks\n                    with patch.object(self.command, 'check'):\n                        # Set up command state as if parsing \"127.0.0.1:8000\"\n                        self.command.addr = \"127.0.0.1\"\n                        self.command.port = \"8000\"\n                        self.command.protocol = \"http\"\n                        self.command._raw_ipv6 = False\n                        self.command.use_ipv6 = False\n                        \n                        # Call inner_run which contains the display logic\n                        options = {\n                            'use_threading': True,\n                            'skip_checks': True,\n                            'shutdown_message': ''\n                        }\n                        \n                        self.command.inner_run(None, **options)\n                        \n                        # Get the output\n                        output = self.command.stdout.getvalue()\n                        \n                        # This should work correctly both before and after the fix\n                        self.assertIn(\"Starting development server at http://127.0.0.1:8000/\", output)\n\n    def test_runserver_ipv6_address_display(self):\n        \"\"\"\n        Test that IPv6 addresses are displayed correctly with brackets.\n        This should pass both before and after the fix.\n        \"\"\"\n        # Mock the run function to prevent actual server startup\n        with patch('django.core.management.commands.runserver.run') as mock_run:\n            # Mock autoreload to prevent actual reloading\n            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n                # Mock check_migrations to prevent migration checks\n                with patch.object(self.command, 'check_migrations'):\n                    # Mock check to prevent system checks\n                    with patch.object(self.command, 'check'):\n                        # Set up command state as if parsing IPv6 address\n                        self.command.addr = \"::1\"\n                        self.command.port = \"8000\"\n                        self.command.protocol = \"http\"\n                        self.command._raw_ipv6 = True\n                        self.command.use_ipv6 = True\n                        \n                        # Call inner_run which contains the display logic\n                        options = {\n                            'use_threading': True,\n                            'skip_checks': True,\n                            'shutdown_message': ''\n                        }\n                        \n                        self.command.inner_run(None, **options)\n                        \n                        # Get the output\n                        output = self.command.stdout.getvalue()\n                        \n                        # IPv6 addresses should be displayed with brackets\n                        self.assertIn(\"Starting development server at http://[::1]:8000/\", output)\n\n    def test_runserver_address_parsing_zero_shorthand(self):\n        \"\"\"\n        Test that the address parsing correctly handles '0:8000' input.\n        This tests the handle method's parsing logic.\n        \"\"\"\n        # Mock the run method to prevent actual server startup\n        with patch.object(self.command, 'run') as mock_run:\n            # Test parsing \"0:8000\"\n            options = {\n                'addrport': '0:8000',\n                'use_ipv6': False,\n            }\n            \n            self.command.handle(**options)\n            \n            # Verify that addr is set to \"0\" and port to \"8000\"\n            self.assertEqual(self.command.addr, \"0\")\n            self.assertEqual(self.command.port, \"8000\")\n\n    def test_runserver_address_parsing_explicit_zero(self):\n        \"\"\"\n        Test that the address parsing correctly handles '0.0.0.0:8000' input.\n        This tests the handle method's parsing logic.\n        \"\"\"\n        # Mock the run method to prevent actual server startup\n        with patch.object(self.command, 'run') as mock_run:\n            # Test parsing \"0.0.0.0:8000\"\n            options = {\n                'addrport': '0.0.0.0:8000',\n                'use_ipv6': False,\n            }\n            \n            self.command.handle(**options)\n            \n            # Verify that addr is set to \"0.0.0.0\" and port to \"8000\"\n            self.assertEqual(self.command.addr, \"0.0.0.0\")\n            self.assertEqual(self.command.port, \"8000\")\n\n    def test_runserver_zero_address_server_binding_unchanged(self):\n        \"\"\"\n        Test that the actual server binding behavior is unchanged.\n        When addr is \"0\", the server should still bind to the correct address.\n        \"\"\"\n        # Mock the run function to capture what address is passed to it\n        with patch('django.core.management.commands.runserver.run') as mock_run:\n            # Mock autoreload to prevent actual reloading\n            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n                # Mock check_migrations to prevent migration checks\n                with patch.object(self.command, 'check_migrations'):\n                    # Mock check to prevent system checks\n                    with patch.object(self.command, 'check'):\n                        # Set up command state as if parsing \"0:8000\"\n                        self.command.addr = \"0\"\n                        self.command.port = \"8000\"\n                        self.command.protocol = \"http\"\n                        self.command._raw_ipv6 = False\n                        self.command.use_ipv6 = False\n                        \n                        # Call inner_run which contains the server startup logic\n                        options = {\n                            'use_threading': True,\n                            'skip_checks': True,\n                            'shutdown_message': ''\n                        }\n                        \n                        self.command.inner_run(None, **options)\n                        \n                        # Verify that the run function is called with \"0\" as the address\n                        # This ensures the server binding behavior is unchanged\n                        mock_run.assert_called_once()\n                        call_args = mock_run.call_args\n                        self.assertEqual(call_args[0][0], \"0\")  # First argument should be the address\n                        self.assertEqual(call_args[0][1], 8000)  # Second argument should be the port\n\n    def test_runserver_edge_case_empty_address(self):\n        \"\"\"\n        Test edge case where address is empty (default behavior).\n        This should use the default address and display it correctly.\n        \"\"\"\n        # Mock the run function to prevent actual server startup\n        with patch('django.core.management.commands.runserver.run') as mock_run:\n            # Mock autoreload to prevent actual reloading\n            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n                # Mock check_migrations to prevent migration checks\n                with patch.object(self.command, 'check_migrations'):\n                    # Mock check to prevent system checks\n                    with patch.object(self.command, 'check'):\n                        # Set up command state for default address\n                        self.command.addr = \"127.0.0.1\"  # default_addr\n                        self.command.port = \"8000\"\n                        self.command.protocol = \"http\"\n                        self.command._raw_ipv6 = False\n                        self.command.use_ipv6 = False\n                        \n                        # Call inner_run which contains the display logic\n                        options = {\n                            'use_threading': True,\n                            'skip_checks': True,\n                            'shutdown_message': ''\n                        }\n                        \n                        self.command.inner_run(None, **options)\n                        \n                        # Get the output\n                        output = self.command.stdout.getvalue()\n                        \n                        # Default address should be displayed correctly\n                        self.assertIn(\"Starting development server at http://127.0.0.1:8000/\", output)\n</patched>\n```",
  "patch": "--- a/tests/management/commands/test_runserver.py\n+++ b/tests/management/commands/test_runserver.py\n-# Empty if creating new file\n+import pytest\n+import io\n+import sys\n+from unittest.mock import patch, MagicMock\n+from django.core.management import call_command\n+from django.core.management.commands.runserver import Command\n+from django.test import TestCase, override_settings\n+from django.core.management.base import CommandError\n+\n+\n+class RunserverDisplayTests(TestCase):\n+    \"\"\"Test cases for runserver command display output.\"\"\"\n+\n+    def setUp(self):\n+        \"\"\"Set up test fixtures.\"\"\"\n+        self.command = Command()\n+        self.command.stdout = io.StringIO()\n+        self.command.stderr = io.StringIO()\n+\n+    def test_runserver_zero_address_display_bug(self):\n+        \"\"\"\n+        Test that demonstrates the bug: when using '0:8000', \n+        the output shows 'http://0:8000/' instead of 'http://0.0.0.0:8000/'.\n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        # Mock the run function to prevent actual server startup\n+        with patch('django.core.management.commands.runserver.run') as mock_run:\n+            # Mock autoreload to prevent actual reloading\n+            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n+                # Mock check_migrations to prevent migration checks\n+                with patch.object(self.command, 'check_migrations'):\n+                    # Mock check to prevent system checks\n+                    with patch.object(self.command, 'check'):\n+                        # Set up command state as if parsing \"0:8000\"\n+                        self.command.addr = \"0\"\n+                        self.command.port = \"8000\"\n+                        self.command.protocol = \"http\"\n+                        self.command._raw_ipv6 = False\n+                        self.command.use_ipv6 = False\n+                        \n+                        # Call inner_run which contains the display logic\n+                        options = {\n+                            'use_threading': True,\n+                            'skip_checks': True,\n+                            'shutdown_message': ''\n+                        }\n+                        \n+                        self.command.inner_run(None, **options)\n+                        \n+                        # Get the output\n+                        output = self.command.stdout.getvalue()\n+                        \n+                        # This assertion should fail before the fix - demonstrates the bug\n+                        # The output currently shows \"http://0:8000/\" but should show \"http://0.0.0.0:8000/\"\n+                        self.assertIn(\"Starting development server at http://0.0.0.0:8000/\", output)\n+                        self.assertNotIn(\"Starting development server at http://0:8000/\", output)\n+\n+    def test_runserver_zero_address_display_current_behavior(self):\n+        \"\"\"\n+        Test that shows the current buggy behavior.\n+        This test passes before the fix and should fail after the fix.\n+        \"\"\"\n+        # Mock the run function to prevent actual server startup\n+        with patch('django.core.management.commands.runserver.run') as mock_run:\n+            # Mock autoreload to prevent actual reloading\n+            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n+                # Mock check_migrations to prevent migration checks\n+                with patch.object(self.command, 'check_migrations'):\n+                    # Mock check to prevent system checks\n+                    with patch.object(self.command, 'check'):\n+                        # Set up command state as if parsing \"0:8000\"\n+                        self.command.addr = \"0\"\n+                        self.command.port = \"8000\"\n+                        self.command.protocol = \"http\"\n+                        self.command._raw_ipv6 = False\n+                        self.command.use_ipv6 = False\n+                        \n+                        # Call inner_run which contains the display logic\n+                        options = {\n+                            'use_threading': True,\n+                            'skip_checks': True,\n+                            'shutdown_message': ''\n+                        }\n+                        \n+                        self.command.inner_run(None, **options)\n+                        \n+                        # Get the output\n+                        output = self.command.stdout.getvalue()\n+                        \n+                        # This shows the current buggy behavior\n+                        self.assertIn(\"Starting development server at http://0:8000/\", output)\n+\n+    def test_runserver_explicit_zero_address_display(self):\n+        \"\"\"\n+        Test that when using '0.0.0.0:8000' explicitly, \n+        the output correctly shows 'http://0.0.0.0:8000/'.\n+        This should pass both before and after the fix.\n+        \"\"\"\n+        # Mock the run function to prevent actual server startup\n+        with patch('django.core.management.commands.runserver.run') as mock_run:\n+            # Mock autoreload to prevent actual reloading\n+            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n+                # Mock check_migrations to prevent migration checks\n+                with patch.object(self.command, 'check_migrations'):\n+                    # Mock check to prevent system checks\n+                    with patch.object(self.command, 'check'):\n+                        # Set up command state as if parsing \"0.0.0.0:8000\"\n+                        self.command.addr = \"0.0.0.0\"\n+                        self.command.port = \"8000\"\n+                        self.command.protocol = \"http\"\n+                        self.command._raw_ipv6 = False\n+                        self.command.use_ipv6 = False\n+                        \n+                        # Call inner_run which contains the display logic\n+                        options = {\n+                            'use_threading': True,\n+                            'skip_checks': True,\n+                            'shutdown_message': ''\n+                        }\n+                        \n+                        self.command.inner_run(None, **options)\n+                        \n+                        # Get the output\n+                        output = self.command.stdout.getvalue()\n+                        \n+                        # This should work correctly both before and after the fix\n+                        self.assertIn(\"Starting development server at http://0.0.0.0:8000/\", output)\n+\n+    def test_runserver_localhost_address_display(self):\n+        \"\"\"\n+        Test that localhost addresses are displayed correctly.\n+        This should pass both before and after the fix.\n+        \"\"\"\n+        # Mock the run function to prevent actual server startup\n+        with patch('django.core.management.commands.runserver.run') as mock_run:\n+            # Mock autoreload to prevent actual reloading\n+            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n+                # Mock check_migrations to prevent migration checks\n+                with patch.object(self.command, 'check_migrations'):\n+                    # Mock check to prevent system checks\n+                    with patch.object(self.command, 'check'):\n+                        # Set up command state as if parsing \"127.0.0.1:8000\"\n+                        self.command.addr = \"127.0.0.1\"\n+                        self.command.port = \"8000\"\n+                        self.command.protocol = \"http\"\n+                        self.command._raw_ipv6 = False\n+                        self.command.use_ipv6 = False\n+                        \n+                        # Call inner_run which contains the display logic\n+                        options = {\n+                            'use_threading': True,\n+                            'skip_checks': True,\n+                            'shutdown_message': ''\n+                        }\n+                        \n+                        self.command.inner_run(None, **options)\n+                        \n+                        # Get the output\n+                        output = self.command.stdout.getvalue()\n+                        \n+                        # This should work correctly both before and after the fix\n+                        self.assertIn(\"Starting development server at http://127.0.0.1:8000/\", output)\n+\n+    def test_runserver_ipv6_address_display(self):\n+        \"\"\"\n+        Test that IPv6 addresses are displayed correctly with brackets.\n+        This should pass both before and after the fix.\n+        \"\"\"\n+        # Mock the run function to prevent actual server startup\n+        with patch('django.core.management.commands.runserver.run') as mock_run:\n+            # Mock autoreload to prevent actual reloading\n+            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n+                # Mock check_migrations to prevent migration checks\n+                with patch.object(self.command, 'check_migrations'):\n+                    # Mock check to prevent system checks\n+                    with patch.object(self.command, 'check'):\n+                        # Set up command state as if parsing IPv6 address\n+                        self.command.addr = \"::1\"\n+                        self.command.port = \"8000\"\n+                        self.command.protocol = \"http\"\n+                        self.command._raw_ipv6 = True\n+                        self.command.use_ipv6 = True\n+                        \n+                        # Call inner_run which contains the display logic\n+                        options = {\n+                            'use_threading': True,\n+                            'skip_checks': True,\n+                            'shutdown_message': ''\n+                        }\n+                        \n+                        self.command.inner_run(None, **options)\n+                        \n+                        # Get the output\n+                        output = self.command.stdout.getvalue()\n+                        \n+                        # IPv6 addresses should be displayed with brackets\n+                        self.assertIn(\"Starting development server at http://[::1]:8000/\", output)\n+\n+    def test_runserver_address_parsing_zero_shorthand(self):\n+        \"\"\"\n+        Test that the address parsing correctly handles '0:8000' input.\n+        This tests the handle method's parsing logic.\n+        \"\"\"\n+        # Mock the run method to prevent actual server startup\n+        with patch.object(self.command, 'run') as mock_run:\n+            # Test parsing \"0:8000\"\n+            options = {\n+                'addrport': '0:8000',\n+                'use_ipv6': False,\n+            }\n+            \n+            self.command.handle(**options)\n+            \n+            # Verify that addr is set to \"0\" and port to \"8000\"\n+            self.assertEqual(self.command.addr, \"0\")\n+            self.assertEqual(self.command.port, \"8000\")\n+\n+    def test_runserver_address_parsing_explicit_zero(self):\n+        \"\"\"\n+        Test that the address parsing correctly handles '0.0.0.0:8000' input.\n+        This tests the handle method's parsing logic.\n+        \"\"\"\n+        # Mock the run method to prevent actual server startup\n+        with patch.object(self.command, 'run') as mock_run:\n+            # Test parsing \"0.0.0.0:8000\"\n+            options = {\n+                'addrport': '0.0.0.0:8000',\n+                'use_ipv6': False,\n+            }\n+            \n+            self.command.handle(**options)\n+            \n+            # Verify that addr is set to \"0.0.0.0\" and port to \"8000\"\n+            self.assertEqual(self.command.addr, \"0.0.0.0\")\n+            self.assertEqual(self.command.port, \"8000\")\n+\n+    def test_runserver_zero_address_server_binding_unchanged(self):\n+        \"\"\"\n+        Test that the actual server binding behavior is unchanged.\n+        When addr is \"0\", the server should still bind to the correct address.\n+        \"\"\"\n+        # Mock the run function to capture what address is passed to it\n+        with patch('django.core.management.commands.runserver.run') as mock_run:\n+            # Mock autoreload to prevent actual reloading\n+            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n+                # Mock check_migrations to prevent migration checks\n+                with patch.object(self.command, 'check_migrations'):\n+                    # Mock check to prevent system checks\n+                    with patch.object(self.command, 'check'):\n+                        # Set up command state as if parsing \"0:8000\"\n+                        self.command.addr = \"0\"\n+                        self.command.port = \"8000\"\n+                        self.command.protocol = \"http\"\n+                        self.command._raw_ipv6 = False\n+                        self.command.use_ipv6 = False\n+                        \n+                        # Call inner_run which contains the server startup logic\n+                        options = {\n+                            'use_threading': True,\n+                            'skip_checks': True,\n+                            'shutdown_message': ''\n+                        }\n+                        \n+                        self.command.inner_run(None, **options)\n+                        \n+                        # Verify that the run function is called with \"0\" as the address\n+                        # This ensures the server binding behavior is unchanged\n+                        mock_run.assert_called_once()\n+                        call_args = mock_run.call_args\n+                        self.assertEqual(call_args[0][0], \"0\")  # First argument should be the address\n+                        self.assertEqual(call_args[0][1], 8000)  # Second argument should be the port\n+\n+    def test_runserver_edge_case_empty_address(self):\n+        \"\"\"\n+        Test edge case where address is empty (default behavior).\n+        This should use the default address and display it correctly.\n+        \"\"\"\n+        # Mock the run function to prevent actual server startup\n+        with patch('django.core.management.commands.runserver.run') as mock_run:\n+            # Mock autoreload to prevent actual reloading\n+            with patch('django.core.management.commands.runserver.autoreload.raise_last_exception'):\n+                # Mock check_migrations to prevent migration checks\n+                with patch.object(self.command, 'check_migrations'):\n+                    # Mock check to prevent system checks\n+                    with patch.object(self.command, 'check'):\n+                        # Set up command state for default address\n+                        self.command.addr = \"127.0.0.1\"  # default_addr\n+                        self.command.port = \"8000\"\n+                        self.command.protocol = \"http\"\n+                        self.command._raw_ipv6 = False\n+                        self.command.use_ipv6 = False\n+                        \n+                        # Call inner_run which contains the display logic\n+                        options = {\n+                            'use_threading': True,\n+                            'skip_checks': True,\n+                            'shutdown_message': ''\n+                        }\n+                        \n+                        self.command.inner_run(None, **options)\n+                        \n+                        # Get the output\n+                        output = self.command.stdout.getvalue()\n+                        \n+                        # Default address should be displayed correctly\n+                        self.assertIn(\"Starting development server at http://127.0.0.1:8000/\", output)\n"
}