{
  "instance_id": "django__django-13741",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/auth_tests/test_forms.py</file>\n<original>\nimport datetime\nfrom unittest import mock\n\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.forms import (\n    AdminPasswordChangeForm, AuthenticationForm, PasswordChangeForm,\n    PasswordResetForm, ReadOnlyPasswordHashField, SetPasswordForm,\n    UserChangeForm, UserCreationForm, UsernameField,\n)\nfrom django.contrib.auth.models import User\nfrom django.contrib.sites.models import Site\nfrom django.core import mail\nfrom django.core.exceptions import ValidationError\nfrom django.forms.fields import CharField, Field, IntegerField\nfrom django.test import SimpleTestCase, TestCase, override_settings\nfrom django.utils import translation\nfrom django.utils.text import capfirst\nfrom django.utils.translation import gettext as _\n\nfrom .models import CustomUser, CustomUserWithoutIsActiveField\n\n\nclass ReadOnlyPasswordHashTest(SimpleTestCase):\n\n    def test_bug_19349_render_with_none_value(self):\n        # Rendering the widget with value set to None\n        # mustn't raise an exception.\n        field = ReadOnlyPasswordHashField()\n        html = field.widget.render(name='password', value=None, attrs={})\n        self.assertIn(_(\"No password set.\"), html)\n\n    def test_render_with_empty_string_value(self):\n        field = ReadOnlyPasswordHashField()\n        html = field.widget.render(name='password', value='', attrs={})\n        self.assertIn(_(\"No password set.\"), html)\n</original>\n<patched>\nimport datetime\nfrom unittest import mock\n\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.forms import (\n    AdminPasswordChangeForm, AuthenticationForm, PasswordChangeForm,\n    PasswordResetForm, ReadOnlyPasswordHashField, SetPasswordForm,\n    UserChangeForm, UserCreationForm, UsernameField,\n)\nfrom django.contrib.auth.models import User\nfrom django.contrib.sites.models import Site\nfrom django.core import mail\nfrom django.core.exceptions import ValidationError\nfrom django.forms.fields import CharField, Field, IntegerField\nfrom django.test import SimpleTestCase, TestCase, override_settings\nfrom django.utils import translation\nfrom django.utils.text import capfirst\nfrom django.utils.translation import gettext as _\n\nfrom .models import CustomUser, CustomUserWithoutIsActiveField\n\n\nclass ReadOnlyPasswordHashTest(SimpleTestCase):\n\n    def test_bug_19349_render_with_none_value(self):\n        # Rendering the widget with value set to None\n        # mustn't raise an exception.\n        field = ReadOnlyPasswordHashField()\n        html = field.widget.render(name='password', value=None, attrs={})\n        self.assertIn(_(\"No password set.\"), html)\n\n    def test_render_with_empty_string_value(self):\n        field = ReadOnlyPasswordHashField()\n        html = field.widget.render(name='password', value='', attrs={})\n        self.assertIn(_(\"No password set.\"), html)\n\n    def test_disabled_property_set_by_default(self):\n        \"\"\"Test that ReadOnlyPasswordHashField has disabled=True by default.\"\"\"\n        field = ReadOnlyPasswordHashField()\n        self.assertTrue(field.disabled)\n\n    def test_disabled_property_can_be_overridden(self):\n        \"\"\"Test that disabled property can be explicitly overridden.\"\"\"\n        field = ReadOnlyPasswordHashField(disabled=False)\n        self.assertFalse(field.disabled)\n\n    def test_disabled_field_ignores_user_input(self):\n        \"\"\"Test that disabled field ignores user input and returns initial value.\"\"\"\n        field = ReadOnlyPasswordHashField()\n        initial_value = 'pbkdf2_sha256$initial_hash'\n        user_input = 'pbkdf2_sha256$tampered_hash'\n        \n        # Test bound_data method returns initial value when disabled\n        bound_value = field.bound_data(user_input, initial_value)\n        self.assertEqual(bound_value, initial_value)\n\n    def test_disabled_field_has_changed_always_false(self):\n        \"\"\"Test that disabled field always reports no changes.\"\"\"\n        field = ReadOnlyPasswordHashField()\n        initial_value = 'pbkdf2_sha256$initial_hash'\n        user_input = 'pbkdf2_sha256$tampered_hash'\n        \n        # Test has_changed method returns False when disabled\n        has_changed = field.has_changed(initial_value, user_input)\n        self.assertFalse(has_changed)\n\n    def test_non_disabled_field_behavior_unchanged(self):\n        \"\"\"Test that explicitly non-disabled field behaves as before.\"\"\"\n        field = ReadOnlyPasswordHashField(disabled=False)\n        initial_value = 'pbkdf2_sha256$initial_hash'\n        user_input = 'pbkdf2_sha256$tampered_hash'\n        \n        # When not disabled, bound_data should still return initial (existing behavior)\n        bound_value = field.bound_data(user_input, initial_value)\n        self.assertEqual(bound_value, initial_value)\n        \n        # has_changed should still return False (existing behavior)\n        has_changed = field.has_changed(initial_value, user_input)\n        self.assertFalse(has_changed)\n\n\nclass UserChangeFormDisabledPasswordTest(TestCase):\n    \"\"\"Test that UserChangeForm works correctly with disabled ReadOnlyPasswordHashField.\"\"\"\n\n    def setUp(self):\n        self.user = User.objects.create_user(\n            username='testuser',\n            email='test@example.com',\n            password='testpass123'\n        )\n\n    def test_form_with_disabled_password_field_ignores_tampering(self):\n        \"\"\"Test that form ignores password tampering when field is disabled.\"\"\"\n        original_password = self.user.password\n        \n        # Create form with initial data\n        form = UserChangeForm(instance=self.user)\n        \n        # Verify password field is disabled\n        self.assertTrue(form.fields['password'].disabled)\n        \n        # Simulate form submission with tampered password data\n        tampered_data = {\n            'username': 'testuser',\n            'email': 'test@example.com',\n            'password': 'pbkdf2_sha256$tampered_hash',\n            'first_name': '',\n            'last_name': '',\n            'is_active': True,\n            'is_staff': False,\n            'is_superuser': False,\n            'date_joined': self.user.date_joined,\n        }\n        \n        form = UserChangeForm(data=tampered_data, instance=self.user)\n        \n        # Form should be valid and password should remain unchanged\n        self.assertTrue(form.is_valid())\n        saved_user = form.save()\n        self.assertEqual(saved_user.password, original_password)\n\n    def test_clean_password_method_still_works_but_not_needed(self):\n        \"\"\"Test that clean_password method still works but is redundant with disabled field.\"\"\"\n        original_password = self.user.password\n        \n        # Create form and simulate tampering\n        tampered_data = {\n            'username': 'testuser',\n            'email': 'test@example.com',\n            'password': 'pbkdf2_sha256$tampered_hash',\n            'first_name': '',\n            'last_name': '',\n            'is_active': True,\n            'is_staff': False,\n            'is_superuser': False,\n            'date_joined': self.user.date_joined,\n        }\n        \n        form = UserChangeForm(data=tampered_data, instance=self.user)\n        \n        # The clean_password method should still return the initial value\n        form.is_valid()  # Trigger cleaning\n        cleaned_password = form.clean_password()\n        self.assertEqual(cleaned_password, original_password)\n\n    def test_custom_form_without_clean_password_works(self):\n        \"\"\"Test that custom forms without clean_password method work correctly.\"\"\"\n        from django import forms\n        from django.contrib.auth.forms import ReadOnlyPasswordHashField\n        \n        class CustomUserChangeForm(forms.ModelForm):\n            password = ReadOnlyPasswordHashField(\n                label=\"Password\",\n                help_text=\"Raw passwords are not stored.\"\n            )\n            \n            class Meta:\n                model = User\n                fields = ['username', 'email', 'password']\n        \n        original_password = self.user.password\n        \n        # Create form without clean_password method\n        form = CustomUserChangeForm(instance=self.user)\n        \n        # Verify password field is disabled\n        self.assertTrue(form.fields['password'].disabled)\n        \n        # Simulate tampering\n        tampered_data = {\n            'username': 'testuser',\n            'email': 'test@example.com',\n            'password': 'pbkdf2_sha256$tampered_hash',\n        }\n        \n        form = CustomUserChangeForm(data=tampered_data, instance=self.user)\n        \n        # Form should be valid and password should remain unchanged\n        self.assertTrue(form.is_valid())\n        saved_user = form.save()\n        self.assertEqual(saved_user.password, original_password)\n\n    def test_backward_compatibility_with_explicit_disabled_false(self):\n        \"\"\"Test backward compatibility when explicitly setting disabled=False.\"\"\"\n        from django import forms\n        from django.contrib.auth.forms import ReadOnlyPasswordHashField\n        \n        class LegacyUserChangeForm(forms.ModelForm):\n            password = ReadOnlyPasswordHashField(\n                label=\"Password\",\n                disabled=False,  # Explicitly disable the new behavior\n                help_text=\"Raw passwords are not stored.\"\n            )\n            \n            class Meta:\n                model = User\n                fields = ['username', 'email', 'password']\n            \n            def clean_password(self):\n                # Legacy clean_password method still needed when disabled=False\n                return self.initial.get('password')\n        \n        original_password = self.user.password\n        \n        # Create form with disabled=False\n        form = LegacyUserChangeForm(instance=self.user)\n        \n        # Verify password field is not disabled\n        self.assertFalse(form.fields['password'].disabled)\n        \n        # Simulate tampering\n        tampered_data = {\n            'username': 'testuser',\n            'email': 'test@example.com',\n            'password': 'pbkdf2_sha256$tampered_hash',\n        }\n        \n        form = LegacyUserChangeForm(data=tampered_data, instance=self.user)\n        \n        # Form should be valid and clean_password should handle the protection\n        self.assertTrue(form.is_valid())\n        saved_user = form.save()\n        self.assertEqual(saved_user.password, original_password)\n</patched>\n```",
  "patch": "--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n-import datetime\n-from unittest import mock\n-\n-from django.contrib.auth import get_user_model\n-from django.contrib.auth.forms import (\n-    AdminPasswordChangeForm, AuthenticationForm, PasswordChangeForm,\n-    PasswordResetForm, ReadOnlyPasswordHashField, SetPasswordForm,\n-    UserChangeForm, UserCreationForm, UsernameField,\n-)\n-from django.contrib.auth.models import User\n-from django.contrib.sites.models import Site\n-from django.core import mail\n-from django.core.exceptions import ValidationError\n-from django.forms.fields import CharField, Field, IntegerField\n-from django.test import SimpleTestCase, TestCase, override_settings\n-from django.utils import translation\n-from django.utils.text import capfirst\n-from django.utils.translation import gettext as _\n-\n-from .models import CustomUser, CustomUserWithoutIsActiveField\n-\n-\n-class ReadOnlyPasswordHashTest(SimpleTestCase):\n-\n-    def test_bug_19349_render_with_none_value(self):\n-        # Rendering the widget with value set to None\n-        # mustn't raise an exception.\n-        field = ReadOnlyPasswordHashField()\n-        html = field.widget.render(name='password', value=None, attrs={})\n-        self.assertIn(_(\"No password set.\"), html)\n-\n-    def test_render_with_empty_string_value(self):\n-        field = ReadOnlyPasswordHashField()\n-        html = field.widget.render(name='password', value='', attrs={})\n-        self.assertIn(_(\"No password set.\"), html)\n+import datetime\n+from unittest import mock\n+\n+from django.contrib.auth import get_user_model\n+from django.contrib.auth.forms import (\n+    AdminPasswordChangeForm, AuthenticationForm, PasswordChangeForm,\n+    PasswordResetForm, ReadOnlyPasswordHashField, SetPasswordForm,\n+    UserChangeForm, UserCreationForm, UsernameField,\n+)\n+from django.contrib.auth.models import User\n+from django.contrib.sites.models import Site\n+from django.core import mail\n+from django.core.exceptions import ValidationError\n+from django.forms.fields import CharField, Field, IntegerField\n+from django.test import SimpleTestCase, TestCase, override_settings\n+from django.utils import translation\n+from django.utils.text import capfirst\n+from django.utils.translation import gettext as _\n+\n+from .models import CustomUser, CustomUserWithoutIsActiveField\n+\n+\n+class ReadOnlyPasswordHashTest(SimpleTestCase):\n+\n+    def test_bug_19349_render_with_none_value(self):\n+        # Rendering the widget with value set to None\n+        # mustn't raise an exception.\n+        field = ReadOnlyPasswordHashField()\n+        html = field.widget.render(name='password', value=None, attrs={})\n+        self.assertIn(_(\"No password set.\"), html)\n+\n+    def test_render_with_empty_string_value(self):\n+        field = ReadOnlyPasswordHashField()\n+        html = field.widget.render(name='password', value='', attrs={})\n+        self.assertIn(_(\"No password set.\"), html)\n+\n+    def test_disabled_property_set_by_default(self):\n+        \"\"\"Test that ReadOnlyPasswordHashField has disabled=True by default.\"\"\"\n+        field = ReadOnlyPasswordHashField()\n+        self.assertTrue(field.disabled)\n+\n+    def test_disabled_property_can_be_overridden(self):\n+        \"\"\"Test that disabled property can be explicitly overridden.\"\"\"\n+        field = ReadOnlyPasswordHashField(disabled=False)\n+        self.assertFalse(field.disabled)\n+\n+    def test_disabled_field_ignores_user_input(self):\n+        \"\"\"Test that disabled field ignores user input and returns initial value.\"\"\"\n+        field = ReadOnlyPasswordHashField()\n+        initial_value = 'pbkdf2_sha256$initial_hash'\n+        user_input = 'pbkdf2_sha256$tampered_hash'\n+        \n+        # Test bound_data method returns initial value when disabled\n+        bound_value = field.bound_data(user_input, initial_value)\n+        self.assertEqual(bound_value, initial_value)\n+\n+    def test_disabled_field_has_changed_always_false(self):\n+        \"\"\"Test that disabled field always reports no changes.\"\"\"\n+        field = ReadOnlyPasswordHashField()\n+        initial_value = 'pbkdf2_sha256$initial_hash'\n+        user_input = 'pbkdf2_sha256$tampered_hash'\n+        \n+        # Test has_changed method returns False when disabled\n+        has_changed = field.has_changed(initial_value, user_input)\n+        self.assertFalse(has_changed)\n+\n+    def test_non_disabled_field_behavior_unchanged(self):\n+        \"\"\"Test that explicitly non-disabled field behaves as before.\"\"\"\n+        field = ReadOnlyPasswordHashField(disabled=False)\n+        initial_value = 'pbkdf2_sha256$initial_hash'\n+        user_input = 'pbkdf2_sha256$tampered_hash'\n+        \n+        # When not disabled, bound_data should still return initial (existing behavior)\n+        bound_value = field.bound_data(user_input, initial_value)\n+        self.assertEqual(bound_value, initial_value)\n+        \n+        # has_changed should still return False (existing behavior)\n+        has_changed = field.has_changed(initial_value, user_input)\n+        self.assertFalse(has_changed)\n+\n+\n+class UserChangeFormDisabledPasswordTest(TestCase):\n+    \"\"\"Test that UserChangeForm works correctly with disabled ReadOnlyPasswordHashField.\"\"\"\n+\n+    def setUp(self):\n+        self.user = User.objects.create_user(\n+            username='testuser',\n+            email='test@example.com',\n+            password='testpass123'\n+        )\n+\n+    def test_form_with_disabled_password_field_ignores_tampering(self):\n+        \"\"\"Test that form ignores password tampering when field is disabled.\"\"\"\n+        original_password = self.user.password\n+        \n+        # Create form with initial data\n+        form = UserChangeForm(instance=self.user)\n+        \n+        # Verify password field is disabled\n+        self.assertTrue(form.fields['password'].disabled)\n+        \n+        # Simulate form submission with tampered password data\n+        tampered_data = {\n+            'username': 'testuser',\n+            'email': 'test@example.com',\n+            'password': 'pbkdf2_sha256$tampered_hash',\n+            'first_name': '',\n+            'last_name': '',\n+            'is_active': True,\n+            'is_staff': False,\n+            'is_superuser': False,\n+            'date_joined': self.user.date_joined,\n+        }\n+        \n+        form = UserChangeForm(data=tampered_data, instance=self.user)\n+        \n+        # Form should be valid and password should remain unchanged\n+        self.assertTrue(form.is_valid())\n+        saved_user = form.save()\n+        self.assertEqual(saved_user.password, original_password)\n+\n+    def test_clean_password_method_still_works_but_not_needed(self):\n+        \"\"\"Test that clean_password method still works but is redundant with disabled field.\"\"\"\n+        original_password = self.user.password\n+        \n+        # Create form and simulate tampering\n+        tampered_data = {\n+            'username': 'testuser',\n+            'email': 'test@example.com',\n+            'password': 'pbkdf2_sha256$tampered_hash',\n+            'first_name': '',\n+            'last_name': '',\n+            'is_active': True,\n+            'is_staff': False,\n+            'is_superuser': False,\n+            'date_joined': self.user.date_joined,\n+        }\n+        \n+        form = UserChangeForm(data=tampered_data, instance=self.user)\n+        \n+        # The clean_password method should still return the initial value\n+        form.is_valid()  # Trigger cleaning\n+        cleaned_password = form.clean_password()\n+        self.assertEqual(cleaned_password, original_password)\n+\n+    def test_custom_form_without_clean_password_works(self):\n+        \"\"\"Test that custom forms without clean_password method work correctly.\"\"\"\n+        from django import forms\n+        from django.contrib.auth.forms import ReadOnlyPasswordHashField\n+        \n+        class CustomUserChangeForm(forms.ModelForm):\n+            password = ReadOnlyPasswordHashField(\n+                label=\"Password\",\n+                help_text=\"Raw passwords are not stored.\"\n+            )\n+            \n+            class Meta:\n+                model = User\n+                fields = ['username', 'email', 'password']\n+        \n+        original_password = self.user.password\n+        \n+        # Create form without clean_password method\n+        form = CustomUserChangeForm(instance=self.user)\n+        \n+        # Verify password field is disabled\n+        self.assertTrue(form.fields['password'].disabled)\n+        \n+        # Simulate tampering\n+        tampered_data = {\n+            'username': 'testuser',\n+            'email': 'test@example.com',\n+            'password': 'pbkdf2_sha256$tampered_hash',\n+        }\n+        \n+        form = CustomUserChangeForm(data=tampered_data, instance=self.user)\n+        \n+        # Form should be valid and password should remain unchanged\n+        self.assertTrue(form.is_valid())\n+        saved_user = form.save()\n+        self.assertEqual(saved_user.password, original_password)\n+\n+    def test_backward_compatibility_with_explicit_disabled_false(self):\n+        \"\"\"Test backward compatibility when explicitly setting disabled=False.\"\"\"\n+        from django import forms\n+        from django.contrib.auth.forms import ReadOnlyPasswordHashField\n+        \n+        class LegacyUserChangeForm(forms.ModelForm):\n+            password = ReadOnlyPasswordHashField(\n+                label=\"Password\",\n+                disabled=False,  # Explicitly disable the new behavior\n+                help_text=\"Raw passwords are not stored.\"\n+            )\n+            \n+            class Meta:\n+                model = User\n+                fields = ['username', 'email', 'password']\n+            \n+            def clean_password(self):\n+                # Legacy clean_password method still needed when disabled=False\n+                return self.initial.get('password')\n+        \n+        original_password = self.user.password\n+        \n+        # Create form with disabled=False\n+        form = LegacyUserChangeForm(instance=self.user)\n+        \n+        # Verify password field is not disabled\n+        self.assertFalse(form.fields['password'].disabled)\n+        \n+        # Simulate tampering\n+        tampered_data = {\n+            'username': 'testuser',\n+            'email': 'test@example.com',\n+            'password': 'pbkdf2_sha256$tampered_hash',\n+        }\n+        \n+        form = LegacyUserChangeForm(data=tampered_data, instance=self.user)\n+        \n+        # Form should be valid and clean_password should handle the protection\n+        self.assertTrue(form.is_valid())\n+        saved_user = form.save()\n+        self.assertEqual(saved_user.password, original_password)\n"
}