{
  "instance_id": "django__django-12193",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/postgres_tests/test_array_forms.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django import forms\nfrom django.contrib.postgres.forms import SplitArrayField\nfrom django.test import TestCase\n\n\nclass SplitArrayFieldBooleanTest(TestCase):\n    \"\"\"Test SplitArrayField with BooleanField for checkbox widget behavior.\"\"\"\n\n    def test_split_array_boolean_field_widgets_not_all_checked_after_first_true(self):\n        \"\"\"\n        Test that SplitArrayField with BooleanField doesn't have all widgets\n        checked after the first True value in the initial data.\n        \n        This test reproduces the bug where CheckboxInput.get_context() modifies\n        the attrs dict, causing subsequent widgets to be incorrectly checked.\n        \"\"\"\n        # Create a SplitArrayField with BooleanField\n        field = SplitArrayField(\n            forms.BooleanField(required=False),\n            size=5,\n            remove_trailing_nulls=False\n        )\n        \n        # Initial data with mixed True/False values\n        # The pattern [True, False, True, False, False] should be preserved\n        initial_data = [True, False, True, False, False]\n        \n        # Create a form with this field\n        class TestForm(forms.Form):\n            bool_array = field\n        \n        form = TestForm(initial={'bool_array': initial_data})\n        \n        # Render the form to trigger widget context generation\n        rendered_form = str(form)\n        \n        # Get the widget contexts to check the 'checked' attribute\n        widget = form.fields['bool_array'].widget\n        context = widget.get_context('bool_array', initial_data, {})\n        subwidgets = context['widget']['subwidgets']\n        \n        # Check that only the widgets with True values have 'checked' attribute\n        expected_checked = [True, False, True, False, False]\n        \n        for i, (subwidget, should_be_checked) in enumerate(zip(subwidgets, expected_checked)):\n            widget_attrs = subwidget.get('attrs', {})\n            is_checked = widget_attrs.get('checked', False)\n            \n            if should_be_checked:\n                self.assertTrue(\n                    is_checked,\n                    f\"Widget {i} should be checked but isn't. Widget attrs: {widget_attrs}\"\n                )\n            else:\n                self.assertFalse(\n                    is_checked,\n                    f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n                )\n\n    def test_split_array_boolean_field_all_false_values(self):\n        \"\"\"\n        Test SplitArrayField with all False values to ensure none are checked.\n        \"\"\"\n        field = SplitArrayField(\n            forms.BooleanField(required=False),\n            size=4,\n            remove_trailing_nulls=False\n        )\n        \n        initial_data = [False, False, False, False]\n        \n        class TestForm(forms.Form):\n            bool_array = field\n        \n        form = TestForm(initial={'bool_array': initial_data})\n        \n        widget = form.fields['bool_array'].widget\n        context = widget.get_context('bool_array', initial_data, {})\n        subwidgets = context['widget']['subwidgets']\n        \n        # None of the widgets should be checked\n        for i, subwidget in enumerate(subwidgets):\n            widget_attrs = subwidget.get('attrs', {})\n            is_checked = widget_attrs.get('checked', False)\n            self.assertFalse(\n                is_checked,\n                f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n            )\n\n    def test_split_array_boolean_field_all_true_values(self):\n        \"\"\"\n        Test SplitArrayField with all True values to ensure all are checked.\n        \"\"\"\n        field = SplitArrayField(\n            forms.BooleanField(required=False),\n            size=3,\n            remove_trailing_nulls=False\n        )\n        \n        initial_data = [True, True, True]\n        \n        class TestForm(forms.Form):\n            bool_array = field\n        \n        form = TestForm(initial={'bool_array': initial_data})\n        \n        widget = form.fields['bool_array'].widget\n        context = widget.get_context('bool_array', initial_data, {})\n        subwidgets = context['widget']['subwidgets']\n        \n        # All widgets should be checked\n        for i, subwidget in enumerate(subwidgets):\n            widget_attrs = subwidget.get('attrs', {})\n            is_checked = widget_attrs.get('checked', False)\n            self.assertTrue(\n                is_checked,\n                f\"Widget {i} should be checked but isn't. Widget attrs: {widget_attrs}\"\n            )\n\n    def test_split_array_boolean_field_true_followed_by_false_pattern(self):\n        \"\"\"\n        Test the specific pattern that triggers the bug: True followed by False values.\n        This test should fail before the fix and pass after the fix.\n        \"\"\"\n        field = SplitArrayField(\n            forms.BooleanField(required=False),\n            size=6,\n            remove_trailing_nulls=False\n        )\n        \n        # Pattern that specifically triggers the bug\n        initial_data = [True, False, False, False, False, False]\n        \n        class TestForm(forms.Form):\n            bool_array = field\n        \n        form = TestForm(initial={'bool_array': initial_data})\n        \n        widget = form.fields['bool_array'].widget\n        context = widget.get_context('bool_array', initial_data, {})\n        subwidgets = context['widget']['subwidgets']\n        \n        # Only the first widget should be checked\n        for i, subwidget in enumerate(subwidgets):\n            widget_attrs = subwidget.get('attrs', {})\n            is_checked = widget_attrs.get('checked', False)\n            \n            if i == 0:\n                self.assertTrue(\n                    is_checked,\n                    f\"First widget should be checked but isn't. Widget attrs: {widget_attrs}\"\n                )\n            else:\n                self.assertFalse(\n                    is_checked,\n                    f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n                )\n\n    def test_split_array_boolean_field_empty_initial_data(self):\n        \"\"\"\n        Test SplitArrayField with empty initial data.\n        \"\"\"\n        field = SplitArrayField(\n            forms.BooleanField(required=False),\n            size=3,\n            remove_trailing_nulls=False\n        )\n        \n        initial_data = []\n        \n        class TestForm(forms.Form):\n            bool_array = field\n        \n        form = TestForm(initial={'bool_array': initial_data})\n        \n        widget = form.fields['bool_array'].widget\n        context = widget.get_context('bool_array', initial_data, {})\n        subwidgets = context['widget']['subwidgets']\n        \n        # All widgets should be unchecked since there's no initial data\n        for i, subwidget in enumerate(subwidgets):\n            widget_attrs = subwidget.get('attrs', {})\n            is_checked = widget_attrs.get('checked', False)\n            self.assertFalse(\n                is_checked,\n                f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n            )\n\n    def test_split_array_boolean_field_none_initial_data(self):\n        \"\"\"\n        Test SplitArrayField with None initial data.\n        \"\"\"\n        field = SplitArrayField(\n            forms.BooleanField(required=False),\n            size=3,\n            remove_trailing_nulls=False\n        )\n        \n        initial_data = None\n        \n        class TestForm(forms.Form):\n            bool_array = field\n        \n        form = TestForm(initial={'bool_array': initial_data})\n        \n        widget = form.fields['bool_array'].widget\n        context = widget.get_context('bool_array', initial_data, {})\n        subwidgets = context['widget']['subwidgets']\n        \n        # All widgets should be unchecked since initial data is None\n        for i, subwidget in enumerate(subwidgets):\n            widget_attrs = subwidget.get('attrs', {})\n            is_checked = widget_attrs.get('checked', False)\n            self.assertFalse(\n                is_checked,\n                f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n            )\n\n    def test_checkbox_input_attrs_not_modified_directly(self):\n        \"\"\"\n        Test that CheckboxInput.get_context() doesn't modify the original attrs dict.\n        This is a unit test for the specific bug in CheckboxInput.\n        \"\"\"\n        from django.forms.widgets import CheckboxInput\n        \n        # Create a CheckboxInput widget\n        widget = CheckboxInput()\n        \n        # Create an attrs dict that we'll pass to get_context\n        original_attrs = {'class': 'test-class', 'id': 'test-id'}\n        attrs_copy = original_attrs.copy()\n        \n        # Call get_context with a True value (which should set checked=True)\n        context = widget.get_context('test_name', True, original_attrs)\n        \n        # The original attrs dict should not be modified\n        self.assertEqual(\n            original_attrs, \n            attrs_copy,\n            \"CheckboxInput.get_context() should not modify the original attrs dict\"\n        )\n        \n        # But the context should have the checked attribute\n        widget_attrs = context['widget']['attrs']\n        self.assertTrue(\n            widget_attrs.get('checked', False),\n            \"The widget context should have checked=True\"\n        )\n\n    def test_checkbox_input_attrs_modification_isolation(self):\n        \"\"\"\n        Test that multiple calls to CheckboxInput.get_context() with the same attrs\n        dict don't interfere with each other.\n        \"\"\"\n        from django.forms.widgets import CheckboxInput\n        \n        widget = CheckboxInput()\n        shared_attrs = {'class': 'shared-class'}\n        \n        # First call with True value\n        context1 = widget.get_context('test1', True, shared_attrs)\n        \n        # Second call with False value using the same attrs dict\n        context2 = widget.get_context('test2', False, shared_attrs)\n        \n        # The first context should have checked=True\n        self.assertTrue(\n            context1['widget']['attrs'].get('checked', False),\n            \"First widget should be checked\"\n        )\n        \n        # The second context should NOT have checked=True\n        self.assertFalse(\n            context2['widget']['attrs'].get('checked', False),\n            \"Second widget should not be checked\"\n        )\n        \n        # The original shared_attrs should not be modified\n        self.assertNotIn(\n            'checked',\n            shared_attrs,\n            \"Original shared attrs should not contain 'checked' key\"\n        )\n</patched>\n```",
  "patch": "--- a/tests/postgres_tests/test_array_forms.py\n+++ b/tests/postgres_tests/test_array_forms.py\n-# Empty if creating new file\n+import pytest\n+from django import forms\n+from django.contrib.postgres.forms import SplitArrayField\n+from django.test import TestCase\n+\n+\n+class SplitArrayFieldBooleanTest(TestCase):\n+    \"\"\"Test SplitArrayField with BooleanField for checkbox widget behavior.\"\"\"\n+\n+    def test_split_array_boolean_field_widgets_not_all_checked_after_first_true(self):\n+        \"\"\"\n+        Test that SplitArrayField with BooleanField doesn't have all widgets\n+        checked after the first True value in the initial data.\n+        \n+        This test reproduces the bug where CheckboxInput.get_context() modifies\n+        the attrs dict, causing subsequent widgets to be incorrectly checked.\n+        \"\"\"\n+        # Create a SplitArrayField with BooleanField\n+        field = SplitArrayField(\n+            forms.BooleanField(required=False),\n+            size=5,\n+            remove_trailing_nulls=False\n+        )\n+        \n+        # Initial data with mixed True/False values\n+        # The pattern [True, False, True, False, False] should be preserved\n+        initial_data = [True, False, True, False, False]\n+        \n+        # Create a form with this field\n+        class TestForm(forms.Form):\n+            bool_array = field\n+        \n+        form = TestForm(initial={'bool_array': initial_data})\n+        \n+        # Render the form to trigger widget context generation\n+        rendered_form = str(form)\n+        \n+        # Get the widget contexts to check the 'checked' attribute\n+        widget = form.fields['bool_array'].widget\n+        context = widget.get_context('bool_array', initial_data, {})\n+        subwidgets = context['widget']['subwidgets']\n+        \n+        # Check that only the widgets with True values have 'checked' attribute\n+        expected_checked = [True, False, True, False, False]\n+        \n+        for i, (subwidget, should_be_checked) in enumerate(zip(subwidgets, expected_checked)):\n+            widget_attrs = subwidget.get('attrs', {})\n+            is_checked = widget_attrs.get('checked', False)\n+            \n+            if should_be_checked:\n+                self.assertTrue(\n+                    is_checked,\n+                    f\"Widget {i} should be checked but isn't. Widget attrs: {widget_attrs}\"\n+                )\n+            else:\n+                self.assertFalse(\n+                    is_checked,\n+                    f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n+                )\n+\n+    def test_split_array_boolean_field_all_false_values(self):\n+        \"\"\"\n+        Test SplitArrayField with all False values to ensure none are checked.\n+        \"\"\"\n+        field = SplitArrayField(\n+            forms.BooleanField(required=False),\n+            size=4,\n+            remove_trailing_nulls=False\n+        )\n+        \n+        initial_data = [False, False, False, False]\n+        \n+        class TestForm(forms.Form):\n+            bool_array = field\n+        \n+        form = TestForm(initial={'bool_array': initial_data})\n+        \n+        widget = form.fields['bool_array'].widget\n+        context = widget.get_context('bool_array', initial_data, {})\n+        subwidgets = context['widget']['subwidgets']\n+        \n+        # None of the widgets should be checked\n+        for i, subwidget in enumerate(subwidgets):\n+            widget_attrs = subwidget.get('attrs', {})\n+            is_checked = widget_attrs.get('checked', False)\n+            self.assertFalse(\n+                is_checked,\n+                f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n+            )\n+\n+    def test_split_array_boolean_field_all_true_values(self):\n+        \"\"\"\n+        Test SplitArrayField with all True values to ensure all are checked.\n+        \"\"\"\n+        field = SplitArrayField(\n+            forms.BooleanField(required=False),\n+            size=3,\n+            remove_trailing_nulls=False\n+        )\n+        \n+        initial_data = [True, True, True]\n+        \n+        class TestForm(forms.Form):\n+            bool_array = field\n+        \n+        form = TestForm(initial={'bool_array': initial_data})\n+        \n+        widget = form.fields['bool_array'].widget\n+        context = widget.get_context('bool_array', initial_data, {})\n+        subwidgets = context['widget']['subwidgets']\n+        \n+        # All widgets should be checked\n+        for i, subwidget in enumerate(subwidgets):\n+            widget_attrs = subwidget.get('attrs', {})\n+            is_checked = widget_attrs.get('checked', False)\n+            self.assertTrue(\n+                is_checked,\n+                f\"Widget {i} should be checked but isn't. Widget attrs: {widget_attrs}\"\n+            )\n+\n+    def test_split_array_boolean_field_true_followed_by_false_pattern(self):\n+        \"\"\"\n+        Test the specific pattern that triggers the bug: True followed by False values.\n+        This test should fail before the fix and pass after the fix.\n+        \"\"\"\n+        field = SplitArrayField(\n+            forms.BooleanField(required=False),\n+            size=6,\n+            remove_trailing_nulls=False\n+        )\n+        \n+        # Pattern that specifically triggers the bug\n+        initial_data = [True, False, False, False, False, False]\n+        \n+        class TestForm(forms.Form):\n+            bool_array = field\n+        \n+        form = TestForm(initial={'bool_array': initial_data})\n+        \n+        widget = form.fields['bool_array'].widget\n+        context = widget.get_context('bool_array', initial_data, {})\n+        subwidgets = context['widget']['subwidgets']\n+        \n+        # Only the first widget should be checked\n+        for i, subwidget in enumerate(subwidgets):\n+            widget_attrs = subwidget.get('attrs', {})\n+            is_checked = widget_attrs.get('checked', False)\n+            \n+            if i == 0:\n+                self.assertTrue(\n+                    is_checked,\n+                    f\"First widget should be checked but isn't. Widget attrs: {widget_attrs}\"\n+                )\n+            else:\n+                self.assertFalse(\n+                    is_checked,\n+                    f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n+                )\n+\n+    def test_split_array_boolean_field_empty_initial_data(self):\n+        \"\"\"\n+        Test SplitArrayField with empty initial data.\n+        \"\"\"\n+        field = SplitArrayField(\n+            forms.BooleanField(required=False),\n+            size=3,\n+            remove_trailing_nulls=False\n+        )\n+        \n+        initial_data = []\n+        \n+        class TestForm(forms.Form):\n+            bool_array = field\n+        \n+        form = TestForm(initial={'bool_array': initial_data})\n+        \n+        widget = form.fields['bool_array'].widget\n+        context = widget.get_context('bool_array', initial_data, {})\n+        subwidgets = context['widget']['subwidgets']\n+        \n+        # All widgets should be unchecked since there's no initial data\n+        for i, subwidget in enumerate(subwidgets):\n+            widget_attrs = subwidget.get('attrs', {})\n+            is_checked = widget_attrs.get('checked', False)\n+            self.assertFalse(\n+                is_checked,\n+                f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n+            )\n+\n+    def test_split_array_boolean_field_none_initial_data(self):\n+        \"\"\"\n+        Test SplitArrayField with None initial data.\n+        \"\"\"\n+        field = SplitArrayField(\n+            forms.BooleanField(required=False),\n+            size=3,\n+            remove_trailing_nulls=False\n+        )\n+        \n+        initial_data = None\n+        \n+        class TestForm(forms.Form):\n+            bool_array = field\n+        \n+        form = TestForm(initial={'bool_array': initial_data})\n+        \n+        widget = form.fields['bool_array'].widget\n+        context = widget.get_context('bool_array', initial_data, {})\n+        subwidgets = context['widget']['subwidgets']\n+        \n+        # All widgets should be unchecked since initial data is None\n+        for i, subwidget in enumerate(subwidgets):\n+            widget_attrs = subwidget.get('attrs', {})\n+            is_checked = widget_attrs.get('checked', False)\n+            self.assertFalse(\n+                is_checked,\n+                f\"Widget {i} should not be checked but is. Widget attrs: {widget_attrs}\"\n+            )\n+\n+    def test_checkbox_input_attrs_not_modified_directly(self):\n+        \"\"\"\n+        Test that CheckboxInput.get_context() doesn't modify the original attrs dict.\n+        This is a unit test for the specific bug in CheckboxInput.\n+        \"\"\"\n+        from django.forms.widgets import CheckboxInput\n+        \n+        # Create a CheckboxInput widget\n+        widget = CheckboxInput()\n+        \n+        # Create an attrs dict that we'll pass to get_context\n+        original_attrs = {'class': 'test-class', 'id': 'test-id'}\n+        attrs_copy = original_attrs.copy()\n+        \n+        # Call get_context with a True value (which should set checked=True)\n+        context = widget.get_context('test_name', True, original_attrs)\n+        \n+        # The original attrs dict should not be modified\n+        self.assertEqual(\n+            original_attrs, \n+            attrs_copy,\n+            \"CheckboxInput.get_context() should not modify the original attrs dict\"\n+        )\n+        \n+        # But the context should have the checked attribute\n+        widget_attrs = context['widget']['attrs']\n+        self.assertTrue(\n+            widget_attrs.get('checked', False),\n+            \"The widget context should have checked=True\"\n+        )\n+\n+    def test_checkbox_input_attrs_modification_isolation(self):\n+        \"\"\"\n+        Test that multiple calls to CheckboxInput.get_context() with the same attrs\n+        dict don't interfere with each other.\n+        \"\"\"\n+        from django.forms.widgets import CheckboxInput\n+        \n+        widget = CheckboxInput()\n+        shared_attrs = {'class': 'shared-class'}\n+        \n+        # First call with True value\n+        context1 = widget.get_context('test1', True, shared_attrs)\n+        \n+        # Second call with False value using the same attrs dict\n+        context2 = widget.get_context('test2', False, shared_attrs)\n+        \n+        # The first context should have checked=True\n+        self.assertTrue(\n+            context1['widget']['attrs'].get('checked', False),\n+            \"First widget should be checked\"\n+        )\n+        \n+        # The second context should NOT have checked=True\n+        self.assertFalse(\n+            context2['widget']['attrs'].get('checked', False),\n+            \"Second widget should not be checked\"\n+        )\n+        \n+        # The original shared_attrs should not be modified\n+        self.assertNotIn(\n+            'checked',\n+            shared_attrs,\n+            \"Original shared attrs should not contain 'checked' key\"\n+        )\n"
}