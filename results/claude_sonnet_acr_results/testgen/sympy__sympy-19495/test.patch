--- a/sympy/sets/tests/test_conditionset_subs_bug.py
+++ b/sympy/sets/tests/test_conditionset_subs_bug.py
-# Empty if creating new file
+import pytest
+from sympy import (
+    Symbol, S, ConditionSet, ImageSet, Lambda, Interval, 
+    Rational, pi, asin, Contains, solveset_real, Abs
+)
+from sympy.abc import x, y, z, n
+
+
+class TestConditionSetSubsBug:
+    """Test suite for ConditionSet substitution bug with ImageSet."""
+    
+    def test_conditionset_subs_with_finite_set_works(self):
+        """Test that subs works correctly with FiniteSet base_set (baseline case)."""
+        # This should work correctly as shown in the issue
+        result = solveset_real(Abs(x) - y, x)
+        expected_type = ConditionSet
+        assert isinstance(result, expected_type)
+        
+        # Substitute y with 1/3
+        substituted = result.subs(y, Rational(1, 3))
+        # Should return a FiniteSet {-1/3, 1/3}
+        from sympy.sets.sets import FiniteSet
+        assert isinstance(substituted, FiniteSet)
+        assert substituted == FiniteSet(Rational(-1, 3), Rational(1, 3))
+    
+    def test_imageset_subs_works_correctly(self):
+        """Test that ImageSet substitution works correctly in isolation."""
+        # This should work as shown in the issue
+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+        
+        # Test substitution with y -> 1/3
+        substituted = img_set.subs(y, Rational(1, 3))
+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)
+        assert substituted == expected
+        
+        # Test substitution with y -> z
+        substituted_z = img_set.subs(y, z)
+        expected_z = ImageSet(Lambda(n, 2*n*pi + asin(z)), S.Integers)
+        assert substituted_z == expected_z
+    
+    def test_conditionset_with_imageset_subs_bug(self):
+        """Test the main bug: ConditionSet with ImageSet base_set produces wrong result."""
+        # Create the problematic ConditionSet
+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)
+        
+        # This substitution should NOT produce the malformed result
+        result = condition_set.subs(y, Rational(1, 3))
+        
+        # The result should NOT be malformed like:
+        # {1/3 | 1/3 ∊ {2⋅π⋅n + asin(1/3) | n ∊ ℤ} ∧ (1/3 ∈ {2⋅π⋅n + asin(1/3) | n ∊ ℤ})}
+        
+        # Instead, it should be the ImageSet:
+        # {2⋅π⋅n + asin(1/3) | n ∊ ℤ}
+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)
+        
+        # This test will FAIL before the fix is applied
+        assert result == expected, f"Expected {expected}, but got {result}"
+    
+    def test_conditionset_subs_bound_variable_protection(self):
+        """Test that bound variable is protected during substitution."""
+        # Create a ConditionSet where x is the bound variable
+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)
+        
+        # Try to substitute the bound variable x - this should not corrupt the set
+        result = condition_set.subs(x, Rational(1, 3))
+        
+        # The bound variable should be protected, so result should be unchanged
+        assert result == condition_set
+    
+    def test_conditionset_xreplace_works(self):
+        """Test that xreplace works as a workaround."""
+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)
+        
+        # xreplace should work correctly
+        result = condition_set.xreplace({y: Rational(1, 3)})
+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)
+        assert result == expected
+    
+    def test_conditionset_subs_simultaneous_works(self):
+        """Test that subs with simultaneous=True works as a workaround."""
+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)
+        
+        # subs with simultaneous=True should work correctly
+        result = condition_set.subs({y: Rational(1, 3)}, simultaneous=True)
+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)
+        assert result == expected
+    
+    def test_conditionset_subs_different_variables(self):
+        """Test substitution with different variables to ensure general correctness."""
+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)
+        
+        # Substitute y with z (different variable)
+        result = condition_set.subs(y, z)
+        expected = ConditionSet(x, Contains(z, Interval(-1, 1)), 
+                               ImageSet(Lambda(n, 2*n*pi + asin(z)), S.Integers))
+        
+        # This might simplify to just the ImageSet if the condition becomes True
+        # but at minimum it should not be malformed
+        assert isinstance(result, (ConditionSet, ImageSet))
+        
+        # If it's still a ConditionSet, check the structure
+        if isinstance(result, ConditionSet):
+            assert result.sym == x
+            assert z in result.condition.free_symbols
+            assert z in result.base_set.free_symbols
+    
+    def test_conditionset_subs_condition_becomes_true(self):
+        """Test case where condition becomes True after substitution."""
+        # Create a condition that will become True when y=1/3
+        # Since 1/3 is in [-1, 1], the condition should be True
+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)
+        
+        # When y = 1/3, the condition Contains(1/3, [-1, 1]) is True
+        # So the result should be the base_set with y substituted
+        result = condition_set.subs(y, Rational(1, 3))
+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)
+        
+        assert result == expected
+    
+    def test_conditionset_subs_condition_becomes_false(self):
+        """Test case where condition becomes False after substitution."""
+        # Create a condition that will become False when y=2
+        # Since 2 is not in [-1, 1], the condition should be False
+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)
+        
+        # When y = 2, the condition Contains(2, [-1, 1]) is False
+        # So the result should be EmptySet
+        result = condition_set.subs(y, 2)
+        assert result == S.EmptySet
+    
+    def test_conditionset_subs_preserves_structure_when_needed(self):
+        """Test that ConditionSet structure is preserved when condition doesn't simplify."""
+        # Use a more complex condition that won't simplify to True/False
+        from sympy import sin, cos
+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+        condition_set = ConditionSet(x, sin(x) + cos(y) > 0, img_set)
+        
+        # Substitute y with 1/3 - condition won't simplify to True/False
+        result = condition_set.subs(y, Rational(1, 3))
+        
+        # Should still be a ConditionSet
+        assert isinstance(result, ConditionSet)
+        assert result.sym == x
+        # Check that y was substituted in both condition and base_set
+        assert Rational(1, 3) in result.condition.free_symbols or \
+               not y in result.condition.free_symbols
+        assert Rational(1, 3) in result.base_set.free_symbols or \
+               not y in result.base_set.free_symbols
