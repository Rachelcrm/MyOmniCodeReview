{
  "instance_id": "sympy__sympy-19495",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>sympy/sets/tests/test_conditionset_subs_bug.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom sympy import (\n    Symbol, S, ConditionSet, ImageSet, Lambda, Interval, \n    Rational, pi, asin, Contains, solveset_real, Abs\n)\nfrom sympy.abc import x, y, z, n\n\n\nclass TestConditionSetSubsBug:\n    \"\"\"Test suite for ConditionSet substitution bug with ImageSet.\"\"\"\n    \n    def test_conditionset_subs_with_finite_set_works(self):\n        \"\"\"Test that subs works correctly with FiniteSet base_set (baseline case).\"\"\"\n        # This should work correctly as shown in the issue\n        result = solveset_real(Abs(x) - y, x)\n        expected_type = ConditionSet\n        assert isinstance(result, expected_type)\n        \n        # Substitute y with 1/3\n        substituted = result.subs(y, Rational(1, 3))\n        # Should return a FiniteSet {-1/3, 1/3}\n        from sympy.sets.sets import FiniteSet\n        assert isinstance(substituted, FiniteSet)\n        assert substituted == FiniteSet(Rational(-1, 3), Rational(1, 3))\n    \n    def test_imageset_subs_works_correctly(self):\n        \"\"\"Test that ImageSet substitution works correctly in isolation.\"\"\"\n        # This should work as shown in the issue\n        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n        \n        # Test substitution with y -> 1/3\n        substituted = img_set.subs(y, Rational(1, 3))\n        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n        assert substituted == expected\n        \n        # Test substitution with y -> z\n        substituted_z = img_set.subs(y, z)\n        expected_z = ImageSet(Lambda(n, 2*n*pi + asin(z)), S.Integers)\n        assert substituted_z == expected_z\n    \n    def test_conditionset_with_imageset_subs_bug(self):\n        \"\"\"Test the main bug: ConditionSet with ImageSet base_set produces wrong result.\"\"\"\n        # Create the problematic ConditionSet\n        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n        \n        # This substitution should NOT produce the malformed result\n        result = condition_set.subs(y, Rational(1, 3))\n        \n        # The result should NOT be malformed like:\n        # {1/3 | 1/3 \u220a {2\u22c5\u03c0\u22c5n + asin(1/3) | n \u220a \u2124} \u2227 (1/3 \u2208 {2\u22c5\u03c0\u22c5n + asin(1/3) | n \u220a \u2124})}\n        \n        # Instead, it should be the ImageSet:\n        # {2\u22c5\u03c0\u22c5n + asin(1/3) | n \u220a \u2124}\n        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n        \n        # This test will FAIL before the fix is applied\n        assert result == expected, f\"Expected {expected}, but got {result}\"\n    \n    def test_conditionset_subs_bound_variable_protection(self):\n        \"\"\"Test that bound variable is protected during substitution.\"\"\"\n        # Create a ConditionSet where x is the bound variable\n        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n        \n        # Try to substitute the bound variable x - this should not corrupt the set\n        result = condition_set.subs(x, Rational(1, 3))\n        \n        # The bound variable should be protected, so result should be unchanged\n        assert result == condition_set\n    \n    def test_conditionset_xreplace_works(self):\n        \"\"\"Test that xreplace works as a workaround.\"\"\"\n        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n        \n        # xreplace should work correctly\n        result = condition_set.xreplace({y: Rational(1, 3)})\n        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n        assert result == expected\n    \n    def test_conditionset_subs_simultaneous_works(self):\n        \"\"\"Test that subs with simultaneous=True works as a workaround.\"\"\"\n        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n        \n        # subs with simultaneous=True should work correctly\n        result = condition_set.subs({y: Rational(1, 3)}, simultaneous=True)\n        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n        assert result == expected\n    \n    def test_conditionset_subs_different_variables(self):\n        \"\"\"Test substitution with different variables to ensure general correctness.\"\"\"\n        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n        \n        # Substitute y with z (different variable)\n        result = condition_set.subs(y, z)\n        expected = ConditionSet(x, Contains(z, Interval(-1, 1)), \n                               ImageSet(Lambda(n, 2*n*pi + asin(z)), S.Integers))\n        \n        # This might simplify to just the ImageSet if the condition becomes True\n        # but at minimum it should not be malformed\n        assert isinstance(result, (ConditionSet, ImageSet))\n        \n        # If it's still a ConditionSet, check the structure\n        if isinstance(result, ConditionSet):\n            assert result.sym == x\n            assert z in result.condition.free_symbols\n            assert z in result.base_set.free_symbols\n    \n    def test_conditionset_subs_condition_becomes_true(self):\n        \"\"\"Test case where condition becomes True after substitution.\"\"\"\n        # Create a condition that will become True when y=1/3\n        # Since 1/3 is in [-1, 1], the condition should be True\n        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n        \n        # When y = 1/3, the condition Contains(1/3, [-1, 1]) is True\n        # So the result should be the base_set with y substituted\n        result = condition_set.subs(y, Rational(1, 3))\n        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n        \n        assert result == expected\n    \n    def test_conditionset_subs_condition_becomes_false(self):\n        \"\"\"Test case where condition becomes False after substitution.\"\"\"\n        # Create a condition that will become False when y=2\n        # Since 2 is not in [-1, 1], the condition should be False\n        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n        \n        # When y = 2, the condition Contains(2, [-1, 1]) is False\n        # So the result should be EmptySet\n        result = condition_set.subs(y, 2)\n        assert result == S.EmptySet\n    \n    def test_conditionset_subs_preserves_structure_when_needed(self):\n        \"\"\"Test that ConditionSet structure is preserved when condition doesn't simplify.\"\"\"\n        # Use a more complex condition that won't simplify to True/False\n        from sympy import sin, cos\n        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n        condition_set = ConditionSet(x, sin(x) + cos(y) > 0, img_set)\n        \n        # Substitute y with 1/3 - condition won't simplify to True/False\n        result = condition_set.subs(y, Rational(1, 3))\n        \n        # Should still be a ConditionSet\n        assert isinstance(result, ConditionSet)\n        assert result.sym == x\n        # Check that y was substituted in both condition and base_set\n        assert Rational(1, 3) in result.condition.free_symbols or \\\n               not y in result.condition.free_symbols\n        assert Rational(1, 3) in result.base_set.free_symbols or \\\n               not y in result.base_set.free_symbols\n</patched>\n</file>\n```",
  "patch": "--- a/sympy/sets/tests/test_conditionset_subs_bug.py\n+++ b/sympy/sets/tests/test_conditionset_subs_bug.py\n-# Empty if creating new file\n+import pytest\n+from sympy import (\n+    Symbol, S, ConditionSet, ImageSet, Lambda, Interval, \n+    Rational, pi, asin, Contains, solveset_real, Abs\n+)\n+from sympy.abc import x, y, z, n\n+\n+\n+class TestConditionSetSubsBug:\n+    \"\"\"Test suite for ConditionSet substitution bug with ImageSet.\"\"\"\n+    \n+    def test_conditionset_subs_with_finite_set_works(self):\n+        \"\"\"Test that subs works correctly with FiniteSet base_set (baseline case).\"\"\"\n+        # This should work correctly as shown in the issue\n+        result = solveset_real(Abs(x) - y, x)\n+        expected_type = ConditionSet\n+        assert isinstance(result, expected_type)\n+        \n+        # Substitute y with 1/3\n+        substituted = result.subs(y, Rational(1, 3))\n+        # Should return a FiniteSet {-1/3, 1/3}\n+        from sympy.sets.sets import FiniteSet\n+        assert isinstance(substituted, FiniteSet)\n+        assert substituted == FiniteSet(Rational(-1, 3), Rational(1, 3))\n+    \n+    def test_imageset_subs_works_correctly(self):\n+        \"\"\"Test that ImageSet substitution works correctly in isolation.\"\"\"\n+        # This should work as shown in the issue\n+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n+        \n+        # Test substitution with y -> 1/3\n+        substituted = img_set.subs(y, Rational(1, 3))\n+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n+        assert substituted == expected\n+        \n+        # Test substitution with y -> z\n+        substituted_z = img_set.subs(y, z)\n+        expected_z = ImageSet(Lambda(n, 2*n*pi + asin(z)), S.Integers)\n+        assert substituted_z == expected_z\n+    \n+    def test_conditionset_with_imageset_subs_bug(self):\n+        \"\"\"Test the main bug: ConditionSet with ImageSet base_set produces wrong result.\"\"\"\n+        # Create the problematic ConditionSet\n+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n+        \n+        # This substitution should NOT produce the malformed result\n+        result = condition_set.subs(y, Rational(1, 3))\n+        \n+        # The result should NOT be malformed like:\n+        # {1/3 | 1/3 \u220a {2\u22c5\u03c0\u22c5n + asin(1/3) | n \u220a \u2124} \u2227 (1/3 \u2208 {2\u22c5\u03c0\u22c5n + asin(1/3) | n \u220a \u2124})}\n+        \n+        # Instead, it should be the ImageSet:\n+        # {2\u22c5\u03c0\u22c5n + asin(1/3) | n \u220a \u2124}\n+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n+        \n+        # This test will FAIL before the fix is applied\n+        assert result == expected, f\"Expected {expected}, but got {result}\"\n+    \n+    def test_conditionset_subs_bound_variable_protection(self):\n+        \"\"\"Test that bound variable is protected during substitution.\"\"\"\n+        # Create a ConditionSet where x is the bound variable\n+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n+        \n+        # Try to substitute the bound variable x - this should not corrupt the set\n+        result = condition_set.subs(x, Rational(1, 3))\n+        \n+        # The bound variable should be protected, so result should be unchanged\n+        assert result == condition_set\n+    \n+    def test_conditionset_xreplace_works(self):\n+        \"\"\"Test that xreplace works as a workaround.\"\"\"\n+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n+        \n+        # xreplace should work correctly\n+        result = condition_set.xreplace({y: Rational(1, 3)})\n+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n+        assert result == expected\n+    \n+    def test_conditionset_subs_simultaneous_works(self):\n+        \"\"\"Test that subs with simultaneous=True works as a workaround.\"\"\"\n+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n+        \n+        # subs with simultaneous=True should work correctly\n+        result = condition_set.subs({y: Rational(1, 3)}, simultaneous=True)\n+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n+        assert result == expected\n+    \n+    def test_conditionset_subs_different_variables(self):\n+        \"\"\"Test substitution with different variables to ensure general correctness.\"\"\"\n+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n+        \n+        # Substitute y with z (different variable)\n+        result = condition_set.subs(y, z)\n+        expected = ConditionSet(x, Contains(z, Interval(-1, 1)), \n+                               ImageSet(Lambda(n, 2*n*pi + asin(z)), S.Integers))\n+        \n+        # This might simplify to just the ImageSet if the condition becomes True\n+        # but at minimum it should not be malformed\n+        assert isinstance(result, (ConditionSet, ImageSet))\n+        \n+        # If it's still a ConditionSet, check the structure\n+        if isinstance(result, ConditionSet):\n+            assert result.sym == x\n+            assert z in result.condition.free_symbols\n+            assert z in result.base_set.free_symbols\n+    \n+    def test_conditionset_subs_condition_becomes_true(self):\n+        \"\"\"Test case where condition becomes True after substitution.\"\"\"\n+        # Create a condition that will become True when y=1/3\n+        # Since 1/3 is in [-1, 1], the condition should be True\n+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n+        \n+        # When y = 1/3, the condition Contains(1/3, [-1, 1]) is True\n+        # So the result should be the base_set with y substituted\n+        result = condition_set.subs(y, Rational(1, 3))\n+        expected = ImageSet(Lambda(n, 2*n*pi + asin(Rational(1, 3))), S.Integers)\n+        \n+        assert result == expected\n+    \n+    def test_conditionset_subs_condition_becomes_false(self):\n+        \"\"\"Test case where condition becomes False after substitution.\"\"\"\n+        # Create a condition that will become False when y=2\n+        # Since 2 is not in [-1, 1], the condition should be False\n+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n+        condition_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img_set)\n+        \n+        # When y = 2, the condition Contains(2, [-1, 1]) is False\n+        # So the result should be EmptySet\n+        result = condition_set.subs(y, 2)\n+        assert result == S.EmptySet\n+    \n+    def test_conditionset_subs_preserves_structure_when_needed(self):\n+        \"\"\"Test that ConditionSet structure is preserved when condition doesn't simplify.\"\"\"\n+        # Use a more complex condition that won't simplify to True/False\n+        from sympy import sin, cos\n+        img_set = ImageSet(Lambda(n, 2*n*pi + asin(y)), S.Integers)\n+        condition_set = ConditionSet(x, sin(x) + cos(y) > 0, img_set)\n+        \n+        # Substitute y with 1/3 - condition won't simplify to True/False\n+        result = condition_set.subs(y, Rational(1, 3))\n+        \n+        # Should still be a ConditionSet\n+        assert isinstance(result, ConditionSet)\n+        assert result.sym == x\n+        # Check that y was substituted in both condition and base_set\n+        assert Rational(1, 3) in result.condition.free_symbols or \\\n+               not y in result.condition.free_symbols\n+        assert Rational(1, 3) in result.base_set.free_symbols or \\\n+               not y in result.base_set.free_symbols\n"
}