--- a/tests/sessions_tests/test_session_encoding_transition.py
+++ b/tests/sessions_tests/test_session_encoding_transition.py
-# Empty if creating new file
+import base64
+import pytest
+from unittest import mock
+
+from django.conf import settings
+from django.contrib.sessions.backends.base import SessionBase
+from django.core.exceptions import SuspiciousSession
+from django.test import TestCase, override_settings
+from django.utils.crypto import salted_hmac
+
+
+class SessionEncodingTransitionTests(TestCase):
+    """
+    Test session data encoding/decoding during transition to Django 3.1.
+    
+    This tests the bug where session data cannot be decoded during the transition
+    when DEFAULT_HASHING_ALGORITHM is set to 'sha1' for backward compatibility.
+    """
+
+    def setUp(self):
+        self.session = SessionBase()
+        self.test_data = {'user_id': 123, 'username': 'testuser', 'preferences': {'theme': 'dark'}}
+
+    def test_encode_decode_with_default_algorithm(self):
+        """Test that encoding and decoding works with default algorithm (sha256)."""
+        encoded = self.session.encode(self.test_data)
+        decoded = self.session.decode(encoded)
+        self.assertEqual(decoded, self.test_data)
+
+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha1')
+    def test_encode_decode_with_sha1_algorithm_fails_before_fix(self):
+        """
+        Test that demonstrates the bug: when DEFAULT_HASHING_ALGORITHM is 'sha1',
+        encoding uses sha1 but legacy decoding might use sha256, causing mismatch.
+        
+        This test should fail before the fix is applied.
+        """
+        # Create a session with sha1 algorithm
+        session = SessionBase()
+        
+        # Encode data - this will use sha1 via signing.dumps()
+        encoded = session.encode(self.test_data)
+        
+        # Create legacy-style encoded data that would be generated by old Django
+        # This simulates data that was encoded with the old format using sha1
+        serialized = session.serializer().dumps(self.test_data)
+        
+        # Create hash using the _hash method (which should use sha1 but might not)
+        hash_value = session._hash(serialized)
+        legacy_encoded = base64.b64encode(f"{hash_value}:".encode() + serialized).decode()
+        
+        # Try to decode the legacy data - this should work but might fail due to algorithm mismatch
+        try:
+            decoded = session.decode(legacy_encoded)
+            # If we get here, the algorithms matched
+            self.assertEqual(decoded, self.test_data)
+        except (SuspiciousSession, Exception):
+            # This is the bug - the algorithms don't match
+            # The test should fail here before the fix
+            self.fail("Legacy decoding failed due to algorithm mismatch")
+
+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha1')
+    def test_legacy_hash_method_uses_correct_algorithm(self):
+        """
+        Test that _hash method uses the DEFAULT_HASHING_ALGORITHM setting.
+        
+        This test verifies that the _hash method respects the algorithm setting.
+        """
+        session = SessionBase()
+        test_value = b"test_session_data"
+        
+        # Get hash using session's _hash method
+        session_hash = session._hash(test_value)
+        
+        # Calculate expected hash using sha1 explicitly
+        key_salt = "django.contrib.sessions" + session.__class__.__name__
+        expected_hash = salted_hmac(key_salt, test_value, algorithm='sha1').hexdigest()
+        
+        # They should match when DEFAULT_HASHING_ALGORITHM is sha1
+        self.assertEqual(session_hash, expected_hash)
+
+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha256')
+    def test_legacy_hash_method_uses_sha256_when_configured(self):
+        """Test that _hash method uses sha256 when DEFAULT_HASHING_ALGORITHM is sha256."""
+        session = SessionBase()
+        test_value = b"test_session_data"
+        
+        # Get hash using session's _hash method
+        session_hash = session._hash(test_value)
+        
+        # Calculate expected hash using sha256 explicitly
+        key_salt = "django.contrib.sessions" + session.__class__.__name__
+        expected_hash = salted_hmac(key_salt, test_value, algorithm='sha256').hexdigest()
+        
+        # They should match when DEFAULT_HASHING_ALGORITHM is sha256
+        self.assertEqual(session_hash, expected_hash)
+
+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha1')
+    def test_encode_uses_legacy_format_with_sha1(self):
+        """
+        Test that encode method uses legacy format when DEFAULT_HASHING_ALGORITHM is sha1.
+        
+        This test verifies the intended fix behavior.
+        """
+        session = SessionBase()
+        
+        # Encode the data
+        encoded = session.encode(self.test_data)
+        
+        # The encoded data should be decodable by legacy decoder
+        decoded = session._legacy_decode(encoded)
+        self.assertEqual(decoded, self.test_data)
+
+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha1')
+    def test_cross_compatibility_during_transition(self):
+        """
+        Test that session data encoded with sha1 setting can be decoded
+        by both new and legacy decoders.
+        """
+        session = SessionBase()
+        
+        # Encode data with sha1 setting
+        encoded = session.encode(self.test_data)
+        
+        # Should be decodable by regular decode method
+        decoded_new = session.decode(encoded)
+        self.assertEqual(decoded_new, self.test_data)
+        
+        # Should also be decodable by legacy decode method
+        decoded_legacy = session._legacy_decode(encoded)
+        self.assertEqual(decoded_legacy, self.test_data)
+
+    def test_legacy_decode_handles_corrupted_data(self):
+        """Test that legacy decode handles corrupted session data gracefully."""
+        session = SessionBase()
+        
+        # Test with completely invalid data
+        result = session._legacy_decode("invalid_base64_data")
+        self.assertEqual(result, {})
+        
+        # Test with valid base64 but invalid format
+        invalid_data = base64.b64encode(b"no_colon_separator").decode()
+        result = session._legacy_decode(invalid_data)
+        self.assertEqual(result, {})
+
+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha1')
+    def test_multiple_encode_decode_cycles_with_sha1(self):
+        """
+        Test multiple encode/decode cycles work correctly with sha1 algorithm.
+        """
+        session = SessionBase()
+        
+        # Test multiple cycles
+        data = self.test_data
+        for i in range(3):
+            encoded = session.encode(data)
+            decoded = session.decode(encoded)
+            self.assertEqual(decoded, data)
+            
+            # Modify data slightly for next iteration
+            data = dict(data)
+            data[f'cycle_{i}'] = i
+
+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha1')
+    def test_empty_session_data_encoding_with_sha1(self):
+        """Test encoding/decoding empty session data with sha1."""
+        session = SessionBase()
+        empty_data = {}
+        
+        encoded = session.encode(empty_data)
+        decoded = session.decode(encoded)
+        self.assertEqual(decoded, empty_data)
+
+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha1')
+    def test_complex_session_data_encoding_with_sha1(self):
+        """Test encoding/decoding complex session data with sha1."""
+        session = SessionBase()
+        complex_data = {
+            'user': {
+                'id': 123,
+                'profile': {
+                    'name': 'Test User',
+                    'settings': {
+                        'notifications': True,
+                        'theme': 'dark'
+                    }
+                }
+            },
+            'cart': [
+                {'item_id': 1, 'quantity': 2},
+                {'item_id': 5, 'quantity': 1}
+            ],
+            'session_start': '2023-01-01T00:00:00Z'
+        }
+        
+        encoded = session.encode(complex_data)
+        decoded = session.decode(encoded)
+        self.assertEqual(decoded, complex_data)
+
+    def test_algorithm_mismatch_detection(self):
+        """
+        Test that we can detect when there's an algorithm mismatch
+        between encoding and decoding.
+        """
+        # Create session data with sha256 (default)
+        session_sha256 = SessionBase()
+        encoded_sha256 = session_sha256.encode(self.test_data)
+        
+        # Try to decode with sha1 setting
+        with override_settings(DEFAULT_HASHING_ALGORITHM='sha1'):
+            session_sha1 = SessionBase()
+            
+            # This should still work because decode() falls back to legacy decode
+            decoded = session_sha1.decode(encoded_sha256)
+            self.assertEqual(decoded, self.test_data)
+
+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha1')
+    def test_session_key_salt_consistency(self):
+        """Test that key_salt is used consistently in encoding and decoding."""
+        session = SessionBase()
+        
+        # Verify that key_salt is properly set
+        self.assertTrue(hasattr(session, 'key_salt'))
+        
+        # Encode and decode should work with the same key_salt
+        encoded = session.encode(self.test_data)
+        decoded = session.decode(encoded)
+        self.assertEqual(decoded, self.test_data)
