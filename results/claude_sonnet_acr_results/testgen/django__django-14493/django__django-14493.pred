{
  "instance_id": "django__django-14493",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/staticfiles_tests/test_storage.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nimport tempfile\nimport os\nfrom django.test import TestCase, override_settings\nfrom django.contrib.staticfiles.storage import ManifestStaticFilesStorage\nfrom django.core.management import call_command\nfrom django.core.files.storage import default_storage\nfrom django.conf import settings\n\n\nclass ZeroPassManifestStaticFilesStorage(ManifestStaticFilesStorage):\n    \"\"\"Custom storage class with max_post_process_passes set to 0.\"\"\"\n    max_post_process_passes = 0\n\n\nclass TestManifestStaticFilesStorageZeroPasses(TestCase):\n    \"\"\"Test ManifestStaticFilesStorage with max_post_process_passes = 0.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test environment with temporary directories.\"\"\"\n        self.temp_static_root = tempfile.mkdtemp()\n        self.temp_static_dir = tempfile.mkdtemp()\n        \n        # Create a simple CSS file for testing\n        css_content = \"\"\"\n        body {\n            background: url('image.png');\n        }\n        \"\"\"\n        css_file_path = os.path.join(self.temp_static_dir, 'test.css')\n        with open(css_file_path, 'w') as f:\n            f.write(css_content)\n            \n        # Create a simple image file for testing\n        img_file_path = os.path.join(self.temp_static_dir, 'image.png')\n        with open(img_file_path, 'wb') as f:\n            f.write(b'\\x89PNG\\r\\n\\x1a\\n')  # Minimal PNG header\n    \n    def tearDown(self):\n        \"\"\"Clean up temporary directories.\"\"\"\n        import shutil\n        shutil.rmtree(self.temp_static_root, ignore_errors=True)\n        shutil.rmtree(self.temp_static_dir, ignore_errors=True)\n    \n    @override_settings(\n        STATICFILES_STORAGE='tests.staticfiles_tests.test_storage.ZeroPassManifestStaticFilesStorage',\n        STATIC_ROOT=None,  # Will be set in test\n        STATICFILES_DIRS=[]  # Will be set in test\n    )\n    def test_zero_max_post_process_passes_no_crash(self):\n        \"\"\"Test that setting max_post_process_passes to 0 doesn't crash.\"\"\"\n        with self.settings(\n            STATIC_ROOT=self.temp_static_root,\n            STATICFILES_DIRS=[self.temp_static_dir]\n        ):\n            storage = ZeroPassManifestStaticFilesStorage()\n            \n            # This should not raise UnboundLocalError\n            try:\n                # Simulate what collectstatic does\n                paths = {\n                    'test.css': (storage, 'test.css'),\n                    'image.png': (storage, 'image.png'),\n                }\n                \n                # Call post_process directly to test the bug\n                results = list(storage.post_process(paths, dry_run=False))\n                \n                # Should complete without error\n                self.assertIsInstance(results, list)\n                \n            except UnboundLocalError as e:\n                if \"substitutions\" in str(e):\n                    self.fail(\"UnboundLocalError for 'substitutions' variable should not occur\")\n                else:\n                    raise\n    \n    @override_settings(\n        STATICFILES_STORAGE='tests.staticfiles_tests.test_storage.ZeroPassManifestStaticFilesStorage',\n        STATIC_ROOT=None,  # Will be set in test\n        STATICFILES_DIRS=[]  # Will be set in test\n    )\n    def test_zero_passes_with_collectstatic_command(self):\n        \"\"\"Test that collectstatic command works with max_post_process_passes = 0.\"\"\"\n        with self.settings(\n            STATIC_ROOT=self.temp_static_root,\n            STATICFILES_DIRS=[self.temp_static_dir]\n        ):\n            # This should not raise UnboundLocalError during collectstatic\n            try:\n                call_command('collectstatic', verbosity=0, interactive=False)\n                \n                # Verify files were collected\n                self.assertTrue(os.path.exists(os.path.join(self.temp_static_root, 'test.css')))\n                self.assertTrue(os.path.exists(os.path.join(self.temp_static_root, 'image.png')))\n                \n            except UnboundLocalError as e:\n                if \"substitutions\" in str(e):\n                    self.fail(\"collectstatic should not fail with UnboundLocalError for 'substitutions'\")\n                else:\n                    raise\n    \n    def test_zero_passes_post_process_behavior(self):\n        \"\"\"Test the specific behavior of post_process with zero passes.\"\"\"\n        storage = ZeroPassManifestStaticFilesStorage()\n        \n        # Create minimal test data\n        paths = {\n            'test.css': (storage, 'test.css'),\n        }\n        \n        # Mock the _post_process method to avoid file system operations\n        original_post_process = storage._post_process\n        \n        def mock_post_process(paths, adjustable_paths, hashed_files):\n            for path in paths:\n                yield path, path, True, False\n        \n        storage._post_process = mock_post_process\n        \n        try:\n            results = list(storage.post_process(paths, dry_run=False))\n            \n            # Should return results without crashing\n            self.assertIsInstance(results, list)\n            self.assertGreater(len(results), 0)\n            \n        except UnboundLocalError as e:\n            if \"substitutions\" in str(e):\n                self.fail(\"post_process should handle zero passes without UnboundLocalError\")\n            else:\n                raise\n        finally:\n            storage._post_process = original_post_process\n    \n    def test_normal_passes_still_work(self):\n        \"\"\"Test that normal max_post_process_passes values still work correctly.\"\"\"\n        # Test with default value (should be > 0)\n        storage = ManifestStaticFilesStorage()\n        self.assertGreater(storage.max_post_process_passes, 0)\n        \n        # Create minimal test data\n        paths = {\n            'test.css': (storage, 'test.css'),\n        }\n        \n        # Mock the _post_process method\n        def mock_post_process(paths, adjustable_paths, hashed_files):\n            for path in paths:\n                yield path, path, True, False\n        \n        storage._post_process = mock_post_process\n        \n        # Should work without issues\n        results = list(storage.post_process(paths, dry_run=False))\n        self.assertIsInstance(results, list)\n\n\nclass TestManifestStaticFilesStorageEdgeCases(TestCase):\n    \"\"\"Test edge cases for ManifestStaticFilesStorage.\"\"\"\n    \n    def test_negative_max_post_process_passes(self):\n        \"\"\"Test behavior with negative max_post_process_passes.\"\"\"\n        class NegativePassStorage(ManifestStaticFilesStorage):\n            max_post_process_passes = -1\n        \n        storage = NegativePassStorage()\n        paths = {'test.css': (storage, 'test.css')}\n        \n        # Mock _post_process to avoid file operations\n        def mock_post_process(paths, adjustable_paths, hashed_files):\n            for path in paths:\n                yield path, path, True, False\n        \n        storage._post_process = mock_post_process\n        \n        # Should handle negative values gracefully (loop won't execute)\n        try:\n            results = list(storage.post_process(paths, dry_run=False))\n            self.assertIsInstance(results, list)\n        except UnboundLocalError as e:\n            if \"substitutions\" in str(e):\n                self.fail(\"Negative max_post_process_passes should not cause UnboundLocalError\")\n            else:\n                raise\n    \n    def test_one_pass_works_correctly(self):\n        \"\"\"Test that max_post_process_passes = 1 works correctly.\"\"\"\n        class OnePassStorage(ManifestStaticFilesStorage):\n            max_post_process_passes = 1\n        \n        storage = OnePassStorage()\n        paths = {'test.css': (storage, 'test.css')}\n        \n        # Mock _post_process\n        def mock_post_process(paths, adjustable_paths, hashed_files):\n            for path in paths:\n                yield path, path, True, False\n        \n        storage._post_process = mock_post_process\n        \n        # Should work correctly with one pass\n        results = list(storage.post_process(paths, dry_run=False))\n        self.assertIsInstance(results, list)\n</patched>\n</file>\n```",
  "patch": "--- a/tests/staticfiles_tests/test_storage.py\n+++ b/tests/staticfiles_tests/test_storage.py\n-# Empty if creating new file\n+import pytest\n+import tempfile\n+import os\n+from django.test import TestCase, override_settings\n+from django.contrib.staticfiles.storage import ManifestStaticFilesStorage\n+from django.core.management import call_command\n+from django.core.files.storage import default_storage\n+from django.conf import settings\n+\n+\n+class ZeroPassManifestStaticFilesStorage(ManifestStaticFilesStorage):\n+    \"\"\"Custom storage class with max_post_process_passes set to 0.\"\"\"\n+    max_post_process_passes = 0\n+\n+\n+class TestManifestStaticFilesStorageZeroPasses(TestCase):\n+    \"\"\"Test ManifestStaticFilesStorage with max_post_process_passes = 0.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test environment with temporary directories.\"\"\"\n+        self.temp_static_root = tempfile.mkdtemp()\n+        self.temp_static_dir = tempfile.mkdtemp()\n+        \n+        # Create a simple CSS file for testing\n+        css_content = \"\"\"\n+        body {\n+            background: url('image.png');\n+        }\n+        \"\"\"\n+        css_file_path = os.path.join(self.temp_static_dir, 'test.css')\n+        with open(css_file_path, 'w') as f:\n+            f.write(css_content)\n+            \n+        # Create a simple image file for testing\n+        img_file_path = os.path.join(self.temp_static_dir, 'image.png')\n+        with open(img_file_path, 'wb') as f:\n+            f.write(b'\\x89PNG\\r\\n\\x1a\\n')  # Minimal PNG header\n+    \n+    def tearDown(self):\n+        \"\"\"Clean up temporary directories.\"\"\"\n+        import shutil\n+        shutil.rmtree(self.temp_static_root, ignore_errors=True)\n+        shutil.rmtree(self.temp_static_dir, ignore_errors=True)\n+    \n+    @override_settings(\n+        STATICFILES_STORAGE='tests.staticfiles_tests.test_storage.ZeroPassManifestStaticFilesStorage',\n+        STATIC_ROOT=None,  # Will be set in test\n+        STATICFILES_DIRS=[]  # Will be set in test\n+    )\n+    def test_zero_max_post_process_passes_no_crash(self):\n+        \"\"\"Test that setting max_post_process_passes to 0 doesn't crash.\"\"\"\n+        with self.settings(\n+            STATIC_ROOT=self.temp_static_root,\n+            STATICFILES_DIRS=[self.temp_static_dir]\n+        ):\n+            storage = ZeroPassManifestStaticFilesStorage()\n+            \n+            # This should not raise UnboundLocalError\n+            try:\n+                # Simulate what collectstatic does\n+                paths = {\n+                    'test.css': (storage, 'test.css'),\n+                    'image.png': (storage, 'image.png'),\n+                }\n+                \n+                # Call post_process directly to test the bug\n+                results = list(storage.post_process(paths, dry_run=False))\n+                \n+                # Should complete without error\n+                self.assertIsInstance(results, list)\n+                \n+            except UnboundLocalError as e:\n+                if \"substitutions\" in str(e):\n+                    self.fail(\"UnboundLocalError for 'substitutions' variable should not occur\")\n+                else:\n+                    raise\n+    \n+    @override_settings(\n+        STATICFILES_STORAGE='tests.staticfiles_tests.test_storage.ZeroPassManifestStaticFilesStorage',\n+        STATIC_ROOT=None,  # Will be set in test\n+        STATICFILES_DIRS=[]  # Will be set in test\n+    )\n+    def test_zero_passes_with_collectstatic_command(self):\n+        \"\"\"Test that collectstatic command works with max_post_process_passes = 0.\"\"\"\n+        with self.settings(\n+            STATIC_ROOT=self.temp_static_root,\n+            STATICFILES_DIRS=[self.temp_static_dir]\n+        ):\n+            # This should not raise UnboundLocalError during collectstatic\n+            try:\n+                call_command('collectstatic', verbosity=0, interactive=False)\n+                \n+                # Verify files were collected\n+                self.assertTrue(os.path.exists(os.path.join(self.temp_static_root, 'test.css')))\n+                self.assertTrue(os.path.exists(os.path.join(self.temp_static_root, 'image.png')))\n+                \n+            except UnboundLocalError as e:\n+                if \"substitutions\" in str(e):\n+                    self.fail(\"collectstatic should not fail with UnboundLocalError for 'substitutions'\")\n+                else:\n+                    raise\n+    \n+    def test_zero_passes_post_process_behavior(self):\n+        \"\"\"Test the specific behavior of post_process with zero passes.\"\"\"\n+        storage = ZeroPassManifestStaticFilesStorage()\n+        \n+        # Create minimal test data\n+        paths = {\n+            'test.css': (storage, 'test.css'),\n+        }\n+        \n+        # Mock the _post_process method to avoid file system operations\n+        original_post_process = storage._post_process\n+        \n+        def mock_post_process(paths, adjustable_paths, hashed_files):\n+            for path in paths:\n+                yield path, path, True, False\n+        \n+        storage._post_process = mock_post_process\n+        \n+        try:\n+            results = list(storage.post_process(paths, dry_run=False))\n+            \n+            # Should return results without crashing\n+            self.assertIsInstance(results, list)\n+            self.assertGreater(len(results), 0)\n+            \n+        except UnboundLocalError as e:\n+            if \"substitutions\" in str(e):\n+                self.fail(\"post_process should handle zero passes without UnboundLocalError\")\n+            else:\n+                raise\n+        finally:\n+            storage._post_process = original_post_process\n+    \n+    def test_normal_passes_still_work(self):\n+        \"\"\"Test that normal max_post_process_passes values still work correctly.\"\"\"\n+        # Test with default value (should be > 0)\n+        storage = ManifestStaticFilesStorage()\n+        self.assertGreater(storage.max_post_process_passes, 0)\n+        \n+        # Create minimal test data\n+        paths = {\n+            'test.css': (storage, 'test.css'),\n+        }\n+        \n+        # Mock the _post_process method\n+        def mock_post_process(paths, adjustable_paths, hashed_files):\n+            for path in paths:\n+                yield path, path, True, False\n+        \n+        storage._post_process = mock_post_process\n+        \n+        # Should work without issues\n+        results = list(storage.post_process(paths, dry_run=False))\n+        self.assertIsInstance(results, list)\n+\n+\n+class TestManifestStaticFilesStorageEdgeCases(TestCase):\n+    \"\"\"Test edge cases for ManifestStaticFilesStorage.\"\"\"\n+    \n+    def test_negative_max_post_process_passes(self):\n+        \"\"\"Test behavior with negative max_post_process_passes.\"\"\"\n+        class NegativePassStorage(ManifestStaticFilesStorage):\n+            max_post_process_passes = -1\n+        \n+        storage = NegativePassStorage()\n+        paths = {'test.css': (storage, 'test.css')}\n+        \n+        # Mock _post_process to avoid file operations\n+        def mock_post_process(paths, adjustable_paths, hashed_files):\n+            for path in paths:\n+                yield path, path, True, False\n+        \n+        storage._post_process = mock_post_process\n+        \n+        # Should handle negative values gracefully (loop won't execute)\n+        try:\n+            results = list(storage.post_process(paths, dry_run=False))\n+            self.assertIsInstance(results, list)\n+        except UnboundLocalError as e:\n+            if \"substitutions\" in str(e):\n+                self.fail(\"Negative max_post_process_passes should not cause UnboundLocalError\")\n+            else:\n+                raise\n+    \n+    def test_one_pass_works_correctly(self):\n+        \"\"\"Test that max_post_process_passes = 1 works correctly.\"\"\"\n+        class OnePassStorage(ManifestStaticFilesStorage):\n+            max_post_process_passes = 1\n+        \n+        storage = OnePassStorage()\n+        paths = {'test.css': (storage, 'test.css')}\n+        \n+        # Mock _post_process\n+        def mock_post_process(paths, adjustable_paths, hashed_files):\n+            for path in paths:\n+                yield path, path, True, False\n+        \n+        storage._post_process = mock_post_process\n+        \n+        # Should work correctly with one pass\n+        results = list(storage.post_process(paths, dry_run=False))\n+        self.assertIsInstance(results, list)\n"
}