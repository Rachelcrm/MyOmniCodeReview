{
  "instance_id": "django__django-13513",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "Looking at the analysis, I can see that the bug has already been fixed in the current codebase. However, since the task is to write comprehensive pytest unit tests for this feature, I'll create tests that verify the correct behavior of the `__suppress_context__` handling in Django's debug error view.\n\n```\n<file>tests/view_tests/test_debug_suppress_context.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nimport sys\nfrom django.http import HttpRequest\nfrom django.views.debug import ExceptionReporter\nfrom django.views.generic import View\n\n\nclass TestSuppressContextView(View):\n    \"\"\"Test view that demonstrates exception chaining with suppress_context.\"\"\"\n    \n    def get(self, request, *args, **kwargs):\n        try:\n            raise RuntimeError('original error')\n        except Exception as exc:\n            raise ValueError('new error') from None\n\n\nclass TestExplicitCauseView(View):\n    \"\"\"Test view that demonstrates explicit exception chaining.\"\"\"\n    \n    def get(self, request, *args, **kwargs):\n        try:\n            raise RuntimeError('original error')\n        except Exception as exc:\n            raise ValueError('new error') from exc\n\n\nclass TestImplicitCauseView(View):\n    \"\"\"Test view that demonstrates implicit exception chaining.\"\"\"\n    \n    def get(self, request, *args, **kwargs):\n        try:\n            raise RuntimeError('original error')\n        except Exception:\n            raise ValueError('new error')\n\n\nclass TestDebugSuppressContext:\n    \"\"\"Test suite for PEP 415 __suppress_context__ support in Django debug views.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.request = HttpRequest()\n        self.request.method = 'GET'\n        self.request.path = '/test/'\n    \n    def test_suppress_context_with_raise_from_none(self):\n        \"\"\"Test that 'raise ... from None' properly suppresses context in debug view.\"\"\"\n        # Create an exception with suppressed context\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception:\n                raise ValueError('new error') from None\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        # Create ExceptionReporter and get traceback frames\n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        frames = reporter.get_traceback_frames()\n        \n        # Verify that __suppress_context__ is respected\n        assert exc_value.__suppress_context__ is True\n        assert exc_value.__context__ is not None  # Context exists but should be suppressed\n        assert exc_value.__cause__ is None  # No explicit cause\n        \n        # The frames should not include the suppressed context\n        # We should only see frames from the ValueError, not the RuntimeError\n        exception_types_in_frames = []\n        for frame in frames:\n            if 'exc_cause' in frame and frame['exc_cause']:\n                exception_types_in_frames.append(type(frame['exc_cause']).__name__)\n        \n        # With proper suppress_context handling, we shouldn't see RuntimeError\n        assert 'RuntimeError' not in exception_types_in_frames\n    \n    def test_explicit_cause_with_raise_from_exception(self):\n        \"\"\"Test that 'raise ... from exc' shows explicit cause in debug view.\"\"\"\n        original_exc = None\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception as exc:\n                original_exc = exc\n                raise ValueError('new error') from exc\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        # Create ExceptionReporter and get traceback frames\n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        frames = reporter.get_traceback_frames()\n        \n        # Verify explicit cause is preserved\n        assert exc_value.__suppress_context__ is False\n        assert exc_value.__context__ is original_exc\n        assert exc_value.__cause__ is original_exc\n        \n        # The frames should include the explicit cause\n        found_runtime_error = False\n        for frame in frames:\n            if 'exc_cause' in frame and frame['exc_cause']:\n                if isinstance(frame['exc_cause'], RuntimeError):\n                    found_runtime_error = True\n                    break\n        \n        assert found_runtime_error, \"Explicit cause should be included in frames\"\n    \n    def test_implicit_cause_without_suppression(self):\n        \"\"\"Test that implicit exception chaining works when not suppressed.\"\"\"\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception:\n                raise ValueError('new error')  # No 'from' clause\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        # Create ExceptionReporter and get traceback frames\n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        frames = reporter.get_traceback_frames()\n        \n        # Verify implicit cause is preserved\n        assert exc_value.__suppress_context__ is False\n        assert exc_value.__context__ is not None\n        assert exc_value.__cause__ is None  # No explicit cause\n        \n        # The frames should include the implicit context\n        found_runtime_error = False\n        for frame in frames:\n            if 'exc_cause' in frame and frame['exc_cause']:\n                if isinstance(frame['exc_cause'], RuntimeError):\n                    found_runtime_error = True\n                    break\n        \n        assert found_runtime_error, \"Implicit context should be included in frames\"\n    \n    def test_explicit_or_implicit_cause_function_behavior(self):\n        \"\"\"Test the explicit_or_implicit_cause function directly.\"\"\"\n        # Create an exception with suppressed context\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception:\n                raise ValueError('new error') from None\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        \n        # Access the nested function by calling get_traceback_frames and inspecting\n        # We'll test the behavior indirectly through the frames\n        frames = reporter.get_traceback_frames()\n        \n        # For suppressed context, exc_cause should be None\n        for frame in frames:\n            if 'exc_cause' in frame:\n                # When context is suppressed, exc_cause should be None\n                if exc_value.__suppress_context__:\n                    assert frame['exc_cause'] is None or not isinstance(frame['exc_cause'], RuntimeError)\n    \n    def test_exception_cycle_detection_with_suppress_context(self):\n        \"\"\"Test that exception cycle detection works with suppress_context.\"\"\"\n        # Create a more complex scenario to test cycle detection\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception:\n                raise ValueError('new error') from None\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        \n        # This should not raise any warnings or errors\n        frames = reporter.get_traceback_frames()\n        assert isinstance(frames, list)\n    \n    def test_no_exception_case(self):\n        \"\"\"Test behavior when no exception is provided.\"\"\"\n        reporter = ExceptionReporter(self.request, None, None, None)\n        frames = reporter.get_traceback_frames()\n        assert frames == []\n    \n    def test_exception_with_no_context_or_cause(self):\n        \"\"\"Test exception with neither context nor cause.\"\"\"\n        try:\n            raise ValueError('standalone error')\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        frames = reporter.get_traceback_frames()\n        \n        # Should handle gracefully\n        assert isinstance(frames, list)\n        for frame in frames:\n            if 'exc_cause' in frame:\n                assert frame['exc_cause'] is None\n    \n    def test_suppress_context_attribute_values(self):\n        \"\"\"Test different values of __suppress_context__ attribute.\"\"\"\n        # Test with __suppress_context__ = True\n        try:\n            try:\n                raise RuntimeError('original')\n            except Exception:\n                raise ValueError('new') from None\n        except Exception as exc:\n            assert exc.__suppress_context__ is True\n            \n        # Test with __suppress_context__ = False (implicit chaining)\n        try:\n            try:\n                raise RuntimeError('original')\n            except Exception:\n                raise ValueError('new')\n        except Exception as exc:\n            assert exc.__suppress_context__ is False\n            \n        # Test with explicit chaining\n        try:\n            try:\n                raise RuntimeError('original')\n            except Exception as orig:\n                raise ValueError('new') from orig\n        except Exception as exc:\n            assert exc.__suppress_context__ is False\n    \n    def test_nested_exception_chains_with_suppression(self):\n        \"\"\"Test complex nested exception chains with mixed suppression.\"\"\"\n        try:\n            try:\n                try:\n                    raise RuntimeError('level 1')\n                except Exception:\n                    raise ValueError('level 2') from None  # Suppress level 1\n            except Exception:\n                raise TypeError('level 3')  # Don't suppress level 2\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        frames = reporter.get_traceback_frames()\n        \n        # Should handle complex chaining correctly\n        assert isinstance(frames, list)\n        \n        # The RuntimeError should be suppressed, but ValueError should be visible\n        found_runtime_error = False\n        found_value_error = False\n        \n        for frame in frames:\n            if 'exc_cause' in frame and frame['exc_cause']:\n                if isinstance(frame['exc_cause'], RuntimeError):\n                    found_runtime_error = True\n                elif isinstance(frame['exc_cause'], ValueError):\n                    found_value_error = True\n        \n        # RuntimeError should be suppressed, ValueError should be visible as context\n        assert not found_runtime_error, \"RuntimeError should be suppressed\"\n        assert found_value_error, \"ValueError should be visible as context\"\n</patched>\n</file>\n```\n\n```\n<file>tests/view_tests/test_debug_exception_reporter.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nimport warnings\nfrom django.http import HttpRequest\nfrom django.views.debug import ExceptionReporter, ExceptionCycleWarning\n\n\nclass TestExceptionReporterSuppressContext:\n    \"\"\"Additional tests for ExceptionReporter's handling of __suppress_context__.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.request = HttpRequest()\n        self.request.method = 'GET'\n        self.request.path = '/test/'\n    \n    def test_get_traceback_data_with_suppressed_context(self):\n        \"\"\"Test that get_traceback_data respects suppressed context.\"\"\"\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception:\n                raise ValueError('new error') from None\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        traceback_data = reporter.get_traceback_data()\n        \n        # Verify the traceback data structure\n        assert 'frames' in traceback_data\n        assert isinstance(traceback_data['frames'], list)\n        \n        # Check that suppressed context is not included in frames\n        frames = traceback_data['frames']\n        for frame in frames:\n            if 'exc_cause' in frame and frame['exc_cause']:\n                assert not isinstance(frame['exc_cause'], RuntimeError), \\\n                    \"Suppressed RuntimeError should not appear in frames\"\n    \n    def test_get_traceback_html_with_suppressed_context(self):\n        \"\"\"Test that HTML traceback respects suppressed context.\"\"\"\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception:\n                raise ValueError('new error') from None\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        html_output = reporter.get_traceback_html()\n        \n        # Verify HTML is generated\n        assert isinstance(html_output, str)\n        assert len(html_output) > 0\n        \n        # The HTML should not contain references to the suppressed RuntimeError\n        # This is a basic check - in practice, the template rendering would\n        # handle the display logic\n        assert 'ValueError' in html_output\n    \n    def test_get_traceback_text_with_suppressed_context(self):\n        \"\"\"Test that text traceback respects suppressed context.\"\"\"\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception:\n                raise ValueError('new error') from None\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        text_output = reporter.get_traceback_text()\n        \n        # Verify text is generated\n        assert isinstance(text_output, str)\n        assert len(text_output) > 0\n        \n        # The text should contain the ValueError but handling of suppressed\n        # context depends on the template\n        assert 'ValueError' in text_output\n    \n    def test_exception_cycle_warning_with_suppressed_context(self):\n        \"\"\"Test that exception cycle detection works with suppressed context.\"\"\"\n        # Create a scenario that could potentially cause cycles\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception:\n                raise ValueError('new error') from None\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        \n        # This should not trigger any cycle warnings since context is suppressed\n        with warnings.catch_warnings(record=True) as w:\n            warnings.simplefilter(\"always\")\n            frames = reporter.get_traceback_frames()\n            \n            # Check that no ExceptionCycleWarning was raised\n            cycle_warnings = [warning for warning in w \n                            if issubclass(warning.category, ExceptionCycleWarning)]\n            assert len(cycle_warnings) == 0\n    \n    def test_frame_exc_cause_explicit_flag(self):\n        \"\"\"Test that exc_cause_explicit flag is set correctly.\"\"\"\n        # Test explicit cause\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception as exc:\n                raise ValueError('new error') from exc\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        frames = reporter.get_traceback_frames()\n        \n        # Check exc_cause_explicit flag\n        for frame in frames:\n            if 'exc_cause_explicit' in frame:\n                # Should be True for explicit cause\n                assert frame['exc_cause_explicit'] is True\n        \n        # Test suppressed context\n        try:\n            try:\n                raise RuntimeError('original error')\n            except Exception:\n                raise ValueError('new error') from None\n        except Exception as exc:\n            exc_type = type(exc)\n            exc_value = exc\n            tb = exc.__traceback__\n        \n        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n        frames = reporter.get_traceback_",
  "patch": "--- a/tests/view_tests/test_debug_suppress_context.py\n+++ b/tests/view_tests/test_debug_suppress_context.py\n-# Empty if creating new file\n+import pytest\n+import sys\n+from django.http import HttpRequest\n+from django.views.debug import ExceptionReporter\n+from django.views.generic import View\n+\n+\n+class TestSuppressContextView(View):\n+    \"\"\"Test view that demonstrates exception chaining with suppress_context.\"\"\"\n+    \n+    def get(self, request, *args, **kwargs):\n+        try:\n+            raise RuntimeError('original error')\n+        except Exception as exc:\n+            raise ValueError('new error') from None\n+\n+\n+class TestExplicitCauseView(View):\n+    \"\"\"Test view that demonstrates explicit exception chaining.\"\"\"\n+    \n+    def get(self, request, *args, **kwargs):\n+        try:\n+            raise RuntimeError('original error')\n+        except Exception as exc:\n+            raise ValueError('new error') from exc\n+\n+\n+class TestImplicitCauseView(View):\n+    \"\"\"Test view that demonstrates implicit exception chaining.\"\"\"\n+    \n+    def get(self, request, *args, **kwargs):\n+        try:\n+            raise RuntimeError('original error')\n+        except Exception:\n+            raise ValueError('new error')\n+\n+\n+class TestDebugSuppressContext:\n+    \"\"\"Test suite for PEP 415 __suppress_context__ support in Django debug views.\"\"\"\n+    \n+    def setup_method(self):\n+        \"\"\"Set up test fixtures.\"\"\"\n+        self.request = HttpRequest()\n+        self.request.method = 'GET'\n+        self.request.path = '/test/'\n+    \n+    def test_suppress_context_with_raise_from_none(self):\n+        \"\"\"Test that 'raise ... from None' properly suppresses context in debug view.\"\"\"\n+        # Create an exception with suppressed context\n+        try:\n+            try:\n+                raise RuntimeError('original error')\n+            except Exception:\n+                raise ValueError('new error') from None\n+        except Exception as exc:\n+            exc_type = type(exc)\n+            exc_value = exc\n+            tb = exc.__traceback__\n+        \n+        # Create ExceptionReporter and get traceback frames\n+        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n+        frames = reporter.get_traceback_frames()\n+        \n+        # Verify that __suppress_context__ is respected\n+        assert exc_value.__suppress_context__ is True\n+        assert exc_value.__context__ is not None  # Context exists but should be suppressed\n+        assert exc_value.__cause__ is None  # No explicit cause\n+        \n+        # The frames should not include the suppressed context\n+        # We should only see frames from the ValueError, not the RuntimeError\n+        exception_types_in_frames = []\n+        for frame in frames:\n+            if 'exc_cause' in frame and frame['exc_cause']:\n+                exception_types_in_frames.append(type(frame['exc_cause']).__name__)\n+        \n+        # With proper suppress_context handling, we shouldn't see RuntimeError\n+        assert 'RuntimeError' not in exception_types_in_frames\n+    \n+    def test_explicit_cause_with_raise_from_exception(self):\n+        \"\"\"Test that 'raise ... from exc' shows explicit cause in debug view.\"\"\"\n+        original_exc = None\n+        try:\n+            try:\n+                raise RuntimeError('original error')\n+            except Exception as exc:\n+                original_exc = exc\n+                raise ValueError('new error') from exc\n+        except Exception as exc:\n+            exc_type = type(exc)\n+            exc_value = exc\n+            tb = exc.__traceback__\n+        \n+        # Create ExceptionReporter and get traceback frames\n+        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n+        frames = reporter.get_traceback_frames()\n+        \n+        # Verify explicit cause is preserved\n+        assert exc_value.__suppress_context__ is False\n+        assert exc_value.__context__ is original_exc\n+        assert exc_value.__cause__ is original_exc\n+        \n+        # The frames should include the explicit cause\n+        found_runtime_error = False\n+        for frame in frames:\n+            if 'exc_cause' in frame and frame['exc_cause']:\n+                if isinstance(frame['exc_cause'], RuntimeError):\n+                    found_runtime_error = True\n+                    break\n+        \n+        assert found_runtime_error, \"Explicit cause should be included in frames\"\n+    \n+    def test_implicit_cause_without_suppression(self):\n+        \"\"\"Test that implicit exception chaining works when not suppressed.\"\"\"\n+        try:\n+            try:\n+                raise RuntimeError('original error')\n+            except Exception:\n+                raise ValueError('new error')  # No 'from' clause\n+        except Exception as exc:\n+            exc_type = type(exc)\n+            exc_value = exc\n+            tb = exc.__traceback__\n+        \n+        # Create ExceptionReporter and get traceback frames\n+        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n+        frames = reporter.get_traceback_frames()\n+        \n+        # Verify implicit cause is preserved\n+        assert exc_value.__suppress_context__ is False\n+        assert exc_value.__context__ is not None\n+        assert exc_value.__cause__ is None  # No explicit cause\n+        \n+        # The frames should include the implicit context\n+        found_runtime_error = False\n+        for frame in frames:\n+            if 'exc_cause' in frame and frame['exc_cause']:\n+                if isinstance(frame['exc_cause'], RuntimeError):\n+                    found_runtime_error = True\n+                    break\n+        \n+        assert found_runtime_error, \"Implicit context should be included in frames\"\n+    \n+    def test_explicit_or_implicit_cause_function_behavior(self):\n+        \"\"\"Test the explicit_or_implicit_cause function directly.\"\"\"\n+        # Create an exception with suppressed context\n+        try:\n+            try:\n+                raise RuntimeError('original error')\n+            except Exception:\n+                raise ValueError('new error') from None\n+        except Exception as exc:\n+            exc_type = type(exc)\n+            exc_value = exc\n+            tb = exc.__traceback__\n+        \n+        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n+        \n+        # Access the nested function by calling get_traceback_frames and inspecting\n+        # We'll test the behavior indirectly through the frames\n+        frames = reporter.get_traceback_frames()\n+        \n+        # For suppressed context, exc_cause should be None\n+        for frame in frames:\n+            if 'exc_cause' in frame:\n+                # When context is suppressed, exc_cause should be None\n+                if exc_value.__suppress_context__:\n+                    assert frame['exc_cause'] is None or not isinstance(frame['exc_cause'], RuntimeError)\n+    \n+    def test_exception_cycle_detection_with_suppress_context(self):\n+        \"\"\"Test that exception cycle detection works with suppress_context.\"\"\"\n+        # Create a more complex scenario to test cycle detection\n+        try:\n+            try:\n+                raise RuntimeError('original error')\n+            except Exception:\n+                raise ValueError('new error') from None\n+        except Exception as exc:\n+            exc_type = type(exc)\n+            exc_value = exc\n+            tb = exc.__traceback__\n+        \n+        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n+        \n+        # This should not raise any warnings or errors\n+        frames = reporter.get_traceback_frames()\n+        assert isinstance(frames, list)\n+    \n+    def test_no_exception_case(self):\n+        \"\"\"Test behavior when no exception is provided.\"\"\"\n+        reporter = ExceptionReporter(self.request, None, None, None)\n+        frames = reporter.get_traceback_frames()\n+        assert frames == []\n+    \n+    def test_exception_with_no_context_or_cause(self):\n+        \"\"\"Test exception with neither context nor cause.\"\"\"\n+        try:\n+            raise ValueError('standalone error')\n+        except Exception as exc:\n+            exc_type = type(exc)\n+            exc_value = exc\n+            tb = exc.__traceback__\n+        \n+        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n+        frames = reporter.get_traceback_frames()\n+        \n+        # Should handle gracefully\n+        assert isinstance(frames, list)\n+        for frame in frames:\n+            if 'exc_cause' in frame:\n+                assert frame['exc_cause'] is None\n+    \n+    def test_suppress_context_attribute_values(self):\n+        \"\"\"Test different values of __suppress_context__ attribute.\"\"\"\n+        # Test with __suppress_context__ = True\n+        try:\n+            try:\n+                raise RuntimeError('original')\n+            except Exception:\n+                raise ValueError('new') from None\n+        except Exception as exc:\n+            assert exc.__suppress_context__ is True\n+            \n+        # Test with __suppress_context__ = False (implicit chaining)\n+        try:\n+            try:\n+                raise RuntimeError('original')\n+            except Exception:\n+                raise ValueError('new')\n+        except Exception as exc:\n+            assert exc.__suppress_context__ is False\n+            \n+        # Test with explicit chaining\n+        try:\n+            try:\n+                raise RuntimeError('original')\n+            except Exception as orig:\n+                raise ValueError('new') from orig\n+        except Exception as exc:\n+            assert exc.__suppress_context__ is False\n+    \n+    def test_nested_exception_chains_with_suppression(self):\n+        \"\"\"Test complex nested exception chains with mixed suppression.\"\"\"\n+        try:\n+            try:\n+                try:\n+                    raise RuntimeError('level 1')\n+                except Exception:\n+                    raise ValueError('level 2') from None  # Suppress level 1\n+            except Exception:\n+                raise TypeError('level 3')  # Don't suppress level 2\n+        except Exception as exc:\n+            exc_type = type(exc)\n+            exc_value = exc\n+            tb = exc.__traceback__\n+        \n+        reporter = ExceptionReporter(self.request, exc_type, exc_value, tb)\n+        frames = reporter.get_traceback_frames()\n+        \n+        # Should handle complex chaining correctly\n+        assert isinstance(frames, list)\n+        \n+        # The RuntimeError should be suppressed, but ValueError should be visible\n+        found_runtime_error = False\n+        found_value_error = False\n+        \n+        for frame in frames:\n+            if 'exc_cause' in frame and frame['exc_cause']:\n+                if isinstance(frame['exc_cause'], RuntimeError):\n+                    found_runtime_error = True\n+                elif isinstance(frame['exc_cause'], ValueError):\n+                    found_value_error = True\n+        \n+        # RuntimeError should be suppressed, ValueError should be visible as context\n+        assert not found_runtime_error, \"RuntimeError should be suppressed\"\n+        assert found_value_error, \"ValueError should be visible as context\"\n"
}