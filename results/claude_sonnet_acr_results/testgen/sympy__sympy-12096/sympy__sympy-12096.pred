{
  "instance_id": "sympy__sympy-12096",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>sympy/utilities/tests/test_lambdify_evalf_bug.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom sympy.utilities.lambdify import implemented_function\nfrom sympy import symbols, Float, I\nfrom sympy.core.function import UndefinedFunction\n\n\nclass TestImplementedFunctionEvalf:\n    \"\"\"Test suite for the evalf bug with implemented functions.\"\"\"\n    \n    def test_single_implemented_function_evalf(self):\n        \"\"\"Test that a single implemented function evaluates correctly.\"\"\"\n        f = implemented_function('f', lambda x: x ** 2)\n        result = f(2).evalf()\n        expected = Float(4.0)\n        assert result == expected\n        \n    def test_single_implemented_function_evalf_complex(self):\n        \"\"\"Test that a single implemented function works with complex numbers.\"\"\"\n        f = implemented_function('f', lambda x: x * 2)\n        result = f(1 + I).evalf()\n        # Should evaluate to 2 + 2*I\n        assert result.real == 2\n        assert result.imag == 2\n        \n    def test_composed_implemented_functions_evalf_fails_before_fix(self):\n        \"\"\"Test that demonstrates the bug - composed functions don't evaluate.\n        \n        This test should fail before the fix is applied, showing that\n        f(g(2)).evalf() returns the symbolic expression instead of the numeric result.\n        \"\"\"\n        f = implemented_function('f', lambda x: x ** 2)\n        g = implemented_function('g', lambda x: 2 * x)\n        \n        # This should evaluate to 16.0 but currently returns f(g(2))\n        result = f(g(2)).evalf()\n        \n        # Before fix: this will be a symbolic expression f(g(2))\n        # After fix: this should be Float(16.0)\n        if hasattr(result, 'func') and result.func.__name__ == 'f':\n            # This indicates the bug is present - we got back a symbolic expression\n            pytest.fail(\"Bug reproduced: f(g(2)).evalf() returned symbolic expression instead of numeric value\")\n        else:\n            # This means the bug is fixed\n            assert result == Float(16.0)\n    \n    def test_composed_implemented_functions_evalf_after_fix(self):\n        \"\"\"Test that composed implemented functions evaluate correctly after fix.\"\"\"\n        f = implemented_function('f', lambda x: x ** 2)\n        g = implemented_function('g', lambda x: 2 * x)\n        \n        # Test the composition f(g(2))\n        # g(2) should evaluate to 4, then f(4) should evaluate to 16\n        result = f(g(2)).evalf()\n        expected = Float(16.0)\n        assert result == expected\n        \n    def test_triple_composed_implemented_functions(self):\n        \"\"\"Test that triple composition works: f(g(h(x))).\"\"\"\n        f = implemented_function('f', lambda x: x ** 2)\n        g = implemented_function('g', lambda x: 2 * x)\n        h = implemented_function('h', lambda x: x + 1)\n        \n        # h(2) = 3, g(3) = 6, f(6) = 36\n        result = f(g(h(2))).evalf()\n        expected = Float(36.0)\n        assert result == expected\n        \n    def test_implemented_function_with_multiple_args(self):\n        \"\"\"Test implemented functions with multiple arguments.\"\"\"\n        add_func = implemented_function('add_func', lambda x, y: x + y)\n        mult_func = implemented_function('mult_func', lambda x: x * 3)\n        \n        # mult_func(2) = 6, then add_func(6, 4) = 10\n        result = add_func(mult_func(2), 4).evalf()\n        expected = Float(10.0)\n        assert result == expected\n        \n    def test_implemented_function_with_symbolic_args(self):\n        \"\"\"Test that implemented functions work with symbolic arguments that evaluate to numbers.\"\"\"\n        from sympy import pi, sin, cos\n        \n        f = implemented_function('f', lambda x: x ** 2)\n        \n        # Test with pi/2 which should evaluate to a numeric value\n        result = f(pi/6).evalf()\n        expected = Float((pi/6)**2)\n        assert abs(result - expected) < 1e-10\n        \n    def test_nested_composition_with_different_precisions(self):\n        \"\"\"Test that precision is handled correctly in nested compositions.\"\"\"\n        f = implemented_function('f', lambda x: x ** 2)\n        g = implemented_function('g', lambda x: x / 3)\n        \n        # Test with different precision levels\n        result_default = f(g(3)).evalf()\n        result_high_prec = f(g(3)).evalf(50)\n        \n        # Both should be 1.0, but high precision should have more decimal places\n        assert result_default == Float(1.0)\n        assert abs(result_high_prec - 1) < 1e-40\n        \n    def test_implemented_function_error_handling(self):\n        \"\"\"Test that error handling works correctly in compositions.\"\"\"\n        # Function that might raise an error\n        def risky_func(x):\n            if x < 0:\n                raise ValueError(\"Negative input\")\n            return x ** 0.5\n            \n        f = implemented_function('f', risky_func)\n        g = implemented_function('g', lambda x: -x)\n        \n        # This should handle the error gracefully\n        # g(2) = -2, f(-2) should raise ValueError\n        result = f(g(2)).evalf()\n        \n        # If the composition doesn't work, we might get back a symbolic expression\n        # If it works but errors, we might get None or the original expression\n        # The exact behavior depends on how errors are handled\n        assert result is None or (hasattr(result, 'func') and result.func.__name__ == 'f')\n        \n    def test_mixed_implemented_and_regular_functions(self):\n        \"\"\"Test composition of implemented functions with regular SymPy functions.\"\"\"\n        from sympy import sin, cos\n        \n        f = implemented_function('f', lambda x: x ** 2)\n        \n        # Mix implemented function with regular SymPy function\n        # sin(1) should evaluate to a number, then f should square it\n        result = f(sin(1)).evalf()\n        expected = Float(sin(1)**2)\n        \n        # Check that they're approximately equal (floating point precision)\n        assert abs(result - expected) < 1e-10\n        \n    def test_implemented_function_preserves_existing_functionality(self):\n        \"\"\"Test that the fix doesn't break existing single function evaluation.\"\"\"\n        # Test various single function cases to ensure no regression\n        \n        # Integer input\n        f1 = implemented_function('f1', lambda x: x * 2)\n        assert f1(5).evalf() == Float(10.0)\n        \n        # Float input  \n        f2 = implemented_function('f2', lambda x: x + 1)\n        assert f2(3.5).evalf() == Float(4.5)\n        \n        # Complex function\n        f3 = implemented_function('f3', lambda x: x.real + x.imag)\n        result = f3(2 + 3*I).evalf()\n        assert result == Float(5.0)\n</patched>\n```",
  "patch": "--- a/sympy/utilities/tests/test_lambdify_evalf_bug.py\n+++ b/sympy/utilities/tests/test_lambdify_evalf_bug.py\n-# Empty if creating new file\n+import pytest\n+from sympy.utilities.lambdify import implemented_function\n+from sympy import symbols, Float, I\n+from sympy.core.function import UndefinedFunction\n+\n+\n+class TestImplementedFunctionEvalf:\n+    \"\"\"Test suite for the evalf bug with implemented functions.\"\"\"\n+    \n+    def test_single_implemented_function_evalf(self):\n+        \"\"\"Test that a single implemented function evaluates correctly.\"\"\"\n+        f = implemented_function('f', lambda x: x ** 2)\n+        result = f(2).evalf()\n+        expected = Float(4.0)\n+        assert result == expected\n+        \n+    def test_single_implemented_function_evalf_complex(self):\n+        \"\"\"Test that a single implemented function works with complex numbers.\"\"\"\n+        f = implemented_function('f', lambda x: x * 2)\n+        result = f(1 + I).evalf()\n+        # Should evaluate to 2 + 2*I\n+        assert result.real == 2\n+        assert result.imag == 2\n+        \n+    def test_composed_implemented_functions_evalf_fails_before_fix(self):\n+        \"\"\"Test that demonstrates the bug - composed functions don't evaluate.\n+        \n+        This test should fail before the fix is applied, showing that\n+        f(g(2)).evalf() returns the symbolic expression instead of the numeric result.\n+        \"\"\"\n+        f = implemented_function('f', lambda x: x ** 2)\n+        g = implemented_function('g', lambda x: 2 * x)\n+        \n+        # This should evaluate to 16.0 but currently returns f(g(2))\n+        result = f(g(2)).evalf()\n+        \n+        # Before fix: this will be a symbolic expression f(g(2))\n+        # After fix: this should be Float(16.0)\n+        if hasattr(result, 'func') and result.func.__name__ == 'f':\n+            # This indicates the bug is present - we got back a symbolic expression\n+            pytest.fail(\"Bug reproduced: f(g(2)).evalf() returned symbolic expression instead of numeric value\")\n+        else:\n+            # This means the bug is fixed\n+            assert result == Float(16.0)\n+    \n+    def test_composed_implemented_functions_evalf_after_fix(self):\n+        \"\"\"Test that composed implemented functions evaluate correctly after fix.\"\"\"\n+        f = implemented_function('f', lambda x: x ** 2)\n+        g = implemented_function('g', lambda x: 2 * x)\n+        \n+        # Test the composition f(g(2))\n+        # g(2) should evaluate to 4, then f(4) should evaluate to 16\n+        result = f(g(2)).evalf()\n+        expected = Float(16.0)\n+        assert result == expected\n+        \n+    def test_triple_composed_implemented_functions(self):\n+        \"\"\"Test that triple composition works: f(g(h(x))).\"\"\"\n+        f = implemented_function('f', lambda x: x ** 2)\n+        g = implemented_function('g', lambda x: 2 * x)\n+        h = implemented_function('h', lambda x: x + 1)\n+        \n+        # h(2) = 3, g(3) = 6, f(6) = 36\n+        result = f(g(h(2))).evalf()\n+        expected = Float(36.0)\n+        assert result == expected\n+        \n+    def test_implemented_function_with_multiple_args(self):\n+        \"\"\"Test implemented functions with multiple arguments.\"\"\"\n+        add_func = implemented_function('add_func', lambda x, y: x + y)\n+        mult_func = implemented_function('mult_func', lambda x: x * 3)\n+        \n+        # mult_func(2) = 6, then add_func(6, 4) = 10\n+        result = add_func(mult_func(2), 4).evalf()\n+        expected = Float(10.0)\n+        assert result == expected\n+        \n+    def test_implemented_function_with_symbolic_args(self):\n+        \"\"\"Test that implemented functions work with symbolic arguments that evaluate to numbers.\"\"\"\n+        from sympy import pi, sin, cos\n+        \n+        f = implemented_function('f', lambda x: x ** 2)\n+        \n+        # Test with pi/2 which should evaluate to a numeric value\n+        result = f(pi/6).evalf()\n+        expected = Float((pi/6)**2)\n+        assert abs(result - expected) < 1e-10\n+        \n+    def test_nested_composition_with_different_precisions(self):\n+        \"\"\"Test that precision is handled correctly in nested compositions.\"\"\"\n+        f = implemented_function('f', lambda x: x ** 2)\n+        g = implemented_function('g', lambda x: x / 3)\n+        \n+        # Test with different precision levels\n+        result_default = f(g(3)).evalf()\n+        result_high_prec = f(g(3)).evalf(50)\n+        \n+        # Both should be 1.0, but high precision should have more decimal places\n+        assert result_default == Float(1.0)\n+        assert abs(result_high_prec - 1) < 1e-40\n+        \n+    def test_implemented_function_error_handling(self):\n+        \"\"\"Test that error handling works correctly in compositions.\"\"\"\n+        # Function that might raise an error\n+        def risky_func(x):\n+            if x < 0:\n+                raise ValueError(\"Negative input\")\n+            return x ** 0.5\n+            \n+        f = implemented_function('f', risky_func)\n+        g = implemented_function('g', lambda x: -x)\n+        \n+        # This should handle the error gracefully\n+        # g(2) = -2, f(-2) should raise ValueError\n+        result = f(g(2)).evalf()\n+        \n+        # If the composition doesn't work, we might get back a symbolic expression\n+        # If it works but errors, we might get None or the original expression\n+        # The exact behavior depends on how errors are handled\n+        assert result is None or (hasattr(result, 'func') and result.func.__name__ == 'f')\n+        \n+    def test_mixed_implemented_and_regular_functions(self):\n+        \"\"\"Test composition of implemented functions with regular SymPy functions.\"\"\"\n+        from sympy import sin, cos\n+        \n+        f = implemented_function('f', lambda x: x ** 2)\n+        \n+        # Mix implemented function with regular SymPy function\n+        # sin(1) should evaluate to a number, then f should square it\n+        result = f(sin(1)).evalf()\n+        expected = Float(sin(1)**2)\n+        \n+        # Check that they're approximately equal (floating point precision)\n+        assert abs(result - expected) < 1e-10\n+        \n+    def test_implemented_function_preserves_existing_functionality(self):\n+        \"\"\"Test that the fix doesn't break existing single function evaluation.\"\"\"\n+        # Test various single function cases to ensure no regression\n+        \n+        # Integer input\n+        f1 = implemented_function('f1', lambda x: x * 2)\n+        assert f1(5).evalf() == Float(10.0)\n+        \n+        # Float input  \n+        f2 = implemented_function('f2', lambda x: x + 1)\n+        assert f2(3.5).evalf() == Float(4.5)\n+        \n+        # Complex function\n+        f3 = implemented_function('f3', lambda x: x.real + x.imag)\n+        result = f3(2 + 3*I).evalf()\n+        assert result == Float(5.0)\n"
}