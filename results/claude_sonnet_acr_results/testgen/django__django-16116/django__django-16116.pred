{
  "instance_id": "django__django-16116",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/migrations/test_commands.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport os\nimport sys\nimport tempfile\nfrom io import StringIO\nfrom unittest import mock\n\nimport pytest\nfrom django.core.management import call_command\nfrom django.core.management.base import CommandError\nfrom django.db import models\nfrom django.test import TestCase, override_settings\nfrom django.test.utils import isolate_apps\n\n\nclass MakeMigrationsCheckTests(TestCase):\n    \"\"\"\n    Test suite for makemigrations --check flag behavior.\n    \n    This tests the bug where makemigrations --check was inconsistent with\n    other Django commands like migrate --check and optimizemigration --check.\n    The --check flag should exit without creating migration files.\n    \"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test environment with temporary migration directory.\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.addCleanup(lambda: __import__('shutil').rmtree(self.temp_dir, ignore_errors=True))\n\n    @isolate_apps('test_app')\n    def test_makemigrations_check_with_no_changes_exits_zero(self):\n        \"\"\"\n        Test that makemigrations --check exits with code 0 when no changes are detected.\n        This should be the successful case - no migrations needed.\n        \"\"\"\n        # Create a simple model\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n\n        # Mock the autodetector to return no changes\n        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes:\n            mock_changes.return_value = {}\n            \n            # Capture stdout/stderr\n            stdout = StringIO()\n            stderr = StringIO()\n            \n            # This should exit with code 0 (success) and not create any files\n            with self.assertRaises(SystemExit) as cm:\n                call_command('makemigrations', 'test_app', check_changes=True, \n                           stdout=stdout, stderr=stderr, verbosity=1)\n            \n            # Should exit with code 0 (no changes needed)\n            self.assertEqual(cm.exception.code, 0)\n            \n            # Should not have written any migration files\n            self.assertEqual(len(os.listdir(self.temp_dir)), 0)\n\n    @isolate_apps('test_app')\n    def test_makemigrations_check_with_changes_exits_one(self):\n        \"\"\"\n        Test that makemigrations --check exits with code 1 when changes are detected.\n        This is the main bug fix - it should exit without creating migration files.\n        \"\"\"\n        # Create a simple model\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n\n        # Mock the autodetector to return changes (simulating pending migrations)\n        fake_migration = mock.MagicMock()\n        fake_migration.name = 'test_migration'\n        \n        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes:\n            mock_changes.return_value = {'test_app': [fake_migration]}\n            \n            # Capture stdout/stderr\n            stdout = StringIO()\n            stderr = StringIO()\n            \n            # This should exit with code 1 (changes detected) and not create any files\n            with self.assertRaises(SystemExit) as cm:\n                call_command('makemigrations', 'test_app', check_changes=True, \n                           stdout=stdout, stderr=stderr, verbosity=1)\n            \n            # Should exit with code 1 (changes detected)\n            self.assertEqual(cm.exception.code, 1)\n            \n            # Should not have written any migration files\n            self.assertEqual(len(os.listdir(self.temp_dir)), 0)\n\n    @isolate_apps('test_app')\n    def test_makemigrations_check_does_not_write_files(self):\n        \"\"\"\n        Test that makemigrations --check never writes migration files,\n        even when changes are detected. This is the core of the bug fix.\n        \"\"\"\n        # Create a simple model\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n\n        # Mock the autodetector and file writing\n        fake_migration = mock.MagicMock()\n        fake_migration.name = 'test_migration'\n        \n        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes, \\\n             mock.patch('django.core.management.commands.makemigrations.Command.write_migration_files') as mock_write:\n            \n            mock_changes.return_value = {'test_app': [fake_migration]}\n            \n            # Capture stdout/stderr\n            stdout = StringIO()\n            stderr = StringIO()\n            \n            # This should exit before write_migration_files is called\n            with self.assertRaises(SystemExit):\n                call_command('makemigrations', 'test_app', check_changes=True, \n                           stdout=stdout, stderr=stderr)\n            \n            # write_migration_files should never be called when --check is used\n            mock_write.assert_not_called()\n\n    @isolate_apps('test_app')\n    def test_makemigrations_without_check_still_writes_files(self):\n        \"\"\"\n        Test that makemigrations without --check still works normally.\n        This ensures we don't break existing functionality.\n        \"\"\"\n        # Create a simple model\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n\n        # Mock the autodetector and file writing\n        fake_migration = mock.MagicMock()\n        fake_migration.name = 'test_migration'\n        \n        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes, \\\n             mock.patch('django.core.management.commands.makemigrations.Command.write_migration_files') as mock_write:\n            \n            mock_changes.return_value = {'test_app': [fake_migration]}\n            \n            # Capture stdout/stderr\n            stdout = StringIO()\n            stderr = StringIO()\n            \n            # This should call write_migration_files normally\n            call_command('makemigrations', 'test_app', check_changes=False, \n                        stdout=stdout, stderr=stderr)\n            \n            # write_migration_files should be called when --check is not used\n            mock_write.assert_called_once()\n\n    @isolate_apps('test_app')\n    def test_makemigrations_check_with_dry_run_combination(self):\n        \"\"\"\n        Test that makemigrations --check --dry-run behaves correctly.\n        The issue mentioned that currently both flags are needed, but\n        after the fix, --check alone should be sufficient.\n        \"\"\"\n        # Create a simple model\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n\n        # Mock the autodetector to return changes\n        fake_migration = mock.MagicMock()\n        fake_migration.name = 'test_migration'\n        \n        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes:\n            mock_changes.return_value = {'test_app': [fake_migration]}\n            \n            # Capture stdout/stderr\n            stdout = StringIO()\n            stderr = StringIO()\n            \n            # Even with both flags, should exit with code 1 and not write files\n            with self.assertRaises(SystemExit) as cm:\n                call_command('makemigrations', 'test_app', check_changes=True, \n                           dry_run=True, stdout=stdout, stderr=stderr)\n            \n            # Should exit with code 1 (changes detected)\n            self.assertEqual(cm.exception.code, 1)\n\n    @isolate_apps('test_app')\n    def test_makemigrations_check_consistency_with_migrate_check(self):\n        \"\"\"\n        Test that makemigrations --check behaves consistently with migrate --check.\n        Both should exit immediately after checking without performing their main action.\n        \"\"\"\n        # Create a simple model\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n\n        # Test makemigrations --check behavior\n        fake_migration = mock.MagicMock()\n        fake_migration.name = 'test_migration'\n        \n        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes, \\\n             mock.patch('django.core.management.commands.makemigrations.Command.write_migration_files') as mock_write:\n            \n            mock_changes.return_value = {'test_app': [fake_migration]}\n            \n            # makemigrations --check should exit without writing files\n            with self.assertRaises(SystemExit) as cm:\n                call_command('makemigrations', 'test_app', check_changes=True)\n            \n            self.assertEqual(cm.exception.code, 1)\n            mock_write.assert_not_called()\n\n        # Test migrate --check behavior for comparison\n        with mock.patch('django.db.migrations.executor.MigrationExecutor.migration_plan') as mock_plan, \\\n             mock.patch('django.db.migrations.executor.MigrationExecutor.migrate') as mock_migrate:\n            \n            # Mock unapplied migrations\n            mock_plan.return_value = [('test_app', '0001_initial')]\n            \n            # migrate --check should exit without running migrations\n            with self.assertRaises(SystemExit) as cm:\n                call_command('migrate', check=True)\n            \n            self.assertEqual(cm.exception.code, 1)\n            mock_migrate.assert_not_called()\n\n    @isolate_apps('test_app')\n    def test_makemigrations_check_multiple_apps(self):\n        \"\"\"\n        Test that makemigrations --check works correctly with multiple apps.\n        \"\"\"\n        # Create models for multiple apps\n        class TestModel1(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n\n        class TestModel2(models.Model):\n            title = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app2'\n\n        # Mock the autodetector to return changes for multiple apps\n        fake_migration1 = mock.MagicMock()\n        fake_migration1.name = 'test_migration1'\n        fake_migration2 = mock.MagicMock()\n        fake_migration2.name = 'test_migration2'\n        \n        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes:\n            mock_changes.return_value = {\n                'test_app': [fake_migration1],\n                'test_app2': [fake_migration2]\n            }\n            \n            # Should exit with code 1 when changes are detected in any app\n            with self.assertRaises(SystemExit) as cm:\n                call_command('makemigrations', check_changes=True)\n            \n            self.assertEqual(cm.exception.code, 1)\n\n    def test_makemigrations_check_help_text(self):\n        \"\"\"\n        Test that the help text for --check flag is accurate.\n        \"\"\"\n        from django.core.management.commands.makemigrations import Command\n        \n        command = Command()\n        parser = command.create_parser('manage.py', 'makemigrations')\n        \n        # Find the --check argument\n        check_action = None\n        for action in parser._actions:\n            if '--check' in action.option_strings:\n                check_action = action\n                break\n        \n        self.assertIsNotNone(check_action)\n        self.assertEqual(check_action.dest, 'check_changes')\n        self.assertIn('Exit with a non-zero status', check_action.help)\n        self.assertIn('missing migrations', check_action.help)\n</patched>\n</file>\n```\n\n```\n<file>tests/migrations/test_makemigrations_check_integration.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport os\nimport tempfile\nfrom io import StringIO\nfrom unittest import mock\n\nfrom django.core.management import call_command\nfrom django.db import models\nfrom django.test import TestCase, override_settings\nfrom django.test.utils import isolate_apps\n\n\nclass MakeMigrationsCheckIntegrationTests(TestCase):\n    \"\"\"\n    Integration tests for makemigrations --check flag.\n    \n    These tests verify the fix for the bug where makemigrations --check\n    was inconsistent with other Django commands. The --check flag should\n    exit without creating migration files, just like migrate --check and\n    optimizemigration --check.\n    \"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test environment.\"\"\"\n        self.temp_migrations_dir = tempfile.mkdtemp()\n        self.addCleanup(lambda: __import__('shutil').rmtree(self.temp_migrations_dir, ignore_errors=True))\n\n    @isolate_apps('test_check_app')\n    @override_settings(MIGRATION_MODULES={'test_check_app': 'test_migrations'})\n    def test_check_flag_exits_before_file_creation(self):\n        \"\"\"\n        Integration test to verify that --check exits before any file I/O operations.\n        This is the core behavior that was broken before the fix.\n        \"\"\"\n        # Create a model that would generate a migration\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            created_at = models.DateTimeField(auto_now_add=True)\n            \n            class Meta:\n                app_label = 'test_check_app'\n\n        # Mock file system operations to ensure they're not called\n        with mock.patch('builtins.open', side_effect=Exception(\"File should not be opened\")) as mock_open, \\\n             mock.patch('os.makedirs', side_effect=Exception(\"Directory should not be created\")) as mock_makedirs, \\\n             mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes:\n            \n            # Simulate detected changes\n            fake_migration = mock.MagicMock()\n            fake_migration.name = 'test_migration'\n            mock_changes.return_value = {'test_check_app': [fake_migration]}\n            \n            # The command should exit with code 1 without attempting file operations\n            with self.assertRaises(SystemExit) as cm:\n                call_command('makemigrations', 'test_check_app', check_changes=True, verbosity=0)\n            \n            self.assertEqual(cm.exception.code, 1)\n            \n            # Verify no file operations were attempted\n            mock_open.assert_not_called()\n            mock_makedirs.assert_not_called()\n\n    @isolate_apps('test_check_app')\n    def test_check_flag_vs_normal_operation(self):\n        \"\"\"\n        Test that demonstrates the difference between --check and normal operation.\n        Normal operation should proceed with file writing, --check should not.\n        \"\"\"\n        # Create a model\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_check_app'\n\n        fake_migration = mock.MagicMock()\n        fake_migration.name = 'test_migration'\n        \n        # Test normal operation (without --check)\n        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes, \\\n             mock.patch('django.core.management.",
  "patch": "--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n-# Empty if creating new file\n+import os\n+import sys\n+import tempfile\n+from io import StringIO\n+from unittest import mock\n+\n+import pytest\n+from django.core.management import call_command\n+from django.core.management.base import CommandError\n+from django.db import models\n+from django.test import TestCase, override_settings\n+from django.test.utils import isolate_apps\n+\n+\n+class MakeMigrationsCheckTests(TestCase):\n+    \"\"\"\n+    Test suite for makemigrations --check flag behavior.\n+    \n+    This tests the bug where makemigrations --check was inconsistent with\n+    other Django commands like migrate --check and optimizemigration --check.\n+    The --check flag should exit without creating migration files.\n+    \"\"\"\n+\n+    def setUp(self):\n+        \"\"\"Set up test environment with temporary migration directory.\"\"\"\n+        self.temp_dir = tempfile.mkdtemp()\n+        self.addCleanup(lambda: __import__('shutil').rmtree(self.temp_dir, ignore_errors=True))\n+\n+    @isolate_apps('test_app')\n+    def test_makemigrations_check_with_no_changes_exits_zero(self):\n+        \"\"\"\n+        Test that makemigrations --check exits with code 0 when no changes are detected.\n+        This should be the successful case - no migrations needed.\n+        \"\"\"\n+        # Create a simple model\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+\n+        # Mock the autodetector to return no changes\n+        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes:\n+            mock_changes.return_value = {}\n+            \n+            # Capture stdout/stderr\n+            stdout = StringIO()\n+            stderr = StringIO()\n+            \n+            # This should exit with code 0 (success) and not create any files\n+            with self.assertRaises(SystemExit) as cm:\n+                call_command('makemigrations', 'test_app', check_changes=True, \n+                           stdout=stdout, stderr=stderr, verbosity=1)\n+            \n+            # Should exit with code 0 (no changes needed)\n+            self.assertEqual(cm.exception.code, 0)\n+            \n+            # Should not have written any migration files\n+            self.assertEqual(len(os.listdir(self.temp_dir)), 0)\n+\n+    @isolate_apps('test_app')\n+    def test_makemigrations_check_with_changes_exits_one(self):\n+        \"\"\"\n+        Test that makemigrations --check exits with code 1 when changes are detected.\n+        This is the main bug fix - it should exit without creating migration files.\n+        \"\"\"\n+        # Create a simple model\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+\n+        # Mock the autodetector to return changes (simulating pending migrations)\n+        fake_migration = mock.MagicMock()\n+        fake_migration.name = 'test_migration'\n+        \n+        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes:\n+            mock_changes.return_value = {'test_app': [fake_migration]}\n+            \n+            # Capture stdout/stderr\n+            stdout = StringIO()\n+            stderr = StringIO()\n+            \n+            # This should exit with code 1 (changes detected) and not create any files\n+            with self.assertRaises(SystemExit) as cm:\n+                call_command('makemigrations', 'test_app', check_changes=True, \n+                           stdout=stdout, stderr=stderr, verbosity=1)\n+            \n+            # Should exit with code 1 (changes detected)\n+            self.assertEqual(cm.exception.code, 1)\n+            \n+            # Should not have written any migration files\n+            self.assertEqual(len(os.listdir(self.temp_dir)), 0)\n+\n+    @isolate_apps('test_app')\n+    def test_makemigrations_check_does_not_write_files(self):\n+        \"\"\"\n+        Test that makemigrations --check never writes migration files,\n+        even when changes are detected. This is the core of the bug fix.\n+        \"\"\"\n+        # Create a simple model\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+\n+        # Mock the autodetector and file writing\n+        fake_migration = mock.MagicMock()\n+        fake_migration.name = 'test_migration'\n+        \n+        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes, \\\n+             mock.patch('django.core.management.commands.makemigrations.Command.write_migration_files') as mock_write:\n+            \n+            mock_changes.return_value = {'test_app': [fake_migration]}\n+            \n+            # Capture stdout/stderr\n+            stdout = StringIO()\n+            stderr = StringIO()\n+            \n+            # This should exit before write_migration_files is called\n+            with self.assertRaises(SystemExit):\n+                call_command('makemigrations', 'test_app', check_changes=True, \n+                           stdout=stdout, stderr=stderr)\n+            \n+            # write_migration_files should never be called when --check is used\n+            mock_write.assert_not_called()\n+\n+    @isolate_apps('test_app')\n+    def test_makemigrations_without_check_still_writes_files(self):\n+        \"\"\"\n+        Test that makemigrations without --check still works normally.\n+        This ensures we don't break existing functionality.\n+        \"\"\"\n+        # Create a simple model\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+\n+        # Mock the autodetector and file writing\n+        fake_migration = mock.MagicMock()\n+        fake_migration.name = 'test_migration'\n+        \n+        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes, \\\n+             mock.patch('django.core.management.commands.makemigrations.Command.write_migration_files') as mock_write:\n+            \n+            mock_changes.return_value = {'test_app': [fake_migration]}\n+            \n+            # Capture stdout/stderr\n+            stdout = StringIO()\n+            stderr = StringIO()\n+            \n+            # This should call write_migration_files normally\n+            call_command('makemigrations', 'test_app', check_changes=False, \n+                        stdout=stdout, stderr=stderr)\n+            \n+            # write_migration_files should be called when --check is not used\n+            mock_write.assert_called_once()\n+\n+    @isolate_apps('test_app')\n+    def test_makemigrations_check_with_dry_run_combination(self):\n+        \"\"\"\n+        Test that makemigrations --check --dry-run behaves correctly.\n+        The issue mentioned that currently both flags are needed, but\n+        after the fix, --check alone should be sufficient.\n+        \"\"\"\n+        # Create a simple model\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+\n+        # Mock the autodetector to return changes\n+        fake_migration = mock.MagicMock()\n+        fake_migration.name = 'test_migration'\n+        \n+        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes:\n+            mock_changes.return_value = {'test_app': [fake_migration]}\n+            \n+            # Capture stdout/stderr\n+            stdout = StringIO()\n+            stderr = StringIO()\n+            \n+            # Even with both flags, should exit with code 1 and not write files\n+            with self.assertRaises(SystemExit) as cm:\n+                call_command('makemigrations', 'test_app', check_changes=True, \n+                           dry_run=True, stdout=stdout, stderr=stderr)\n+            \n+            # Should exit with code 1 (changes detected)\n+            self.assertEqual(cm.exception.code, 1)\n+\n+    @isolate_apps('test_app')\n+    def test_makemigrations_check_consistency_with_migrate_check(self):\n+        \"\"\"\n+        Test that makemigrations --check behaves consistently with migrate --check.\n+        Both should exit immediately after checking without performing their main action.\n+        \"\"\"\n+        # Create a simple model\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+\n+        # Test makemigrations --check behavior\n+        fake_migration = mock.MagicMock()\n+        fake_migration.name = 'test_migration'\n+        \n+        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes, \\\n+             mock.patch('django.core.management.commands.makemigrations.Command.write_migration_files') as mock_write:\n+            \n+            mock_changes.return_value = {'test_app': [fake_migration]}\n+            \n+            # makemigrations --check should exit without writing files\n+            with self.assertRaises(SystemExit) as cm:\n+                call_command('makemigrations', 'test_app', check_changes=True)\n+            \n+            self.assertEqual(cm.exception.code, 1)\n+            mock_write.assert_not_called()\n+\n+        # Test migrate --check behavior for comparison\n+        with mock.patch('django.db.migrations.executor.MigrationExecutor.migration_plan') as mock_plan, \\\n+             mock.patch('django.db.migrations.executor.MigrationExecutor.migrate') as mock_migrate:\n+            \n+            # Mock unapplied migrations\n+            mock_plan.return_value = [('test_app', '0001_initial')]\n+            \n+            # migrate --check should exit without running migrations\n+            with self.assertRaises(SystemExit) as cm:\n+                call_command('migrate', check=True)\n+            \n+            self.assertEqual(cm.exception.code, 1)\n+            mock_migrate.assert_not_called()\n+\n+    @isolate_apps('test_app')\n+    def test_makemigrations_check_multiple_apps(self):\n+        \"\"\"\n+        Test that makemigrations --check works correctly with multiple apps.\n+        \"\"\"\n+        # Create models for multiple apps\n+        class TestModel1(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+\n+        class TestModel2(models.Model):\n+            title = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app2'\n+\n+        # Mock the autodetector to return changes for multiple apps\n+        fake_migration1 = mock.MagicMock()\n+        fake_migration1.name = 'test_migration1'\n+        fake_migration2 = mock.MagicMock()\n+        fake_migration2.name = 'test_migration2'\n+        \n+        with mock.patch('django.db.migrations.autodetector.MigrationAutodetector.changes') as mock_changes:\n+            mock_changes.return_value = {\n+                'test_app': [fake_migration1],\n+                'test_app2': [fake_migration2]\n+            }\n+            \n+            # Should exit with code 1 when changes are detected in any app\n+            with self.assertRaises(SystemExit) as cm:\n+                call_command('makemigrations', check_changes=True)\n+            \n+            self.assertEqual(cm.exception.code, 1)\n+\n+    def test_makemigrations_check_help_text(self):\n+        \"\"\"\n+        Test that the help text for --check flag is accurate.\n+        \"\"\"\n+        from django.core.management.commands.makemigrations import Command\n+        \n+        command = Command()\n+        parser = command.create_parser('manage.py', 'makemigrations')\n+        \n+        # Find the --check argument\n+        check_action = None\n+        for action in parser._actions:\n+            if '--check' in action.option_strings:\n+                check_action = action\n+                break\n+        \n+        self.assertIsNotNone(check_action)\n+        self.assertEqual(check_action.dest, 'check_changes')\n+        self.assertIn('Exit with a non-zero status', check_action.help)\n+        self.assertIn('missing migrations', check_action.help)\n"
}