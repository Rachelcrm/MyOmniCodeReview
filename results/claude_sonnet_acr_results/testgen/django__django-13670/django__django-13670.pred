{
  "instance_id": "django__django-13670",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/utils_tests/test_dateformat.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport datetime\nimport pytest\nfrom django.utils import dateformat\n\n\nclass TestDateFormatYearFormatting:\n    \"\"\"Test suite for the 'y' format character in Django's dateformat module.\"\"\"\n\n    def test_y_format_years_less_than_1000(self):\n        \"\"\"Test that 'y' format correctly handles years < 1000 with leading zeros.\"\"\"\n        # Test the specific case mentioned in the issue\n        dt = datetime.datetime(123, 4, 5, 6, 7)\n        result = dateformat.format(dt, \"y\")\n        assert result == \"23\", f\"Expected '23' for year 123, got '{result}'\"\n\n    def test_y_format_single_digit_years(self):\n        \"\"\"Test that 'y' format correctly handles single-digit years.\"\"\"\n        dt = datetime.datetime(9, 4, 5, 6, 7)\n        result = dateformat.format(dt, \"y\")\n        assert result == \"09\", f\"Expected '09' for year 9, got '{result}'\"\n\n    def test_y_format_two_digit_years(self):\n        \"\"\"Test that 'y' format correctly handles two-digit years.\"\"\"\n        dt = datetime.datetime(99, 4, 5, 6, 7)\n        result = dateformat.format(dt, \"y\")\n        assert result == \"99\", f\"Expected '99' for year 99, got '{result}'\"\n\n    def test_y_format_three_digit_years(self):\n        \"\"\"Test that 'y' format correctly handles three-digit years.\"\"\"\n        test_cases = [\n            (100, \"00\"),\n            (105, \"05\"),\n            (123, \"23\"),\n            (199, \"99\"),\n            (999, \"99\"),\n        ]\n        \n        for year, expected in test_cases:\n            dt = datetime.datetime(year, 4, 5, 6, 7)\n            result = dateformat.format(dt, \"y\")\n            assert result == expected, f\"Expected '{expected}' for year {year}, got '{result}'\"\n\n    def test_y_format_normal_years(self):\n        \"\"\"Test that 'y' format works correctly for normal years (>= 1000).\"\"\"\n        test_cases = [\n            (1000, \"00\"),\n            (1999, \"99\"),\n            (2000, \"00\"),\n            (2023, \"23\"),\n            (2099, \"99\"),\n        ]\n        \n        for year, expected in test_cases:\n            dt = datetime.datetime(year, 4, 5, 6, 7)\n            result = dateformat.format(dt, \"y\")\n            assert result == expected, f\"Expected '{expected}' for year {year}, got '{result}'\"\n\n    def test_y_format_consistency_with_python_strftime(self):\n        \"\"\"Test that Django's 'y' format is consistent with Python's strftime('%y').\"\"\"\n        # Test years that Python's strftime can handle (>= 1900)\n        test_years = [1900, 1999, 2000, 2023, 2099]\n        \n        for year in test_years:\n            dt = datetime.datetime(year, 4, 5, 6, 7)\n            django_result = dateformat.format(dt, \"y\")\n            python_result = dt.strftime(\"%y\")\n            assert django_result == python_result, (\n                f\"Django result '{django_result}' != Python result '{python_result}' for year {year}\"\n            )\n\n    def test_y_format_edge_cases(self):\n        \"\"\"Test edge cases for 'y' format.\"\"\"\n        # Test year 1 (minimum possible year)\n        dt = datetime.datetime(1, 1, 1)\n        result = dateformat.format(dt, \"y\")\n        assert result == \"01\", f\"Expected '01' for year 1, got '{result}'\"\n        \n        # Test year 10\n        dt = datetime.datetime(10, 1, 1)\n        result = dateformat.format(dt, \"y\")\n        assert result == \"10\", f\"Expected '10' for year 10, got '{result}'\"\n\n    def test_y_format_with_date_objects(self):\n        \"\"\"Test that 'y' format works with date objects (not just datetime).\"\"\"\n        dt = datetime.date(123, 4, 5)\n        result = dateformat.format(dt, \"y\")\n        assert result == \"23\", f\"Expected '23' for date year 123, got '{result}'\"\n\n    def test_y_format_in_complex_format_string(self):\n        \"\"\"Test 'y' format as part of a more complex format string.\"\"\"\n        dt = datetime.datetime(123, 4, 5, 6, 7)\n        result = dateformat.format(dt, \"d/m/y H:i\")\n        assert \"23\" in result, f\"Expected '23' to be in result '{result}'\"\n        assert result == \"05/04/23 06:07\", f\"Expected '05/04/23 06:07', got '{result}'\"\n\n    def test_dateformat_class_y_method_directly(self):\n        \"\"\"Test the DateFormat.y() method directly.\"\"\"\n        dt = datetime.datetime(123, 4, 5, 6, 7)\n        df = dateformat.DateFormat(dt)\n        result = df.y()\n        assert result == \"23\", f\"Expected '23' from DateFormat.y() for year 123, got '{result}'\"\n\n    def test_y_format_preserves_existing_functionality(self):\n        \"\"\"Test that the fix doesn't break existing functionality for normal years.\"\"\"\n        # Test a range of normal years to ensure backward compatibility\n        normal_years = [1970, 1980, 1990, 2000, 2010, 2020, 2030]\n        \n        for year in normal_years:\n            dt = datetime.datetime(year, 6, 15, 12, 30)\n            result = dateformat.format(dt, \"y\")\n            expected = str(year % 100).zfill(2)\n            assert result == expected, (\n                f\"Expected '{expected}' for year {year}, got '{result}'\"\n            )\n\n    def test_y_format_bug_reproduction(self):\n        \"\"\"Reproduce the exact bug described in the issue.\"\"\"\n        # This test reproduces the exact scenario from the GitHub issue\n        dt = datetime.datetime(123, 4, 5, 6, 7)\n        result = dateformat.format(dt, \"y\")\n        \n        # Before the fix, this would return '3' instead of '23'\n        assert result == \"23\", (\n            f\"Bug reproduction failed: expected '23' for year 123, got '{result}'. \"\n            f\"This should match Python's strftime behavior.\"\n        )\n        \n        # Verify it matches Python's behavior for years >= 1900\n        dt_modern = datetime.datetime(2023, 4, 5, 6, 7)\n        django_result = dateformat.format(dt_modern, \"y\")\n        python_result = dt_modern.strftime(\"%y\")\n        assert django_result == python_result, (\n            f\"Modern year handling broken: Django '{django_result}' != Python '{python_result}'\"\n        )\n</patched>\n```",
  "patch": "--- a/tests/utils_tests/test_dateformat.py\n+++ b/tests/utils_tests/test_dateformat.py\n-# Empty if creating new file\n+import datetime\n+import pytest\n+from django.utils import dateformat\n+\n+\n+class TestDateFormatYearFormatting:\n+    \"\"\"Test suite for the 'y' format character in Django's dateformat module.\"\"\"\n+\n+    def test_y_format_years_less_than_1000(self):\n+        \"\"\"Test that 'y' format correctly handles years < 1000 with leading zeros.\"\"\"\n+        # Test the specific case mentioned in the issue\n+        dt = datetime.datetime(123, 4, 5, 6, 7)\n+        result = dateformat.format(dt, \"y\")\n+        assert result == \"23\", f\"Expected '23' for year 123, got '{result}'\"\n+\n+    def test_y_format_single_digit_years(self):\n+        \"\"\"Test that 'y' format correctly handles single-digit years.\"\"\"\n+        dt = datetime.datetime(9, 4, 5, 6, 7)\n+        result = dateformat.format(dt, \"y\")\n+        assert result == \"09\", f\"Expected '09' for year 9, got '{result}'\"\n+\n+    def test_y_format_two_digit_years(self):\n+        \"\"\"Test that 'y' format correctly handles two-digit years.\"\"\"\n+        dt = datetime.datetime(99, 4, 5, 6, 7)\n+        result = dateformat.format(dt, \"y\")\n+        assert result == \"99\", f\"Expected '99' for year 99, got '{result}'\"\n+\n+    def test_y_format_three_digit_years(self):\n+        \"\"\"Test that 'y' format correctly handles three-digit years.\"\"\"\n+        test_cases = [\n+            (100, \"00\"),\n+            (105, \"05\"),\n+            (123, \"23\"),\n+            (199, \"99\"),\n+            (999, \"99\"),\n+        ]\n+        \n+        for year, expected in test_cases:\n+            dt = datetime.datetime(year, 4, 5, 6, 7)\n+            result = dateformat.format(dt, \"y\")\n+            assert result == expected, f\"Expected '{expected}' for year {year}, got '{result}'\"\n+\n+    def test_y_format_normal_years(self):\n+        \"\"\"Test that 'y' format works correctly for normal years (>= 1000).\"\"\"\n+        test_cases = [\n+            (1000, \"00\"),\n+            (1999, \"99\"),\n+            (2000, \"00\"),\n+            (2023, \"23\"),\n+            (2099, \"99\"),\n+        ]\n+        \n+        for year, expected in test_cases:\n+            dt = datetime.datetime(year, 4, 5, 6, 7)\n+            result = dateformat.format(dt, \"y\")\n+            assert result == expected, f\"Expected '{expected}' for year {year}, got '{result}'\"\n+\n+    def test_y_format_consistency_with_python_strftime(self):\n+        \"\"\"Test that Django's 'y' format is consistent with Python's strftime('%y').\"\"\"\n+        # Test years that Python's strftime can handle (>= 1900)\n+        test_years = [1900, 1999, 2000, 2023, 2099]\n+        \n+        for year in test_years:\n+            dt = datetime.datetime(year, 4, 5, 6, 7)\n+            django_result = dateformat.format(dt, \"y\")\n+            python_result = dt.strftime(\"%y\")\n+            assert django_result == python_result, (\n+                f\"Django result '{django_result}' != Python result '{python_result}' for year {year}\"\n+            )\n+\n+    def test_y_format_edge_cases(self):\n+        \"\"\"Test edge cases for 'y' format.\"\"\"\n+        # Test year 1 (minimum possible year)\n+        dt = datetime.datetime(1, 1, 1)\n+        result = dateformat.format(dt, \"y\")\n+        assert result == \"01\", f\"Expected '01' for year 1, got '{result}'\"\n+        \n+        # Test year 10\n+        dt = datetime.datetime(10, 1, 1)\n+        result = dateformat.format(dt, \"y\")\n+        assert result == \"10\", f\"Expected '10' for year 10, got '{result}'\"\n+\n+    def test_y_format_with_date_objects(self):\n+        \"\"\"Test that 'y' format works with date objects (not just datetime).\"\"\"\n+        dt = datetime.date(123, 4, 5)\n+        result = dateformat.format(dt, \"y\")\n+        assert result == \"23\", f\"Expected '23' for date year 123, got '{result}'\"\n+\n+    def test_y_format_in_complex_format_string(self):\n+        \"\"\"Test 'y' format as part of a more complex format string.\"\"\"\n+        dt = datetime.datetime(123, 4, 5, 6, 7)\n+        result = dateformat.format(dt, \"d/m/y H:i\")\n+        assert \"23\" in result, f\"Expected '23' to be in result '{result}'\"\n+        assert result == \"05/04/23 06:07\", f\"Expected '05/04/23 06:07', got '{result}'\"\n+\n+    def test_dateformat_class_y_method_directly(self):\n+        \"\"\"Test the DateFormat.y() method directly.\"\"\"\n+        dt = datetime.datetime(123, 4, 5, 6, 7)\n+        df = dateformat.DateFormat(dt)\n+        result = df.y()\n+        assert result == \"23\", f\"Expected '23' from DateFormat.y() for year 123, got '{result}'\"\n+\n+    def test_y_format_preserves_existing_functionality(self):\n+        \"\"\"Test that the fix doesn't break existing functionality for normal years.\"\"\"\n+        # Test a range of normal years to ensure backward compatibility\n+        normal_years = [1970, 1980, 1990, 2000, 2010, 2020, 2030]\n+        \n+        for year in normal_years:\n+            dt = datetime.datetime(year, 6, 15, 12, 30)\n+            result = dateformat.format(dt, \"y\")\n+            expected = str(year % 100).zfill(2)\n+            assert result == expected, (\n+                f\"Expected '{expected}' for year {year}, got '{result}'\"\n+            )\n+\n+    def test_y_format_bug_reproduction(self):\n+        \"\"\"Reproduce the exact bug described in the issue.\"\"\"\n+        # This test reproduces the exact scenario from the GitHub issue\n+        dt = datetime.datetime(123, 4, 5, 6, 7)\n+        result = dateformat.format(dt, \"y\")\n+        \n+        # Before the fix, this would return '3' instead of '23'\n+        assert result == \"23\", (\n+            f\"Bug reproduction failed: expected '23' for year 123, got '{result}'. \"\n+            f\"This should match Python's strftime behavior.\"\n+        )\n+        \n+        # Verify it matches Python's behavior for years >= 1900\n+        dt_modern = datetime.datetime(2023, 4, 5, 6, 7)\n+        django_result = dateformat.format(dt_modern, \"y\")\n+        python_result = dt_modern.strftime(\"%y\")\n+        assert django_result == python_result, (\n+            f\"Modern year handling broken: Django '{django_result}' != Python '{python_result}'\"\n+        )\n"
}