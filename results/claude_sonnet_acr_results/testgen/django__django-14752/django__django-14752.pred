{
  "instance_id": "django__django-14752",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/admin_views/test_autocomplete_view.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport json\nfrom django.contrib.admin.sites import site\nfrom django.contrib.admin.views.autocomplete import AutocompleteJsonView\nfrom django.contrib.auth.models import User\nfrom django.http import JsonResponse\nfrom django.test import RequestFactory, TestCase\nfrom django.contrib.admin import ModelAdmin\nfrom django.db import models\nfrom django.test.utils import override_settings\n\n\nclass TestModel(models.Model):\n    \"\"\"Test model for autocomplete functionality.\"\"\"\n    name = models.CharField(max_length=100)\n    notes = models.TextField(blank=True)\n    \n    def __str__(self):\n        return self.name\n    \n    class Meta:\n        app_label = 'admin_views'\n\n\nclass TestModelAdmin(ModelAdmin):\n    \"\"\"Test ModelAdmin for autocomplete functionality.\"\"\"\n    search_fields = ['name']\n\n\nclass CustomAutocompleteJsonView(AutocompleteJsonView):\n    \"\"\"Custom autocomplete view that adds extra fields to response.\"\"\"\n    \n    def serialize_result(self, obj, to_field_name):\n        \"\"\"Override to add notes field to autocomplete response.\"\"\"\n        result = super().serialize_result(obj, to_field_name)\n        result['notes'] = obj.notes\n        return result\n\n\nclass TestAutocompleteJsonViewRefactor(TestCase):\n    \"\"\"Test suite for AutocompleteJsonView refactoring to support extra fields.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data and request factory.\"\"\"\n        self.factory = RequestFactory()\n        self.user = User.objects.create_superuser(\n            username='admin', email='admin@test.com', password='password'\n        )\n        \n        # Create test objects\n        self.obj1 = TestModel.objects.create(name='Test Object 1', notes='First note')\n        self.obj2 = TestModel.objects.create(name='Test Object 2', notes='Second note')\n        \n        # Set up model admin\n        self.model_admin = TestModelAdmin(TestModel, site)\n        \n    def test_original_serialize_result_method_exists(self):\n        \"\"\"Test that the new serialize_result method exists and works correctly.\"\"\"\n        view = AutocompleteJsonView()\n        \n        # Test that the method exists\n        self.assertTrue(hasattr(view, 'serialize_result'))\n        self.assertTrue(callable(getattr(view, 'serialize_result')))\n        \n        # Test the method returns correct format\n        result = view.serialize_result(self.obj1, 'pk')\n        expected = {'id': str(self.obj1.pk), 'text': str(self.obj1)}\n        self.assertEqual(result, expected)\n        \n    def test_serialize_result_with_different_to_field(self):\n        \"\"\"Test serialize_result works with different to_field_name values.\"\"\"\n        view = AutocompleteJsonView()\n        \n        # Test with 'name' field\n        result = view.serialize_result(self.obj1, 'name')\n        expected = {'id': self.obj1.name, 'text': str(self.obj1)}\n        self.assertEqual(result, expected)\n        \n    def test_get_method_uses_serialize_result(self):\n        \"\"\"Test that the get method now uses serialize_result for object serialization.\"\"\"\n        request = self.factory.get('/admin/autocomplete/', {\n            'term': 'Test',\n            'app_label': 'admin_views',\n            'model_name': 'testmodel',\n            'field_name': 'name'\n        })\n        request.user = self.user\n        \n        view = AutocompleteJsonView()\n        view.admin_site = site\n        \n        # Mock the serialize_result method to verify it's called\n        original_serialize = view.serialize_result\n        call_count = 0\n        \n        def mock_serialize_result(obj, to_field_name):\n            nonlocal call_count\n            call_count += 1\n            return original_serialize(obj, to_field_name)\n        \n        view.serialize_result = mock_serialize_result\n        \n        # Set up view attributes that would normally be set by process_request\n        view.term = 'Test'\n        view.model_admin = self.model_admin\n        view.source_field = TestModel._meta.get_field('name')\n        \n        # Call get method\n        response = view.get(request)\n        \n        # Verify serialize_result was called\n        self.assertGreater(call_count, 0)\n        \n        # Verify response format is correct\n        self.assertIsInstance(response, JsonResponse)\n        data = json.loads(response.content)\n        self.assertIn('results', data)\n        self.assertIn('pagination', data)\n        \n    def test_backward_compatibility_maintained(self):\n        \"\"\"Test that the refactoring maintains backward compatibility.\"\"\"\n        request = self.factory.get('/admin/autocomplete/', {\n            'term': 'Test',\n            'app_label': 'admin_views',\n            'model_name': 'testmodel',\n            'field_name': 'name'\n        })\n        request.user = self.user\n        \n        view = AutocompleteJsonView()\n        view.admin_site = site\n        view.term = 'Test'\n        view.model_admin = self.model_admin\n        view.source_field = TestModel._meta.get_field('name')\n        \n        response = view.get(request)\n        data = json.loads(response.content)\n        \n        # Verify the response structure is unchanged\n        self.assertIn('results', data)\n        self.assertIn('pagination', data)\n        \n        # Verify each result has the expected format\n        for result in data['results']:\n            self.assertIn('id', result)\n            self.assertIn('text', result)\n            self.assertEqual(len(result), 2)  # Only id and text, no extra fields\n            \n    def test_custom_autocomplete_view_can_add_extra_fields(self):\n        \"\"\"Test that custom views can now easily add extra fields by overriding serialize_result.\"\"\"\n        request = self.factory.get('/admin/autocomplete/', {\n            'term': 'Test',\n            'app_label': 'admin_views',\n            'model_name': 'testmodel',\n            'field_name': 'name'\n        })\n        request.user = self.user\n        \n        view = CustomAutocompleteJsonView()\n        view.admin_site = site\n        view.term = 'Test'\n        view.model_admin = self.model_admin\n        view.source_field = TestModel._meta.get_field('name')\n        \n        response = view.get(request)\n        data = json.loads(response.content)\n        \n        # Verify the response includes extra fields\n        for result in data['results']:\n            self.assertIn('id', result)\n            self.assertIn('text', result)\n            self.assertIn('notes', result)  # Extra field added by custom view\n            \n    def test_serialize_result_override_preserves_base_functionality(self):\n        \"\"\"Test that overriding serialize_result can extend base functionality.\"\"\"\n        view = CustomAutocompleteJsonView()\n        \n        result = view.serialize_result(self.obj1, 'pk')\n        \n        # Should have base fields\n        self.assertIn('id', result)\n        self.assertIn('text', result)\n        self.assertEqual(result['id'], str(self.obj1.pk))\n        self.assertEqual(result['text'], str(self.obj1))\n        \n        # Should have extra field\n        self.assertIn('notes', result)\n        self.assertEqual(result['notes'], self.obj1.notes)\n        \n    def test_serialize_result_handles_none_values(self):\n        \"\"\"Test that serialize_result handles None values gracefully.\"\"\"\n        view = AutocompleteJsonView()\n        \n        # Create object with None/empty values\n        obj_with_none = TestModel.objects.create(name='', notes='')\n        \n        result = view.serialize_result(obj_with_none, 'pk')\n        \n        self.assertEqual(result['id'], str(obj_with_none.pk))\n        self.assertEqual(result['text'], str(obj_with_none))\n        \n    def test_multiple_custom_fields_in_serialize_result(self):\n        \"\"\"Test that serialize_result can be overridden to add multiple custom fields.\"\"\"\n        \n        class MultiFieldAutocompleteView(AutocompleteJsonView):\n            def serialize_result(self, obj, to_field_name):\n                result = super().serialize_result(obj, to_field_name)\n                result.update({\n                    'notes': obj.notes,\n                    'name_upper': obj.name.upper(),\n                    'has_notes': bool(obj.notes)\n                })\n                return result\n        \n        view = MultiFieldAutocompleteView()\n        result = view.serialize_result(self.obj1, 'pk')\n        \n        # Should have all fields\n        expected_keys = {'id', 'text', 'notes', 'name_upper', 'has_notes'}\n        self.assertEqual(set(result.keys()), expected_keys)\n        \n        # Verify custom field values\n        self.assertEqual(result['notes'], self.obj1.notes)\n        self.assertEqual(result['name_upper'], self.obj1.name.upper())\n        self.assertEqual(result['has_notes'], bool(self.obj1.notes))\n        \n    def test_serialize_result_method_signature(self):\n        \"\"\"Test that serialize_result has the correct method signature.\"\"\"\n        view = AutocompleteJsonView()\n        \n        # Test method exists and is callable\n        self.assertTrue(hasattr(view, 'serialize_result'))\n        method = getattr(view, 'serialize_result')\n        self.assertTrue(callable(method))\n        \n        # Test method accepts correct parameters\n        try:\n            result = method(self.obj1, 'pk')\n            self.assertIsInstance(result, dict)\n        except TypeError:\n            self.fail(\"serialize_result method should accept (obj, to_field_name) parameters\")\n            \n    def test_refactoring_does_not_break_existing_functionality(self):\n        \"\"\"Test that the refactoring doesn't break any existing autocomplete functionality.\"\"\"\n        request = self.factory.get('/admin/autocomplete/', {\n            'term': 'Object',\n            'app_label': 'admin_views', \n            'model_name': 'testmodel',\n            'field_name': 'name'\n        })\n        request.user = self.user\n        \n        view = AutocompleteJsonView()\n        view.admin_site = site\n        view.term = 'Object'\n        view.model_admin = self.model_admin\n        view.source_field = TestModel._meta.get_field('name')\n        \n        # This should work without any errors\n        response = view.get(request)\n        \n        # Verify response is valid JSON\n        self.assertIsInstance(response, JsonResponse)\n        data = json.loads(response.content)\n        \n        # Verify structure matches expected format\n        self.assertIn('results', data)\n        self.assertIn('pagination', data)\n        self.assertIsInstance(data['results'], list)\n        self.assertIsInstance(data['pagination'], dict)\n        \n        # Verify pagination structure\n        self.assertIn('more', data['pagination'])\n        self.assertIsInstance(data['pagination']['more'], bool)\n</patched>\n```",
  "patch": "--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n-# Empty if creating new file\n+import json\n+from django.contrib.admin.sites import site\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+from django.contrib.auth.models import User\n+from django.http import JsonResponse\n+from django.test import RequestFactory, TestCase\n+from django.contrib.admin import ModelAdmin\n+from django.db import models\n+from django.test.utils import override_settings\n+\n+\n+class TestModel(models.Model):\n+    \"\"\"Test model for autocomplete functionality.\"\"\"\n+    name = models.CharField(max_length=100)\n+    notes = models.TextField(blank=True)\n+    \n+    def __str__(self):\n+        return self.name\n+    \n+    class Meta:\n+        app_label = 'admin_views'\n+\n+\n+class TestModelAdmin(ModelAdmin):\n+    \"\"\"Test ModelAdmin for autocomplete functionality.\"\"\"\n+    search_fields = ['name']\n+\n+\n+class CustomAutocompleteJsonView(AutocompleteJsonView):\n+    \"\"\"Custom autocomplete view that adds extra fields to response.\"\"\"\n+    \n+    def serialize_result(self, obj, to_field_name):\n+        \"\"\"Override to add notes field to autocomplete response.\"\"\"\n+        result = super().serialize_result(obj, to_field_name)\n+        result['notes'] = obj.notes\n+        return result\n+\n+\n+class TestAutocompleteJsonViewRefactor(TestCase):\n+    \"\"\"Test suite for AutocompleteJsonView refactoring to support extra fields.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data and request factory.\"\"\"\n+        self.factory = RequestFactory()\n+        self.user = User.objects.create_superuser(\n+            username='admin', email='admin@test.com', password='password'\n+        )\n+        \n+        # Create test objects\n+        self.obj1 = TestModel.objects.create(name='Test Object 1', notes='First note')\n+        self.obj2 = TestModel.objects.create(name='Test Object 2', notes='Second note')\n+        \n+        # Set up model admin\n+        self.model_admin = TestModelAdmin(TestModel, site)\n+        \n+    def test_original_serialize_result_method_exists(self):\n+        \"\"\"Test that the new serialize_result method exists and works correctly.\"\"\"\n+        view = AutocompleteJsonView()\n+        \n+        # Test that the method exists\n+        self.assertTrue(hasattr(view, 'serialize_result'))\n+        self.assertTrue(callable(getattr(view, 'serialize_result')))\n+        \n+        # Test the method returns correct format\n+        result = view.serialize_result(self.obj1, 'pk')\n+        expected = {'id': str(self.obj1.pk), 'text': str(self.obj1)}\n+        self.assertEqual(result, expected)\n+        \n+    def test_serialize_result_with_different_to_field(self):\n+        \"\"\"Test serialize_result works with different to_field_name values.\"\"\"\n+        view = AutocompleteJsonView()\n+        \n+        # Test with 'name' field\n+        result = view.serialize_result(self.obj1, 'name')\n+        expected = {'id': self.obj1.name, 'text': str(self.obj1)}\n+        self.assertEqual(result, expected)\n+        \n+    def test_get_method_uses_serialize_result(self):\n+        \"\"\"Test that the get method now uses serialize_result for object serialization.\"\"\"\n+        request = self.factory.get('/admin/autocomplete/', {\n+            'term': 'Test',\n+            'app_label': 'admin_views',\n+            'model_name': 'testmodel',\n+            'field_name': 'name'\n+        })\n+        request.user = self.user\n+        \n+        view = AutocompleteJsonView()\n+        view.admin_site = site\n+        \n+        # Mock the serialize_result method to verify it's called\n+        original_serialize = view.serialize_result\n+        call_count = 0\n+        \n+        def mock_serialize_result(obj, to_field_name):\n+            nonlocal call_count\n+            call_count += 1\n+            return original_serialize(obj, to_field_name)\n+        \n+        view.serialize_result = mock_serialize_result\n+        \n+        # Set up view attributes that would normally be set by process_request\n+        view.term = 'Test'\n+        view.model_admin = self.model_admin\n+        view.source_field = TestModel._meta.get_field('name')\n+        \n+        # Call get method\n+        response = view.get(request)\n+        \n+        # Verify serialize_result was called\n+        self.assertGreater(call_count, 0)\n+        \n+        # Verify response format is correct\n+        self.assertIsInstance(response, JsonResponse)\n+        data = json.loads(response.content)\n+        self.assertIn('results', data)\n+        self.assertIn('pagination', data)\n+        \n+    def test_backward_compatibility_maintained(self):\n+        \"\"\"Test that the refactoring maintains backward compatibility.\"\"\"\n+        request = self.factory.get('/admin/autocomplete/', {\n+            'term': 'Test',\n+            'app_label': 'admin_views',\n+            'model_name': 'testmodel',\n+            'field_name': 'name'\n+        })\n+        request.user = self.user\n+        \n+        view = AutocompleteJsonView()\n+        view.admin_site = site\n+        view.term = 'Test'\n+        view.model_admin = self.model_admin\n+        view.source_field = TestModel._meta.get_field('name')\n+        \n+        response = view.get(request)\n+        data = json.loads(response.content)\n+        \n+        # Verify the response structure is unchanged\n+        self.assertIn('results', data)\n+        self.assertIn('pagination', data)\n+        \n+        # Verify each result has the expected format\n+        for result in data['results']:\n+            self.assertIn('id', result)\n+            self.assertIn('text', result)\n+            self.assertEqual(len(result), 2)  # Only id and text, no extra fields\n+            \n+    def test_custom_autocomplete_view_can_add_extra_fields(self):\n+        \"\"\"Test that custom views can now easily add extra fields by overriding serialize_result.\"\"\"\n+        request = self.factory.get('/admin/autocomplete/', {\n+            'term': 'Test',\n+            'app_label': 'admin_views',\n+            'model_name': 'testmodel',\n+            'field_name': 'name'\n+        })\n+        request.user = self.user\n+        \n+        view = CustomAutocompleteJsonView()\n+        view.admin_site = site\n+        view.term = 'Test'\n+        view.model_admin = self.model_admin\n+        view.source_field = TestModel._meta.get_field('name')\n+        \n+        response = view.get(request)\n+        data = json.loads(response.content)\n+        \n+        # Verify the response includes extra fields\n+        for result in data['results']:\n+            self.assertIn('id', result)\n+            self.assertIn('text', result)\n+            self.assertIn('notes', result)  # Extra field added by custom view\n+            \n+    def test_serialize_result_override_preserves_base_functionality(self):\n+        \"\"\"Test that overriding serialize_result can extend base functionality.\"\"\"\n+        view = CustomAutocompleteJsonView()\n+        \n+        result = view.serialize_result(self.obj1, 'pk')\n+        \n+        # Should have base fields\n+        self.assertIn('id', result)\n+        self.assertIn('text', result)\n+        self.assertEqual(result['id'], str(self.obj1.pk))\n+        self.assertEqual(result['text'], str(self.obj1))\n+        \n+        # Should have extra field\n+        self.assertIn('notes', result)\n+        self.assertEqual(result['notes'], self.obj1.notes)\n+        \n+    def test_serialize_result_handles_none_values(self):\n+        \"\"\"Test that serialize_result handles None values gracefully.\"\"\"\n+        view = AutocompleteJsonView()\n+        \n+        # Create object with None/empty values\n+        obj_with_none = TestModel.objects.create(name='', notes='')\n+        \n+        result = view.serialize_result(obj_with_none, 'pk')\n+        \n+        self.assertEqual(result['id'], str(obj_with_none.pk))\n+        self.assertEqual(result['text'], str(obj_with_none))\n+        \n+    def test_multiple_custom_fields_in_serialize_result(self):\n+        \"\"\"Test that serialize_result can be overridden to add multiple custom fields.\"\"\"\n+        \n+        class MultiFieldAutocompleteView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                result = super().serialize_result(obj, to_field_name)\n+                result.update({\n+                    'notes': obj.notes,\n+                    'name_upper': obj.name.upper(),\n+                    'has_notes': bool(obj.notes)\n+                })\n+                return result\n+        \n+        view = MultiFieldAutocompleteView()\n+        result = view.serialize_result(self.obj1, 'pk')\n+        \n+        # Should have all fields\n+        expected_keys = {'id', 'text', 'notes', 'name_upper', 'has_notes'}\n+        self.assertEqual(set(result.keys()), expected_keys)\n+        \n+        # Verify custom field values\n+        self.assertEqual(result['notes'], self.obj1.notes)\n+        self.assertEqual(result['name_upper'], self.obj1.name.upper())\n+        self.assertEqual(result['has_notes'], bool(self.obj1.notes))\n+        \n+    def test_serialize_result_method_signature(self):\n+        \"\"\"Test that serialize_result has the correct method signature.\"\"\"\n+        view = AutocompleteJsonView()\n+        \n+        # Test method exists and is callable\n+        self.assertTrue(hasattr(view, 'serialize_result'))\n+        method = getattr(view, 'serialize_result')\n+        self.assertTrue(callable(method))\n+        \n+        # Test method accepts correct parameters\n+        try:\n+            result = method(self.obj1, 'pk')\n+            self.assertIsInstance(result, dict)\n+        except TypeError:\n+            self.fail(\"serialize_result method should accept (obj, to_field_name) parameters\")\n+            \n+    def test_refactoring_does_not_break_existing_functionality(self):\n+        \"\"\"Test that the refactoring doesn't break any existing autocomplete functionality.\"\"\"\n+        request = self.factory.get('/admin/autocomplete/', {\n+            'term': 'Object',\n+            'app_label': 'admin_views', \n+            'model_name': 'testmodel',\n+            'field_name': 'name'\n+        })\n+        request.user = self.user\n+        \n+        view = AutocompleteJsonView()\n+        view.admin_site = site\n+        view.term = 'Object'\n+        view.model_admin = self.model_admin\n+        view.source_field = TestModel._meta.get_field('name')\n+        \n+        # This should work without any errors\n+        response = view.get(request)\n+        \n+        # Verify response is valid JSON\n+        self.assertIsInstance(response, JsonResponse)\n+        data = json.loads(response.content)\n+        \n+        # Verify structure matches expected format\n+        self.assertIn('results', data)\n+        self.assertIn('pagination', data)\n+        self.assertIsInstance(data['results'], list)\n+        self.assertIsInstance(data['pagination'], dict)\n+        \n+        # Verify pagination structure\n+        self.assertIn('more', data['pagination'])\n+        self.assertIsInstance(data['pagination']['more'], bool)\n"
}