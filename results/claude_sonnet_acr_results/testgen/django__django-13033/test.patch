--- a/tests/queries/test_self_referencing_ordering.py
+++ b/tests/queries/test_self_referencing_ordering.py
-# Empty if creating new file
+import pytest
+from django.db import models
+from django.test import TestCase
+from django.db.models import F
+
+
+class OneModel(models.Model):
+    """Model with self-referencing foreign key and default ordering."""
+    class Meta:
+        ordering = ("-id",)
+        app_label = 'queries'
+    
+    id = models.BigAutoField(primary_key=True)
+    root = models.ForeignKey("OneModel", on_delete=models.CASCADE, null=True)
+    oneval = models.BigIntegerField(null=True)
+
+
+class TwoModel(models.Model):
+    """Model that references OneModel."""
+    class Meta:
+        app_label = 'queries'
+    
+    id = models.BigAutoField(primary_key=True)
+    record = models.ForeignKey(OneModel, on_delete=models.CASCADE)
+    twoval = models.BigIntegerField(null=True)
+
+
+class ThreeModel(models.Model):
+    """Model without default ordering for comparison."""
+    class Meta:
+        app_label = 'queries'
+    
+    id = models.BigAutoField(primary_key=True)
+    name = models.CharField(max_length=100)
+
+
+class FourModel(models.Model):
+    """Model that references ThreeModel (non-self-referencing)."""
+    class Meta:
+        app_label = 'queries'
+    
+    id = models.BigAutoField(primary_key=True)
+    other = models.ForeignKey(ThreeModel, on_delete=models.CASCADE)
+    record = models.ForeignKey(OneModel, on_delete=models.CASCADE)
+
+
+class SelfReferencingOrderingTest(TestCase):
+    """Test ordering behavior with self-referencing foreign keys."""
+    
+    @classmethod
+    def setUpTestData(cls):
+        # Create test data
+        cls.root1 = OneModel.objects.create(id=1, root=None, oneval=1)
+        cls.root2 = OneModel.objects.create(id=2, root=None, oneval=2)
+        cls.child1 = OneModel.objects.create(id=3, root=cls.root1, oneval=1)
+        cls.child2 = OneModel.objects.create(id=4, root=cls.root2, oneval=2)
+        cls.child3 = OneModel.objects.create(id=5, root=cls.root1, oneval=3)
+        
+        cls.two1 = TwoModel.objects.create(record=cls.child1, twoval=10)
+        cls.two2 = TwoModel.objects.create(record=cls.child2, twoval=20)
+        cls.two3 = TwoModel.objects.create(record=cls.child3, twoval=30)
+        
+        cls.three1 = ThreeModel.objects.create(name="test1")
+        cls.three2 = ThreeModel.objects.create(name="test2")
+        
+        cls.four1 = FourModel.objects.create(other=cls.three1, record=cls.child1)
+        cls.four2 = FourModel.objects.create(other=cls.three2, record=cls.child2)
+
+    def test_self_referencing_order_by_id_field_bug(self):
+        """
+        Test that demonstrates the bug: ordering by record__root_id 
+        should use ASC ordering and single INNER JOIN, not DESC with LEFT OUTER JOIN.
+        This test should FAIL before the fix is applied.
+        """
+        qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3])
+        qs = qs.order_by("record__root_id")
+        
+        # Check the generated SQL
+        sql = str(qs.query)
+        
+        # The bug: should NOT have LEFT OUTER JOIN
+        self.assertNotIn("LEFT OUTER JOIN", sql)
+        
+        # The bug: should have ASC ordering, not DESC
+        # This checks that the ordering is not affected by OneModel's default ordering
+        self.assertIn("ASC", sql)
+        self.assertNotIn("DESC", sql)
+        
+        # Should only have one JOIN (INNER JOIN)
+        join_count = sql.count("JOIN")
+        self.assertEqual(join_count, 1, f"Expected 1 JOIN, got {join_count} in SQL: {sql}")
+        
+        # Verify the actual ordering of results
+        results = list(qs.values_list('id', 'record__root_id'))
+        # Should be ordered by root_id ASC: None values first, then 1, then 2
+        root_ids = [r[1] for r in results]
+        
+        # Filter out None values and check ordering
+        non_none_root_ids = [rid for rid in root_ids if rid is not None]
+        self.assertEqual(non_none_root_ids, sorted(non_none_root_ids))
+
+    def test_self_referencing_order_by_double_underscore_id_works(self):
+        """
+        Test that ordering by record__root__id works correctly.
+        This should pass both before and after the fix.
+        """
+        qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3])
+        qs = qs.order_by("record__root__id")
+        
+        sql = str(qs.query)
+        
+        # Should have ASC ordering
+        self.assertIn("ASC", sql)
+        self.assertNotIn("DESC", sql)
+        
+        # Should only have one JOIN
+        join_count = sql.count("JOIN")
+        self.assertEqual(join_count, 1)
+
+    def test_self_referencing_order_by_negative_id_field(self):
+        """
+        Test that ordering by -record__root_id should use DESC ordering
+        but still avoid unnecessary joins.
+        """
+        qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3])
+        qs = qs.order_by("-record__root_id")
+        
+        sql = str(qs.query)
+        
+        # Should have DESC ordering when explicitly requested
+        self.assertIn("DESC", sql) or self.assertIn("ASC", sql)  # May be ASC due to bug
+        
+        # The key issue: should not have unnecessary LEFT OUTER JOIN
+        # This test documents the current buggy behavior
+        if "LEFT OUTER JOIN" in sql:
+            # This is the current buggy behavior - should be fixed
+            join_count = sql.count("JOIN")
+            self.assertEqual(join_count, 2)  # Currently has 2 JOINs due to bug
+        else:
+            # This is the desired behavior after fix
+            join_count = sql.count("JOIN")
+            self.assertEqual(join_count, 1)
+
+    def test_non_self_referencing_order_by_works_correctly(self):
+        """
+        Test that ordering by non-self-referencing foreign key works correctly.
+        This should work fine both before and after the fix.
+        """
+        qs = FourModel.objects.filter(record__oneval__in=[1, 2])
+        qs = qs.order_by("other_id")
+        
+        sql = str(qs.query)
+        
+        # Should work correctly without issues
+        self.assertIn("ASC", sql)
+        
+        # Should have appropriate number of JOINs
+        join_count = sql.count("JOIN")
+        self.assertGreaterEqual(join_count, 1)
+
+    def test_self_referencing_order_by_relation_field_applies_default_ordering(self):
+        """
+        Test that ordering by record__root (without _id) correctly applies
+        the related model's default ordering. This behavior should be preserved.
+        """
+        qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3])
+        qs = qs.order_by("record__root")
+        
+        sql = str(qs.query)
+        
+        # Should apply OneModel's default ordering (DESC)
+        self.assertIn("DESC", sql)
+        
+        # May have LEFT OUTER JOIN due to nullable foreign key
+        # This is expected behavior for ordering by the relation itself
+
+    def test_annotation_workaround_works(self):
+        """
+        Test that the annotation workaround mentioned in the issue works correctly.
+        """
+        qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3])
+        qs = qs.annotate(root_id=F("record__root_id"))
+        qs = qs.order_by("root_id")
+        
+        sql = str(qs.query)
+        
+        # Should have ASC ordering
+        self.assertIn("ASC", sql)
+        
+        # Should only have one INNER JOIN
+        self.assertIn("INNER JOIN", sql)
+        self.assertNotIn("LEFT OUTER JOIN", sql)
+        
+        join_count = sql.count("JOIN")
+        self.assertEqual(join_count, 1)
+
+    def test_ordering_consistency_across_methods(self):
+        """
+        Test that different ways of ordering produce consistent results.
+        """
+        base_qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3])
+        
+        # Method 1: order_by("record__root__id") - should work
+        qs1 = base_qs.order_by("record__root__id")
+        results1 = list(qs1.values_list('id', flat=True))
+        
+        # Method 2: annotation workaround - should work
+        qs2 = base_qs.annotate(root_id=F("record__root_id")).order_by("root_id")
+        results2 = list(qs2.values_list('id', flat=True))
+        
+        # Method 3: order_by("record__root_id") - currently buggy
+        qs3 = base_qs.order_by("record__root_id")
+        results3 = list(qs3.values_list('id', flat=True))
+        
+        # Results1 and Results2 should be the same (both work correctly)
+        self.assertEqual(results1, results2)
+        
+        # Results3 might be different due to the bug (DESC vs ASC ordering)
+        # After the fix, all three should be the same
+
+    def test_multiple_self_referencing_order_fields(self):
+        """
+        Test ordering by multiple fields including self-referencing _id fields.
+        """
+        qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3])
+        qs = qs.order_by("record__root_id", "record_id")
+        
+        sql = str(qs.query)
+        
+        # Should not have unnecessary LEFT OUTER JOINs
+        # After fix, should only have necessary INNER JOINs
+        join_count = sql.count("LEFT OUTER JOIN")
+        # Currently might have 1 due to bug, should be 0 after fix
+        
+        # Should be able to execute without errors
+        list(qs)
+
+    def test_order_by_pk_shortcut_works(self):
+        """
+        Test that ordering by pk shortcut works correctly and doesn't trigger the bug.
+        """
+        qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3])
+        qs = qs.order_by("record__root__pk")
+        
+        sql = str(qs.query)
+        
+        # Should work correctly
+        list(qs)
+
+    def test_deep_self_referencing_chain(self):
+        """
+        Test ordering with deeper self-referencing chains.
+        """
+        # Create a deeper chain
+        deep_child = OneModel.objects.create(root=self.child1, oneval=1)
+        TwoModel.objects.create(record=deep_child, twoval=40)
+        
+        qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3])
+        qs = qs.order_by("record__root__root_id")
+        
+        # Should work without errors
+        list(qs)
