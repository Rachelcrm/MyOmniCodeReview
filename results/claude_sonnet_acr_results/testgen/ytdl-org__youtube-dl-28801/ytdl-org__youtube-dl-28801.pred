{
  "instance_id": "ytdl-org__youtube-dl-28801",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>test/test_http_auth.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\n#!/usr/bin/env python\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport pytest\nimport sys\nimport os\nimport threading\nimport time\ntry:\n    from http.server import HTTPServer, BaseHTTPRequestHandler\n    from urllib.parse import urlparse\nexcept ImportError:\n    from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler\n    from urlparse import urlparse\nimport base64\n\n# Add the parent directory to the path so we can import youtube_dl\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom youtube_dl import YoutubeDL\nfrom youtube_dl.utils import ExtractorError\n\n\nclass AuthHTTPRequestHandler(BaseHTTPRequestHandler):\n    \"\"\"HTTP request handler that requires basic authentication\"\"\"\n    \n    def do_GET(self):\n        auth_header = self.headers.get('Authorization')\n        \n        if not auth_header:\n            self.send_response(401)\n            self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')\n            self.end_headers()\n            self.wfile.write(b'Authentication required')\n            return\n            \n        try:\n            auth_type, credentials = auth_header.split(' ', 1)\n            if auth_type.lower() != 'basic':\n                self.send_response(401)\n                self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')\n                self.end_headers()\n                return\n                \n            decoded_creds = base64.b64decode(credentials).decode('utf-8')\n            username, password = decoded_creds.split(':', 1)\n            \n            # Check credentials\n            if username == 'testuser' and password == 'testpass':\n                self.send_response(200)\n                self.send_header('Content-Type', 'text/plain')\n                self.end_headers()\n                self.wfile.write(b'Authentication successful')\n            else:\n                self.send_response(401)\n                self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')\n                self.end_headers()\n                self.wfile.write(b'Invalid credentials')\n        except Exception:\n            self.send_response(401)\n            self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')\n            self.end_headers()\n            self.wfile.write(b'Invalid authorization header')\n    \n    def do_HEAD(self):\n        self.do_GET()\n    \n    def log_message(self, format, *args):\n        # Suppress log messages\n        pass\n\n\nclass TestHTTPAuthentication:\n    \"\"\"Test suite for HTTP Basic Authentication functionality\"\"\"\n    \n    @pytest.fixture(scope=\"class\")\n    def auth_server(self):\n        \"\"\"Start a test HTTP server that requires authentication\"\"\"\n        server = HTTPServer(('localhost', 0), AuthHTTPRequestHandler)\n        port = server.server_address[1]\n        \n        def run_server():\n            server.serve_forever()\n        \n        server_thread = threading.Thread(target=run_server)\n        server_thread.daemon = True\n        server_thread.start()\n        \n        # Give the server time to start\n        time.sleep(0.1)\n        \n        yield f'http://localhost:{port}'\n        \n        server.shutdown()\n        server.server_close()\n    \n    def test_http_auth_without_credentials_fails(self, auth_server):\n        \"\"\"Test that accessing protected URL without credentials fails with 401\"\"\"\n        ydl = YoutubeDL({'quiet': True})\n        \n        with pytest.raises(ExtractorError) as exc_info:\n            ydl.extract_info(f'{auth_server}/test', download=False)\n        \n        # Should fail with 401 Authorization Required\n        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n    \n    def test_http_auth_with_wrong_credentials_fails(self, auth_server):\n        \"\"\"Test that accessing protected URL with wrong credentials fails with 401\"\"\"\n        ydl = YoutubeDL({\n            'quiet': True,\n            'username': 'wronguser',\n            'password': 'wrongpass'\n        })\n        \n        with pytest.raises(ExtractorError) as exc_info:\n            ydl.extract_info(f'{auth_server}/test', download=False)\n        \n        # Should fail with 401 or authentication error\n        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n    \n    def test_http_auth_with_correct_credentials_succeeds(self, auth_server):\n        \"\"\"Test that accessing protected URL with correct credentials succeeds\"\"\"\n        ydl = YoutubeDL({\n            'quiet': True,\n            'username': 'testuser',\n            'password': 'testpass'\n        })\n        \n        # This should not raise an exception\n        try:\n            ydl.extract_info(f'{auth_server}/test', download=False)\n        except ExtractorError as e:\n            # If it fails, it should not be due to authentication\n            assert '401' not in str(e) and 'Authorization Required' not in str(e)\n    \n    def test_http_auth_with_username_only_fails(self, auth_server):\n        \"\"\"Test that providing only username without password fails\"\"\"\n        ydl = YoutubeDL({\n            'quiet': True,\n            'username': 'testuser'\n        })\n        \n        with pytest.raises(ExtractorError) as exc_info:\n            ydl.extract_info(f'{auth_server}/test', download=False)\n        \n        # Should fail with 401 Authorization Required\n        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n    \n    def test_http_auth_with_password_only_fails(self, auth_server):\n        \"\"\"Test that providing only password without username fails\"\"\"\n        ydl = YoutubeDL({\n            'quiet': True,\n            'password': 'testpass'\n        })\n        \n        with pytest.raises(ExtractorError) as exc_info:\n            ydl.extract_info(f'{auth_server}/test', download=False)\n        \n        # Should fail with 401 Authorization Required\n        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n    \n    def test_http_auth_with_empty_credentials_fails(self, auth_server):\n        \"\"\"Test that providing empty username/password fails\"\"\"\n        ydl = YoutubeDL({\n            'quiet': True,\n            'username': '',\n            'password': ''\n        })\n        \n        with pytest.raises(ExtractorError) as exc_info:\n            ydl.extract_info(f'{auth_server}/test', download=False)\n        \n        # Should fail with 401 Authorization Required\n        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n    \n    def test_http_auth_opener_setup(self):\n        \"\"\"Test that the opener is properly configured with authentication handler\"\"\"\n        ydl = YoutubeDL({\n            'username': 'testuser',\n            'password': 'testpass'\n        })\n        \n        # Check that the opener has been set up\n        assert hasattr(ydl, '_opener')\n        assert ydl._opener is not None\n        \n        # Check that authentication parameters are stored\n        assert ydl.params.get('username') == 'testuser'\n        assert ydl.params.get('password') == 'testpass'\n    \n    def test_http_auth_opener_without_credentials(self):\n        \"\"\"Test that the opener works normally without authentication credentials\"\"\"\n        ydl = YoutubeDL({'quiet': True})\n        \n        # Check that the opener has been set up normally\n        assert hasattr(ydl, '_opener')\n        assert ydl._opener is not None\n        \n        # Check that no authentication parameters are set\n        assert ydl.params.get('username') is None\n        assert ydl.params.get('password') is None\n\n\nif __name__ == '__main__':\n    pytest.main([__file__])\n</patched>\n</file>\n```\n\n```\n<file>test/test_youtubedl.py</file>\n<original>\n#!/usr/bin/env python\n# coding: utf-8\nfrom __future__ import unicode_literals\n\n# Allow direct execution\nimport os\nimport sys\nimport unittest\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom test.helper import FakeYDL, expect_dict, expect_value, http_server_port\nfrom youtube_dl import YoutubeDL\nfrom youtube_dl.compat import compat_str, compat_urllib_error\nfrom youtube_dl.utils import ExtractorError\nfrom youtube_dl.extractor import YoutubeIE, get_info_extractor\n\n\nclass TestYoutubeDL(unittest.TestCase):\n    def test_subtitles(self):\n        def s_formats(lang, autocaption=False):\n            return [{\n                'ext': ext,\n                'url': 'http://localhost/video.%s.%s' % (lang, ext),\n                '_auto': autocaption,\n            } for ext in ['vtt', 'srt', 'ass']]\n        subtitles = dict((l, s_formats(l)) for l in ['en', 'fr', 'es'])\n        auto_captions = dict((l, s_formats(l, True)) for l in ['it', 'pt', 'es'])\n        info_dict = {\n            'id': 'test',\n            'title': 'Test',\n            'url': 'http://localhost/video.mp4',\n            'subtitles': subtitles,\n            'automatic_captions': auto_captions,\n            'duration': 30,\n            'view_count': 1000,\n            'like_count': 100,\n            'dislike_count': 50,\n            'average_rating': 4.5,\n        }\n\n        def get_info(params={}):\n            params.setdefault('simulate', True)\n            ydl = YoutubeDL(params)\n            ydl._sort_formats = lambda *args: None\n            return ydl.process_info(info_dict.copy())\n\n        result = get_info()\n        self.assertFalse(result.get('requested_subtitles'))\n        self.assertEqual(result['subtitles'], subtitles)\n        self.assertEqual(result['automatic_captions'], auto_captions)\n\n        result = get_info({'writesubtitles': True})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), {'en'})\n        self.assertTrue(subs['en'].get('data') is None)\n        self.assertEqual(subs['en']['ext'], 'ass')\n\n        result = get_info({'writesubtitles': True, 'subtitlesformat': 'foo/srt'})\n        subs = result['requested_subtitles']\n        self.assertEqual(subs['en']['ext'], 'srt')\n\n        result = get_info({'writesubtitles': True, 'subtitleslangs': ['es', 'fr', 'it']})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), {'es', 'fr'})\n\n        result = get_info({'writesubtitles': True, 'writeautomaticsub': True, 'subtitleslangs': ['es', 'pt']})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), {'es', 'pt'})\n        self.assertFalse(subs['es']['_auto'])\n        self.assertTrue(subs['pt']['_auto'])\n\n        result = get_info({'writeautomaticsub': True, 'subtitleslangs': ['es', 'pt']})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), {'es', 'pt'})\n        self.assertTrue(subs['es']['_auto'])\n        self.assertTrue(subs['pt']['_auto'])\n\n    def test_add_extra_info(self):\n        test_dict = {\n            'extractor': 'Foo',\n        }\n        extra_info = {\n            'extractor': 'Bar',\n            'playlist': 'funny videos',\n        }\n        YoutubeDL.add_extra_info(test_dict, extra_info)\n        self.assertEqual(test_dict['extractor'], 'Foo')\n        self.assertEqual(test_dict['playlist'], 'funny videos')\n\n    def test_prepare_filename(self):\n        info = {\n            'id': 'foo',\n            'title': 'A title',\n            'ext': 'mp4',\n        }\n        def fname(templ):\n            ydl = YoutubeDL({'outtmpl': templ})\n            return ydl.prepare_filename(info)\n        self.assertEqual(fname('%(id)s.%(ext)s'), 'foo.mp4')\n        self.assertEqual(fname('%(id)s-%(title)s.%(ext)s'), 'foo-A title.mp4')\n\n    def test_format_note(self):\n        ydl = YoutubeDL()\n        self.assertEqual(ydl._format_note({}), '')\n        assertRegexpMatches = getattr(self, 'assertRegex', self.assertRegexpMatches)\n        assertRegexpMatches(ydl._format_note({\n            'vbr': 10,\n        }), r'^\\s*10k$')\n        assertRegexpMatches(ydl._format_note({\n            'fps': 30,\n        }), r'^30fps$')\n\n    def test_postprocessors(self):\n        filename = 'post-processor-testfile.mp4'\n        audiofile = filename + '.mp3'\n\n        class SimplePP(object):\n            def __init__(self, return_value):\n                self._return_value = return_value\n\n            def run(self, info):\n                with open(audiofile, 'w') as f:\n                    f.write('EXAMPLE')\n                info['filepath'] = audiofile\n                return self._return_value, info\n\n        def run_pp(params, PP):\n            with open(filename, 'w') as f:\n                f.write('EXAMPLE')\n            ydl = YoutubeDL(params)\n            ydl.add_post_processor(PP)\n            ydl.post_process(filename, {'filepath': filename})\n\n        run_pp({'keepvideo': True}, SimplePP([]))\n        self.assertTrue(os.path.exists(filename), '%s doesn\\'t exist' % filename)\n        self.assertTrue(os.path.exists(audiofile), '%s doesn\\'t exist' % audiofile)\n        os.unlink(filename)\n        os.unlink(audiofile)\n\n        run_pp({'keepvideo': False}, SimplePP([]))\n        self.assertFalse(os.path.exists(filename), '%s exists' % filename)\n        self.assertTrue(os.path.exists(audiofile), '%s doesn\\'t exist' % audiofile)\n        os.unlink(audiofile)\n\n        run_pp({}, SimplePP([audiofile]))\n        self.assertFalse(os.path.exists(filename), '%s exists' % filename)\n        self.assertTrue(os.path.exists(audiofile), '%s doesn\\'t exist' % audiofile)\n        os.unlink(audiofile)\n\n    def test_match_filter(self):\n        class FilterYDL(YoutubeDL):\n            def __init__(self, *args, **kwargs):\n                super(FilterYDL, self).__init__(*args, **kwargs)\n                self.params['simulate'] = True\n\n            def process_info(self, info_dict):",
  "patch": "--- a/test/test_http_auth.py\n+++ b/test/test_http_auth.py\n-# Empty if creating new file\n+#!/usr/bin/env python\n+# coding: utf-8\n+from __future__ import unicode_literals\n+\n+import pytest\n+import sys\n+import os\n+import threading\n+import time\n+try:\n+    from http.server import HTTPServer, BaseHTTPRequestHandler\n+    from urllib.parse import urlparse\n+except ImportError:\n+    from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler\n+    from urlparse import urlparse\n+import base64\n+\n+# Add the parent directory to the path so we can import youtube_dl\n+sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n+\n+from youtube_dl import YoutubeDL\n+from youtube_dl.utils import ExtractorError\n+\n+\n+class AuthHTTPRequestHandler(BaseHTTPRequestHandler):\n+    \"\"\"HTTP request handler that requires basic authentication\"\"\"\n+    \n+    def do_GET(self):\n+        auth_header = self.headers.get('Authorization')\n+        \n+        if not auth_header:\n+            self.send_response(401)\n+            self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')\n+            self.end_headers()\n+            self.wfile.write(b'Authentication required')\n+            return\n+            \n+        try:\n+            auth_type, credentials = auth_header.split(' ', 1)\n+            if auth_type.lower() != 'basic':\n+                self.send_response(401)\n+                self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')\n+                self.end_headers()\n+                return\n+                \n+            decoded_creds = base64.b64decode(credentials).decode('utf-8')\n+            username, password = decoded_creds.split(':', 1)\n+            \n+            # Check credentials\n+            if username == 'testuser' and password == 'testpass':\n+                self.send_response(200)\n+                self.send_header('Content-Type', 'text/plain')\n+                self.end_headers()\n+                self.wfile.write(b'Authentication successful')\n+            else:\n+                self.send_response(401)\n+                self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')\n+                self.end_headers()\n+                self.wfile.write(b'Invalid credentials')\n+        except Exception:\n+            self.send_response(401)\n+            self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')\n+            self.end_headers()\n+            self.wfile.write(b'Invalid authorization header')\n+    \n+    def do_HEAD(self):\n+        self.do_GET()\n+    \n+    def log_message(self, format, *args):\n+        # Suppress log messages\n+        pass\n+\n+\n+class TestHTTPAuthentication:\n+    \"\"\"Test suite for HTTP Basic Authentication functionality\"\"\"\n+    \n+    @pytest.fixture(scope=\"class\")\n+    def auth_server(self):\n+        \"\"\"Start a test HTTP server that requires authentication\"\"\"\n+        server = HTTPServer(('localhost', 0), AuthHTTPRequestHandler)\n+        port = server.server_address[1]\n+        \n+        def run_server():\n+            server.serve_forever()\n+        \n+        server_thread = threading.Thread(target=run_server)\n+        server_thread.daemon = True\n+        server_thread.start()\n+        \n+        # Give the server time to start\n+        time.sleep(0.1)\n+        \n+        yield f'http://localhost:{port}'\n+        \n+        server.shutdown()\n+        server.server_close()\n+    \n+    def test_http_auth_without_credentials_fails(self, auth_server):\n+        \"\"\"Test that accessing protected URL without credentials fails with 401\"\"\"\n+        ydl = YoutubeDL({'quiet': True})\n+        \n+        with pytest.raises(ExtractorError) as exc_info:\n+            ydl.extract_info(f'{auth_server}/test', download=False)\n+        \n+        # Should fail with 401 Authorization Required\n+        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n+    \n+    def test_http_auth_with_wrong_credentials_fails(self, auth_server):\n+        \"\"\"Test that accessing protected URL with wrong credentials fails with 401\"\"\"\n+        ydl = YoutubeDL({\n+            'quiet': True,\n+            'username': 'wronguser',\n+            'password': 'wrongpass'\n+        })\n+        \n+        with pytest.raises(ExtractorError) as exc_info:\n+            ydl.extract_info(f'{auth_server}/test', download=False)\n+        \n+        # Should fail with 401 or authentication error\n+        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n+    \n+    def test_http_auth_with_correct_credentials_succeeds(self, auth_server):\n+        \"\"\"Test that accessing protected URL with correct credentials succeeds\"\"\"\n+        ydl = YoutubeDL({\n+            'quiet': True,\n+            'username': 'testuser',\n+            'password': 'testpass'\n+        })\n+        \n+        # This should not raise an exception\n+        try:\n+            ydl.extract_info(f'{auth_server}/test', download=False)\n+        except ExtractorError as e:\n+            # If it fails, it should not be due to authentication\n+            assert '401' not in str(e) and 'Authorization Required' not in str(e)\n+    \n+    def test_http_auth_with_username_only_fails(self, auth_server):\n+        \"\"\"Test that providing only username without password fails\"\"\"\n+        ydl = YoutubeDL({\n+            'quiet': True,\n+            'username': 'testuser'\n+        })\n+        \n+        with pytest.raises(ExtractorError) as exc_info:\n+            ydl.extract_info(f'{auth_server}/test', download=False)\n+        \n+        # Should fail with 401 Authorization Required\n+        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n+    \n+    def test_http_auth_with_password_only_fails(self, auth_server):\n+        \"\"\"Test that providing only password without username fails\"\"\"\n+        ydl = YoutubeDL({\n+            'quiet': True,\n+            'password': 'testpass'\n+        })\n+        \n+        with pytest.raises(ExtractorError) as exc_info:\n+            ydl.extract_info(f'{auth_server}/test', download=False)\n+        \n+        # Should fail with 401 Authorization Required\n+        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n+    \n+    def test_http_auth_with_empty_credentials_fails(self, auth_server):\n+        \"\"\"Test that providing empty username/password fails\"\"\"\n+        ydl = YoutubeDL({\n+            'quiet': True,\n+            'username': '',\n+            'password': ''\n+        })\n+        \n+        with pytest.raises(ExtractorError) as exc_info:\n+            ydl.extract_info(f'{auth_server}/test', download=False)\n+        \n+        # Should fail with 401 Authorization Required\n+        assert '401' in str(exc_info.value) or 'Authorization Required' in str(exc_info.value)\n+    \n+    def test_http_auth_opener_setup(self):\n+        \"\"\"Test that the opener is properly configured with authentication handler\"\"\"\n+        ydl = YoutubeDL({\n+            'username': 'testuser',\n+            'password': 'testpass'\n+        })\n+        \n+        # Check that the opener has been set up\n+        assert hasattr(ydl, '_opener')\n+        assert ydl._opener is not None\n+        \n+        # Check that authentication parameters are stored\n+        assert ydl.params.get('username') == 'testuser'\n+        assert ydl.params.get('password') == 'testpass'\n+    \n+    def test_http_auth_opener_without_credentials(self):\n+        \"\"\"Test that the opener works normally without authentication credentials\"\"\"\n+        ydl = YoutubeDL({'quiet': True})\n+        \n+        # Check that the opener has been set up normally\n+        assert hasattr(ydl, '_opener')\n+        assert ydl._opener is not None\n+        \n+        # Check that no authentication parameters are set\n+        assert ydl.params.get('username') is None\n+        assert ydl.params.get('password') is None\n+\n+\n+if __name__ == '__main__':\n+    pytest.main([__file__])\n"
}