{
  "instance_id": "django__django-15525",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/serializers/test_natural_keys_multidb.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.core import serializers\nfrom django.core.management import call_command\nfrom django.db import connections\nfrom django.test import TestCase, TransactionTestCase\nfrom django.test.utils import override_settings\nfrom django.apps import apps\nfrom django.db import models\nimport tempfile\nimport json\nimport os\n\n\n# Test models for natural keys with foreign keys\nclass AuthorManager(models.Manager):\n    def get_by_natural_key(self, name):\n        return self.get(name=name)\n\n\nclass Author(models.Model):\n    name = models.CharField(max_length=255, unique=True)\n    objects = AuthorManager()\n\n    def natural_key(self):\n        return (self.name,)\n\n    def __str__(self):\n        return f\"{self.id} {self.name}\"\n\n    class Meta:\n        app_label = 'serializers'\n\n\nclass BookManager(models.Manager):\n    def get_by_natural_key(self, title, author_name):\n        return self.get(title=title, author__name=author_name)\n\n\nclass Book(models.Model):\n    title = models.CharField(max_length=255)\n    author = models.ForeignKey(Author, models.CASCADE, related_name=\"books\")\n    objects = BookManager()\n\n    def natural_key(self):\n        return (self.title,) + self.author.natural_key()\n\n    natural_key.dependencies = [\"serializers.Author\"]\n\n    class Meta:\n        unique_together = [[\"title\", \"author\"]]\n        app_label = 'serializers'\n\n    def __str__(self):\n        return f\"{self.id}: '{self.title}' by {self.author}\"\n\n\n@override_settings(\n    DATABASES={\n        'default': {\n            'ENGINE': 'django.db.backends.sqlite3',\n            'NAME': ':memory:',\n        },\n        'other': {\n            'ENGINE': 'django.db.backends.sqlite3',\n            'NAME': ':memory:',\n        }\n    }\n)\nclass NaturalKeysMultiDbTestCase(TransactionTestCase):\n    \"\"\"Test natural keys with foreign keys across multiple databases.\"\"\"\n    \n    available_apps = ['serializers']\n    \n    def setUp(self):\n        # Create tables in both databases\n        for db_alias in ['default', 'other']:\n            with connections[db_alias].schema_editor() as schema_editor:\n                schema_editor.create_model(Author)\n                schema_editor.create_model(Book)\n    \n    def tearDown(self):\n        # Clean up tables\n        for db_alias in ['default', 'other']:\n            with connections[db_alias].schema_editor() as schema_editor:\n                schema_editor.delete_model(Book)\n                schema_editor.delete_model(Author)\n\n    def test_loaddata_natural_keys_default_database_works(self):\n        \"\"\"Test that loaddata with natural keys works on default database.\"\"\"\n        # Create test data in default database\n        author = Author.objects.using('default').create(name=\"JR Tolkien\")\n        book = Book.objects.using('default').create(title=\"The Ring\", author=author)\n        \n        # Serialize the data\n        data = serializers.serialize(\n            \"json\", \n            [author, book], \n            use_natural_foreign_keys=True, \n            use_natural_primary_keys=True\n        )\n        \n        # Clear the database\n        Book.objects.using('default').all().delete()\n        Author.objects.using('default').all().delete()\n        \n        # Create temporary file with the data\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            f.write(data)\n            temp_file = f.name\n        \n        try:\n            # Load data back into default database - should work\n            call_command('loaddata', temp_file, database='default', verbosity=0)\n            \n            # Verify data was loaded\n            self.assertEqual(Author.objects.using('default').count(), 1)\n            self.assertEqual(Book.objects.using('default').count(), 1)\n            \n            loaded_author = Author.objects.using('default').get(name=\"JR Tolkien\")\n            loaded_book = Book.objects.using('default').get(title=\"The Ring\")\n            self.assertEqual(loaded_book.author, loaded_author)\n        finally:\n            os.unlink(temp_file)\n\n    def test_loaddata_natural_keys_non_default_database_fails_before_fix(self):\n        \"\"\"Test that demonstrates the bug: loaddata fails on non-default database with natural keys.\"\"\"\n        # Create test data in default database first\n        author = Author.objects.using('default').create(name=\"JR Tolkien\")\n        book = Book.objects.using('default').create(title=\"The Ring\", author=author)\n        \n        # Serialize the data\n        data = serializers.serialize(\n            \"json\", \n            [author, book], \n            use_natural_foreign_keys=True, \n            use_natural_primary_keys=True\n        )\n        \n        # Create temporary file with the data\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            f.write(data)\n            temp_file = f.name\n        \n        try:\n            # This should fail before the fix is applied\n            # The error occurs because when building the Book instance for natural key lookup,\n            # it tries to access self.author.natural_key() but the author lookup uses the default\n            # database instead of the 'other' database\n            with self.assertRaises(Author.DoesNotExist):\n                call_command('loaddata', temp_file, database='other', verbosity=0)\n            \n            # Verify no data was loaded in the other database\n            self.assertEqual(Author.objects.using('other').count(), 0)\n            self.assertEqual(Book.objects.using('other').count(), 0)\n        finally:\n            os.unlink(temp_file)\n\n    def test_loaddata_natural_keys_non_default_database_works_after_fix(self):\n        \"\"\"Test that loaddata works on non-default database after the fix.\"\"\"\n        # Create test data in default database\n        author = Author.objects.using('default').create(name=\"JR Tolkien\")\n        book = Book.objects.using('default').create(title=\"The Ring\", author=author)\n        \n        # Serialize the data\n        data = serializers.serialize(\n            \"json\", \n            [author, book], \n            use_natural_foreign_keys=True, \n            use_natural_primary_keys=True\n        )\n        \n        # Create temporary file with the data\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            f.write(data)\n            temp_file = f.name\n        \n        try:\n            # After the fix, this should work\n            call_command('loaddata', temp_file, database='other', verbosity=0)\n            \n            # Verify data was loaded in the other database\n            self.assertEqual(Author.objects.using('other').count(), 1)\n            self.assertEqual(Book.objects.using('other').count(), 1)\n            \n            loaded_author = Author.objects.using('other').get(name=\"JR Tolkien\")\n            loaded_book = Book.objects.using('other').get(title=\"The Ring\")\n            self.assertEqual(loaded_book.author, loaded_author)\n            \n            # Verify data is not in default database (we didn't load it there)\n            self.assertEqual(Author.objects.using('default').count(), 1)  # Original data\n            self.assertEqual(Book.objects.using('default').count(), 1)    # Original data\n        finally:\n            os.unlink(temp_file)\n\n    def test_loaddata_natural_keys_empty_non_default_database(self):\n        \"\"\"Test loaddata on completely empty non-default database.\"\"\"\n        # Create test data in default database\n        author = Author.objects.using('default').create(name=\"JR Tolkien\")\n        book = Book.objects.using('default').create(title=\"The Ring\", author=author)\n        \n        # Serialize the data\n        data = serializers.serialize(\n            \"json\", \n            [author, book], \n            use_natural_foreign_keys=True, \n            use_natural_primary_keys=True\n        )\n        \n        # Ensure other database is completely empty\n        Author.objects.using('other').all().delete()\n        Book.objects.using('other').all().delete()\n        \n        # Create temporary file with the data\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            f.write(data)\n            temp_file = f.name\n        \n        try:\n            # This should work after the fix\n            call_command('loaddata', temp_file, database='other', verbosity=0)\n            \n            # Verify data was loaded\n            self.assertEqual(Author.objects.using('other').count(), 1)\n            self.assertEqual(Book.objects.using('other').count(), 1)\n            \n            loaded_author = Author.objects.using('other').get(name=\"JR Tolkien\")\n            loaded_book = Book.objects.using('other').get(title=\"The Ring\")\n            self.assertEqual(loaded_book.author, loaded_author)\n        finally:\n            os.unlink(temp_file)\n\n    def test_natural_key_lookup_uses_correct_database(self):\n        \"\"\"Test that natural key lookups use the correct database during deserialization.\"\"\"\n        # Create author in 'other' database only\n        author_other = Author.objects.using('other').create(name=\"JR Tolkien\")\n        \n        # Create different author in default database\n        author_default = Author.objects.using('default').create(name=\"Different Author\")\n        \n        # Serialize data that references the author in 'other' database\n        data = serializers.serialize(\n            \"json\", \n            [author_other], \n            use_natural_foreign_keys=True, \n            use_natural_primary_keys=True\n        )\n        \n        # Parse the JSON to create a book entry manually\n        parsed_data = json.loads(data)\n        book_data = {\n            \"model\": \"serializers.book\",\n            \"fields\": {\n                \"title\": \"The Ring\",\n                \"author\": [\"JR Tolkien\"]\n            }\n        }\n        parsed_data.append(book_data)\n        \n        # Create temporary file with the modified data\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            json.dump(parsed_data, f)\n            temp_file = f.name\n        \n        try:\n            # Load into 'other' database - should work and find the correct author\n            call_command('loaddata', temp_file, database='other', verbosity=0)\n            \n            # Verify the book was created with the correct author from 'other' database\n            loaded_book = Book.objects.using('other').get(title=\"The Ring\")\n            self.assertEqual(loaded_book.author.name, \"JR Tolkien\")\n            self.assertEqual(loaded_book.author.pk, author_other.pk)\n            \n            # Verify no book was created in default database\n            self.assertEqual(Book.objects.using('default').count(), 0)\n        finally:\n            os.unlink(temp_file)\n\n    def test_multiple_related_objects_natural_keys(self):\n        \"\"\"Test natural keys with multiple levels of foreign key relationships.\"\"\"\n        # Create test data\n        author1 = Author.objects.using('other').create(name=\"Author One\")\n        author2 = Author.objects.using('other').create(name=\"Author Two\")\n        book1 = Book.objects.using('other').create(title=\"Book One\", author=author1)\n        book2 = Book.objects.using('other').create(title=\"Book Two\", author=author2)\n        \n        # Serialize all data\n        data = serializers.serialize(\n            \"json\", \n            [author1, author2, book1, book2], \n            use_natural_foreign_keys=True, \n            use_natural_primary_keys=True\n        )\n        \n        # Clear the database\n        Book.objects.using('other').all().delete()\n        Author.objects.using('other').all().delete()\n        \n        # Create temporary file with the data\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            f.write(data)\n            temp_file = f.name\n        \n        try:\n            # Load data back - should work after fix\n            call_command('loaddata', temp_file, database='other', verbosity=0)\n            \n            # Verify all data was loaded correctly\n            self.assertEqual(Author.objects.using('other').count(), 2)\n            self.assertEqual(Book.objects.using('other').count(), 2)\n            \n            loaded_book1 = Book.objects.using('other').get(title=\"Book One\")\n            loaded_book2 = Book.objects.using('other').get(title=\"Book Two\")\n            \n            self.assertEqual(loaded_book1.author.name, \"Author One\")\n            self.assertEqual(loaded_book2.author.name, \"Author Two\")\n        finally:\n            os.unlink(temp_file)\n\n    def test_deserializer_direct_usage(self):\n        \"\"\"Test the deserializer directly to isolate the bug.\"\"\"\n        # Create author in 'other' database\n        author = Author.objects.using('other').create(name=\"Test Author\")\n        \n        # Create serialized data for a book\n        data = [\n            {\n                \"model\": \"serializers.author\",\n                \"fields\": {\"name\": \"Test Author\"}\n            },\n            {\n                \"model\": \"serializers.book\", \n                \"fields\": {\n                    \"title\": \"Test Book\",\n                    \"author\": [\"Test Author\"]\n                }\n            }\n        ]\n        \n        # Test deserializing to 'other' database\n        objects = list(serializers.deserialize(\"python\", data, using='other'))\n        \n        # Should not raise an exception after fix\n        self.assertEqual(len(objects), 2)\n        \n        # Save the objects\n        for obj in objects:\n            obj.save()\n        \n        # Verify they were saved to the correct database\n        self.assertEqual(Author.objects.using('other').count(), 1)  # Original + deserialized\n        self.assertEqual(Book.objects.using('other').count(), 1)\n        \n        loaded_book = Book.objects.using('other').get(title=\"Test Book\")\n        self.assertEqual(loaded_book.author.name, \"Test Author\")\n</patched>\n```",
  "patch": "--- a/tests/serializers/test_natural_keys_multidb.py\n+++ b/tests/serializers/test_natural_keys_multidb.py\n-# Empty if creating new file\n+import pytest\n+from django.core import serializers\n+from django.core.management import call_command\n+from django.db import connections\n+from django.test import TestCase, TransactionTestCase\n+from django.test.utils import override_settings\n+from django.apps import apps\n+from django.db import models\n+import tempfile\n+import json\n+import os\n+\n+\n+# Test models for natural keys with foreign keys\n+class AuthorManager(models.Manager):\n+    def get_by_natural_key(self, name):\n+        return self.get(name=name)\n+\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=255, unique=True)\n+    objects = AuthorManager()\n+\n+    def natural_key(self):\n+        return (self.name,)\n+\n+    def __str__(self):\n+        return f\"{self.id} {self.name}\"\n+\n+    class Meta:\n+        app_label = 'serializers'\n+\n+\n+class BookManager(models.Manager):\n+    def get_by_natural_key(self, title, author_name):\n+        return self.get(title=title, author__name=author_name)\n+\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=255)\n+    author = models.ForeignKey(Author, models.CASCADE, related_name=\"books\")\n+    objects = BookManager()\n+\n+    def natural_key(self):\n+        return (self.title,) + self.author.natural_key()\n+\n+    natural_key.dependencies = [\"serializers.Author\"]\n+\n+    class Meta:\n+        unique_together = [[\"title\", \"author\"]]\n+        app_label = 'serializers'\n+\n+    def __str__(self):\n+        return f\"{self.id}: '{self.title}' by {self.author}\"\n+\n+\n+@override_settings(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        },\n+        'other': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+class NaturalKeysMultiDbTestCase(TransactionTestCase):\n+    \"\"\"Test natural keys with foreign keys across multiple databases.\"\"\"\n+    \n+    available_apps = ['serializers']\n+    \n+    def setUp(self):\n+        # Create tables in both databases\n+        for db_alias in ['default', 'other']:\n+            with connections[db_alias].schema_editor() as schema_editor:\n+                schema_editor.create_model(Author)\n+                schema_editor.create_model(Book)\n+    \n+    def tearDown(self):\n+        # Clean up tables\n+        for db_alias in ['default', 'other']:\n+            with connections[db_alias].schema_editor() as schema_editor:\n+                schema_editor.delete_model(Book)\n+                schema_editor.delete_model(Author)\n+\n+    def test_loaddata_natural_keys_default_database_works(self):\n+        \"\"\"Test that loaddata with natural keys works on default database.\"\"\"\n+        # Create test data in default database\n+        author = Author.objects.using('default').create(name=\"JR Tolkien\")\n+        book = Book.objects.using('default').create(title=\"The Ring\", author=author)\n+        \n+        # Serialize the data\n+        data = serializers.serialize(\n+            \"json\", \n+            [author, book], \n+            use_natural_foreign_keys=True, \n+            use_natural_primary_keys=True\n+        )\n+        \n+        # Clear the database\n+        Book.objects.using('default').all().delete()\n+        Author.objects.using('default').all().delete()\n+        \n+        # Create temporary file with the data\n+        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n+            f.write(data)\n+            temp_file = f.name\n+        \n+        try:\n+            # Load data back into default database - should work\n+            call_command('loaddata', temp_file, database='default', verbosity=0)\n+            \n+            # Verify data was loaded\n+            self.assertEqual(Author.objects.using('default').count(), 1)\n+            self.assertEqual(Book.objects.using('default').count(), 1)\n+            \n+            loaded_author = Author.objects.using('default').get(name=\"JR Tolkien\")\n+            loaded_book = Book.objects.using('default').get(title=\"The Ring\")\n+            self.assertEqual(loaded_book.author, loaded_author)\n+        finally:\n+            os.unlink(temp_file)\n+\n+    def test_loaddata_natural_keys_non_default_database_fails_before_fix(self):\n+        \"\"\"Test that demonstrates the bug: loaddata fails on non-default database with natural keys.\"\"\"\n+        # Create test data in default database first\n+        author = Author.objects.using('default').create(name=\"JR Tolkien\")\n+        book = Book.objects.using('default').create(title=\"The Ring\", author=author)\n+        \n+        # Serialize the data\n+        data = serializers.serialize(\n+            \"json\", \n+            [author, book], \n+            use_natural_foreign_keys=True, \n+            use_natural_primary_keys=True\n+        )\n+        \n+        # Create temporary file with the data\n+        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n+            f.write(data)\n+            temp_file = f.name\n+        \n+        try:\n+            # This should fail before the fix is applied\n+            # The error occurs because when building the Book instance for natural key lookup,\n+            # it tries to access self.author.natural_key() but the author lookup uses the default\n+            # database instead of the 'other' database\n+            with self.assertRaises(Author.DoesNotExist):\n+                call_command('loaddata', temp_file, database='other', verbosity=0)\n+            \n+            # Verify no data was loaded in the other database\n+            self.assertEqual(Author.objects.using('other').count(), 0)\n+            self.assertEqual(Book.objects.using('other').count(), 0)\n+        finally:\n+            os.unlink(temp_file)\n+\n+    def test_loaddata_natural_keys_non_default_database_works_after_fix(self):\n+        \"\"\"Test that loaddata works on non-default database after the fix.\"\"\"\n+        # Create test data in default database\n+        author = Author.objects.using('default').create(name=\"JR Tolkien\")\n+        book = Book.objects.using('default').create(title=\"The Ring\", author=author)\n+        \n+        # Serialize the data\n+        data = serializers.serialize(\n+            \"json\", \n+            [author, book], \n+            use_natural_foreign_keys=True, \n+            use_natural_primary_keys=True\n+        )\n+        \n+        # Create temporary file with the data\n+        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n+            f.write(data)\n+            temp_file = f.name\n+        \n+        try:\n+            # After the fix, this should work\n+            call_command('loaddata', temp_file, database='other', verbosity=0)\n+            \n+            # Verify data was loaded in the other database\n+            self.assertEqual(Author.objects.using('other').count(), 1)\n+            self.assertEqual(Book.objects.using('other').count(), 1)\n+            \n+            loaded_author = Author.objects.using('other').get(name=\"JR Tolkien\")\n+            loaded_book = Book.objects.using('other').get(title=\"The Ring\")\n+            self.assertEqual(loaded_book.author, loaded_author)\n+            \n+            # Verify data is not in default database (we didn't load it there)\n+            self.assertEqual(Author.objects.using('default').count(), 1)  # Original data\n+            self.assertEqual(Book.objects.using('default').count(), 1)    # Original data\n+        finally:\n+            os.unlink(temp_file)\n+\n+    def test_loaddata_natural_keys_empty_non_default_database(self):\n+        \"\"\"Test loaddata on completely empty non-default database.\"\"\"\n+        # Create test data in default database\n+        author = Author.objects.using('default').create(name=\"JR Tolkien\")\n+        book = Book.objects.using('default').create(title=\"The Ring\", author=author)\n+        \n+        # Serialize the data\n+        data = serializers.serialize(\n+            \"json\", \n+            [author, book], \n+            use_natural_foreign_keys=True, \n+            use_natural_primary_keys=True\n+        )\n+        \n+        # Ensure other database is completely empty\n+        Author.objects.using('other').all().delete()\n+        Book.objects.using('other').all().delete()\n+        \n+        # Create temporary file with the data\n+        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n+            f.write(data)\n+            temp_file = f.name\n+        \n+        try:\n+            # This should work after the fix\n+            call_command('loaddata', temp_file, database='other', verbosity=0)\n+            \n+            # Verify data was loaded\n+            self.assertEqual(Author.objects.using('other').count(), 1)\n+            self.assertEqual(Book.objects.using('other').count(), 1)\n+            \n+            loaded_author = Author.objects.using('other').get(name=\"JR Tolkien\")\n+            loaded_book = Book.objects.using('other').get(title=\"The Ring\")\n+            self.assertEqual(loaded_book.author, loaded_author)\n+        finally:\n+            os.unlink(temp_file)\n+\n+    def test_natural_key_lookup_uses_correct_database(self):\n+        \"\"\"Test that natural key lookups use the correct database during deserialization.\"\"\"\n+        # Create author in 'other' database only\n+        author_other = Author.objects.using('other').create(name=\"JR Tolkien\")\n+        \n+        # Create different author in default database\n+        author_default = Author.objects.using('default').create(name=\"Different Author\")\n+        \n+        # Serialize data that references the author in 'other' database\n+        data = serializers.serialize(\n+            \"json\", \n+            [author_other], \n+            use_natural_foreign_keys=True, \n+            use_natural_primary_keys=True\n+        )\n+        \n+        # Parse the JSON to create a book entry manually\n+        parsed_data = json.loads(data)\n+        book_data = {\n+            \"model\": \"serializers.book\",\n+            \"fields\": {\n+                \"title\": \"The Ring\",\n+                \"author\": [\"JR Tolkien\"]\n+            }\n+        }\n+        parsed_data.append(book_data)\n+        \n+        # Create temporary file with the modified data\n+        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n+            json.dump(parsed_data, f)\n+            temp_file = f.name\n+        \n+        try:\n+            # Load into 'other' database - should work and find the correct author\n+            call_command('loaddata', temp_file, database='other', verbosity=0)\n+            \n+            # Verify the book was created with the correct author from 'other' database\n+            loaded_book = Book.objects.using('other').get(title=\"The Ring\")\n+            self.assertEqual(loaded_book.author.name, \"JR Tolkien\")\n+            self.assertEqual(loaded_book.author.pk, author_other.pk)\n+            \n+            # Verify no book was created in default database\n+            self.assertEqual(Book.objects.using('default').count(), 0)\n+        finally:\n+            os.unlink(temp_file)\n+\n+    def test_multiple_related_objects_natural_keys(self):\n+        \"\"\"Test natural keys with multiple levels of foreign key relationships.\"\"\"\n+        # Create test data\n+        author1 = Author.objects.using('other').create(name=\"Author One\")\n+        author2 = Author.objects.using('other').create(name=\"Author Two\")\n+        book1 = Book.objects.using('other').create(title=\"Book One\", author=author1)\n+        book2 = Book.objects.using('other').create(title=\"Book Two\", author=author2)\n+        \n+        # Serialize all data\n+        data = serializers.serialize(\n+            \"json\", \n+            [author1, author2, book1, book2], \n+            use_natural_foreign_keys=True, \n+            use_natural_primary_keys=True\n+        )\n+        \n+        # Clear the database\n+        Book.objects.using('other').all().delete()\n+        Author.objects.using('other').all().delete()\n+        \n+        # Create temporary file with the data\n+        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n+            f.write(data)\n+            temp_file = f.name\n+        \n+        try:\n+            # Load data back - should work after fix\n+            call_command('loaddata', temp_file, database='other', verbosity=0)\n+            \n+            # Verify all data was loaded correctly\n+            self.assertEqual(Author.objects.using('other').count(), 2)\n+            self.assertEqual(Book.objects.using('other').count(), 2)\n+            \n+            loaded_book1 = Book.objects.using('other').get(title=\"Book One\")\n+            loaded_book2 = Book.objects.using('other').get(title=\"Book Two\")\n+            \n+            self.assertEqual(loaded_book1.author.name, \"Author One\")\n+            self.assertEqual(loaded_book2.author.name, \"Author Two\")\n+        finally:\n+            os.unlink(temp_file)\n+\n+    def test_deserializer_direct_usage(self):\n+        \"\"\"Test the deserializer directly to isolate the bug.\"\"\"\n+        # Create author in 'other' database\n+        author = Author.objects.using('other').create(name=\"Test Author\")\n+        \n+        # Create serialized data for a book\n+        data = [\n+            {\n+                \"model\": \"serializers.author\",\n+                \"fields\": {\"name\": \"Test Author\"}\n+            },\n+            {\n+                \"model\": \"serializers.book\", \n+                \"fields\": {\n+                    \"title\": \"Test Book\",\n+                    \"author\": [\"Test Author\"]\n+                }\n+            }\n+        ]\n+        \n+        # Test deserializing to 'other' database\n+        objects = list(serializers.deserialize(\"python\", data, using='other'))\n+        \n+        # Should not raise an exception after fix\n+        self.assertEqual(len(objects), 2)\n+        \n+        # Save the objects\n+        for obj in objects:\n+            obj.save()\n+        \n+        # Verify they were saved to the correct database\n+        self.assertEqual(Author.objects.using('other').count(), 1)  # Original + deserialized\n+        self.assertEqual(Book.objects.using('other').count(), 1)\n+        \n+        loaded_book = Book.objects.using('other').get(title=\"Test Book\")\n+        self.assertEqual(loaded_book.author.name, \"Test Author\")\n"
}