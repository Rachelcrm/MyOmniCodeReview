{
  "instance_id": "django__django-14855",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/admin_views/test_readonly_fields.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib import admin\nfrom django.contrib.admin.sites import AdminSite\nfrom django.contrib.admin.helpers import AdminReadonlyField\nfrom django.contrib.auth.models import User\nfrom django.db import models\nfrom django.forms import ModelForm\nfrom django.test import TestCase, RequestFactory\nfrom django.urls import reverse\n\n\n# Test models for the readonly field URL generation tests\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'admin_views'\n    \n    def __str__(self):\n        return self.name\n\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n    \n    class Meta:\n        app_label = 'admin_views'\n    \n    def __str__(self):\n        return self.title\n\n\n# Admin classes for testing\nclass AuthorAdmin(admin.ModelAdmin):\n    pass\n\n\nclass BookAdmin(admin.ModelAdmin):\n    readonly_fields = ('author',)\n\n\nclass BookForm(ModelForm):\n    class Meta:\n        model = Book\n        fields = '__all__'\n\n\nclass TestReadonlyFieldURLGeneration(TestCase):\n    \"\"\"Test that readonly field URLs are generated correctly for custom admin sites.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data and admin sites.\"\"\"\n        self.factory = RequestFactory()\n        \n        # Create test data\n        self.author = Author.objects.create(name=\"Test Author\")\n        self.book = Book.objects.create(title=\"Test Book\", author=self.author)\n        \n        # Create default admin site\n        self.default_admin_site = admin.site\n        \n        # Create custom admin site\n        self.custom_admin_site = AdminSite(name='custom_admin')\n        \n        # Register models with both admin sites\n        self.default_admin_site.register(Author, AuthorAdmin)\n        self.default_admin_site.register(Book, BookAdmin)\n        self.custom_admin_site.register(Author, AuthorAdmin)\n        self.custom_admin_site.register(Book, BookAdmin)\n        \n        # Create admin instances\n        self.default_book_admin = BookAdmin(Book, self.default_admin_site)\n        self.custom_book_admin = BookAdmin(Book, self.custom_admin_site)\n        \n        # Create forms\n        self.book_form = BookForm(instance=self.book)\n        self.book_form._meta = type('Meta', (), {\n            'model': Book,\n            'labels': {},\n            'help_texts': {}\n        })()\n    \n    def test_readonly_field_url_default_admin_site(self):\n        \"\"\"Test that readonly field URLs are correct for default admin site.\"\"\"\n        # Create AdminReadonlyField for default admin site\n        readonly_field = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=self.default_book_admin\n        )\n        \n        # Get the admin URL for the author field\n        author_field = Book._meta.get_field('author')\n        url = readonly_field.get_admin_url(author_field, self.author)\n        \n        # The URL should point to the default admin site\n        expected_url = reverse(\n            'admin:admin_views_author_change',\n            args=[self.author.pk]\n        )\n        \n        # Extract URL from the HTML link\n        self.assertIn(expected_url, url)\n        self.assertIn('/admin/', url)\n    \n    def test_readonly_field_url_custom_admin_site_fails_before_fix(self):\n        \"\"\"Test that demonstrates the bug - custom admin site URLs are wrong.\"\"\"\n        # Create AdminReadonlyField for custom admin site\n        readonly_field = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=self.custom_book_admin\n        )\n        \n        # Get the admin URL for the author field\n        author_field = Book._meta.get_field('author')\n        url = readonly_field.get_admin_url(author_field, self.author)\n        \n        # Before the fix, this will incorrectly point to /admin/ instead of /custom_admin/\n        # This test demonstrates the bug\n        self.assertIn('/admin/', url)  # This is the bug - should be /custom_admin/\n        self.assertNotIn('/custom_admin/', url)  # This shows the bug exists\n    \n    def test_readonly_field_url_custom_admin_site_after_fix(self):\n        \"\"\"Test that readonly field URLs are correct for custom admin site after fix.\"\"\"\n        # This test will pass after the fix is applied\n        # Create AdminReadonlyField for custom admin site\n        readonly_field = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=self.custom_book_admin\n        )\n        \n        # Manually apply the fix for testing purposes\n        # In the actual fix, this would be done in the get_admin_url method\n        author_field = Book._meta.get_field('author')\n        \n        # Simulate the fixed behavior\n        from django.contrib.admin.utils import quote\n        from django.urls import reverse, NoReverseMatch\n        from django.utils.html import format_html\n        \n        url_name = 'admin:%s_%s_change' % (\n            author_field.related_model._meta.app_label,\n            author_field.related_model._meta.model_name,\n        )\n        \n        try:\n            # This is the fix - using current_app parameter\n            url = reverse(\n                url_name,\n                args=[quote(self.author.pk)],\n                current_app=self.custom_book_admin.admin_site.name\n            )\n            formatted_url = format_html('<a href=\"{}\">{}</a>', url, self.author)\n        except NoReverseMatch:\n            formatted_url = str(self.author)\n        \n        # After the fix, the URL should point to the custom admin site\n        expected_url = reverse(\n            'admin:admin_views_author_change',\n            args=[self.author.pk],\n            current_app='custom_admin'\n        )\n        \n        self.assertIn(expected_url, formatted_url)\n        # Note: The actual URL structure depends on URL configuration\n        # but the current_app parameter ensures the correct admin site is used\n    \n    def test_readonly_field_url_with_no_reverse_match(self):\n        \"\"\"Test that readonly field handles NoReverseMatch gracefully.\"\"\"\n        # Create a readonly field that will cause NoReverseMatch\n        readonly_field = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=self.default_book_admin\n        )\n        \n        # Create a mock field that will cause NoReverseMatch\n        class MockField:\n            related_model = type('MockModel', (), {\n                '_meta': type('Meta', (), {\n                    'app_label': 'nonexistent',\n                    'model_name': 'nonexistent'\n                })()\n            })\n        \n        mock_field = MockField()\n        result = readonly_field.get_admin_url(mock_field, self.author)\n        \n        # Should return string representation when reverse fails\n        self.assertEqual(result, str(self.author))\n    \n    def test_readonly_field_model_admin_attribute(self):\n        \"\"\"Test that AdminReadonlyField correctly stores model_admin.\"\"\"\n        readonly_field = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=self.custom_book_admin\n        )\n        \n        # Verify that model_admin is correctly stored\n        self.assertEqual(readonly_field.model_admin, self.custom_book_admin)\n        self.assertEqual(readonly_field.model_admin.admin_site.name, 'custom_admin')\n    \n    def test_readonly_field_admin_site_name_access(self):\n        \"\"\"Test that we can access admin site name through model_admin.\"\"\"\n        readonly_field = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=self.custom_book_admin\n        )\n        \n        # Verify we can access the admin site name\n        admin_site_name = readonly_field.model_admin.admin_site.name\n        self.assertEqual(admin_site_name, 'custom_admin')\n        \n        # Test with default admin site\n        default_readonly_field = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=self.default_book_admin\n        )\n        \n        default_admin_site_name = default_readonly_field.model_admin.admin_site.name\n        self.assertEqual(default_admin_site_name, 'admin')\n\n\nclass TestReadonlyFieldEdgeCases(TestCase):\n    \"\"\"Test edge cases for readonly field URL generation.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data for edge cases.\"\"\"\n        self.factory = RequestFactory()\n        self.author = Author.objects.create(name=\"Edge Case Author\")\n        self.book = Book.objects.create(title=\"Edge Case Book\", author=self.author)\n        \n        self.custom_admin_site = AdminSite(name='edge_case_admin')\n        self.custom_book_admin = BookAdmin(Book, self.custom_admin_site)\n        \n        self.book_form = BookForm(instance=self.book)\n        self.book_form._meta = type('Meta', (), {\n            'model': Book,\n            'labels': {},\n            'help_texts': {}\n        })()\n    \n    def test_readonly_field_with_none_model_admin(self):\n        \"\"\"Test readonly field behavior when model_admin is None.\"\"\"\n        readonly_field = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=None\n        )\n        \n        # Should handle None model_admin gracefully\n        self.assertIsNone(readonly_field.model_admin)\n    \n    def test_readonly_field_with_special_characters_in_pk(self):\n        \"\"\"Test readonly field URL generation with special characters in primary key.\"\"\"\n        # Create author with special characters in name (if using name as PK)\n        special_author = Author.objects.create(name=\"Author with 'quotes' & symbols\")\n        special_book = Book.objects.create(title=\"Special Book\", author=special_author)\n        \n        special_form = BookForm(instance=special_book)\n        special_form._meta = type('Meta', (), {\n            'model': Book,\n            'labels': {},\n            'help_texts': {}\n        })()\n        \n        readonly_field = AdminReadonlyField(\n            form=special_form,\n            field='author',\n            is_first=True,\n            model_admin=self.custom_book_admin\n        )\n        \n        author_field = Book._meta.get_field('author')\n        url = readonly_field.get_admin_url(author_field, special_author)\n        \n        # Should handle special characters properly (through quote function)\n        self.assertIsInstance(url, str)\n        self.assertIn(str(special_author), url)\n    \n    def test_multiple_custom_admin_sites(self):\n        \"\"\"Test that different custom admin sites generate different URLs.\"\"\"\n        # Create two different custom admin sites\n        admin_site_1 = AdminSite(name='custom_admin_1')\n        admin_site_2 = AdminSite(name='custom_admin_2')\n        \n        book_admin_1 = BookAdmin(Book, admin_site_1)\n        book_admin_2 = BookAdmin(Book, admin_site_2)\n        \n        readonly_field_1 = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=book_admin_1\n        )\n        \n        readonly_field_2 = AdminReadonlyField(\n            form=self.book_form,\n            field='author',\n            is_first=True,\n            model_admin=book_admin_2\n        )\n        \n        # Verify they have different admin site names\n        self.assertEqual(readonly_field_1.model_admin.admin_site.name, 'custom_admin_1')\n        self.assertEqual(readonly_field_2.model_admin.admin_site.name, 'custom_admin_2')\n        self.assertNotEqual(\n            readonly_field_1.model_admin.admin_site.name,\n            readonly_field_2.model_admin.admin_site.name\n        )\n</patched>\n</file>\n```",
  "patch": "--- a/tests/admin_views/test_readonly_fields.py\n+++ b/tests/admin_views/test_readonly_fields.py\n-# Empty if creating new file\n+import pytest\n+from django.contrib import admin\n+from django.contrib.admin.sites import AdminSite\n+from django.contrib.admin.helpers import AdminReadonlyField\n+from django.contrib.auth.models import User\n+from django.db import models\n+from django.forms import ModelForm\n+from django.test import TestCase, RequestFactory\n+from django.urls import reverse\n+\n+\n+# Test models for the readonly field URL generation tests\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'admin_views'\n+    \n+    def __str__(self):\n+        return self.name\n+\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'admin_views'\n+    \n+    def __str__(self):\n+        return self.title\n+\n+\n+# Admin classes for testing\n+class AuthorAdmin(admin.ModelAdmin):\n+    pass\n+\n+\n+class BookAdmin(admin.ModelAdmin):\n+    readonly_fields = ('author',)\n+\n+\n+class BookForm(ModelForm):\n+    class Meta:\n+        model = Book\n+        fields = '__all__'\n+\n+\n+class TestReadonlyFieldURLGeneration(TestCase):\n+    \"\"\"Test that readonly field URLs are generated correctly for custom admin sites.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data and admin sites.\"\"\"\n+        self.factory = RequestFactory()\n+        \n+        # Create test data\n+        self.author = Author.objects.create(name=\"Test Author\")\n+        self.book = Book.objects.create(title=\"Test Book\", author=self.author)\n+        \n+        # Create default admin site\n+        self.default_admin_site = admin.site\n+        \n+        # Create custom admin site\n+        self.custom_admin_site = AdminSite(name='custom_admin')\n+        \n+        # Register models with both admin sites\n+        self.default_admin_site.register(Author, AuthorAdmin)\n+        self.default_admin_site.register(Book, BookAdmin)\n+        self.custom_admin_site.register(Author, AuthorAdmin)\n+        self.custom_admin_site.register(Book, BookAdmin)\n+        \n+        # Create admin instances\n+        self.default_book_admin = BookAdmin(Book, self.default_admin_site)\n+        self.custom_book_admin = BookAdmin(Book, self.custom_admin_site)\n+        \n+        # Create forms\n+        self.book_form = BookForm(instance=self.book)\n+        self.book_form._meta = type('Meta', (), {\n+            'model': Book,\n+            'labels': {},\n+            'help_texts': {}\n+        })()\n+    \n+    def test_readonly_field_url_default_admin_site(self):\n+        \"\"\"Test that readonly field URLs are correct for default admin site.\"\"\"\n+        # Create AdminReadonlyField for default admin site\n+        readonly_field = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=self.default_book_admin\n+        )\n+        \n+        # Get the admin URL for the author field\n+        author_field = Book._meta.get_field('author')\n+        url = readonly_field.get_admin_url(author_field, self.author)\n+        \n+        # The URL should point to the default admin site\n+        expected_url = reverse(\n+            'admin:admin_views_author_change',\n+            args=[self.author.pk]\n+        )\n+        \n+        # Extract URL from the HTML link\n+        self.assertIn(expected_url, url)\n+        self.assertIn('/admin/', url)\n+    \n+    def test_readonly_field_url_custom_admin_site_fails_before_fix(self):\n+        \"\"\"Test that demonstrates the bug - custom admin site URLs are wrong.\"\"\"\n+        # Create AdminReadonlyField for custom admin site\n+        readonly_field = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=self.custom_book_admin\n+        )\n+        \n+        # Get the admin URL for the author field\n+        author_field = Book._meta.get_field('author')\n+        url = readonly_field.get_admin_url(author_field, self.author)\n+        \n+        # Before the fix, this will incorrectly point to /admin/ instead of /custom_admin/\n+        # This test demonstrates the bug\n+        self.assertIn('/admin/', url)  # This is the bug - should be /custom_admin/\n+        self.assertNotIn('/custom_admin/', url)  # This shows the bug exists\n+    \n+    def test_readonly_field_url_custom_admin_site_after_fix(self):\n+        \"\"\"Test that readonly field URLs are correct for custom admin site after fix.\"\"\"\n+        # This test will pass after the fix is applied\n+        # Create AdminReadonlyField for custom admin site\n+        readonly_field = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=self.custom_book_admin\n+        )\n+        \n+        # Manually apply the fix for testing purposes\n+        # In the actual fix, this would be done in the get_admin_url method\n+        author_field = Book._meta.get_field('author')\n+        \n+        # Simulate the fixed behavior\n+        from django.contrib.admin.utils import quote\n+        from django.urls import reverse, NoReverseMatch\n+        from django.utils.html import format_html\n+        \n+        url_name = 'admin:%s_%s_change' % (\n+            author_field.related_model._meta.app_label,\n+            author_field.related_model._meta.model_name,\n+        )\n+        \n+        try:\n+            # This is the fix - using current_app parameter\n+            url = reverse(\n+                url_name,\n+                args=[quote(self.author.pk)],\n+                current_app=self.custom_book_admin.admin_site.name\n+            )\n+            formatted_url = format_html('<a href=\"{}\">{}</a>', url, self.author)\n+        except NoReverseMatch:\n+            formatted_url = str(self.author)\n+        \n+        # After the fix, the URL should point to the custom admin site\n+        expected_url = reverse(\n+            'admin:admin_views_author_change',\n+            args=[self.author.pk],\n+            current_app='custom_admin'\n+        )\n+        \n+        self.assertIn(expected_url, formatted_url)\n+        # Note: The actual URL structure depends on URL configuration\n+        # but the current_app parameter ensures the correct admin site is used\n+    \n+    def test_readonly_field_url_with_no_reverse_match(self):\n+        \"\"\"Test that readonly field handles NoReverseMatch gracefully.\"\"\"\n+        # Create a readonly field that will cause NoReverseMatch\n+        readonly_field = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=self.default_book_admin\n+        )\n+        \n+        # Create a mock field that will cause NoReverseMatch\n+        class MockField:\n+            related_model = type('MockModel', (), {\n+                '_meta': type('Meta', (), {\n+                    'app_label': 'nonexistent',\n+                    'model_name': 'nonexistent'\n+                })()\n+            })\n+        \n+        mock_field = MockField()\n+        result = readonly_field.get_admin_url(mock_field, self.author)\n+        \n+        # Should return string representation when reverse fails\n+        self.assertEqual(result, str(self.author))\n+    \n+    def test_readonly_field_model_admin_attribute(self):\n+        \"\"\"Test that AdminReadonlyField correctly stores model_admin.\"\"\"\n+        readonly_field = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=self.custom_book_admin\n+        )\n+        \n+        # Verify that model_admin is correctly stored\n+        self.assertEqual(readonly_field.model_admin, self.custom_book_admin)\n+        self.assertEqual(readonly_field.model_admin.admin_site.name, 'custom_admin')\n+    \n+    def test_readonly_field_admin_site_name_access(self):\n+        \"\"\"Test that we can access admin site name through model_admin.\"\"\"\n+        readonly_field = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=self.custom_book_admin\n+        )\n+        \n+        # Verify we can access the admin site name\n+        admin_site_name = readonly_field.model_admin.admin_site.name\n+        self.assertEqual(admin_site_name, 'custom_admin')\n+        \n+        # Test with default admin site\n+        default_readonly_field = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=self.default_book_admin\n+        )\n+        \n+        default_admin_site_name = default_readonly_field.model_admin.admin_site.name\n+        self.assertEqual(default_admin_site_name, 'admin')\n+\n+\n+class TestReadonlyFieldEdgeCases(TestCase):\n+    \"\"\"Test edge cases for readonly field URL generation.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data for edge cases.\"\"\"\n+        self.factory = RequestFactory()\n+        self.author = Author.objects.create(name=\"Edge Case Author\")\n+        self.book = Book.objects.create(title=\"Edge Case Book\", author=self.author)\n+        \n+        self.custom_admin_site = AdminSite(name='edge_case_admin')\n+        self.custom_book_admin = BookAdmin(Book, self.custom_admin_site)\n+        \n+        self.book_form = BookForm(instance=self.book)\n+        self.book_form._meta = type('Meta', (), {\n+            'model': Book,\n+            'labels': {},\n+            'help_texts': {}\n+        })()\n+    \n+    def test_readonly_field_with_none_model_admin(self):\n+        \"\"\"Test readonly field behavior when model_admin is None.\"\"\"\n+        readonly_field = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=None\n+        )\n+        \n+        # Should handle None model_admin gracefully\n+        self.assertIsNone(readonly_field.model_admin)\n+    \n+    def test_readonly_field_with_special_characters_in_pk(self):\n+        \"\"\"Test readonly field URL generation with special characters in primary key.\"\"\"\n+        # Create author with special characters in name (if using name as PK)\n+        special_author = Author.objects.create(name=\"Author with 'quotes' & symbols\")\n+        special_book = Book.objects.create(title=\"Special Book\", author=special_author)\n+        \n+        special_form = BookForm(instance=special_book)\n+        special_form._meta = type('Meta', (), {\n+            'model': Book,\n+            'labels': {},\n+            'help_texts': {}\n+        })()\n+        \n+        readonly_field = AdminReadonlyField(\n+            form=special_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=self.custom_book_admin\n+        )\n+        \n+        author_field = Book._meta.get_field('author')\n+        url = readonly_field.get_admin_url(author_field, special_author)\n+        \n+        # Should handle special characters properly (through quote function)\n+        self.assertIsInstance(url, str)\n+        self.assertIn(str(special_author), url)\n+    \n+    def test_multiple_custom_admin_sites(self):\n+        \"\"\"Test that different custom admin sites generate different URLs.\"\"\"\n+        # Create two different custom admin sites\n+        admin_site_1 = AdminSite(name='custom_admin_1')\n+        admin_site_2 = AdminSite(name='custom_admin_2')\n+        \n+        book_admin_1 = BookAdmin(Book, admin_site_1)\n+        book_admin_2 = BookAdmin(Book, admin_site_2)\n+        \n+        readonly_field_1 = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=book_admin_1\n+        )\n+        \n+        readonly_field_2 = AdminReadonlyField(\n+            form=self.book_form,\n+            field='author',\n+            is_first=True,\n+            model_admin=book_admin_2\n+        )\n+        \n+        # Verify they have different admin site names\n+        self.assertEqual(readonly_field_1.model_admin.admin_site.name, 'custom_admin_1')\n+        self.assertEqual(readonly_field_2.model_admin.admin_site.name, 'custom_admin_2')\n+        self.assertNotEqual(\n+            readonly_field_1.model_admin.admin_site.name,\n+            readonly_field_2.model_admin.admin_site.name\n+        )\n"
}