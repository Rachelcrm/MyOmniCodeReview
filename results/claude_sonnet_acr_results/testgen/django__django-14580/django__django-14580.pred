{
  "instance_id": "django__django-14580",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/migrations/test_writer.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models\nfrom django.db.migrations.writer import MigrationWriter\nfrom django.db.migrations.operations.models import CreateModel\nfrom django.db.migrations import Migration\nfrom django.test import TestCase\n\n\nclass TestMigrationWriterImports(TestCase):\n    \"\"\"Test that MigrationWriter generates correct imports for models.Model in bases.\"\"\"\n    \n    def test_models_model_in_bases_generates_import(self):\n        \"\"\"\n        Test that when models.Model appears in bases tuple, the migration\n        includes 'from django.db import models' import.\n        \n        This reproduces the bug where models.Model in bases causes\n        NameError: name 'models' is not defined.\n        \"\"\"\n        # Create a custom field class for testing\n        class MyField(models.TextField):\n            pass\n        \n        # Create a custom mixin class\n        class MyMixin:\n            pass\n        \n        # Create the migration operation that would cause the bug\n        operation = CreateModel(\n            name='MyModel',\n            fields=[\n                ('name', MyField(primary_key=True)),\n            ],\n            options={\n                'abstract': False,\n            },\n            bases=(MyMixin, models.Model),  # This should trigger the import\n        )\n        \n        # Create a migration with this operation\n        migration = Migration('0001_initial', 'testapp')\n        migration.operations = [operation]\n        \n        # Generate the migration string\n        writer = MigrationWriter(migration)\n        migration_string = writer.as_string()\n        \n        # The migration should include the models import\n        self.assertIn('from django.db import migrations, models', migration_string)\n        \n        # The migration should be valid Python (no NameError when executed)\n        # We test this by checking that models.Model appears in bases\n        self.assertIn('bases=(', migration_string)\n        self.assertIn('models.Model', migration_string)\n        \n        # Verify the migration can be compiled without NameError\n        try:\n            compile(migration_string, '<string>', 'exec')\n        except NameError as e:\n            if \"name 'models' is not defined\" in str(e):\n                self.fail(\"Migration contains models.Model but missing models import\")\n            else:\n                raise\n    \n    def test_models_model_only_in_bases_generates_import(self):\n        \"\"\"\n        Test that models.Model in bases generates import even when\n        no fields use models classes.\n        \"\"\"\n        # Create operation with models.Model in bases but no model fields\n        operation = CreateModel(\n            name='SimpleModel',\n            fields=[\n                ('id', models.AutoField(primary_key=True)),\n            ],\n            bases=(models.Model,),  # Only models.Model in bases\n        )\n        \n        migration = Migration('0001_initial', 'testapp')\n        migration.operations = [operation]\n        \n        writer = MigrationWriter(migration)\n        migration_string = writer.as_string()\n        \n        # Should include models import due to models.Model in bases\n        self.assertIn('from django.db import migrations, models', migration_string)\n        self.assertIn('models.Model', migration_string)\n    \n    def test_multiple_bases_with_models_model(self):\n        \"\"\"\n        Test that models.Model in bases with other classes generates correct import.\n        \"\"\"\n        class CustomMixin:\n            pass\n        \n        class AnotherMixin:\n            pass\n        \n        operation = CreateModel(\n            name='MultiBaseModel',\n            fields=[\n                ('name', models.CharField(max_length=100)),\n            ],\n            bases=(CustomMixin, AnotherMixin, models.Model),\n        )\n        \n        migration = Migration('0001_initial', 'testapp')\n        migration.operations = [operation]\n        \n        writer = MigrationWriter(migration)\n        migration_string = writer.as_string()\n        \n        # Should include models import\n        self.assertIn('from django.db import migrations, models', migration_string)\n        self.assertIn('models.Model', migration_string)\n        \n        # Verify compilation works\n        compile(migration_string, '<string>', 'exec')\n    \n    def test_no_models_model_in_bases_no_extra_import(self):\n        \"\"\"\n        Test that when models.Model is not in bases, we don't get\n        unnecessary models import (unless needed for fields).\n        \"\"\"\n        class CustomBase:\n            pass\n        \n        operation = CreateModel(\n            name='CustomBaseModel',\n            fields=[\n                ('id', models.AutoField(primary_key=True)),\n            ],\n            bases=(CustomBase,),  # No models.Model\n        )\n        \n        migration = Migration('0001_initial', 'testapp')\n        migration.operations = [operation]\n        \n        writer = MigrationWriter(migration)\n        migration_string = writer.as_string()\n        \n        # Should still include models import due to AutoField\n        self.assertIn('from django.db import migrations, models', migration_string)\n        # But models.Model should not appear in bases\n        self.assertNotIn('models.Model', migration_string.split('bases=')[1].split(')')[0])\n    \n    def test_migration_executes_without_error(self):\n        \"\"\"\n        Test that the generated migration can actually be executed\n        without NameError.\n        \"\"\"\n        class TestMixin:\n            pass\n        \n        operation = CreateModel(\n            name='ExecutableModel',\n            fields=[\n                ('name', models.CharField(max_length=50, primary_key=True)),\n            ],\n            bases=(TestMixin, models.Model),\n        )\n        \n        migration = Migration('0001_initial', 'testapp')\n        migration.operations = [operation]\n        \n        writer = MigrationWriter(migration)\n        migration_string = writer.as_string()\n        \n        # Create a namespace for execution\n        namespace = {}\n        \n        # The migration should execute without NameError\n        try:\n            exec(migration_string, namespace)\n        except NameError as e:\n            if \"name 'models' is not defined\" in str(e):\n                self.fail(f\"Migration execution failed with NameError: {e}\")\n            else:\n                raise\n        \n        # Verify the Migration class was created\n        self.assertIn('Migration', namespace)\n        migration_class = namespace['Migration']\n        self.assertTrue(hasattr(migration_class, 'operations'))\n        self.assertEqual(len(migration_class.operations), 1)\n\n\nclass TestTypeSerializerModelsModel(TestCase):\n    \"\"\"Test the TypeSerializer specifically for models.Model serialization.\"\"\"\n    \n    def test_models_model_serialization_includes_import(self):\n        \"\"\"\n        Test that TypeSerializer.serialize() returns correct import\n        for models.Model.\n        \"\"\"\n        from django.db.migrations.serializer import TypeSerializer\n        \n        serializer = TypeSerializer(models.Model)\n        string_repr, imports = serializer.serialize()\n        \n        # Should return \"models.Model\" as string representation\n        self.assertEqual(string_repr, \"models.Model\")\n        \n        # Should include the models import\n        self.assertIn(\"from django.db import models\", imports)\n    \n    def test_other_types_unchanged(self):\n        \"\"\"\n        Test that other type serializations are not affected by the fix.\n        \"\"\"\n        from django.db.migrations.serializer import TypeSerializer\n        \n        # Test type(None)\n        serializer = TypeSerializer(type(None))\n        string_repr, imports = serializer.serialize()\n        self.assertEqual(string_repr, \"type(None)\")\n        self.assertEqual(imports, set())\n        \n        # Test a regular class\n        class TestClass:\n            pass\n        \n        serializer = TypeSerializer(TestClass)\n        string_repr, imports = serializer.serialize()\n        expected_import = f\"import {TestClass.__module__}\"\n        self.assertIn(expected_import, imports)\n</patched>\n```",
  "patch": "--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models\n+from django.db.migrations.writer import MigrationWriter\n+from django.db.migrations.operations.models import CreateModel\n+from django.db.migrations import Migration\n+from django.test import TestCase\n+\n+\n+class TestMigrationWriterImports(TestCase):\n+    \"\"\"Test that MigrationWriter generates correct imports for models.Model in bases.\"\"\"\n+    \n+    def test_models_model_in_bases_generates_import(self):\n+        \"\"\"\n+        Test that when models.Model appears in bases tuple, the migration\n+        includes 'from django.db import models' import.\n+        \n+        This reproduces the bug where models.Model in bases causes\n+        NameError: name 'models' is not defined.\n+        \"\"\"\n+        # Create a custom field class for testing\n+        class MyField(models.TextField):\n+            pass\n+        \n+        # Create a custom mixin class\n+        class MyMixin:\n+            pass\n+        \n+        # Create the migration operation that would cause the bug\n+        operation = CreateModel(\n+            name='MyModel',\n+            fields=[\n+                ('name', MyField(primary_key=True)),\n+            ],\n+            options={\n+                'abstract': False,\n+            },\n+            bases=(MyMixin, models.Model),  # This should trigger the import\n+        )\n+        \n+        # Create a migration with this operation\n+        migration = Migration('0001_initial', 'testapp')\n+        migration.operations = [operation]\n+        \n+        # Generate the migration string\n+        writer = MigrationWriter(migration)\n+        migration_string = writer.as_string()\n+        \n+        # The migration should include the models import\n+        self.assertIn('from django.db import migrations, models', migration_string)\n+        \n+        # The migration should be valid Python (no NameError when executed)\n+        # We test this by checking that models.Model appears in bases\n+        self.assertIn('bases=(', migration_string)\n+        self.assertIn('models.Model', migration_string)\n+        \n+        # Verify the migration can be compiled without NameError\n+        try:\n+            compile(migration_string, '<string>', 'exec')\n+        except NameError as e:\n+            if \"name 'models' is not defined\" in str(e):\n+                self.fail(\"Migration contains models.Model but missing models import\")\n+            else:\n+                raise\n+    \n+    def test_models_model_only_in_bases_generates_import(self):\n+        \"\"\"\n+        Test that models.Model in bases generates import even when\n+        no fields use models classes.\n+        \"\"\"\n+        # Create operation with models.Model in bases but no model fields\n+        operation = CreateModel(\n+            name='SimpleModel',\n+            fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ],\n+            bases=(models.Model,),  # Only models.Model in bases\n+        )\n+        \n+        migration = Migration('0001_initial', 'testapp')\n+        migration.operations = [operation]\n+        \n+        writer = MigrationWriter(migration)\n+        migration_string = writer.as_string()\n+        \n+        # Should include models import due to models.Model in bases\n+        self.assertIn('from django.db import migrations, models', migration_string)\n+        self.assertIn('models.Model', migration_string)\n+    \n+    def test_multiple_bases_with_models_model(self):\n+        \"\"\"\n+        Test that models.Model in bases with other classes generates correct import.\n+        \"\"\"\n+        class CustomMixin:\n+            pass\n+        \n+        class AnotherMixin:\n+            pass\n+        \n+        operation = CreateModel(\n+            name='MultiBaseModel',\n+            fields=[\n+                ('name', models.CharField(max_length=100)),\n+            ],\n+            bases=(CustomMixin, AnotherMixin, models.Model),\n+        )\n+        \n+        migration = Migration('0001_initial', 'testapp')\n+        migration.operations = [operation]\n+        \n+        writer = MigrationWriter(migration)\n+        migration_string = writer.as_string()\n+        \n+        # Should include models import\n+        self.assertIn('from django.db import migrations, models', migration_string)\n+        self.assertIn('models.Model', migration_string)\n+        \n+        # Verify compilation works\n+        compile(migration_string, '<string>', 'exec')\n+    \n+    def test_no_models_model_in_bases_no_extra_import(self):\n+        \"\"\"\n+        Test that when models.Model is not in bases, we don't get\n+        unnecessary models import (unless needed for fields).\n+        \"\"\"\n+        class CustomBase:\n+            pass\n+        \n+        operation = CreateModel(\n+            name='CustomBaseModel',\n+            fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ],\n+            bases=(CustomBase,),  # No models.Model\n+        )\n+        \n+        migration = Migration('0001_initial', 'testapp')\n+        migration.operations = [operation]\n+        \n+        writer = MigrationWriter(migration)\n+        migration_string = writer.as_string()\n+        \n+        # Should still include models import due to AutoField\n+        self.assertIn('from django.db import migrations, models', migration_string)\n+        # But models.Model should not appear in bases\n+        self.assertNotIn('models.Model', migration_string.split('bases=')[1].split(')')[0])\n+    \n+    def test_migration_executes_without_error(self):\n+        \"\"\"\n+        Test that the generated migration can actually be executed\n+        without NameError.\n+        \"\"\"\n+        class TestMixin:\n+            pass\n+        \n+        operation = CreateModel(\n+            name='ExecutableModel',\n+            fields=[\n+                ('name', models.CharField(max_length=50, primary_key=True)),\n+            ],\n+            bases=(TestMixin, models.Model),\n+        )\n+        \n+        migration = Migration('0001_initial', 'testapp')\n+        migration.operations = [operation]\n+        \n+        writer = MigrationWriter(migration)\n+        migration_string = writer.as_string()\n+        \n+        # Create a namespace for execution\n+        namespace = {}\n+        \n+        # The migration should execute without NameError\n+        try:\n+            exec(migration_string, namespace)\n+        except NameError as e:\n+            if \"name 'models' is not defined\" in str(e):\n+                self.fail(f\"Migration execution failed with NameError: {e}\")\n+            else:\n+                raise\n+        \n+        # Verify the Migration class was created\n+        self.assertIn('Migration', namespace)\n+        migration_class = namespace['Migration']\n+        self.assertTrue(hasattr(migration_class, 'operations'))\n+        self.assertEqual(len(migration_class.operations), 1)\n+\n+\n+class TestTypeSerializerModelsModel(TestCase):\n+    \"\"\"Test the TypeSerializer specifically for models.Model serialization.\"\"\"\n+    \n+    def test_models_model_serialization_includes_import(self):\n+        \"\"\"\n+        Test that TypeSerializer.serialize() returns correct import\n+        for models.Model.\n+        \"\"\"\n+        from django.db.migrations.serializer import TypeSerializer\n+        \n+        serializer = TypeSerializer(models.Model)\n+        string_repr, imports = serializer.serialize()\n+        \n+        # Should return \"models.Model\" as string representation\n+        self.assertEqual(string_repr, \"models.Model\")\n+        \n+        # Should include the models import\n+        self.assertIn(\"from django.db import models\", imports)\n+    \n+    def test_other_types_unchanged(self):\n+        \"\"\"\n+        Test that other type serializations are not affected by the fix.\n+        \"\"\"\n+        from django.db.migrations.serializer import TypeSerializer\n+        \n+        # Test type(None)\n+        serializer = TypeSerializer(type(None))\n+        string_repr, imports = serializer.serialize()\n+        self.assertEqual(string_repr, \"type(None)\")\n+        self.assertEqual(imports, set())\n+        \n+        # Test a regular class\n+        class TestClass:\n+            pass\n+        \n+        serializer = TypeSerializer(TestClass)\n+        string_repr, imports = serializer.serialize()\n+        expected_import = f\"import {TestClass.__module__}\"\n+        self.assertIn(expected_import, imports)\n"
}