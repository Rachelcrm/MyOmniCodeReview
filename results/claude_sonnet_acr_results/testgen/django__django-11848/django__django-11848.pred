{
  "instance_id": "django__django-11848",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/utils_tests/test_http.py</file>\n<original>\nimport unittest\nfrom datetime import datetime\nfrom unittest import mock\n\nfrom django.test import SimpleTestCase\nfrom django.utils.http import (\n    base36_to_int, escape_uri_path, http_date, int_to_base36, is_safe_url,\n    parse_etags, parse_http_date, parse_http_date_safe, quote_etag,\n    urlencode, urlquote, urlquote_plus, urlsafe_base64_decode,\n    urlsafe_base64_encode, urlunquote, urlunquote_plus,\n)\n\n\nclass HttpDateProcessingTests(SimpleTestCase):\n    def test_http_date(self):\n        t = 1167616461.0\n        self.assertEqual(http_date(t), 'Mon, 01 Jan 2007 01:54:21 GMT')\n\n    def test_parsing_rfc1123(self):\n        parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n\n    def test_parsing_rfc850(self):\n        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n\n    def test_parsing_asctime(self):\n        parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n\n    def test_parsing_year_less_than_70(self):\n        # This should be 2005, not 1905\n        parsed = parse_http_date('Sun, 06 Nov 05 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2005, 11, 6, 8, 49, 37))\n\n    def test_parsing_year_greater_than_70(self):\n        parsed = parse_http_date('Sun, 06 Nov 94 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n\n    def test_parsing_rfc850_year_less_than_70(self):\n        parsed = parse_http_date('Sunday, 06-Nov-05 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2005, 11, 6, 8, 49, 37))\n\n    def test_parsing_rfc850_year_greater_than_70(self):\n        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n</original>\n<patched>\nimport unittest\nfrom datetime import datetime\nfrom unittest import mock\n\nfrom django.test import SimpleTestCase\nfrom django.utils.http import (\n    base36_to_int, escape_uri_path, http_date, int_to_base36, is_safe_url,\n    parse_etags, parse_http_date, parse_http_date_safe, quote_etag,\n    urlencode, urlquote, urlquote_plus, urlsafe_base64_decode,\n    urlsafe_base64_encode, urlunquote, urlunquote_plus,\n)\n\n\nclass HttpDateProcessingTests(SimpleTestCase):\n    def test_http_date(self):\n        t = 1167616461.0\n        self.assertEqual(http_date(t), 'Mon, 01 Jan 2007 01:54:21 GMT')\n\n    def test_parsing_rfc1123(self):\n        parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n\n    def test_parsing_rfc850(self):\n        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n\n    def test_parsing_asctime(self):\n        parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n\n    def test_parsing_year_less_than_70(self):\n        # This should be 2005, not 1905\n        parsed = parse_http_date('Sun, 06 Nov 05 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2005, 11, 6, 8, 49, 37))\n\n    def test_parsing_year_greater_than_70(self):\n        parsed = parse_http_date('Sun, 06 Nov 94 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n\n    def test_parsing_rfc850_year_less_than_70(self):\n        parsed = parse_http_date('Sunday, 06-Nov-05 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2005, 11, 6, 8, 49, 37))\n\n    def test_parsing_rfc850_year_greater_than_70(self):\n        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n\n    def test_two_digit_year_rfc7231_compliance_current_year_2023(self):\n        \"\"\"\n        Test RFC 7231 compliance for two-digit years when current year is 2023.\n        Years that would be more than 50 years in the future should be \n        interpreted as being in the past century.\n        \"\"\"\n        with mock.patch('django.utils.http.datetime') as mock_datetime:\n            # Mock current year as 2023\n            mock_datetime.datetime.now.return_value.year = 2023\n            mock_datetime.datetime.side_effect = datetime\n            \n            # Year 25 -> should be 2025 (not more than 50 years in future)\n            parsed = parse_http_date('Sun, 06 Nov 25 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2025, 11, 6, 8, 49, 37))\n            \n            # Year 73 -> should be 2073 (exactly 50 years in future, allowed)\n            parsed = parse_http_date('Sun, 06 Nov 73 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2073, 11, 6, 8, 49, 37))\n            \n            # Year 74 -> should be 1974 (would be 51 years in future, so interpret as past)\n            parsed = parse_http_date('Sun, 06 Nov 74 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1974, 11, 6, 8, 49, 37))\n\n    def test_two_digit_year_rfc7231_compliance_current_year_2050(self):\n        \"\"\"\n        Test RFC 7231 compliance for two-digit years when current year is 2050.\n        This tests the dynamic nature of the 50-year rule.\n        \"\"\"\n        with mock.patch('django.utils.http.datetime') as mock_datetime:\n            # Mock current year as 2050\n            mock_datetime.datetime.now.return_value.year = 2050\n            mock_datetime.datetime.side_effect = datetime\n            \n            # Year 00 -> should be 2100 (exactly 50 years in future, allowed)\n            parsed = parse_http_date('Sun, 06 Nov 00 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2100, 11, 6, 8, 49, 37))\n            \n            # Year 01 -> should be 2001 (would be 51 years in future, so interpret as past)\n            parsed = parse_http_date('Sun, 06 Nov 01 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2001, 11, 6, 8, 49, 37))\n            \n            # Year 49 -> should be 2049 (1 year in past, recent past)\n            parsed = parse_http_date('Sun, 06 Nov 49 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2049, 11, 6, 8, 49, 37))\n\n    def test_two_digit_year_rfc7231_compliance_edge_cases(self):\n        \"\"\"\n        Test edge cases for RFC 7231 two-digit year handling.\n        \"\"\"\n        with mock.patch('django.utils.http.datetime') as mock_datetime:\n            # Mock current year as 2023\n            mock_datetime.datetime.now.return_value.year = 2023\n            mock_datetime.datetime.side_effect = datetime\n            \n            # Year 23 -> should be 2023 (current year)\n            parsed = parse_http_date('Sun, 06 Nov 23 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2023, 11, 6, 8, 49, 37))\n            \n            # Year 22 -> should be 2022 (1 year in past)\n            parsed = parse_http_date('Sun, 06 Nov 22 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2022, 11, 6, 8, 49, 37))\n            \n            # Year 24 -> should be 2024 (1 year in future)\n            parsed = parse_http_date('Sun, 06 Nov 24 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2024, 11, 6, 8, 49, 37))\n\n    def test_two_digit_year_rfc850_format_rfc7231_compliance(self):\n        \"\"\"\n        Test RFC 7231 compliance specifically for RFC 850 date format.\n        \"\"\"\n        with mock.patch('django.utils.http.datetime') as mock_datetime:\n            # Mock current year as 2023\n            mock_datetime.datetime.now.return_value.year = 2023\n            mock_datetime.datetime.side_effect = datetime\n            \n            # Year 25 -> should be 2025 (RFC 850 format)\n            parsed = parse_http_date('Sunday, 06-Nov-25 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2025, 11, 6, 8, 49, 37))\n            \n            # Year 74 -> should be 1974 (RFC 850 format)\n            parsed = parse_http_date('Sunday, 06-Nov-74 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1974, 11, 6, 8, 49, 37))\n\n    def test_two_digit_year_hardcoded_behavior_fails_rfc7231(self):\n        \"\"\"\n        This test demonstrates the bug in the current hardcoded implementation.\n        It should fail before the fix is applied, showing that the current\n        implementation doesn't follow RFC 7231.\n        \"\"\"\n        # This test will fail with the current hardcoded implementation\n        # but should pass after implementing RFC 7231 compliance\n        \n        # Simulate a future year where the hardcoded logic would be wrong\n        with mock.patch('django.utils.http.datetime') as mock_datetime:\n            # Mock current year as 2080\n            mock_datetime.datetime.now.return_value.year = 2080\n            mock_datetime.datetime.side_effect = datetime\n            \n            # With current hardcoded logic: year 30 -> 2030 (50 years in past, should be correct)\n            # But year 69 -> 2069 (11 years in past, should be correct)\n            # But year 70 -> 1970 (110 years in past, this is wrong per RFC 7231)\n            # Year 70 should be 2070 (10 years in past) according to RFC 7231\n            \n            # This will currently return 1970 but should return 2070\n            parsed = parse_http_date('Sun, 06 Nov 70 08:49:37 GMT')\n            # The current implementation will make this assertion fail\n            # because it returns 1970 instead of 2070\n            try:\n                self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2070, 11, 6, 8, 49, 37))\n                self.fail(\"This test should fail with the current hardcoded implementation\")\n            except AssertionError:\n                # Expected to fail with current implementation\n                # Verify it actually returns 1970 (the buggy behavior)\n                self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1970, 11, 6, 8, 49, 37))\n\n    def test_four_digit_years_unchanged(self):\n        \"\"\"\n        Test that four-digit years are not affected by the RFC 7231 changes.\n        \"\"\"\n        with mock.patch('django.utils.http.datetime') as mock_datetime:\n            # Mock current year as 2023\n            mock_datetime.datetime.now.return_value.year = 2023\n            mock_datetime.datetime.side_effect = datetime\n            \n            # Four-digit years should work exactly as before\n            parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n            \n            parsed = parse_http_date('Sun, 06 Nov 2025 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2025, 11, 6, 8, 49, 37))\n\n    def test_parse_http_date_safe_with_rfc7231_compliance(self):\n        \"\"\"\n        Test that parse_http_date_safe also follows RFC 7231 compliance.\n        \"\"\"\n        with mock.patch('django.utils.http.datetime') as mock_datetime:\n            # Mock current year as 2023\n            mock_datetime.datetime.now.return_value.year = 2023\n            mock_datetime.datetime.side_effect = datetime\n            \n            # Valid date that should be parsed according to RFC 7231\n            parsed = parse_http_date_safe('Sun, 06 Nov 25 08:49:37 GMT')\n            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2025, 11, 6, 8, 49, 37))\n            \n            # Invalid date should return None\n            parsed = parse_http_date_safe('Invalid date string')\n            self.assertIsNone(parsed)\n</patched>\n```",
  "patch": "--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n-import unittest\n-from datetime import datetime\n-from unittest import mock\n-\n-from django.test import SimpleTestCase\n-from django.utils.http import (\n-    base36_to_int, escape_uri_path, http_date, int_to_base36, is_safe_url,\n-    parse_etags, parse_http_date, parse_http_date_safe, quote_etag,\n-    urlencode, urlquote, urlquote_plus, urlsafe_base64_decode,\n-    urlsafe_base64_encode, urlunquote, urlunquote_plus,\n-)\n-\n-\n-class HttpDateProcessingTests(SimpleTestCase):\n-    def test_http_date(self):\n-        t = 1167616461.0\n-        self.assertEqual(http_date(t), 'Mon, 01 Jan 2007 01:54:21 GMT')\n-\n-    def test_parsing_rfc1123(self):\n-        parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n-\n-    def test_parsing_rfc850(self):\n-        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n-\n-    def test_parsing_asctime(self):\n-        parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n-\n-    def test_parsing_year_less_than_70(self):\n-        # This should be 2005, not 1905\n-        parsed = parse_http_date('Sun, 06 Nov 05 08:49:37 GMT')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2005, 11, 6, 8, 49, 37))\n-\n-    def test_parsing_year_greater_than_70(self):\n-        parsed = parse_http_date('Sun, 06 Nov 94 08:49:37 GMT')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n-\n-    def test_parsing_rfc850_year_less_than_70(self):\n-        parsed = parse_http_date('Sunday, 06-Nov-05 08:49:37 GMT')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2005, 11, 6, 8, 49, 37))\n-\n-    def test_parsing_rfc850_year_greater_than_70(self):\n-        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+import unittest\n+from datetime import datetime\n+from unittest import mock\n+\n+from django.test import SimpleTestCase\n+from django.utils.http import (\n+    base36_to_int, escape_uri_path, http_date, int_to_base36, is_safe_url,\n+    parse_etags, parse_http_date, parse_http_date_safe, quote_etag,\n+    urlencode, urlquote, urlquote_plus, urlsafe_base64_decode,\n+    urlsafe_base64_encode, urlunquote, urlunquote_plus,\n+)\n+\n+\n+class HttpDateProcessingTests(SimpleTestCase):\n+    def test_http_date(self):\n+        t = 1167616461.0\n+        self.assertEqual(http_date(t), 'Mon, 01 Jan 2007 01:54:21 GMT')\n+\n+    def test_parsing_rfc1123(self):\n+        parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+\n+    def test_parsing_rfc850(self):\n+        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+\n+    def test_parsing_asctime(self):\n+        parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+\n+    def test_parsing_year_less_than_70(self):\n+        # This should be 2005, not 1905\n+        parsed = parse_http_date('Sun, 06 Nov 05 08:49:37 GMT')\n+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2005, 11, 6, 8, 49, 37))\n+\n+    def test_parsing_year_greater_than_70(self):\n+        parsed = parse_http_date('Sun, 06 Nov 94 08:49:37 GMT')\n+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+\n+    def test_parsing_rfc850_year_less_than_70(self):\n+        parsed = parse_http_date('Sunday, 06-Nov-05 08:49:37 GMT')\n+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2005, 11, 6, 8, 49, 37))\n+\n+    def test_parsing_rfc850_year_greater_than_70(self):\n+        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+\n+    def test_two_digit_year_rfc7231_compliance_current_year_2023(self):\n+        \"\"\"\n+        Test RFC 7231 compliance for two-digit years when current year is 2023.\n+        Years that would be more than 50 years in the future should be \n+        interpreted as being in the past century.\n+        \"\"\"\n+        with mock.patch('django.utils.http.datetime') as mock_datetime:\n+            # Mock current year as 2023\n+            mock_datetime.datetime.now.return_value.year = 2023\n+            mock_datetime.datetime.side_effect = datetime\n+            \n+            # Year 25 -> should be 2025 (not more than 50 years in future)\n+            parsed = parse_http_date('Sun, 06 Nov 25 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2025, 11, 6, 8, 49, 37))\n+            \n+            # Year 73 -> should be 2073 (exactly 50 years in future, allowed)\n+            parsed = parse_http_date('Sun, 06 Nov 73 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2073, 11, 6, 8, 49, 37))\n+            \n+            # Year 74 -> should be 1974 (would be 51 years in future, so interpret as past)\n+            parsed = parse_http_date('Sun, 06 Nov 74 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1974, 11, 6, 8, 49, 37))\n+\n+    def test_two_digit_year_rfc7231_compliance_current_year_2050(self):\n+        \"\"\"\n+        Test RFC 7231 compliance for two-digit years when current year is 2050.\n+        This tests the dynamic nature of the 50-year rule.\n+        \"\"\"\n+        with mock.patch('django.utils.http.datetime') as mock_datetime:\n+            # Mock current year as 2050\n+            mock_datetime.datetime.now.return_value.year = 2050\n+            mock_datetime.datetime.side_effect = datetime\n+            \n+            # Year 00 -> should be 2100 (exactly 50 years in future, allowed)\n+            parsed = parse_http_date('Sun, 06 Nov 00 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2100, 11, 6, 8, 49, 37))\n+            \n+            # Year 01 -> should be 2001 (would be 51 years in future, so interpret as past)\n+            parsed = parse_http_date('Sun, 06 Nov 01 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2001, 11, 6, 8, 49, 37))\n+            \n+            # Year 49 -> should be 2049 (1 year in past, recent past)\n+            parsed = parse_http_date('Sun, 06 Nov 49 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2049, 11, 6, 8, 49, 37))\n+\n+    def test_two_digit_year_rfc7231_compliance_edge_cases(self):\n+        \"\"\"\n+        Test edge cases for RFC 7231 two-digit year handling.\n+        \"\"\"\n+        with mock.patch('django.utils.http.datetime') as mock_datetime:\n+            # Mock current year as 2023\n+            mock_datetime.datetime.now.return_value.year = 2023\n+            mock_datetime.datetime.side_effect = datetime\n+            \n+            # Year 23 -> should be 2023 (current year)\n+            parsed = parse_http_date('Sun, 06 Nov 23 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2023, 11, 6, 8, 49, 37))\n+            \n+            # Year 22 -> should be 2022 (1 year in past)\n+            parsed = parse_http_date('Sun, 06 Nov 22 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2022, 11, 6, 8, 49, 37))\n+            \n+            # Year 24 -> should be 2024 (1 year in future)\n+            parsed = parse_http_date('Sun, 06 Nov 24 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2024, 11, 6, 8, 49, 37))\n+\n+    def test_two_digit_year_rfc850_format_rfc7231_compliance(self):\n+        \"\"\"\n+        Test RFC 7231 compliance specifically for RFC 850 date format.\n+        \"\"\"\n+        with mock.patch('django.utils.http.datetime') as mock_datetime:\n+            # Mock current year as 2023\n+            mock_datetime.datetime.now.return_value.year = 2023\n+            mock_datetime.datetime.side_effect = datetime\n+            \n+            # Year 25 -> should be 2025 (RFC 850 format)\n+            parsed = parse_http_date('Sunday, 06-Nov-25 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2025, 11, 6, 8, 49, 37))\n+            \n+            # Year 74 -> should be 1974 (RFC 850 format)\n+            parsed = parse_http_date('Sunday, 06-Nov-74 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1974, 11, 6, 8, 49, 37))\n+\n+    def test_two_digit_year_hardcoded_behavior_fails_rfc7231(self):\n+        \"\"\"\n+        This test demonstrates the bug in the current hardcoded implementation.\n+        It should fail before the fix is applied, showing that the current\n+        implementation doesn't follow RFC 7231.\n+        \"\"\"\n+        # This test will fail with the current hardcoded implementation\n+        # but should pass after implementing RFC 7231 compliance\n+        \n+        # Simulate a future year where the hardcoded logic would be wrong\n+        with mock.patch('django.utils.http.datetime') as mock_datetime:\n+            # Mock current year as 2080\n+            mock_datetime.datetime.now.return_value.year = 2080\n+            mock_datetime.datetime.side_effect = datetime\n+            \n+            # With current hardcoded logic: year 30 -> 2030 (50 years in past, should be correct)\n+            # But year 69 -> 2069 (11 years in past, should be correct)\n+            # But year 70 -> 1970 (110 years in past, this is wrong per RFC 7231)\n+            # Year 70 should be 2070 (10 years in past) according to RFC 7231\n+            \n+            # This will currently return 1970 but should return 2070\n+            parsed = parse_http_date('Sun, 06 Nov 70 08:49:37 GMT')\n+            # The current implementation will make this assertion fail\n+            # because it returns 1970 instead of 2070\n+            try:\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2070, 11, 6, 8, 49, 37))\n+                self.fail(\"This test should fail with the current hardcoded implementation\")\n+            except AssertionError:\n+                # Expected to fail with current implementation\n+                # Verify it actually returns 1970 (the buggy behavior)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1970, 11, 6, 8, 49, 37))\n+\n+    def test_four_digit_years_unchanged(self):\n+        \"\"\"\n+        Test that four-digit years are not affected by the RFC 7231 changes.\n+        \"\"\"\n+        with mock.patch('django.utils.http.datetime') as mock_datetime:\n+            # Mock current year as 2023\n+            mock_datetime.datetime.now.return_value.year = 2023\n+            mock_datetime.datetime.side_effect = datetime\n+            \n+            # Four-digit years should work exactly as before\n+            parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+            \n+            parsed = parse_http_date('Sun, 06 Nov 2025 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2025, 11, 6, 8, 49, 37))\n+\n+    def test_parse_http_date_safe_with_rfc7231_compliance(self):\n+        \"\"\"\n+        Test that parse_http_date_safe also follows RFC 7231 compliance.\n+        \"\"\"\n+        with mock.patch('django.utils.http.datetime') as mock_datetime:\n+            # Mock current year as 2023\n+            mock_datetime.datetime.now.return_value.year = 2023\n+            mock_datetime.datetime.side_effect = datetime\n+            \n+            # Valid date that should be parsed according to RFC 7231\n+            parsed = parse_http_date_safe('Sun, 06 Nov 25 08:49:37 GMT')\n+            self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2025, 11, 6, 8, 49, 37))\n+            \n+            # Invalid date should return None\n+            parsed = parse_http_date_safe('Invalid date string')\n+            self.assertIsNone(parsed)\n"
}