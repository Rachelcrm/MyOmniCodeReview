{
  "instance_id": "django__django-15987",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/management_commands/test_loaddata.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport os\nimport tempfile\nfrom pathlib import Path\nfrom unittest import mock\n\nimport pytest\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.management import call_command\nfrom django.core.management.commands.loaddata import Command\nfrom django.test import TestCase, override_settings\n\n\nclass LoadDataFixtureDirsTests(TestCase):\n    \"\"\"Test fixture directory handling in loaddata command.\"\"\"\n\n    def setUp(self):\n        self.command = Command()\n        self.temp_dir1 = tempfile.mkdtemp()\n        self.temp_dir2 = tempfile.mkdtemp()\n        \n    def tearDown(self):\n        # Clean up temporary directories\n        import shutil\n        shutil.rmtree(self.temp_dir1, ignore_errors=True)\n        shutil.rmtree(self.temp_dir2, ignore_errors=True)\n\n    def test_fixture_dirs_duplicate_detection_with_strings(self):\n        \"\"\"Test that duplicate string paths are detected correctly.\"\"\"\n        duplicate_dirs = [self.temp_dir1, self.temp_dir1]\n        \n        with override_settings(FIXTURE_DIRS=duplicate_dirs):\n            with self.assertRaises(ImproperlyConfigured) as cm:\n                self.command.fixture_dirs\n            self.assertIn(\"contains duplicates\", str(cm.exception))\n\n    def test_fixture_dirs_duplicate_detection_with_path_objects_fails_before_fix(self):\n        \"\"\"Test that demonstrates the bug: Path objects bypass duplicate detection.\"\"\"\n        # This test should fail before the fix is applied\n        duplicate_dirs = [Path(self.temp_dir1), Path(self.temp_dir1)]\n        \n        with override_settings(FIXTURE_DIRS=duplicate_dirs):\n            # Before the fix, this should NOT raise an exception (demonstrating the bug)\n            # After the fix, this SHOULD raise an exception\n            try:\n                dirs = self.command.fixture_dirs\n                # If we get here without exception, the bug exists\n                # This assertion will fail after the fix is applied\n                self.assertTrue(True, \"Bug exists: Path duplicates not detected\")\n            except ImproperlyConfigured:\n                # After fix, this should happen\n                self.fail(\"Fix applied: Path duplicates are now detected\")\n\n    def test_fixture_dirs_duplicate_detection_with_path_objects_after_fix(self):\n        \"\"\"Test that Path object duplicates are detected after fix.\"\"\"\n        duplicate_dirs = [Path(self.temp_dir1), Path(self.temp_dir1)]\n        \n        with override_settings(FIXTURE_DIRS=duplicate_dirs):\n            with self.assertRaises(ImproperlyConfigured) as cm:\n                self.command.fixture_dirs\n            self.assertIn(\"contains duplicates\", str(cm.exception))\n\n    def test_fixture_dirs_mixed_string_and_path_duplicates(self):\n        \"\"\"Test that duplicates are detected when mixing strings and Path objects.\"\"\"\n        mixed_dirs = [self.temp_dir1, Path(self.temp_dir1)]\n        \n        with override_settings(FIXTURE_DIRS=mixed_dirs):\n            with self.assertRaises(ImproperlyConfigured) as cm:\n                self.command.fixture_dirs\n            self.assertIn(\"contains duplicates\", str(cm.exception))\n\n    def test_fixture_dirs_no_duplicates_with_path_objects(self):\n        \"\"\"Test that no exception is raised when Path objects point to different directories.\"\"\"\n        different_dirs = [Path(self.temp_dir1), Path(self.temp_dir2)]\n        \n        with override_settings(FIXTURE_DIRS=different_dirs):\n            # This should not raise an exception\n            dirs = self.command.fixture_dirs\n            self.assertIsInstance(dirs, list)\n\n    def test_fixture_dirs_no_duplicates_with_strings(self):\n        \"\"\"Test that no exception is raised when string paths point to different directories.\"\"\"\n        different_dirs = [self.temp_dir1, self.temp_dir2]\n        \n        with override_settings(FIXTURE_DIRS=different_dirs):\n            # This should not raise an exception\n            dirs = self.command.fixture_dirs\n            self.assertIsInstance(dirs, list)\n\n    def test_fixture_dirs_empty_list(self):\n        \"\"\"Test that empty FIXTURE_DIRS works correctly.\"\"\"\n        with override_settings(FIXTURE_DIRS=[]):\n            dirs = self.command.fixture_dirs\n            self.assertIsInstance(dirs, list)\n\n    def test_fixture_dirs_single_path_object(self):\n        \"\"\"Test that a single Path object works correctly.\"\"\"\n        single_dir = [Path(self.temp_dir1)]\n        \n        with override_settings(FIXTURE_DIRS=single_dir):\n            dirs = self.command.fixture_dirs\n            self.assertIsInstance(dirs, list)\n\n    def test_fixture_dirs_relative_path_duplicates(self):\n        \"\"\"Test duplicate detection with relative paths.\"\"\"\n        # Create relative paths that point to the same directory\n        with tempfile.TemporaryDirectory() as temp_dir:\n            os.chdir(temp_dir)\n            os.makedirs(\"fixtures\", exist_ok=True)\n            \n            duplicate_dirs = [Path(\"fixtures\"), Path(\"./fixtures\")]\n            \n            with override_settings(FIXTURE_DIRS=duplicate_dirs):\n                with self.assertRaises(ImproperlyConfigured) as cm:\n                    self.command.fixture_dirs\n                self.assertIn(\"contains duplicates\", str(cm.exception))\n\n    def test_fixture_dirs_absolute_vs_relative_same_path(self):\n        \"\"\"Test duplicate detection between absolute and relative paths.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            fixtures_dir = os.path.join(temp_dir, \"fixtures\")\n            os.makedirs(fixtures_dir, exist_ok=True)\n            os.chdir(temp_dir)\n            \n            duplicate_dirs = [Path(fixtures_dir), Path(\"fixtures\")]\n            \n            with override_settings(FIXTURE_DIRS=duplicate_dirs):\n                with self.assertRaises(ImproperlyConfigured) as cm:\n                    self.command.fixture_dirs\n                self.assertIn(\"contains duplicates\", str(cm.exception))\n\n    def test_fixture_dirs_symlink_duplicates(self):\n        \"\"\"Test duplicate detection with symlinks.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            real_dir = os.path.join(temp_dir, \"real_fixtures\")\n            link_dir = os.path.join(temp_dir, \"link_fixtures\")\n            os.makedirs(real_dir)\n            \n            try:\n                os.symlink(real_dir, link_dir)\n                duplicate_dirs = [Path(real_dir), Path(link_dir)]\n                \n                with override_settings(FIXTURE_DIRS=duplicate_dirs):\n                    # The fixture_dirs method uses os.path.realpath, so symlinks\n                    # should be resolved and duplicates detected\n                    with self.assertRaises(ImproperlyConfigured) as cm:\n                        self.command.fixture_dirs\n                    self.assertIn(\"contains duplicates\", str(cm.exception))\n            except OSError:\n                # Skip test if symlinks are not supported on this platform\n                self.skipTest(\"Symlinks not supported on this platform\")\n\n    @mock.patch('django.core.management.commands.loaddata.apps.get_app_configs')\n    def test_fixture_dirs_app_dir_conflict_with_path_objects(self, mock_get_app_configs):\n        \"\"\"Test that app fixture directory conflicts are detected with Path objects.\"\"\"\n        # Mock an app config\n        mock_app_config = mock.Mock()\n        mock_app_config.label = 'testapp'\n        mock_app_config.path = self.temp_dir1\n        mock_get_app_configs.return_value = [mock_app_config]\n        \n        app_fixtures_dir = os.path.join(self.temp_dir1, \"fixtures\")\n        os.makedirs(app_fixtures_dir, exist_ok=True)\n        \n        # Use Path object that conflicts with app fixture directory\n        conflicting_dirs = [Path(app_fixtures_dir)]\n        \n        with override_settings(FIXTURE_DIRS=conflicting_dirs):\n            with self.assertRaises(ImproperlyConfigured) as cm:\n                self.command.fixture_dirs\n            self.assertIn(\"is a default fixture directory\", str(cm.exception))\n            self.assertIn(\"testapp\", str(cm.exception))\n\n\nclass LoadDataCommandIntegrationTests(TestCase):\n    \"\"\"Integration tests for loaddata command with Path objects in FIXTURE_DIRS.\"\"\"\n\n    def setUp(self):\n        self.temp_dir = tempfile.mkdtemp()\n        \n    def tearDown(self):\n        import shutil\n        shutil.rmtree(self.temp_dir, ignore_errors=True)\n\n    def test_loaddata_command_with_path_object_fixture_dirs(self):\n        \"\"\"Test that loaddata command works with Path objects in FIXTURE_DIRS.\"\"\"\n        fixture_content = '''[\n    {\n        \"model\": \"auth.user\",\n        \"pk\": 1,\n        \"fields\": {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"is_active\": true,\n            \"is_staff\": false,\n            \"is_superuser\": false\n        }\n    }\n]'''\n        \n        # Create a fixture file\n        fixture_file = os.path.join(self.temp_dir, \"test_fixture.json\")\n        with open(fixture_file, 'w') as f:\n            f.write(fixture_content)\n        \n        # Test with Path object in FIXTURE_DIRS\n        with override_settings(FIXTURE_DIRS=[Path(self.temp_dir)]):\n            # This should work without raising an exception\n            try:\n                call_command('loaddata', 'test_fixture', verbosity=0)\n            except Exception as e:\n                # If it fails, it should not be due to Path object handling\n                self.assertNotIn(\"Path\", str(e))\n                self.assertNotIn(\"duplicate\", str(e).lower())\n</patched>\n</file>\n```",
  "patch": "--- a/tests/management_commands/test_loaddata.py\n+++ b/tests/management_commands/test_loaddata.py\n-# Empty if creating new file\n+import os\n+import tempfile\n+from pathlib import Path\n+from unittest import mock\n+\n+import pytest\n+from django.conf import settings\n+from django.core.exceptions import ImproperlyConfigured\n+from django.core.management import call_command\n+from django.core.management.commands.loaddata import Command\n+from django.test import TestCase, override_settings\n+\n+\n+class LoadDataFixtureDirsTests(TestCase):\n+    \"\"\"Test fixture directory handling in loaddata command.\"\"\"\n+\n+    def setUp(self):\n+        self.command = Command()\n+        self.temp_dir1 = tempfile.mkdtemp()\n+        self.temp_dir2 = tempfile.mkdtemp()\n+        \n+    def tearDown(self):\n+        # Clean up temporary directories\n+        import shutil\n+        shutil.rmtree(self.temp_dir1, ignore_errors=True)\n+        shutil.rmtree(self.temp_dir2, ignore_errors=True)\n+\n+    def test_fixture_dirs_duplicate_detection_with_strings(self):\n+        \"\"\"Test that duplicate string paths are detected correctly.\"\"\"\n+        duplicate_dirs = [self.temp_dir1, self.temp_dir1]\n+        \n+        with override_settings(FIXTURE_DIRS=duplicate_dirs):\n+            with self.assertRaises(ImproperlyConfigured) as cm:\n+                self.command.fixture_dirs\n+            self.assertIn(\"contains duplicates\", str(cm.exception))\n+\n+    def test_fixture_dirs_duplicate_detection_with_path_objects_fails_before_fix(self):\n+        \"\"\"Test that demonstrates the bug: Path objects bypass duplicate detection.\"\"\"\n+        # This test should fail before the fix is applied\n+        duplicate_dirs = [Path(self.temp_dir1), Path(self.temp_dir1)]\n+        \n+        with override_settings(FIXTURE_DIRS=duplicate_dirs):\n+            # Before the fix, this should NOT raise an exception (demonstrating the bug)\n+            # After the fix, this SHOULD raise an exception\n+            try:\n+                dirs = self.command.fixture_dirs\n+                # If we get here without exception, the bug exists\n+                # This assertion will fail after the fix is applied\n+                self.assertTrue(True, \"Bug exists: Path duplicates not detected\")\n+            except ImproperlyConfigured:\n+                # After fix, this should happen\n+                self.fail(\"Fix applied: Path duplicates are now detected\")\n+\n+    def test_fixture_dirs_duplicate_detection_with_path_objects_after_fix(self):\n+        \"\"\"Test that Path object duplicates are detected after fix.\"\"\"\n+        duplicate_dirs = [Path(self.temp_dir1), Path(self.temp_dir1)]\n+        \n+        with override_settings(FIXTURE_DIRS=duplicate_dirs):\n+            with self.assertRaises(ImproperlyConfigured) as cm:\n+                self.command.fixture_dirs\n+            self.assertIn(\"contains duplicates\", str(cm.exception))\n+\n+    def test_fixture_dirs_mixed_string_and_path_duplicates(self):\n+        \"\"\"Test that duplicates are detected when mixing strings and Path objects.\"\"\"\n+        mixed_dirs = [self.temp_dir1, Path(self.temp_dir1)]\n+        \n+        with override_settings(FIXTURE_DIRS=mixed_dirs):\n+            with self.assertRaises(ImproperlyConfigured) as cm:\n+                self.command.fixture_dirs\n+            self.assertIn(\"contains duplicates\", str(cm.exception))\n+\n+    def test_fixture_dirs_no_duplicates_with_path_objects(self):\n+        \"\"\"Test that no exception is raised when Path objects point to different directories.\"\"\"\n+        different_dirs = [Path(self.temp_dir1), Path(self.temp_dir2)]\n+        \n+        with override_settings(FIXTURE_DIRS=different_dirs):\n+            # This should not raise an exception\n+            dirs = self.command.fixture_dirs\n+            self.assertIsInstance(dirs, list)\n+\n+    def test_fixture_dirs_no_duplicates_with_strings(self):\n+        \"\"\"Test that no exception is raised when string paths point to different directories.\"\"\"\n+        different_dirs = [self.temp_dir1, self.temp_dir2]\n+        \n+        with override_settings(FIXTURE_DIRS=different_dirs):\n+            # This should not raise an exception\n+            dirs = self.command.fixture_dirs\n+            self.assertIsInstance(dirs, list)\n+\n+    def test_fixture_dirs_empty_list(self):\n+        \"\"\"Test that empty FIXTURE_DIRS works correctly.\"\"\"\n+        with override_settings(FIXTURE_DIRS=[]):\n+            dirs = self.command.fixture_dirs\n+            self.assertIsInstance(dirs, list)\n+\n+    def test_fixture_dirs_single_path_object(self):\n+        \"\"\"Test that a single Path object works correctly.\"\"\"\n+        single_dir = [Path(self.temp_dir1)]\n+        \n+        with override_settings(FIXTURE_DIRS=single_dir):\n+            dirs = self.command.fixture_dirs\n+            self.assertIsInstance(dirs, list)\n+\n+    def test_fixture_dirs_relative_path_duplicates(self):\n+        \"\"\"Test duplicate detection with relative paths.\"\"\"\n+        # Create relative paths that point to the same directory\n+        with tempfile.TemporaryDirectory() as temp_dir:\n+            os.chdir(temp_dir)\n+            os.makedirs(\"fixtures\", exist_ok=True)\n+            \n+            duplicate_dirs = [Path(\"fixtures\"), Path(\"./fixtures\")]\n+            \n+            with override_settings(FIXTURE_DIRS=duplicate_dirs):\n+                with self.assertRaises(ImproperlyConfigured) as cm:\n+                    self.command.fixture_dirs\n+                self.assertIn(\"contains duplicates\", str(cm.exception))\n+\n+    def test_fixture_dirs_absolute_vs_relative_same_path(self):\n+        \"\"\"Test duplicate detection between absolute and relative paths.\"\"\"\n+        with tempfile.TemporaryDirectory() as temp_dir:\n+            fixtures_dir = os.path.join(temp_dir, \"fixtures\")\n+            os.makedirs(fixtures_dir, exist_ok=True)\n+            os.chdir(temp_dir)\n+            \n+            duplicate_dirs = [Path(fixtures_dir), Path(\"fixtures\")]\n+            \n+            with override_settings(FIXTURE_DIRS=duplicate_dirs):\n+                with self.assertRaises(ImproperlyConfigured) as cm:\n+                    self.command.fixture_dirs\n+                self.assertIn(\"contains duplicates\", str(cm.exception))\n+\n+    def test_fixture_dirs_symlink_duplicates(self):\n+        \"\"\"Test duplicate detection with symlinks.\"\"\"\n+        with tempfile.TemporaryDirectory() as temp_dir:\n+            real_dir = os.path.join(temp_dir, \"real_fixtures\")\n+            link_dir = os.path.join(temp_dir, \"link_fixtures\")\n+            os.makedirs(real_dir)\n+            \n+            try:\n+                os.symlink(real_dir, link_dir)\n+                duplicate_dirs = [Path(real_dir), Path(link_dir)]\n+                \n+                with override_settings(FIXTURE_DIRS=duplicate_dirs):\n+                    # The fixture_dirs method uses os.path.realpath, so symlinks\n+                    # should be resolved and duplicates detected\n+                    with self.assertRaises(ImproperlyConfigured) as cm:\n+                        self.command.fixture_dirs\n+                    self.assertIn(\"contains duplicates\", str(cm.exception))\n+            except OSError:\n+                # Skip test if symlinks are not supported on this platform\n+                self.skipTest(\"Symlinks not supported on this platform\")\n+\n+    @mock.patch('django.core.management.commands.loaddata.apps.get_app_configs')\n+    def test_fixture_dirs_app_dir_conflict_with_path_objects(self, mock_get_app_configs):\n+        \"\"\"Test that app fixture directory conflicts are detected with Path objects.\"\"\"\n+        # Mock an app config\n+        mock_app_config = mock.Mock()\n+        mock_app_config.label = 'testapp'\n+        mock_app_config.path = self.temp_dir1\n+        mock_get_app_configs.return_value = [mock_app_config]\n+        \n+        app_fixtures_dir = os.path.join(self.temp_dir1, \"fixtures\")\n+        os.makedirs(app_fixtures_dir, exist_ok=True)\n+        \n+        # Use Path object that conflicts with app fixture directory\n+        conflicting_dirs = [Path(app_fixtures_dir)]\n+        \n+        with override_settings(FIXTURE_DIRS=conflicting_dirs):\n+            with self.assertRaises(ImproperlyConfigured) as cm:\n+                self.command.fixture_dirs\n+            self.assertIn(\"is a default fixture directory\", str(cm.exception))\n+            self.assertIn(\"testapp\", str(cm.exception))\n+\n+\n+class LoadDataCommandIntegrationTests(TestCase):\n+    \"\"\"Integration tests for loaddata command with Path objects in FIXTURE_DIRS.\"\"\"\n+\n+    def setUp(self):\n+        self.temp_dir = tempfile.mkdtemp()\n+        \n+    def tearDown(self):\n+        import shutil\n+        shutil.rmtree(self.temp_dir, ignore_errors=True)\n+\n+    def test_loaddata_command_with_path_object_fixture_dirs(self):\n+        \"\"\"Test that loaddata command works with Path objects in FIXTURE_DIRS.\"\"\"\n+        fixture_content = '''[\n+    {\n+        \"model\": \"auth.user\",\n+        \"pk\": 1,\n+        \"fields\": {\n+            \"username\": \"testuser\",\n+            \"email\": \"test@example.com\",\n+            \"is_active\": true,\n+            \"is_staff\": false,\n+            \"is_superuser\": false\n+        }\n+    }\n+]'''\n+        \n+        # Create a fixture file\n+        fixture_file = os.path.join(self.temp_dir, \"test_fixture.json\")\n+        with open(fixture_file, 'w') as f:\n+            f.write(fixture_content)\n+        \n+        # Test with Path object in FIXTURE_DIRS\n+        with override_settings(FIXTURE_DIRS=[Path(self.temp_dir)]):\n+            # This should work without raising an exception\n+            try:\n+                call_command('loaddata', 'test_fixture', verbosity=0)\n+            except Exception as e:\n+                # If it fails, it should not be due to Path object handling\n+                self.assertNotIn(\"Path\", str(e))\n+                self.assertNotIn(\"duplicate\", str(e).lower())\n"
}