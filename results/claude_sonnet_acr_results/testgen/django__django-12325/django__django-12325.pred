{
  "instance_id": "django__django-12325",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_inheritance/test_mti_parent_link_order.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db import models\nfrom django.test import TestCase\n\n\nclass MTIParentLinkOrderTests(TestCase):\n    \"\"\"\n    Test cases for Model-Table Inheritance (MTI) parent link field ordering bug.\n    \n    The issue is that when a model has multiple OneToOneField references to the\n    same parent model, the order of field declaration affects whether Django\n    correctly identifies the parent link field marked with parent_link=True.\n    \"\"\"\n\n    def test_parent_link_after_other_onetoonefield_fails_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: when parent_link=True field is declared\n        after another OneToOneField to the same parent, it raises ImproperlyConfigured.\n        \n        This test should fail before the fix is applied.\n        \"\"\"\n        with self.assertRaises(ImproperlyConfigured) as cm:\n            class Document(models.Model):\n                class Meta:\n                    app_label = 'test_app'\n\n            class Picking(Document):\n                # This OneToOneField is declared first but doesn't have parent_link=True\n                origin = models.OneToOneField(\n                    Document, \n                    related_name='picking', \n                    on_delete=models.PROTECT\n                )\n                # This OneToOneField has parent_link=True but is declared second\n                document_ptr = models.OneToOneField(\n                    Document, \n                    on_delete=models.CASCADE, \n                    parent_link=True, \n                    related_name='+'\n                )\n                \n                class Meta:\n                    app_label = 'test_app'\n\n        # The error message should mention adding parent_link=True to the origin field\n        self.assertIn('Add parent_link=True to', str(cm.exception))\n        self.assertIn('origin', str(cm.exception))\n\n    def test_parent_link_before_other_onetoonefield_works(self):\n        \"\"\"\n        Test that when parent_link=True field is declared before other OneToOneFields,\n        it works correctly (this is the current workaround).\n        \"\"\"\n        try:\n            class Document(models.Model):\n                class Meta:\n                    app_label = 'test_app'\n\n            class Picking(Document):\n                # This OneToOneField has parent_link=True and is declared first\n                document_ptr = models.OneToOneField(\n                    Document, \n                    on_delete=models.CASCADE, \n                    parent_link=True, \n                    related_name='+'\n                )\n                # This OneToOneField is declared second but doesn't have parent_link=True\n                origin = models.OneToOneField(\n                    Document, \n                    related_name='picking', \n                    on_delete=models.PROTECT\n                )\n                \n                class Meta:\n                    app_label = 'test_app'\n                    \n            # Should not raise any exception\n            self.assertTrue(hasattr(Picking, 'document_ptr'))\n            self.assertTrue(hasattr(Picking, 'origin'))\n            \n        except ImproperlyConfigured:\n            self.fail(\"Should not raise ImproperlyConfigured when parent_link field is first\")\n\n    def test_parent_link_after_other_onetoonefield_works_after_fix(self):\n        \"\"\"\n        Test that after the fix, parent_link=True field can be declared in any order\n        and Django will correctly identify it as the parent link.\n        \n        This test should pass after the fix is applied.\n        \"\"\"\n        try:\n            class Document(models.Model):\n                class Meta:\n                    app_label = 'test_app'\n\n            class Picking(Document):\n                # This OneToOneField is declared first but doesn't have parent_link=True\n                origin = models.OneToOneField(\n                    Document, \n                    related_name='picking', \n                    on_delete=models.PROTECT\n                )\n                # This OneToOneField has parent_link=True but is declared second\n                document_ptr = models.OneToOneField(\n                    Document, \n                    on_delete=models.CASCADE, \n                    parent_link=True, \n                    related_name='+'\n                )\n                \n                class Meta:\n                    app_label = 'test_app'\n                    \n            # Should not raise any exception after fix\n            self.assertTrue(hasattr(Picking, 'document_ptr'))\n            self.assertTrue(hasattr(Picking, 'origin'))\n            \n            # Verify that the correct field is used as primary key\n            self.assertTrue(Picking._meta.pk.remote_field.parent_link)\n            self.assertEqual(Picking._meta.pk.name, 'document_ptr')\n            \n        except ImproperlyConfigured:\n            self.fail(\"Should not raise ImproperlyConfigured after fix regardless of field order\")\n\n    def test_multiple_onetoonefield_no_parent_link_raises_error(self):\n        \"\"\"\n        Test that when there are multiple OneToOneFields to parent but none\n        has parent_link=True, it raises ImproperlyConfigured.\n        \"\"\"\n        with self.assertRaises(ImproperlyConfigured) as cm:\n            class Document(models.Model):\n                class Meta:\n                    app_label = 'test_app'\n\n            class Picking(Document):\n                # Neither field has parent_link=True\n                origin = models.OneToOneField(\n                    Document, \n                    related_name='picking', \n                    on_delete=models.PROTECT\n                )\n                reference = models.OneToOneField(\n                    Document, \n                    related_name='reference_picking', \n                    on_delete=models.PROTECT\n                )\n                \n                class Meta:\n                    app_label = 'test_app'\n\n        self.assertIn('Add parent_link=True', str(cm.exception))\n\n    def test_single_onetoonefield_without_parent_link_works(self):\n        \"\"\"\n        Test that when there's only one OneToOneField to parent without\n        parent_link=True, it should work (Django auto-detects it).\n        \"\"\"\n        try:\n            class Document(models.Model):\n                class Meta:\n                    app_label = 'test_app'\n\n            class Picking(Document):\n                # Single OneToOneField without explicit parent_link=True\n                # Django should auto-detect this as the parent link\n                document_ptr = models.OneToOneField(\n                    Document, \n                    on_delete=models.CASCADE, \n                    related_name='+'\n                )\n                \n                class Meta:\n                    app_label = 'test_app'\n                    \n            # Should work fine\n            self.assertTrue(hasattr(Picking, 'document_ptr'))\n            \n        except ImproperlyConfigured:\n            self.fail(\"Should not raise ImproperlyConfigured for single OneToOneField\")\n\n    def test_parent_link_field_order_independence_complex(self):\n        \"\"\"\n        Test a more complex scenario with multiple OneToOneFields where\n        parent_link=True field is in the middle of the declaration order.\n        \"\"\"\n        try:\n            class Document(models.Model):\n                class Meta:\n                    app_label = 'test_app'\n\n            class Picking(Document):\n                # First OneToOneField - not parent link\n                origin = models.OneToOneField(\n                    Document, \n                    related_name='picking_origin', \n                    on_delete=models.PROTECT\n                )\n                # Second OneToOneField - this is the parent link\n                document_ptr = models.OneToOneField(\n                    Document, \n                    on_delete=models.CASCADE, \n                    parent_link=True, \n                    related_name='+'\n                )\n                # Third OneToOneField - not parent link\n                reference = models.OneToOneField(\n                    Document, \n                    related_name='picking_reference', \n                    on_delete=models.PROTECT\n                )\n                \n                class Meta:\n                    app_label = 'test_app'\n                    \n            # Should work after fix regardless of order\n            self.assertTrue(hasattr(Picking, 'document_ptr'))\n            self.assertTrue(hasattr(Picking, 'origin'))\n            self.assertTrue(hasattr(Picking, 'reference'))\n            \n            # Verify correct parent link is identified\n            self.assertTrue(Picking._meta.pk.remote_field.parent_link)\n            self.assertEqual(Picking._meta.pk.name, 'document_ptr')\n            \n        except ImproperlyConfigured:\n            self.fail(\"Should not raise ImproperlyConfigured after fix with complex field order\")\n\n    def test_edge_case_parent_link_last_position(self):\n        \"\"\"\n        Test edge case where parent_link=True field is declared last.\n        \"\"\"\n        try:\n            class Document(models.Model):\n                class Meta:\n                    app_label = 'test_app'\n\n            class Picking(Document):\n                # Multiple OneToOneFields before the parent link\n                origin = models.OneToOneField(\n                    Document, \n                    related_name='picking_origin', \n                    on_delete=models.PROTECT\n                )\n                reference = models.OneToOneField(\n                    Document, \n                    related_name='picking_reference', \n                    on_delete=models.PROTECT\n                )\n                source = models.OneToOneField(\n                    Document, \n                    related_name='picking_source', \n                    on_delete=models.PROTECT\n                )\n                # Parent link field declared last\n                document_ptr = models.OneToOneField(\n                    Document, \n                    on_delete=models.CASCADE, \n                    parent_link=True, \n                    related_name='+'\n                )\n                \n                class Meta:\n                    app_label = 'test_app'\n                    \n            # Should work after fix\n            self.assertTrue(hasattr(Picking, 'document_ptr'))\n            self.assertEqual(Picking._meta.pk.name, 'document_ptr')\n            \n        except ImproperlyConfigured:\n            self.fail(\"Should not raise ImproperlyConfigured when parent_link field is last\")\n</patched>\n```",
  "patch": "--- a/tests/model_inheritance/test_mti_parent_link_order.py\n+++ b/tests/model_inheritance/test_mti_parent_link_order.py\n-# Empty if creating new file\n+import pytest\n+from django.core.exceptions import ImproperlyConfigured\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class MTIParentLinkOrderTests(TestCase):\n+    \"\"\"\n+    Test cases for Model-Table Inheritance (MTI) parent link field ordering bug.\n+    \n+    The issue is that when a model has multiple OneToOneField references to the\n+    same parent model, the order of field declaration affects whether Django\n+    correctly identifies the parent link field marked with parent_link=True.\n+    \"\"\"\n+\n+    def test_parent_link_after_other_onetoonefield_fails_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: when parent_link=True field is declared\n+        after another OneToOneField to the same parent, it raises ImproperlyConfigured.\n+        \n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        with self.assertRaises(ImproperlyConfigured) as cm:\n+            class Document(models.Model):\n+                class Meta:\n+                    app_label = 'test_app'\n+\n+            class Picking(Document):\n+                # This OneToOneField is declared first but doesn't have parent_link=True\n+                origin = models.OneToOneField(\n+                    Document, \n+                    related_name='picking', \n+                    on_delete=models.PROTECT\n+                )\n+                # This OneToOneField has parent_link=True but is declared second\n+                document_ptr = models.OneToOneField(\n+                    Document, \n+                    on_delete=models.CASCADE, \n+                    parent_link=True, \n+                    related_name='+'\n+                )\n+                \n+                class Meta:\n+                    app_label = 'test_app'\n+\n+        # The error message should mention adding parent_link=True to the origin field\n+        self.assertIn('Add parent_link=True to', str(cm.exception))\n+        self.assertIn('origin', str(cm.exception))\n+\n+    def test_parent_link_before_other_onetoonefield_works(self):\n+        \"\"\"\n+        Test that when parent_link=True field is declared before other OneToOneFields,\n+        it works correctly (this is the current workaround).\n+        \"\"\"\n+        try:\n+            class Document(models.Model):\n+                class Meta:\n+                    app_label = 'test_app'\n+\n+            class Picking(Document):\n+                # This OneToOneField has parent_link=True and is declared first\n+                document_ptr = models.OneToOneField(\n+                    Document, \n+                    on_delete=models.CASCADE, \n+                    parent_link=True, \n+                    related_name='+'\n+                )\n+                # This OneToOneField is declared second but doesn't have parent_link=True\n+                origin = models.OneToOneField(\n+                    Document, \n+                    related_name='picking', \n+                    on_delete=models.PROTECT\n+                )\n+                \n+                class Meta:\n+                    app_label = 'test_app'\n+                    \n+            # Should not raise any exception\n+            self.assertTrue(hasattr(Picking, 'document_ptr'))\n+            self.assertTrue(hasattr(Picking, 'origin'))\n+            \n+        except ImproperlyConfigured:\n+            self.fail(\"Should not raise ImproperlyConfigured when parent_link field is first\")\n+\n+    def test_parent_link_after_other_onetoonefield_works_after_fix(self):\n+        \"\"\"\n+        Test that after the fix, parent_link=True field can be declared in any order\n+        and Django will correctly identify it as the parent link.\n+        \n+        This test should pass after the fix is applied.\n+        \"\"\"\n+        try:\n+            class Document(models.Model):\n+                class Meta:\n+                    app_label = 'test_app'\n+\n+            class Picking(Document):\n+                # This OneToOneField is declared first but doesn't have parent_link=True\n+                origin = models.OneToOneField(\n+                    Document, \n+                    related_name='picking', \n+                    on_delete=models.PROTECT\n+                )\n+                # This OneToOneField has parent_link=True but is declared second\n+                document_ptr = models.OneToOneField(\n+                    Document, \n+                    on_delete=models.CASCADE, \n+                    parent_link=True, \n+                    related_name='+'\n+                )\n+                \n+                class Meta:\n+                    app_label = 'test_app'\n+                    \n+            # Should not raise any exception after fix\n+            self.assertTrue(hasattr(Picking, 'document_ptr'))\n+            self.assertTrue(hasattr(Picking, 'origin'))\n+            \n+            # Verify that the correct field is used as primary key\n+            self.assertTrue(Picking._meta.pk.remote_field.parent_link)\n+            self.assertEqual(Picking._meta.pk.name, 'document_ptr')\n+            \n+        except ImproperlyConfigured:\n+            self.fail(\"Should not raise ImproperlyConfigured after fix regardless of field order\")\n+\n+    def test_multiple_onetoonefield_no_parent_link_raises_error(self):\n+        \"\"\"\n+        Test that when there are multiple OneToOneFields to parent but none\n+        has parent_link=True, it raises ImproperlyConfigured.\n+        \"\"\"\n+        with self.assertRaises(ImproperlyConfigured) as cm:\n+            class Document(models.Model):\n+                class Meta:\n+                    app_label = 'test_app'\n+\n+            class Picking(Document):\n+                # Neither field has parent_link=True\n+                origin = models.OneToOneField(\n+                    Document, \n+                    related_name='picking', \n+                    on_delete=models.PROTECT\n+                )\n+                reference = models.OneToOneField(\n+                    Document, \n+                    related_name='reference_picking', \n+                    on_delete=models.PROTECT\n+                )\n+                \n+                class Meta:\n+                    app_label = 'test_app'\n+\n+        self.assertIn('Add parent_link=True', str(cm.exception))\n+\n+    def test_single_onetoonefield_without_parent_link_works(self):\n+        \"\"\"\n+        Test that when there's only one OneToOneField to parent without\n+        parent_link=True, it should work (Django auto-detects it).\n+        \"\"\"\n+        try:\n+            class Document(models.Model):\n+                class Meta:\n+                    app_label = 'test_app'\n+\n+            class Picking(Document):\n+                # Single OneToOneField without explicit parent_link=True\n+                # Django should auto-detect this as the parent link\n+                document_ptr = models.OneToOneField(\n+                    Document, \n+                    on_delete=models.CASCADE, \n+                    related_name='+'\n+                )\n+                \n+                class Meta:\n+                    app_label = 'test_app'\n+                    \n+            # Should work fine\n+            self.assertTrue(hasattr(Picking, 'document_ptr'))\n+            \n+        except ImproperlyConfigured:\n+            self.fail(\"Should not raise ImproperlyConfigured for single OneToOneField\")\n+\n+    def test_parent_link_field_order_independence_complex(self):\n+        \"\"\"\n+        Test a more complex scenario with multiple OneToOneFields where\n+        parent_link=True field is in the middle of the declaration order.\n+        \"\"\"\n+        try:\n+            class Document(models.Model):\n+                class Meta:\n+                    app_label = 'test_app'\n+\n+            class Picking(Document):\n+                # First OneToOneField - not parent link\n+                origin = models.OneToOneField(\n+                    Document, \n+                    related_name='picking_origin', \n+                    on_delete=models.PROTECT\n+                )\n+                # Second OneToOneField - this is the parent link\n+                document_ptr = models.OneToOneField(\n+                    Document, \n+                    on_delete=models.CASCADE, \n+                    parent_link=True, \n+                    related_name='+'\n+                )\n+                # Third OneToOneField - not parent link\n+                reference = models.OneToOneField(\n+                    Document, \n+                    related_name='picking_reference', \n+                    on_delete=models.PROTECT\n+                )\n+                \n+                class Meta:\n+                    app_label = 'test_app'\n+                    \n+            # Should work after fix regardless of order\n+            self.assertTrue(hasattr(Picking, 'document_ptr'))\n+            self.assertTrue(hasattr(Picking, 'origin'))\n+            self.assertTrue(hasattr(Picking, 'reference'))\n+            \n+            # Verify correct parent link is identified\n+            self.assertTrue(Picking._meta.pk.remote_field.parent_link)\n+            self.assertEqual(Picking._meta.pk.name, 'document_ptr')\n+            \n+        except ImproperlyConfigured:\n+            self.fail(\"Should not raise ImproperlyConfigured after fix with complex field order\")\n+\n+    def test_edge_case_parent_link_last_position(self):\n+        \"\"\"\n+        Test edge case where parent_link=True field is declared last.\n+        \"\"\"\n+        try:\n+            class Document(models.Model):\n+                class Meta:\n+                    app_label = 'test_app'\n+\n+            class Picking(Document):\n+                # Multiple OneToOneFields before the parent link\n+                origin = models.OneToOneField(\n+                    Document, \n+                    related_name='picking_origin', \n+                    on_delete=models.PROTECT\n+                )\n+                reference = models.OneToOneField(\n+                    Document, \n+                    related_name='picking_reference', \n+                    on_delete=models.PROTECT\n+                )\n+                source = models.OneToOneField(\n+                    Document, \n+                    related_name='picking_source', \n+                    on_delete=models.PROTECT\n+                )\n+                # Parent link field declared last\n+                document_ptr = models.OneToOneField(\n+                    Document, \n+                    on_delete=models.CASCADE, \n+                    parent_link=True, \n+                    related_name='+'\n+                )\n+                \n+                class Meta:\n+                    app_label = 'test_app'\n+                    \n+            # Should work after fix\n+            self.assertTrue(hasattr(Picking, 'document_ptr'))\n+            self.assertEqual(Picking._meta.pk.name, 'document_ptr')\n+            \n+        except ImproperlyConfigured:\n+            self.fail(\"Should not raise ImproperlyConfigured when parent_link field is last\")\n"
}