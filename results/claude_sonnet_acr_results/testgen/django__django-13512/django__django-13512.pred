{
  "instance_id": "django__django-13512",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/forms_tests/test_jsonfield_unicode.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport json\nimport pytest\nfrom django import forms\nfrom django.forms.fields import JSONField\nfrom django.test import TestCase\n\n\nclass JSONFieldUnicodeTests(TestCase):\n    \"\"\"Test that JSONField properly handles Unicode characters in Django admin.\"\"\"\n\n    def test_prepare_value_with_unicode_characters(self):\n        \"\"\"Test that prepare_value displays Unicode characters properly, not as ASCII escape sequences.\"\"\"\n        field = JSONField()\n        \n        # Test Chinese characters\n        chinese_data = {'name': '\u4e2d\u56fd', 'city': '\u5317\u4eac'}\n        prepared_value = field.prepare_value(chinese_data)\n        \n        # The prepared value should contain readable Chinese characters, not escape sequences\n        self.assertIn('\u4e2d\u56fd', prepared_value)\n        self.assertIn('\u5317\u4eac', prepared_value)\n        self.assertNotIn('\\\\u4e2d\\\\u56fd', prepared_value)  # Should not contain ASCII escape sequences\n        \n        # Verify it's still valid JSON\n        parsed_back = json.loads(prepared_value)\n        self.assertEqual(parsed_back, chinese_data)\n\n    def test_prepare_value_with_unicode_characters_before_fix(self):\n        \"\"\"Test that demonstrates the bug - this test should fail before the fix is applied.\"\"\"\n        field = JSONField()\n        \n        # Test Chinese characters\n        chinese_data = {'name': '\u4e2d\u56fd'}\n        \n        # Simulate the old behavior with ensure_ascii=True (default)\n        old_behavior_result = json.dumps(chinese_data)\n        \n        # This should contain ASCII escape sequences (the bug)\n        self.assertIn('\\\\u4e2d\\\\u56fd', old_behavior_result)\n        \n        # After fix, prepare_value should NOT produce ASCII escape sequences\n        prepared_value = field.prepare_value(chinese_data)\n        self.assertNotEqual(prepared_value, old_behavior_result)\n\n    def test_prepare_value_with_various_unicode_characters(self):\n        \"\"\"Test prepare_value with various Unicode characters from different languages.\"\"\"\n        field = JSONField()\n        \n        test_cases = [\n            {'japanese': '\u3053\u3093\u306b\u3061\u306f'},  # Japanese\n            {'korean': '\uc548\ub155\ud558\uc138\uc694'},     # Korean\n            {'arabic': '\u0645\u0631\u062d\u0628\u0627'},        # Arabic\n            {'emoji': '\ud83d\ude00\ud83c\udf89'},          # Emoji\n            {'mixed': '\u4e2d\u56fd Japan \ud55c\uad6d'}, # Mixed languages\n        ]\n        \n        for test_data in test_cases:\n            with self.subTest(test_data=test_data):\n                prepared_value = field.prepare_value(test_data)\n                \n                # Verify Unicode characters are preserved\n                for key, value in test_data.items():\n                    self.assertIn(value, prepared_value)\n                \n                # Verify it's still valid JSON\n                parsed_back = json.loads(prepared_value)\n                self.assertEqual(parsed_back, test_data)\n\n    def test_prepare_value_with_invalid_json_input(self):\n        \"\"\"Test that prepare_value handles InvalidJSONInput correctly.\"\"\"\n        from django.forms.fields import InvalidJSONInput\n        \n        field = JSONField()\n        invalid_input = InvalidJSONInput('invalid json')\n        \n        # Should return the InvalidJSONInput as-is\n        result = field.prepare_value(invalid_input)\n        self.assertEqual(result, invalid_input)\n\n    def test_has_changed_with_unicode_characters(self):\n        \"\"\"Test that has_changed method works correctly with Unicode characters.\"\"\"\n        field = JSONField()\n        \n        # Test data with Chinese characters\n        initial_data = {'name': '\u4e2d\u56fd', 'city': '\u5317\u4eac'}\n        same_data = {'name': '\u4e2d\u56fd', 'city': '\u5317\u4eac'}\n        different_data = {'name': '\u4e2d\u56fd', 'city': '\u4e0a\u6d77'}\n        \n        # Same data should not be considered changed\n        self.assertFalse(field.has_changed(initial_data, json.dumps(same_data, ensure_ascii=False)))\n        \n        # Different data should be considered changed\n        self.assertTrue(field.has_changed(initial_data, json.dumps(different_data, ensure_ascii=False)))\n\n    def test_has_changed_unicode_consistency(self):\n        \"\"\"Test that has_changed is consistent regardless of ensure_ascii setting.\"\"\"\n        field = JSONField()\n        \n        unicode_data = {'greeting': '\u4f60\u597d'}\n        \n        # JSON with ensure_ascii=False (readable Unicode)\n        json_unicode = json.dumps(unicode_data, ensure_ascii=False)\n        \n        # JSON with ensure_ascii=True (ASCII escape sequences)\n        json_ascii = json.dumps(unicode_data, ensure_ascii=True)\n        \n        # Both should be considered the same by has_changed\n        self.assertFalse(field.has_changed(unicode_data, json_unicode))\n        self.assertFalse(field.has_changed(unicode_data, json_ascii))\n\n    def test_bound_data_with_unicode_characters(self):\n        \"\"\"Test that bound_data handles Unicode characters correctly.\"\"\"\n        field = JSONField()\n        \n        # Test with Unicode JSON string\n        unicode_json = '{\"message\": \"\u4f60\u597d\u4e16\u754c\"}'\n        result = field.bound_data(unicode_json, None)\n        \n        expected = {\"message\": \"\u4f60\u597d\u4e16\u754c\"}\n        self.assertEqual(result, expected)\n\n    def test_to_python_with_unicode_characters(self):\n        \"\"\"Test that to_python handles Unicode characters correctly.\"\"\"\n        field = JSONField()\n        \n        # Test with Unicode JSON string\n        unicode_json = '{\"message\": \"\u4f60\u597d\u4e16\u754c\"}'\n        result = field.to_python(unicode_json)\n        \n        expected = {\"message\": \"\u4f60\u597d\u4e16\u754c\"}\n        self.assertEqual(result, expected)\n\n    def test_edge_cases_with_unicode(self):\n        \"\"\"Test edge cases with Unicode characters.\"\"\"\n        field = JSONField()\n        \n        # Empty Unicode string\n        empty_unicode = {'empty': ''}\n        prepared = field.prepare_value(empty_unicode)\n        self.assertIn('\"\"', prepared)  # Should contain empty string representation\n        \n        # Unicode in nested structures\n        nested_unicode = {\n            'level1': {\n                'level2': {\n                    'chinese': '\u4e2d\u6587',\n                    'list': ['\u9879\u76ee1', '\u9879\u76ee2']\n                }\n            }\n        }\n        prepared = field.prepare_value(nested_unicode)\n        self.assertIn('\u4e2d\u6587', prepared)\n        self.assertIn('\u9879\u76ee1', prepared)\n        self.assertIn('\u9879\u76ee2', prepared)\n        \n        # Verify it's still valid JSON\n        parsed_back = json.loads(prepared)\n        self.assertEqual(parsed_back, nested_unicode)\n\n    def test_custom_encoder_with_unicode(self):\n        \"\"\"Test that custom encoder works with Unicode characters.\"\"\"\n        from django.core.serializers.json import DjangoJSONEncoder\n        \n        field = JSONField(encoder=DjangoJSONEncoder)\n        \n        unicode_data = {'message': '\u6d4b\u8bd5\u6d88\u606f'}\n        prepared = field.prepare_value(unicode_data)\n        \n        # Should contain readable Unicode\n        self.assertIn('\u6d4b\u8bd5\u6d88\u606f', prepared)\n        \n        # Should be valid JSON\n        parsed_back = json.loads(prepared)\n        self.assertEqual(parsed_back, unicode_data)\n</patched>\n```\n\n```\n<file>tests/admin_tests/test_jsonfield_admin_unicode.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport json\nfrom django.contrib import admin\nfrom django.contrib.admin.sites import AdminSite\nfrom django.db import models\nfrom django.forms import ModelForm\nfrom django.test import TestCase, RequestFactory\nfrom django.contrib.auth.models import User\n\n\nclass TestModel(models.Model):\n    \"\"\"Test model with JSONField for admin testing.\"\"\"\n    name = models.CharField(max_length=100)\n    data = models.JSONField()\n    \n    class Meta:\n        app_label = 'admin_tests'\n\n\nclass TestModelAdmin(admin.ModelAdmin):\n    \"\"\"Admin class for TestModel.\"\"\"\n    fields = ['name', 'data']\n\n\nclass JSONFieldAdminUnicodeTests(TestCase):\n    \"\"\"Test JSONField Unicode handling in Django admin interface.\"\"\"\n    \n    def setUp(self):\n        self.site = AdminSite()\n        self.admin = TestModelAdmin(TestModel, self.site)\n        self.factory = RequestFactory()\n        self.user = User.objects.create_superuser('admin', 'admin@test.com', 'password')\n\n    def test_admin_form_displays_unicode_properly(self):\n        \"\"\"Test that admin forms display Unicode characters properly in JSONField.\"\"\"\n        # Create test instance with Unicode data\n        unicode_data = {\n            'title': '\u4e2d\u6587\u6807\u9898',\n            'description': '\u8fd9\u662f\u4e00\u4e2a\u6d4b\u8bd5\u63cf\u8ff0',\n            'tags': ['\u6807\u7b7e1', '\u6807\u7b7e2']\n        }\n        \n        instance = TestModel(name='Test', data=unicode_data)\n        \n        # Get the admin form\n        form_class = self.admin.get_form(None)\n        form = form_class(instance=instance)\n        \n        # Get the rendered field value\n        data_field = form['data']\n        rendered_value = data_field.value()\n        \n        # Should contain readable Unicode characters\n        self.assertIn('\u4e2d\u6587\u6807\u9898', rendered_value)\n        self.assertIn('\u8fd9\u662f\u4e00\u4e2a\u6d4b\u8bd5\u63cf\u8ff0', rendered_value)\n        self.assertIn('\u6807\u7b7e1', rendered_value)\n        self.assertIn('\u6807\u7b7e2', rendered_value)\n        \n        # Should NOT contain ASCII escape sequences\n        self.assertNotIn('\\\\u', rendered_value)\n\n    def test_admin_form_unicode_before_fix_demonstration(self):\n        \"\"\"Demonstrate the bug that should exist before the fix.\"\"\"\n        unicode_data = {'message': '\u4e2d\u56fd'}\n        \n        # Simulate old behavior with default json.dumps (ensure_ascii=True)\n        old_behavior = json.dumps(unicode_data)\n        \n        # This should contain ASCII escape sequences (the bug)\n        self.assertIn('\\\\u4e2d\\\\u56fd', old_behavior)\n        \n        # Create instance and form\n        instance = TestModel(name='Test', data=unicode_data)\n        form_class = self.admin.get_form(None)\n        form = form_class(instance=instance)\n        \n        # After fix, the form should NOT display ASCII escape sequences\n        data_field = form['data']\n        rendered_value = data_field.value()\n        \n        # Should be different from the old buggy behavior\n        self.assertNotEqual(rendered_value.strip(), old_behavior)\n        self.assertIn('\u4e2d\u56fd', rendered_value)\n\n    def test_admin_form_submission_with_unicode(self):\n        \"\"\"Test that admin forms can handle Unicode data submission.\"\"\"\n        unicode_data = {\n            'user': '\u7528\u6237\u540d',\n            'email': 'test@\u6d4b\u8bd5.com',\n            'preferences': {\n                'language': '\u4e2d\u6587',\n                'theme': '\u6df1\u8272\u4e3b\u9898'\n            }\n        }\n        \n        # Create form with Unicode data\n        form_class = self.admin.get_form(None)\n        form_data = {\n            'name': 'Unicode Test',\n            'data': json.dumps(unicode_data, ensure_ascii=False)\n        }\n        \n        form = form_class(data=form_data)\n        \n        # Form should be valid\n        self.assertTrue(form.is_valid(), f\"Form errors: {form.errors}\")\n        \n        # Save and verify\n        instance = form.save()\n        self.assertEqual(instance.data, unicode_data)\n\n    def test_admin_changelist_unicode_display(self):\n        \"\"\"Test that Unicode characters display properly in admin changelist.\"\"\"\n        # Create test instances with Unicode data\n        test_cases = [\n            {'name': 'Chinese', 'data': {'title': '\u4e2d\u6587\u6d4b\u8bd5'}},\n            {'name': 'Japanese', 'data': {'title': '\u30c6\u30b9\u30c8'}},\n            {'name': 'Korean', 'data': {'title': '\ud14c\uc2a4\ud2b8'}},\n            {'name': 'Emoji', 'data': {'title': '\ud83c\udf89 \u6d4b\u8bd5 \ud83c\udf89'}},\n        ]\n        \n        instances = []\n        for case in test_cases:\n            instance = TestModel.objects.create(**case)\n            instances.append(instance)\n        \n        # Test that each instance displays Unicode properly\n        for instance in instances:\n            # Get string representation (used in admin)\n            str_repr = str(instance.data)\n            \n            # Should contain readable Unicode\n            for char in instance.data['title']:\n                if ord(char) > 127:  # Non-ASCII character\n                    # Should be readable, not escaped\n                    self.assertIn(char, str_repr)\n\n    def test_admin_form_validation_with_unicode(self):\n        \"\"\"Test form validation works correctly with Unicode JSON data.\"\"\"\n        form_class = self.admin.get_form(None)\n        \n        # Valid Unicode JSON\n        valid_data = {\n            'name': 'Valid Unicode',\n            'data': '{\"message\": \"\u4f60\u597d\u4e16\u754c\", \"count\": 42}'\n        }\n        form = form_class(data=valid_data)\n        self.assertTrue(form.is_valid())\n        \n        # Invalid JSON (should still fail validation)\n        invalid_data = {\n            'name': 'Invalid JSON',\n            'data': '{\"message\": \"\u4f60\u597d\u4e16\u754c\", invalid}'\n        }\n        form = form_class(data=invalid_data)\n        self.assertFalse(form.is_valid())\n        self.assertIn('data', form.errors)\n\n    def test_admin_readonly_unicode_display(self):\n        \"\"\"Test that readonly JSONFields display Unicode properly.\"\"\"\n        class ReadOnlyAdmin(admin.ModelAdmin):\n            readonly_fields = ['data']\n        \n        readonly_admin = ReadOnlyAdmin(TestModel, self.site)\n        \n        unicode_data = {'readonly_message': '\u53ea\u8bfb\u6d88\u606f'}\n        instance = TestModel(name='Readonly Test', data=unicode_data)\n        \n        # Get readonly field display\n        request = self.factory.get('/')\n        request.user = self.user\n        \n        # The readonly field should display Unicode properly\n        # This tests the admin's display of readonly JSON fields\n        form_class = readonly_admin.get_form(request)\n        form = form_class(instance=instance)\n        \n        # Even though it's readonly, the initial value should be Unicode-friendly\n        self.assertIn('\u53ea\u8bfb\u6d88\u606f', str(instance.data))\n</patched>\n```",
  "patch": "--- a/tests/forms_tests/test_jsonfield_unicode.py\n+++ b/tests/forms_tests/test_jsonfield_unicode.py\n-# Empty if creating new file\n+import json\n+import pytest\n+from django import forms\n+from django.forms.fields import JSONField\n+from django.test import TestCase\n+\n+\n+class JSONFieldUnicodeTests(TestCase):\n+    \"\"\"Test that JSONField properly handles Unicode characters in Django admin.\"\"\"\n+\n+    def test_prepare_value_with_unicode_characters(self):\n+        \"\"\"Test that prepare_value displays Unicode characters properly, not as ASCII escape sequences.\"\"\"\n+        field = JSONField()\n+        \n+        # Test Chinese characters\n+        chinese_data = {'name': '\u4e2d\u56fd', 'city': '\u5317\u4eac'}\n+        prepared_value = field.prepare_value(chinese_data)\n+        \n+        # The prepared value should contain readable Chinese characters, not escape sequences\n+        self.assertIn('\u4e2d\u56fd', prepared_value)\n+        self.assertIn('\u5317\u4eac', prepared_value)\n+        self.assertNotIn('\\\\u4e2d\\\\u56fd', prepared_value)  # Should not contain ASCII escape sequences\n+        \n+        # Verify it's still valid JSON\n+        parsed_back = json.loads(prepared_value)\n+        self.assertEqual(parsed_back, chinese_data)\n+\n+    def test_prepare_value_with_unicode_characters_before_fix(self):\n+        \"\"\"Test that demonstrates the bug - this test should fail before the fix is applied.\"\"\"\n+        field = JSONField()\n+        \n+        # Test Chinese characters\n+        chinese_data = {'name': '\u4e2d\u56fd'}\n+        \n+        # Simulate the old behavior with ensure_ascii=True (default)\n+        old_behavior_result = json.dumps(chinese_data)\n+        \n+        # This should contain ASCII escape sequences (the bug)\n+        self.assertIn('\\\\u4e2d\\\\u56fd', old_behavior_result)\n+        \n+        # After fix, prepare_value should NOT produce ASCII escape sequences\n+        prepared_value = field.prepare_value(chinese_data)\n+        self.assertNotEqual(prepared_value, old_behavior_result)\n+\n+    def test_prepare_value_with_various_unicode_characters(self):\n+        \"\"\"Test prepare_value with various Unicode characters from different languages.\"\"\"\n+        field = JSONField()\n+        \n+        test_cases = [\n+            {'japanese': '\u3053\u3093\u306b\u3061\u306f'},  # Japanese\n+            {'korean': '\uc548\ub155\ud558\uc138\uc694'},     # Korean\n+            {'arabic': '\u0645\u0631\u062d\u0628\u0627'},        # Arabic\n+            {'emoji': '\ud83d\ude00\ud83c\udf89'},          # Emoji\n+            {'mixed': '\u4e2d\u56fd Japan \ud55c\uad6d'}, # Mixed languages\n+        ]\n+        \n+        for test_data in test_cases:\n+            with self.subTest(test_data=test_data):\n+                prepared_value = field.prepare_value(test_data)\n+                \n+                # Verify Unicode characters are preserved\n+                for key, value in test_data.items():\n+                    self.assertIn(value, prepared_value)\n+                \n+                # Verify it's still valid JSON\n+                parsed_back = json.loads(prepared_value)\n+                self.assertEqual(parsed_back, test_data)\n+\n+    def test_prepare_value_with_invalid_json_input(self):\n+        \"\"\"Test that prepare_value handles InvalidJSONInput correctly.\"\"\"\n+        from django.forms.fields import InvalidJSONInput\n+        \n+        field = JSONField()\n+        invalid_input = InvalidJSONInput('invalid json')\n+        \n+        # Should return the InvalidJSONInput as-is\n+        result = field.prepare_value(invalid_input)\n+        self.assertEqual(result, invalid_input)\n+\n+    def test_has_changed_with_unicode_characters(self):\n+        \"\"\"Test that has_changed method works correctly with Unicode characters.\"\"\"\n+        field = JSONField()\n+        \n+        # Test data with Chinese characters\n+        initial_data = {'name': '\u4e2d\u56fd', 'city': '\u5317\u4eac'}\n+        same_data = {'name': '\u4e2d\u56fd', 'city': '\u5317\u4eac'}\n+        different_data = {'name': '\u4e2d\u56fd', 'city': '\u4e0a\u6d77'}\n+        \n+        # Same data should not be considered changed\n+        self.assertFalse(field.has_changed(initial_data, json.dumps(same_data, ensure_ascii=False)))\n+        \n+        # Different data should be considered changed\n+        self.assertTrue(field.has_changed(initial_data, json.dumps(different_data, ensure_ascii=False)))\n+\n+    def test_has_changed_unicode_consistency(self):\n+        \"\"\"Test that has_changed is consistent regardless of ensure_ascii setting.\"\"\"\n+        field = JSONField()\n+        \n+        unicode_data = {'greeting': '\u4f60\u597d'}\n+        \n+        # JSON with ensure_ascii=False (readable Unicode)\n+        json_unicode = json.dumps(unicode_data, ensure_ascii=False)\n+        \n+        # JSON with ensure_ascii=True (ASCII escape sequences)\n+        json_ascii = json.dumps(unicode_data, ensure_ascii=True)\n+        \n+        # Both should be considered the same by has_changed\n+        self.assertFalse(field.has_changed(unicode_data, json_unicode))\n+        self.assertFalse(field.has_changed(unicode_data, json_ascii))\n+\n+    def test_bound_data_with_unicode_characters(self):\n+        \"\"\"Test that bound_data handles Unicode characters correctly.\"\"\"\n+        field = JSONField()\n+        \n+        # Test with Unicode JSON string\n+        unicode_json = '{\"message\": \"\u4f60\u597d\u4e16\u754c\"}'\n+        result = field.bound_data(unicode_json, None)\n+        \n+        expected = {\"message\": \"\u4f60\u597d\u4e16\u754c\"}\n+        self.assertEqual(result, expected)\n+\n+    def test_to_python_with_unicode_characters(self):\n+        \"\"\"Test that to_python handles Unicode characters correctly.\"\"\"\n+        field = JSONField()\n+        \n+        # Test with Unicode JSON string\n+        unicode_json = '{\"message\": \"\u4f60\u597d\u4e16\u754c\"}'\n+        result = field.to_python(unicode_json)\n+        \n+        expected = {\"message\": \"\u4f60\u597d\u4e16\u754c\"}\n+        self.assertEqual(result, expected)\n+\n+    def test_edge_cases_with_unicode(self):\n+        \"\"\"Test edge cases with Unicode characters.\"\"\"\n+        field = JSONField()\n+        \n+        # Empty Unicode string\n+        empty_unicode = {'empty': ''}\n+        prepared = field.prepare_value(empty_unicode)\n+        self.assertIn('\"\"', prepared)  # Should contain empty string representation\n+        \n+        # Unicode in nested structures\n+        nested_unicode = {\n+            'level1': {\n+                'level2': {\n+                    'chinese': '\u4e2d\u6587',\n+                    'list': ['\u9879\u76ee1', '\u9879\u76ee2']\n+                }\n+            }\n+        }\n+        prepared = field.prepare_value(nested_unicode)\n+        self.assertIn('\u4e2d\u6587', prepared)\n+        self.assertIn('\u9879\u76ee1', prepared)\n+        self.assertIn('\u9879\u76ee2', prepared)\n+        \n+        # Verify it's still valid JSON\n+        parsed_back = json.loads(prepared)\n+        self.assertEqual(parsed_back, nested_unicode)\n+\n+    def test_custom_encoder_with_unicode(self):\n+        \"\"\"Test that custom encoder works with Unicode characters.\"\"\"\n+        from django.core.serializers.json import DjangoJSONEncoder\n+        \n+        field = JSONField(encoder=DjangoJSONEncoder)\n+        \n+        unicode_data = {'message': '\u6d4b\u8bd5\u6d88\u606f'}\n+        prepared = field.prepare_value(unicode_data)\n+        \n+        # Should contain readable Unicode\n+        self.assertIn('\u6d4b\u8bd5\u6d88\u606f', prepared)\n+        \n+        # Should be valid JSON\n+        parsed_back = json.loads(prepared)\n+        self.assertEqual(parsed_back, unicode_data)\n\n--- a/tests/admin_tests/test_jsonfield_admin_unicode.py\n+++ b/tests/admin_tests/test_jsonfield_admin_unicode.py\n-# Empty if creating new file\n+import json\n+from django.contrib import admin\n+from django.contrib.admin.sites import AdminSite\n+from django.db import models\n+from django.forms import ModelForm\n+from django.test import TestCase, RequestFactory\n+from django.contrib.auth.models import User\n+\n+\n+class TestModel(models.Model):\n+    \"\"\"Test model with JSONField for admin testing.\"\"\"\n+    name = models.CharField(max_length=100)\n+    data = models.JSONField()\n+    \n+    class Meta:\n+        app_label = 'admin_tests'\n+\n+\n+class TestModelAdmin(admin.ModelAdmin):\n+    \"\"\"Admin class for TestModel.\"\"\"\n+    fields = ['name', 'data']\n+\n+\n+class JSONFieldAdminUnicodeTests(TestCase):\n+    \"\"\"Test JSONField Unicode handling in Django admin interface.\"\"\"\n+    \n+    def setUp(self):\n+        self.site = AdminSite()\n+        self.admin = TestModelAdmin(TestModel, self.site)\n+        self.factory = RequestFactory()\n+        self.user = User.objects.create_superuser('admin', 'admin@test.com', 'password')\n+\n+    def test_admin_form_displays_unicode_properly(self):\n+        \"\"\"Test that admin forms display Unicode characters properly in JSONField.\"\"\"\n+        # Create test instance with Unicode data\n+        unicode_data = {\n+            'title': '\u4e2d\u6587\u6807\u9898',\n+            'description': '\u8fd9\u662f\u4e00\u4e2a\u6d4b\u8bd5\u63cf\u8ff0',\n+            'tags': ['\u6807\u7b7e1', '\u6807\u7b7e2']\n+        }\n+        \n+        instance = TestModel(name='Test', data=unicode_data)\n+        \n+        # Get the admin form\n+        form_class = self.admin.get_form(None)\n+        form = form_class(instance=instance)\n+        \n+        # Get the rendered field value\n+        data_field = form['data']\n+        rendered_value = data_field.value()\n+        \n+        # Should contain readable Unicode characters\n+        self.assertIn('\u4e2d\u6587\u6807\u9898', rendered_value)\n+        self.assertIn('\u8fd9\u662f\u4e00\u4e2a\u6d4b\u8bd5\u63cf\u8ff0', rendered_value)\n+        self.assertIn('\u6807\u7b7e1', rendered_value)\n+        self.assertIn('\u6807\u7b7e2', rendered_value)\n+        \n+        # Should NOT contain ASCII escape sequences\n+        self.assertNotIn('\\\\u', rendered_value)\n+\n+    def test_admin_form_unicode_before_fix_demonstration(self):\n+        \"\"\"Demonstrate the bug that should exist before the fix.\"\"\"\n+        unicode_data = {'message': '\u4e2d\u56fd'}\n+        \n+        # Simulate old behavior with default json.dumps (ensure_ascii=True)\n+        old_behavior = json.dumps(unicode_data)\n+        \n+        # This should contain ASCII escape sequences (the bug)\n+        self.assertIn('\\\\u4e2d\\\\u56fd', old_behavior)\n+        \n+        # Create instance and form\n+        instance = TestModel(name='Test', data=unicode_data)\n+        form_class = self.admin.get_form(None)\n+        form = form_class(instance=instance)\n+        \n+        # After fix, the form should NOT display ASCII escape sequences\n+        data_field = form['data']\n+        rendered_value = data_field.value()\n+        \n+        # Should be different from the old buggy behavior\n+        self.assertNotEqual(rendered_value.strip(), old_behavior)\n+        self.assertIn('\u4e2d\u56fd', rendered_value)\n+\n+    def test_admin_form_submission_with_unicode(self):\n+        \"\"\"Test that admin forms can handle Unicode data submission.\"\"\"\n+        unicode_data = {\n+            'user': '\u7528\u6237\u540d',\n+            'email': 'test@\u6d4b\u8bd5.com',\n+            'preferences': {\n+                'language': '\u4e2d\u6587',\n+                'theme': '\u6df1\u8272\u4e3b\u9898'\n+            }\n+        }\n+        \n+        # Create form with Unicode data\n+        form_class = self.admin.get_form(None)\n+        form_data = {\n+            'name': 'Unicode Test',\n+            'data': json.dumps(unicode_data, ensure_ascii=False)\n+        }\n+        \n+        form = form_class(data=form_data)\n+        \n+        # Form should be valid\n+        self.assertTrue(form.is_valid(), f\"Form errors: {form.errors}\")\n+        \n+        # Save and verify\n+        instance = form.save()\n+        self.assertEqual(instance.data, unicode_data)\n+\n+    def test_admin_changelist_unicode_display(self):\n+        \"\"\"Test that Unicode characters display properly in admin changelist.\"\"\"\n+        # Create test instances with Unicode data\n+        test_cases = [\n+            {'name': 'Chinese', 'data': {'title': '\u4e2d\u6587\u6d4b\u8bd5'}},\n+            {'name': 'Japanese', 'data': {'title': '\u30c6\u30b9\u30c8'}},\n+            {'name': 'Korean', 'data': {'title': '\ud14c\uc2a4\ud2b8'}},\n+            {'name': 'Emoji', 'data': {'title': '\ud83c\udf89 \u6d4b\u8bd5 \ud83c\udf89'}},\n+        ]\n+        \n+        instances = []\n+        for case in test_cases:\n+            instance = TestModel.objects.create(**case)\n+            instances.append(instance)\n+        \n+        # Test that each instance displays Unicode properly\n+        for instance in instances:\n+            # Get string representation (used in admin)\n+            str_repr = str(instance.data)\n+            \n+            # Should contain readable Unicode\n+            for char in instance.data['title']:\n+                if ord(char) > 127:  # Non-ASCII character\n+                    # Should be readable, not escaped\n+                    self.assertIn(char, str_repr)\n+\n+    def test_admin_form_validation_with_unicode(self):\n+        \"\"\"Test form validation works correctly with Unicode JSON data.\"\"\"\n+        form_class = self.admin.get_form(None)\n+        \n+        # Valid Unicode JSON\n+        valid_data = {\n+            'name': 'Valid Unicode',\n+            'data': '{\"message\": \"\u4f60\u597d\u4e16\u754c\", \"count\": 42}'\n+        }\n+        form = form_class(data=valid_data)\n+        self.assertTrue(form.is_valid())\n+        \n+        # Invalid JSON (should still fail validation)\n+        invalid_data = {\n+            'name': 'Invalid JSON',\n+            'data': '{\"message\": \"\u4f60\u597d\u4e16\u754c\", invalid}'\n+        }\n+        form = form_class(data=invalid_data)\n+        self.assertFalse(form.is_valid())\n+        self.assertIn('data', form.errors)\n+\n+    def test_admin_readonly_unicode_display(self):\n+        \"\"\"Test that readonly JSONFields display Unicode properly.\"\"\"\n+        class ReadOnlyAdmin(admin.ModelAdmin):\n+            readonly_fields = ['data']\n+        \n+        readonly_admin = ReadOnlyAdmin(TestModel, self.site)\n+        \n+        unicode_data = {'readonly_message': '\u53ea\u8bfb\u6d88\u606f'}\n+        instance = TestModel(name='Readonly Test', data=unicode_data)\n+        \n+        # Get readonly field display\n+        request = self.factory.get('/')\n+        request.user = self.user\n+        \n+        # The readonly field should display Unicode properly\n+        # This tests the admin's display of readonly JSON fields\n+        form_class = readonly_admin.get_form(request)\n+        form = form_class(instance=instance)\n+        \n+        # Even though it's readonly, the initial value should be Unicode-friendly\n+        self.assertIn('\u53ea\u8bfb\u6d88\u606f', str(instance.data))\n"
}