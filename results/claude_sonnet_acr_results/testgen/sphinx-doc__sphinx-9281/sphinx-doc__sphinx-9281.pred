{
  "instance_id": "sphinx-doc__sphinx-9281",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_util_inspect_enum.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport enum\nimport pytest\nfrom sphinx.util.inspect import object_description\n\n\nclass MyEnum(enum.Enum):\n    \"\"\"Test enum for testing object_description formatting.\"\"\"\n    ValueA = 10\n    ValueB = 20\n    ValueC = \"string_value\"\n\n\nclass IntEnum(enum.IntEnum):\n    \"\"\"Test IntEnum for testing object_description formatting.\"\"\"\n    FIRST = 1\n    SECOND = 2\n\n\nclass StringEnum(enum.Enum):\n    \"\"\"Test string enum for testing object_description formatting.\"\"\"\n    RED = \"red\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n\n\ndef test_object_description_enum_basic():\n    \"\"\"Test that object_description formats basic Enum values correctly.\"\"\"\n    # Test basic enum value\n    result = object_description(MyEnum.ValueA)\n    expected = \"MyEnum.ValueA\"\n    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n\n\ndef test_object_description_enum_with_string_value():\n    \"\"\"Test that object_description formats Enum with string values correctly.\"\"\"\n    result = object_description(MyEnum.ValueC)\n    expected = \"MyEnum.ValueC\"\n    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n\n\ndef test_object_description_int_enum():\n    \"\"\"Test that object_description formats IntEnum values correctly.\"\"\"\n    result = object_description(IntEnum.FIRST)\n    expected = \"IntEnum.FIRST\"\n    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n\n\ndef test_object_description_string_enum():\n    \"\"\"Test that object_description formats string Enum values correctly.\"\"\"\n    result = object_description(StringEnum.RED)\n    expected = \"StringEnum.RED\"\n    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n\n\ndef test_object_description_enum_vs_repr():\n    \"\"\"Test that object_description output differs from default repr for enums.\"\"\"\n    enum_value = MyEnum.ValueA\n    \n    # Get the object_description result\n    obj_desc_result = object_description(enum_value)\n    \n    # Get the default repr result\n    repr_result = repr(enum_value)\n    \n    # They should be different\n    assert obj_desc_result != repr_result, f\"object_description should differ from repr: '{obj_desc_result}' vs '{repr_result}'\"\n    \n    # object_description should be cleaner (no angle brackets)\n    assert \"<\" not in obj_desc_result, f\"object_description should not contain angle brackets: '{obj_desc_result}'\"\n    assert \">\" not in obj_desc_result, f\"object_description should not contain angle brackets: '{obj_desc_result}'\"\n    \n    # repr should contain angle brackets (the ugly format)\n    assert \"<\" in repr_result and \">\" in repr_result, f\"repr should contain angle brackets: '{repr_result}'\"\n\n\ndef test_object_description_non_enum_unchanged():\n    \"\"\"Test that object_description behavior for non-enum objects is unchanged.\"\"\"\n    # Test with various non-enum objects to ensure existing functionality is preserved\n    \n    # Test with dict\n    test_dict = {\"key\": \"value\"}\n    result = object_description(test_dict)\n    # Should contain the dict representation\n    assert \"key\" in result and \"value\" in result\n    \n    # Test with string\n    test_string = \"hello world\"\n    result = object_description(test_string)\n    assert result == repr(test_string)\n    \n    # Test with int\n    test_int = 42\n    result = object_description(test_int)\n    assert result == repr(test_int)\n    \n    # Test with list\n    test_list = [1, 2, 3]\n    result = object_description(test_list)\n    assert result == repr(test_list)\n\n\ndef test_object_description_enum_edge_cases():\n    \"\"\"Test edge cases for enum object_description.\"\"\"\n    \n    # Test all enum values from MyEnum\n    for enum_value in MyEnum:\n        result = object_description(enum_value)\n        expected = f\"MyEnum.{enum_value.name}\"\n        assert result == expected, f\"Expected '{expected}', got '{result}'\"\n    \n    # Test all enum values from IntEnum\n    for enum_value in IntEnum:\n        result = object_description(enum_value)\n        expected = f\"IntEnum.{enum_value.name}\"\n        assert result == expected, f\"Expected '{expected}', got '{result}'\"\n\n\nclass NestedEnum(enum.Enum):\n    \"\"\"Test enum with complex names.\"\"\"\n    COMPLEX_NAME_WITH_UNDERSCORES = \"complex\"\n    ANOTHER_VALUE = 999\n\n\ndef test_object_description_enum_complex_names():\n    \"\"\"Test that object_description handles complex enum names correctly.\"\"\"\n    result = object_description(NestedEnum.COMPLEX_NAME_WITH_UNDERSCORES)\n    expected = \"NestedEnum.COMPLEX_NAME_WITH_UNDERSCORES\"\n    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n\n\ndef test_enum_in_function_signature_context():\n    \"\"\"Test that demonstrates the fix works in the context of function signatures.\"\"\"\n    # This test simulates how the enum would be used in a function signature\n    # and verifies that object_description produces the expected clean format\n    \n    def example_function(param: MyEnum = MyEnum.ValueA):\n        \"\"\"Example function with enum default parameter.\"\"\"\n        pass\n    \n    # Simulate what happens when Sphinx processes the default value\n    default_value = MyEnum.ValueA\n    formatted_default = object_description(default_value)\n    \n    # The formatted default should be clean and readable\n    assert formatted_default == \"MyEnum.ValueA\"\n    \n    # It should not contain the ugly repr format\n    assert \"<MyEnum.ValueA: 10>\" != formatted_default\n    assert \"<\" not in formatted_default\n    assert \">\" not in formatted_default\n\n\ndef test_object_description_preserves_existing_behavior():\n    \"\"\"Comprehensive test to ensure existing object_description behavior is preserved.\"\"\"\n    \n    # Test cases that should behave exactly as before\n    test_cases = [\n        # Basic types\n        (42, \"42\"),\n        (\"string\", \"'string'\"),\n        (True, \"True\"),\n        (None, \"None\"),\n        ([], \"[]\"),\n        ({}, \"{}\"),\n        \n        # More complex objects\n        ([1, 2, 3], \"[1, 2, 3]\"),\n        ({\"a\": 1}, \"{'a': 1}\"),\n    ]\n    \n    for obj, expected in test_cases:\n        result = object_description(obj)\n        assert result == expected, f\"For {type(obj).__name__} {obj}: expected '{expected}', got '{result}'\"\n\n\n# Test that verifies the bug is actually fixed\ndef test_enum_bug_reproduction():\n    \"\"\"Test that reproduces the original bug and verifies it's fixed.\"\"\"\n    \n    # Create an enum value like in the bug report\n    enum_value = MyEnum.ValueA\n    \n    # The bug was that this would return \"<MyEnum.ValueA: 10>\"\n    # After the fix, it should return \"MyEnum.ValueA\"\n    result = object_description(enum_value)\n    \n    # Verify the fix\n    assert result == \"MyEnum.ValueA\", f\"Bug not fixed: got '{result}'\"\n    \n    # Verify it's different from the buggy behavior\n    buggy_output = \"<MyEnum.ValueA: 10>\"\n    assert result != buggy_output, f\"Still showing buggy output: '{result}'\"\n    \n    # Verify it's different from repr\n    assert result != repr(enum_value), f\"Should differ from repr: '{result}' vs '{repr(enum_value)}'\"\n</patched>\n```\n\n```\n<file>tests/test_autodoc_enum_signatures.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport enum\nimport pytest\nfrom sphinx.ext.autodoc import FunctionDocumenter\nfrom sphinx.testing.util import SphinxTestApp\nfrom sphinx.util.inspect import object_description\n\n\nclass TestEnum(enum.Enum):\n    \"\"\"Test enum for autodoc signature testing.\"\"\"\n    VALUE_ONE = 1\n    VALUE_TWO = 2\n    STRING_VALUE = \"test\"\n\n\nclass ColorEnum(enum.Enum):\n    \"\"\"Color enum for testing.\"\"\"\n    RED = \"red\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n\n\ndef function_with_enum_default(param: TestEnum = TestEnum.VALUE_ONE) -> None:\n    \"\"\"Function with enum default parameter for testing.\"\"\"\n    pass\n\n\ndef function_with_multiple_enum_defaults(\n    color: ColorEnum = ColorEnum.RED,\n    test_val: TestEnum = TestEnum.STRING_VALUE,\n    normal_param: str = \"default\"\n) -> None:\n    \"\"\"Function with multiple enum defaults for testing.\"\"\"\n    pass\n\n\ndef function_with_enum_no_annotation(param=TestEnum.VALUE_TWO):\n    \"\"\"Function with enum default but no type annotation.\"\"\"\n    pass\n\n\nclass TestEnumInSignatures:\n    \"\"\"Test class for enum handling in function signatures.\"\"\"\n    \n    def test_enum_default_formatting(self):\n        \"\"\"Test that enum defaults are formatted cleanly in signatures.\"\"\"\n        # Test the object_description function directly\n        result = object_description(TestEnum.VALUE_ONE)\n        assert result == \"TestEnum.VALUE_ONE\"\n        assert \"<TestEnum.VALUE_ONE: 1>\" != result\n        \n    def test_enum_string_value_formatting(self):\n        \"\"\"Test that enum with string values are formatted cleanly.\"\"\"\n        result = object_description(ColorEnum.RED)\n        assert result == \"ColorEnum.RED\"\n        assert \"<ColorEnum.RED: 'red'>\" != result\n        \n    def test_multiple_enum_types_formatting(self):\n        \"\"\"Test that different enum types are all formatted cleanly.\"\"\"\n        test_cases = [\n            (TestEnum.VALUE_ONE, \"TestEnum.VALUE_ONE\"),\n            (TestEnum.VALUE_TWO, \"TestEnum.VALUE_TWO\"),\n            (TestEnum.STRING_VALUE, \"TestEnum.STRING_VALUE\"),\n            (ColorEnum.RED, \"ColorEnum.RED\"),\n            (ColorEnum.GREEN, \"ColorEnum.GREEN\"),\n            (ColorEnum.BLUE, \"ColorEnum.BLUE\"),\n        ]\n        \n        for enum_value, expected in test_cases:\n            result = object_description(enum_value)\n            assert result == expected, f\"Expected '{expected}', got '{result}'\"\n            \n    def test_enum_vs_non_enum_defaults(self):\n        \"\"\"Test that enum and non-enum defaults are handled appropriately.\"\"\"\n        # Enum should be formatted cleanly\n        enum_result = object_description(TestEnum.VALUE_ONE)\n        assert enum_result == \"TestEnum.VALUE_ONE\"\n        \n        # Non-enum should use existing behavior\n        string_result = object_description(\"default\")\n        assert string_result == \"'default'\"\n        \n        int_result = object_description(42)\n        assert int_result == \"42\"\n        \n    def test_enum_formatting_consistency(self):\n        \"\"\"Test that enum formatting is consistent across different contexts.\"\"\"\n        # All enum values should follow the same pattern\n        for enum_value in TestEnum:\n            result = object_description(enum_value)\n            expected_pattern = f\"TestEnum.{enum_value.name}\"\n            assert result == expected_pattern\n            \n            # Should not contain angle brackets\n            assert \"<\" not in result\n            assert \">\" not in result\n            \n            # Should not contain the value representation\n            assert str(enum_value.value) not in result or enum_value.name == str(enum_value.value)\n\n\nclass TestEnumSignatureIntegration:\n    \"\"\"Integration tests for enum handling in autodoc signatures.\"\"\"\n    \n    def test_function_signature_with_enum_default(self):\n        \"\"\"Test that function signatures with enum defaults look clean.\"\"\"\n        # This test verifies the integration works end-to-end\n        \n        # Get the default value\n        import inspect\n        sig = inspect.signature(function_with_enum_default)\n        param = sig.parameters['param']\n        default_value = param.default\n        \n        # Format it using object_description (what Sphinx uses)\n        formatted_default = object_description(default_value)\n        \n        # Should be clean format\n        assert formatted_default == \"TestEnum.VALUE_ONE\"\n        \n        # Should not be the ugly format\n        assert formatted_default != \"<TestEnum.VALUE_ONE: 1>\"\n        \n    def test_multiple_enum_defaults_in_signature(self):\n        \"\"\"Test function with multiple enum defaults.\"\"\"\n        import inspect\n        sig = inspect.signature(function_with_multiple_enum_defaults)\n        \n        # Check color parameter\n        color_param = sig.parameters['color']\n        color_default = object_description(color_param.default)\n        assert color_default == \"ColorEnum.RED\"\n        \n        # Check test_val parameter\n        test_param = sig.parameters['test_val']\n        test_default = object_description(test_param.default)\n        assert test_default == \"TestEnum.STRING_VALUE\"\n        \n        # Check normal parameter (should be unchanged)\n        normal_param = sig.parameters['normal_param']\n        normal_default = object_description(normal_param.default)\n        assert normal_default == \"'default'\"\n        \n    def test_enum_without_annotation(self):\n        \"\"\"Test enum default without type annotation.\"\"\"\n        import inspect\n        sig = inspect.signature(function_with_enum_no_annotation)\n        param = sig.parameters['param']\n        default_value = param.default\n        \n        formatted_default = object_description(default_value)\n        assert formatted_default == \"TestEnum.VALUE_TWO\"\n\n\ndef test_enum_signature_bug_reproduction():\n    \"\"\"Test that reproduces the exact bug from the issue description.\"\"\"\n    \n    # Create a function similar to the one in the bug report\n    def ugly_enum_func(e: TestEnum = TestEnum.VALUE_ONE) -> None:\n        \"\"\"Function that demonstrates the enum signature bug.\"\"\"\n        pass\n    \n    # Get the default value\n    import inspect\n    sig = inspect.signature(ugly_enum_func)\n    param = sig.parameters['e']\n    default_value = param.default\n    \n    # Format using object_description (what Sphinx autodoc uses)\n    formatted_default = object_description(default_value)\n    \n    # The bug was that this would show: <TestEnum.VALUE_ONE: 1>\n    # After fix, it should show: TestEnum.VALUE_ONE\n    \n    assert formatted_default == \"TestEnum.VALUE_ONE\"\n    \n    # Verify it's not the ugly format\n    ugly_format = \"<TestEnum.VALUE_ONE: 1>\"\n    assert formatted_default != ugly_format\n    \n    # Verify it doesn't contain angle brackets\n    assert \"<\" not in formatted_default\n    assert \">\" not in formatted_default\n\n\ndef test_enum_edge_cases_in_signatures():\n    \"\"\"Test edge cases for enum handling in signatures.\"\"\"\n    \n    # Test enum with complex name\n    class ComplexEnum(enum.Enum):\n        VERY_LONG_NAME_WITH_UNDERSCORES = \"complex\"\n        ANOTHER_VALUE = 123\n    \n    def func_with_complex_enum(param: ComplexEnum = ComplexEnum.VERY_LONG_NAME_WITH_UNDERSCORES):\n        pass\n    \n    import inspect\n    sig = inspect.signature(func_with_complex_enum)\n    param = sig.parameters['param']\n    default_value = param.default\n    \n    formatted_default = object_description(default_value)\n    assert formatted_default == \"ComplexEnum.VERY_LONG_NAME_WITH_UNDERSCORES\"\n    \n    # Test IntEnum\n    class TestIntEnum(enum.IntEnum):\n        FIRST = 1\n        SECOND = 2\n    \n    def func_with_int_enum(param: TestIntEnum = TestIntEnum.FIRST):\n        pass\n    \n    sig = inspect.signature(func_with_int_enum)\n    param = sig.parameters['param']\n    default_value = param.default\n    \n    formatted_default = object_description(default_value)\n    assert formatted_default == \"TestIntEnum.FIRST\"\n</patched>\n```",
  "patch": "--- a/tests/test_util_inspect_enum.py\n+++ b/tests/test_util_inspect_enum.py\n-# Empty if creating new file\n+import enum\n+import pytest\n+from sphinx.util.inspect import object_description\n+\n+\n+class MyEnum(enum.Enum):\n+    \"\"\"Test enum for testing object_description formatting.\"\"\"\n+    ValueA = 10\n+    ValueB = 20\n+    ValueC = \"string_value\"\n+\n+\n+class IntEnum(enum.IntEnum):\n+    \"\"\"Test IntEnum for testing object_description formatting.\"\"\"\n+    FIRST = 1\n+    SECOND = 2\n+\n+\n+class StringEnum(enum.Enum):\n+    \"\"\"Test string enum for testing object_description formatting.\"\"\"\n+    RED = \"red\"\n+    GREEN = \"green\"\n+    BLUE = \"blue\"\n+\n+\n+def test_object_description_enum_basic():\n+    \"\"\"Test that object_description formats basic Enum values correctly.\"\"\"\n+    # Test basic enum value\n+    result = object_description(MyEnum.ValueA)\n+    expected = \"MyEnum.ValueA\"\n+    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n+\n+\n+def test_object_description_enum_with_string_value():\n+    \"\"\"Test that object_description formats Enum with string values correctly.\"\"\"\n+    result = object_description(MyEnum.ValueC)\n+    expected = \"MyEnum.ValueC\"\n+    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n+\n+\n+def test_object_description_int_enum():\n+    \"\"\"Test that object_description formats IntEnum values correctly.\"\"\"\n+    result = object_description(IntEnum.FIRST)\n+    expected = \"IntEnum.FIRST\"\n+    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n+\n+\n+def test_object_description_string_enum():\n+    \"\"\"Test that object_description formats string Enum values correctly.\"\"\"\n+    result = object_description(StringEnum.RED)\n+    expected = \"StringEnum.RED\"\n+    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n+\n+\n+def test_object_description_enum_vs_repr():\n+    \"\"\"Test that object_description output differs from default repr for enums.\"\"\"\n+    enum_value = MyEnum.ValueA\n+    \n+    # Get the object_description result\n+    obj_desc_result = object_description(enum_value)\n+    \n+    # Get the default repr result\n+    repr_result = repr(enum_value)\n+    \n+    # They should be different\n+    assert obj_desc_result != repr_result, f\"object_description should differ from repr: '{obj_desc_result}' vs '{repr_result}'\"\n+    \n+    # object_description should be cleaner (no angle brackets)\n+    assert \"<\" not in obj_desc_result, f\"object_description should not contain angle brackets: '{obj_desc_result}'\"\n+    assert \">\" not in obj_desc_result, f\"object_description should not contain angle brackets: '{obj_desc_result}'\"\n+    \n+    # repr should contain angle brackets (the ugly format)\n+    assert \"<\" in repr_result and \">\" in repr_result, f\"repr should contain angle brackets: '{repr_result}'\"\n+\n+\n+def test_object_description_non_enum_unchanged():\n+    \"\"\"Test that object_description behavior for non-enum objects is unchanged.\"\"\"\n+    # Test with various non-enum objects to ensure existing functionality is preserved\n+    \n+    # Test with dict\n+    test_dict = {\"key\": \"value\"}\n+    result = object_description(test_dict)\n+    # Should contain the dict representation\n+    assert \"key\" in result and \"value\" in result\n+    \n+    # Test with string\n+    test_string = \"hello world\"\n+    result = object_description(test_string)\n+    assert result == repr(test_string)\n+    \n+    # Test with int\n+    test_int = 42\n+    result = object_description(test_int)\n+    assert result == repr(test_int)\n+    \n+    # Test with list\n+    test_list = [1, 2, 3]\n+    result = object_description(test_list)\n+    assert result == repr(test_list)\n+\n+\n+def test_object_description_enum_edge_cases():\n+    \"\"\"Test edge cases for enum object_description.\"\"\"\n+    \n+    # Test all enum values from MyEnum\n+    for enum_value in MyEnum:\n+        result = object_description(enum_value)\n+        expected = f\"MyEnum.{enum_value.name}\"\n+        assert result == expected, f\"Expected '{expected}', got '{result}'\"\n+    \n+    # Test all enum values from IntEnum\n+    for enum_value in IntEnum:\n+        result = object_description(enum_value)\n+        expected = f\"IntEnum.{enum_value.name}\"\n+        assert result == expected, f\"Expected '{expected}', got '{result}'\"\n+\n+\n+class NestedEnum(enum.Enum):\n+    \"\"\"Test enum with complex names.\"\"\"\n+    COMPLEX_NAME_WITH_UNDERSCORES = \"complex\"\n+    ANOTHER_VALUE = 999\n+\n+\n+def test_object_description_enum_complex_names():\n+    \"\"\"Test that object_description handles complex enum names correctly.\"\"\"\n+    result = object_description(NestedEnum.COMPLEX_NAME_WITH_UNDERSCORES)\n+    expected = \"NestedEnum.COMPLEX_NAME_WITH_UNDERSCORES\"\n+    assert result == expected, f\"Expected '{expected}', got '{result}'\"\n+\n+\n+def test_enum_in_function_signature_context():\n+    \"\"\"Test that demonstrates the fix works in the context of function signatures.\"\"\"\n+    # This test simulates how the enum would be used in a function signature\n+    # and verifies that object_description produces the expected clean format\n+    \n+    def example_function(param: MyEnum = MyEnum.ValueA):\n+        \"\"\"Example function with enum default parameter.\"\"\"\n+        pass\n+    \n+    # Simulate what happens when Sphinx processes the default value\n+    default_value = MyEnum.ValueA\n+    formatted_default = object_description(default_value)\n+    \n+    # The formatted default should be clean and readable\n+    assert formatted_default == \"MyEnum.ValueA\"\n+    \n+    # It should not contain the ugly repr format\n+    assert \"<MyEnum.ValueA: 10>\" != formatted_default\n+    assert \"<\" not in formatted_default\n+    assert \">\" not in formatted_default\n+\n+\n+def test_object_description_preserves_existing_behavior():\n+    \"\"\"Comprehensive test to ensure existing object_description behavior is preserved.\"\"\"\n+    \n+    # Test cases that should behave exactly as before\n+    test_cases = [\n+        # Basic types\n+        (42, \"42\"),\n+        (\"string\", \"'string'\"),\n+        (True, \"True\"),\n+        (None, \"None\"),\n+        ([], \"[]\"),\n+        ({}, \"{}\"),\n+        \n+        # More complex objects\n+        ([1, 2, 3], \"[1, 2, 3]\"),\n+        ({\"a\": 1}, \"{'a': 1}\"),\n+    ]\n+    \n+    for obj, expected in test_cases:\n+        result = object_description(obj)\n+        assert result == expected, f\"For {type(obj).__name__} {obj}: expected '{expected}', got '{result}'\"\n+\n+\n+# Test that verifies the bug is actually fixed\n+def test_enum_bug_reproduction():\n+    \"\"\"Test that reproduces the original bug and verifies it's fixed.\"\"\"\n+    \n+    # Create an enum value like in the bug report\n+    enum_value = MyEnum.ValueA\n+    \n+    # The bug was that this would return \"<MyEnum.ValueA: 10>\"\n+    # After the fix, it should return \"MyEnum.ValueA\"\n+    result = object_description(enum_value)\n+    \n+    # Verify the fix\n+    assert result == \"MyEnum.ValueA\", f\"Bug not fixed: got '{result}'\"\n+    \n+    # Verify it's different from the buggy behavior\n+    buggy_output = \"<MyEnum.ValueA: 10>\"\n+    assert result != buggy_output, f\"Still showing buggy output: '{result}'\"\n+    \n+    # Verify it's different from repr\n+    assert result != repr(enum_value), f\"Should differ from repr: '{result}' vs '{repr(enum_value)}'\"\n\n--- a/tests/test_autodoc_enum_signatures.py\n+++ b/tests/test_autodoc_enum_signatures.py\n-# Empty if creating new file\n+import enum\n+import pytest\n+from sphinx.ext.autodoc import FunctionDocumenter\n+from sphinx.testing.util import SphinxTestApp\n+from sphinx.util.inspect import object_description\n+\n+\n+class TestEnum(enum.Enum):\n+    \"\"\"Test enum for autodoc signature testing.\"\"\"\n+    VALUE_ONE = 1\n+    VALUE_TWO = 2\n+    STRING_VALUE = \"test\"\n+\n+\n+class ColorEnum(enum.Enum):\n+    \"\"\"Color enum for testing.\"\"\"\n+    RED = \"red\"\n+    GREEN = \"green\"\n+    BLUE = \"blue\"\n+\n+\n+def function_with_enum_default(param: TestEnum = TestEnum.VALUE_ONE) -> None:\n+    \"\"\"Function with enum default parameter for testing.\"\"\"\n+    pass\n+\n+\n+def function_with_multiple_enum_defaults(\n+    color: ColorEnum = ColorEnum.RED,\n+    test_val: TestEnum = TestEnum.STRING_VALUE,\n+    normal_param: str = \"default\"\n+) -> None:\n+    \"\"\"Function with multiple enum defaults for testing.\"\"\"\n+    pass\n+\n+\n+def function_with_enum_no_annotation(param=TestEnum.VALUE_TWO):\n+    \"\"\"Function with enum default but no type annotation.\"\"\"\n+    pass\n+\n+\n+class TestEnumInSignatures:\n+    \"\"\"Test class for enum handling in function signatures.\"\"\"\n+    \n+    def test_enum_default_formatting(self):\n+        \"\"\"Test that enum defaults are formatted cleanly in signatures.\"\"\"\n+        # Test the object_description function directly\n+        result = object_description(TestEnum.VALUE_ONE)\n+        assert result == \"TestEnum.VALUE_ONE\"\n+        assert \"<TestEnum.VALUE_ONE: 1>\" != result\n+        \n+    def test_enum_string_value_formatting(self):\n+        \"\"\"Test that enum with string values are formatted cleanly.\"\"\"\n+        result = object_description(ColorEnum.RED)\n+        assert result == \"ColorEnum.RED\"\n+        assert \"<ColorEnum.RED: 'red'>\" != result\n+        \n+    def test_multiple_enum_types_formatting(self):\n+        \"\"\"Test that different enum types are all formatted cleanly.\"\"\"\n+        test_cases = [\n+            (TestEnum.VALUE_ONE, \"TestEnum.VALUE_ONE\"),\n+            (TestEnum.VALUE_TWO, \"TestEnum.VALUE_TWO\"),\n+            (TestEnum.STRING_VALUE, \"TestEnum.STRING_VALUE\"),\n+            (ColorEnum.RED, \"ColorEnum.RED\"),\n+            (ColorEnum.GREEN, \"ColorEnum.GREEN\"),\n+            (ColorEnum.BLUE, \"ColorEnum.BLUE\"),\n+        ]\n+        \n+        for enum_value, expected in test_cases:\n+            result = object_description(enum_value)\n+            assert result == expected, f\"Expected '{expected}', got '{result}'\"\n+            \n+    def test_enum_vs_non_enum_defaults(self):\n+        \"\"\"Test that enum and non-enum defaults are handled appropriately.\"\"\"\n+        # Enum should be formatted cleanly\n+        enum_result = object_description(TestEnum.VALUE_ONE)\n+        assert enum_result == \"TestEnum.VALUE_ONE\"\n+        \n+        # Non-enum should use existing behavior\n+        string_result = object_description(\"default\")\n+        assert string_result == \"'default'\"\n+        \n+        int_result = object_description(42)\n+        assert int_result == \"42\"\n+        \n+    def test_enum_formatting_consistency(self):\n+        \"\"\"Test that enum formatting is consistent across different contexts.\"\"\"\n+        # All enum values should follow the same pattern\n+        for enum_value in TestEnum:\n+            result = object_description(enum_value)\n+            expected_pattern = f\"TestEnum.{enum_value.name}\"\n+            assert result == expected_pattern\n+            \n+            # Should not contain angle brackets\n+            assert \"<\" not in result\n+            assert \">\" not in result\n+            \n+            # Should not contain the value representation\n+            assert str(enum_value.value) not in result or enum_value.name == str(enum_value.value)\n+\n+\n+class TestEnumSignatureIntegration:\n+    \"\"\"Integration tests for enum handling in autodoc signatures.\"\"\"\n+    \n+    def test_function_signature_with_enum_default(self):\n+        \"\"\"Test that function signatures with enum defaults look clean.\"\"\"\n+        # This test verifies the integration works end-to-end\n+        \n+        # Get the default value\n+        import inspect\n+        sig = inspect.signature(function_with_enum_default)\n+        param = sig.parameters['param']\n+        default_value = param.default\n+        \n+        # Format it using object_description (what Sphinx uses)\n+        formatted_default = object_description(default_value)\n+        \n+        # Should be clean format\n+        assert formatted_default == \"TestEnum.VALUE_ONE\"\n+        \n+        # Should not be the ugly format\n+        assert formatted_default != \"<TestEnum.VALUE_ONE: 1>\"\n+        \n+    def test_multiple_enum_defaults_in_signature(self):\n+        \"\"\"Test function with multiple enum defaults.\"\"\"\n+        import inspect\n+        sig = inspect.signature(function_with_multiple_enum_defaults)\n+        \n+        # Check color parameter\n+        color_param = sig.parameters['color']\n+        color_default = object_description(color_param.default)\n+        assert color_default == \"ColorEnum.RED\"\n+        \n+        # Check test_val parameter\n+        test_param = sig.parameters['test_val']\n+        test_default = object_description(test_param.default)\n+        assert test_default == \"TestEnum.STRING_VALUE\"\n+        \n+        # Check normal parameter (should be unchanged)\n+        normal_param = sig.parameters['normal_param']\n+        normal_default = object_description(normal_param.default)\n+        assert normal_default == \"'default'\"\n+        \n+    def test_enum_without_annotation(self):\n+        \"\"\"Test enum default without type annotation.\"\"\"\n+        import inspect\n+        sig = inspect.signature(function_with_enum_no_annotation)\n+        param = sig.parameters['param']\n+        default_value = param.default\n+        \n+        formatted_default = object_description(default_value)\n+        assert formatted_default == \"TestEnum.VALUE_TWO\"\n+\n+\n+def test_enum_signature_bug_reproduction():\n+    \"\"\"Test that reproduces the exact bug from the issue description.\"\"\"\n+    \n+    # Create a function similar to the one in the bug report\n+    def ugly_enum_func(e: TestEnum = TestEnum.VALUE_ONE) -> None:\n+        \"\"\"Function that demonstrates the enum signature bug.\"\"\"\n+        pass\n+    \n+    # Get the default value\n+    import inspect\n+    sig = inspect.signature(ugly_enum_func)\n+    param = sig.parameters['e']\n+    default_value = param.default\n+    \n+    # Format using object_description (what Sphinx autodoc uses)\n+    formatted_default = object_description(default_value)\n+    \n+    # The bug was that this would show: <TestEnum.VALUE_ONE: 1>\n+    # After fix, it should show: TestEnum.VALUE_ONE\n+    \n+    assert formatted_default == \"TestEnum.VALUE_ONE\"\n+    \n+    # Verify it's not the ugly format\n+    ugly_format = \"<TestEnum.VALUE_ONE: 1>\"\n+    assert formatted_default != ugly_format\n+    \n+    # Verify it doesn't contain angle brackets\n+    assert \"<\" not in formatted_default\n+    assert \">\" not in formatted_default\n+\n+\n+def test_enum_edge_cases_in_signatures():\n+    \"\"\"Test edge cases for enum handling in signatures.\"\"\"\n+    \n+    # Test enum with complex name\n+    class ComplexEnum(enum.Enum):\n+        VERY_LONG_NAME_WITH_UNDERSCORES = \"complex\"\n+        ANOTHER_VALUE = 123\n+    \n+    def func_with_complex_enum(param: ComplexEnum = ComplexEnum.VERY_LONG_NAME_WITH_UNDERSCORES):\n+        pass\n+    \n+    import inspect\n+    sig = inspect.signature(func_with_complex_enum)\n+    param = sig.parameters['param']\n+    default_value = param.default\n+    \n+    formatted_default = object_description(default_value)\n+    assert formatted_default == \"ComplexEnum.VERY_LONG_NAME_WITH_UNDERSCORES\"\n+    \n+    # Test IntEnum\n+    class TestIntEnum(enum.IntEnum):\n+        FIRST = 1\n+        SECOND = 2\n+    \n+    def func_with_int_enum(param: TestIntEnum = TestIntEnum.FIRST):\n+        pass\n+    \n+    sig = inspect.signature(func_with_int_enum)\n+    param = sig.parameters['param']\n+    default_value = param.default\n+    \n+    formatted_default = object_description(default_value)\n+    assert formatted_default == \"TestIntEnum.FIRST\"\n"
}