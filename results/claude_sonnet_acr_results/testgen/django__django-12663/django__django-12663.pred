{
  "instance_id": "django__django-12663",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_simple_lazy_object_regression.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib.auth.models import User\nfrom django.db import models\nfrom django.db.models import OuterRef, Subquery\nfrom django.test import TestCase, TransactionTestCase\nfrom django.utils.functional import SimpleLazyObject\n\n\n# Test models for the regression test\nclass A(models.Model):\n    class Meta:\n        app_label = 'test_simple_lazy_object_regression'\n\n\nclass B(models.Model):\n    a = models.ForeignKey(A, on_delete=models.CASCADE)\n    \n    class Meta:\n        app_label = 'test_simple_lazy_object_regression'\n\n\nclass C(models.Model):\n    owner = models.ForeignKey(User, on_delete=models.CASCADE)\n    \n    class Meta:\n        app_label = 'test_simple_lazy_object_regression'\n\n\nclass SimpleLazyObjectRegressionTest(TransactionTestCase):\n    \"\"\"\n    Test for regression where SimpleLazyObject fails with nested subquery annotations.\n    \n    Prior to commit 35431298226165986ad07e91f9d3aca721ff38ec, it was possible to use\n    SimpleLazyObject in querysets. This test ensures the functionality is preserved.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        # Create test user\n        self.user = User.objects.create_user('testuser')\n        \n        # Create test instances\n        self.a_instance = A.objects.create()\n        self.b_instance = B.objects.create(a=self.a_instance)\n        self.c_instance = C.objects.create(owner=self.user)\n    \n    def test_simple_lazy_object_with_nested_subquery_annotation_fails_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug - SimpleLazyObject fails with nested subquery.\n        \n        This test should fail before the fix is applied, demonstrating the regression.\n        \"\"\"\n        # Create the nested subquery annotation as described in the issue\n        owner_user = (\n            B.objects.filter(a=OuterRef(\"pk\"))\n            .annotate(owner_user=Subquery(C.objects.values(\"owner\")))\n            .values(\"owner_user\")\n        )\n        \n        # Create SimpleLazyObject wrapping a user\n        user = SimpleLazyObject(lambda: User.objects.create_user(\"testuser2\"))\n        \n        # This should fail with TypeError before the fix\n        with pytest.raises(TypeError, match=r\"int\\(\\) argument must be a string, a bytes-like object or a number, not 'SimpleLazyObject'\"):\n            list(A.objects.annotate(owner_user=Subquery(owner_user)).filter(\n                owner_user=user\n            ))\n    \n    def test_simple_lazy_object_with_nested_subquery_annotation_works_after_fix(self):\n        \"\"\"\n        Test that SimpleLazyObject works with nested subquery after the fix.\n        \n        This test should pass after the fix is applied.\n        \"\"\"\n        # Create the nested subquery annotation as described in the issue\n        owner_user = (\n            B.objects.filter(a=OuterRef(\"pk\"))\n            .annotate(owner_user=Subquery(C.objects.values(\"owner\")))\n            .values(\"owner_user\")\n        )\n        \n        # Create SimpleLazyObject wrapping the existing user\n        user = SimpleLazyObject(lambda: self.user)\n        \n        # This should work after the fix - no exception should be raised\n        try:\n            queryset = A.objects.annotate(owner_user=Subquery(owner_user)).filter(\n                owner_user=user\n            )\n            # Force evaluation of the queryset\n            list(queryset)\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"SimpleLazyObject should be handled properly, but got: {e}\")\n            else:\n                # Re-raise if it's a different TypeError\n                raise\n    \n    def test_simple_lazy_object_with_direct_filter(self):\n        \"\"\"\n        Test SimpleLazyObject works with direct filtering on foreign key fields.\n        \"\"\"\n        # Create SimpleLazyObject wrapping the user\n        user = SimpleLazyObject(lambda: self.user)\n        \n        # This should work - filtering C objects by owner using SimpleLazyObject\n        try:\n            queryset = C.objects.filter(owner=user)\n            list(queryset)\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"SimpleLazyObject should be handled properly in direct filters, but got: {e}\")\n            else:\n                raise\n    \n    def test_simple_lazy_object_with_integer_field_directly(self):\n        \"\"\"\n        Test SimpleLazyObject containing an integer works with IntegerField.\n        \"\"\"\n        # Create SimpleLazyObject wrapping an integer (user's pk)\n        user_pk = SimpleLazyObject(lambda: self.user.pk)\n        \n        # This should work - filtering by primary key using SimpleLazyObject\n        try:\n            queryset = C.objects.filter(owner_id=user_pk)\n            list(queryset)\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"SimpleLazyObject should be handled properly with integer values, but got: {e}\")\n            else:\n                raise\n    \n    def test_simple_lazy_object_edge_cases(self):\n        \"\"\"\n        Test edge cases with SimpleLazyObject to ensure robustness.\n        \"\"\"\n        # Test with None value\n        none_lazy = SimpleLazyObject(lambda: None)\n        try:\n            queryset = C.objects.filter(owner=none_lazy)\n            list(queryset)\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"SimpleLazyObject with None should be handled properly, but got: {e}\")\n            else:\n                raise\n        \n        # Test with string value that should be converted to int\n        string_pk = SimpleLazyObject(lambda: str(self.user.pk))\n        try:\n            queryset = C.objects.filter(owner_id=string_pk)\n            list(queryset)\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"SimpleLazyObject with string should be handled properly, but got: {e}\")\n            else:\n                raise\n    \n    def test_regular_values_still_work(self):\n        \"\"\"\n        Test that regular (non-lazy) values continue to work as expected.\n        \n        This ensures the fix doesn't break existing functionality.\n        \"\"\"\n        # Test with regular User object\n        queryset = C.objects.filter(owner=self.user)\n        results = list(queryset)\n        assert len(results) == 1\n        assert results[0] == self.c_instance\n        \n        # Test with regular integer\n        queryset = C.objects.filter(owner_id=self.user.pk)\n        results = list(queryset)\n        assert len(results) == 1\n        assert results[0] == self.c_instance\n        \n        # Test with string that gets converted to int\n        queryset = C.objects.filter(owner_id=str(self.user.pk))\n        results = list(queryset)\n        assert len(results) == 1\n        assert results[0] == self.c_instance\n    \n    def test_promise_objects_still_work(self):\n        \"\"\"\n        Test that Promise objects (if any) continue to work as expected.\n        \n        This ensures the fix doesn't interfere with existing Promise handling.\n        \"\"\"\n        # This test ensures that the existing Promise handling logic\n        # continues to work alongside the new SimpleLazyObject handling\n        \n        # Test with regular values to ensure Promise path isn't broken\n        queryset = C.objects.filter(owner=self.user)\n        results = list(queryset)\n        assert len(results) == 1\n        assert results[0] == self.c_instance\n</patched>\n```\n\n```\n<file>tests/db_functions/test_simple_lazy_object.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib.auth.models import User\nfrom django.db import models\nfrom django.test import TestCase\nfrom django.utils.functional import SimpleLazyObject\nfrom django.db.models.fields import IntegerField, CharField, BooleanField\n\n\nclass SimpleLazyObjectFieldTest(TestCase):\n    \"\"\"\n    Test SimpleLazyObject handling in various field types.\n    \n    These tests focus on the get_prep_value method of different field types\n    to ensure SimpleLazyObject is properly resolved.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        self.user = User.objects.create_user('testuser')\n    \n    def test_integer_field_get_prep_value_with_simple_lazy_object(self):\n        \"\"\"\n        Test IntegerField.get_prep_value handles SimpleLazyObject correctly.\n        \n        This is the core issue - IntegerField should be able to handle\n        SimpleLazyObject by resolving it first.\n        \"\"\"\n        field = IntegerField()\n        \n        # Test with SimpleLazyObject containing an integer\n        lazy_int = SimpleLazyObject(lambda: 42)\n        \n        # This should not raise TypeError after the fix\n        try:\n            result = field.get_prep_value(lazy_int)\n            assert result == 42\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"IntegerField should handle SimpleLazyObject, but got: {e}\")\n            else:\n                raise\n    \n    def test_integer_field_get_prep_value_with_simple_lazy_object_user_pk(self):\n        \"\"\"\n        Test IntegerField.get_prep_value with SimpleLazyObject containing User.pk.\n        \n        This simulates the real-world scenario from the bug report.\n        \"\"\"\n        field = IntegerField()\n        \n        # Test with SimpleLazyObject containing a user's primary key\n        lazy_user_pk = SimpleLazyObject(lambda: self.user.pk)\n        \n        try:\n            result = field.get_prep_value(lazy_user_pk)\n            assert result == self.user.pk\n            assert isinstance(result, int)\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"IntegerField should handle SimpleLazyObject with User.pk, but got: {e}\")\n            else:\n                raise\n    \n    def test_char_field_get_prep_value_with_simple_lazy_object(self):\n        \"\"\"\n        Test CharField.get_prep_value handles SimpleLazyObject correctly.\n        \"\"\"\n        field = CharField()\n        \n        # Test with SimpleLazyObject containing a string\n        lazy_str = SimpleLazyObject(lambda: \"test string\")\n        \n        try:\n            result = field.get_prep_value(lazy_str)\n            assert result == \"test string\"\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"CharField should handle SimpleLazyObject, but got: {e}\")\n            else:\n                raise\n    \n    def test_boolean_field_get_prep_value_with_simple_lazy_object(self):\n        \"\"\"\n        Test BooleanField.get_prep_value handles SimpleLazyObject correctly.\n        \"\"\"\n        field = BooleanField()\n        \n        # Test with SimpleLazyObject containing a boolean\n        lazy_bool = SimpleLazyObject(lambda: True)\n        \n        try:\n            result = field.get_prep_value(lazy_bool)\n            assert result is True\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"BooleanField should handle SimpleLazyObject, but got: {e}\")\n            else:\n                raise\n    \n    def test_field_get_prep_value_with_simple_lazy_object_none(self):\n        \"\"\"\n        Test Field.get_prep_value handles SimpleLazyObject containing None.\n        \"\"\"\n        field = IntegerField()\n        \n        # Test with SimpleLazyObject containing None\n        lazy_none = SimpleLazyObject(lambda: None)\n        \n        try:\n            result = field.get_prep_value(lazy_none)\n            assert result is None\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"Field should handle SimpleLazyObject with None, but got: {e}\")\n            else:\n                raise\n    \n    def test_field_get_prep_value_with_simple_lazy_object_complex_object(self):\n        \"\"\"\n        Test Field.get_prep_value handles SimpleLazyObject containing complex objects.\n        \"\"\"\n        field = IntegerField()\n        \n        # Test with SimpleLazyObject containing a User object (should extract pk)\n        lazy_user = SimpleLazyObject(lambda: self.user)\n        \n        try:\n            result = field.get_prep_value(lazy_user)\n            # The result should be the user object itself, which IntegerField\n            # will then try to convert. This tests the resolution step.\n            assert result == self.user\n        except TypeError as e:\n            if \"SimpleLazyObject\" in str(e):\n                pytest.fail(f\"Field should handle SimpleLazyObject resolution, but got: {e}\")\n            else:\n                # This might fail later in IntegerField processing, which is expected\n                # if we pass a User object to IntegerField, but the SimpleLazyObject\n                # should be resolved first\n                pass\n    \n    def test_simple_lazy_object_evaluation_happens_once(self):\n        \"\"\"\n        Test that SimpleLazyObject is evaluated only once during get_prep_value.\n        \"\"\"\n        call_count = 0\n        \n        def lazy_func():\n            nonlocal call_count\n            call_count += 1\n            return 42\n        \n        field = IntegerField()\n        lazy_int = SimpleLazyObject(lazy_func)\n        \n        # Call get_prep_value\n        result = field.get_prep_value(lazy_int)\n        \n        # The lazy function should have been called to resolve the value\n        assert call_count >= 1\n        assert result == 42\n    \n    def test_regular_values_unchanged(self):\n        \"\"\"\n        Test that regular (non-SimpleLazyObject) values are processed normally.\n        \n        This ensures the fix doesn't break existing functionality.\n        \"\"\"\n        field = IntegerField()\n        \n        # Test regular integer\n        result = field.get_prep_value(42)\n        assert result == 42\n        \n        # Test string that should be converted to int\n        result = field.get_prep_value(\"123\")\n        assert result == 123\n        \n        # Test None\n        result = field.get_prep_value(None)\n        assert result is None\n</patched>\n```",
  "patch": "--- a/tests/test_simple_lazy_object_regression.py\n+++ b/tests/test_simple_lazy_object_regression.py\n-# Empty if creating new file\n+import pytest\n+from django.contrib.auth.models import User\n+from django.db import models\n+from django.db.models import OuterRef, Subquery\n+from django.test import TestCase, TransactionTestCase\n+from django.utils.functional import SimpleLazyObject\n+\n+\n+# Test models for the regression test\n+class A(models.Model):\n+    class Meta:\n+        app_label = 'test_simple_lazy_object_regression'\n+\n+\n+class B(models.Model):\n+    a = models.ForeignKey(A, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'test_simple_lazy_object_regression'\n+\n+\n+class C(models.Model):\n+    owner = models.ForeignKey(User, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'test_simple_lazy_object_regression'\n+\n+\n+class SimpleLazyObjectRegressionTest(TransactionTestCase):\n+    \"\"\"\n+    Test for regression where SimpleLazyObject fails with nested subquery annotations.\n+    \n+    Prior to commit 35431298226165986ad07e91f9d3aca721ff38ec, it was possible to use\n+    SimpleLazyObject in querysets. This test ensures the functionality is preserved.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        # Create test user\n+        self.user = User.objects.create_user('testuser')\n+        \n+        # Create test instances\n+        self.a_instance = A.objects.create()\n+        self.b_instance = B.objects.create(a=self.a_instance)\n+        self.c_instance = C.objects.create(owner=self.user)\n+    \n+    def test_simple_lazy_object_with_nested_subquery_annotation_fails_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug - SimpleLazyObject fails with nested subquery.\n+        \n+        This test should fail before the fix is applied, demonstrating the regression.\n+        \"\"\"\n+        # Create the nested subquery annotation as described in the issue\n+        owner_user = (\n+            B.objects.filter(a=OuterRef(\"pk\"))\n+            .annotate(owner_user=Subquery(C.objects.values(\"owner\")))\n+            .values(\"owner_user\")\n+        )\n+        \n+        # Create SimpleLazyObject wrapping a user\n+        user = SimpleLazyObject(lambda: User.objects.create_user(\"testuser2\"))\n+        \n+        # This should fail with TypeError before the fix\n+        with pytest.raises(TypeError, match=r\"int\\(\\) argument must be a string, a bytes-like object or a number, not 'SimpleLazyObject'\"):\n+            list(A.objects.annotate(owner_user=Subquery(owner_user)).filter(\n+                owner_user=user\n+            ))\n+    \n+    def test_simple_lazy_object_with_nested_subquery_annotation_works_after_fix(self):\n+        \"\"\"\n+        Test that SimpleLazyObject works with nested subquery after the fix.\n+        \n+        This test should pass after the fix is applied.\n+        \"\"\"\n+        # Create the nested subquery annotation as described in the issue\n+        owner_user = (\n+            B.objects.filter(a=OuterRef(\"pk\"))\n+            .annotate(owner_user=Subquery(C.objects.values(\"owner\")))\n+            .values(\"owner_user\")\n+        )\n+        \n+        # Create SimpleLazyObject wrapping the existing user\n+        user = SimpleLazyObject(lambda: self.user)\n+        \n+        # This should work after the fix - no exception should be raised\n+        try:\n+            queryset = A.objects.annotate(owner_user=Subquery(owner_user)).filter(\n+                owner_user=user\n+            )\n+            # Force evaluation of the queryset\n+            list(queryset)\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"SimpleLazyObject should be handled properly, but got: {e}\")\n+            else:\n+                # Re-raise if it's a different TypeError\n+                raise\n+    \n+    def test_simple_lazy_object_with_direct_filter(self):\n+        \"\"\"\n+        Test SimpleLazyObject works with direct filtering on foreign key fields.\n+        \"\"\"\n+        # Create SimpleLazyObject wrapping the user\n+        user = SimpleLazyObject(lambda: self.user)\n+        \n+        # This should work - filtering C objects by owner using SimpleLazyObject\n+        try:\n+            queryset = C.objects.filter(owner=user)\n+            list(queryset)\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"SimpleLazyObject should be handled properly in direct filters, but got: {e}\")\n+            else:\n+                raise\n+    \n+    def test_simple_lazy_object_with_integer_field_directly(self):\n+        \"\"\"\n+        Test SimpleLazyObject containing an integer works with IntegerField.\n+        \"\"\"\n+        # Create SimpleLazyObject wrapping an integer (user's pk)\n+        user_pk = SimpleLazyObject(lambda: self.user.pk)\n+        \n+        # This should work - filtering by primary key using SimpleLazyObject\n+        try:\n+            queryset = C.objects.filter(owner_id=user_pk)\n+            list(queryset)\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"SimpleLazyObject should be handled properly with integer values, but got: {e}\")\n+            else:\n+                raise\n+    \n+    def test_simple_lazy_object_edge_cases(self):\n+        \"\"\"\n+        Test edge cases with SimpleLazyObject to ensure robustness.\n+        \"\"\"\n+        # Test with None value\n+        none_lazy = SimpleLazyObject(lambda: None)\n+        try:\n+            queryset = C.objects.filter(owner=none_lazy)\n+            list(queryset)\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"SimpleLazyObject with None should be handled properly, but got: {e}\")\n+            else:\n+                raise\n+        \n+        # Test with string value that should be converted to int\n+        string_pk = SimpleLazyObject(lambda: str(self.user.pk))\n+        try:\n+            queryset = C.objects.filter(owner_id=string_pk)\n+            list(queryset)\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"SimpleLazyObject with string should be handled properly, but got: {e}\")\n+            else:\n+                raise\n+    \n+    def test_regular_values_still_work(self):\n+        \"\"\"\n+        Test that regular (non-lazy) values continue to work as expected.\n+        \n+        This ensures the fix doesn't break existing functionality.\n+        \"\"\"\n+        # Test with regular User object\n+        queryset = C.objects.filter(owner=self.user)\n+        results = list(queryset)\n+        assert len(results) == 1\n+        assert results[0] == self.c_instance\n+        \n+        # Test with regular integer\n+        queryset = C.objects.filter(owner_id=self.user.pk)\n+        results = list(queryset)\n+        assert len(results) == 1\n+        assert results[0] == self.c_instance\n+        \n+        # Test with string that gets converted to int\n+        queryset = C.objects.filter(owner_id=str(self.user.pk))\n+        results = list(queryset)\n+        assert len(results) == 1\n+        assert results[0] == self.c_instance\n+    \n+    def test_promise_objects_still_work(self):\n+        \"\"\"\n+        Test that Promise objects (if any) continue to work as expected.\n+        \n+        This ensures the fix doesn't interfere with existing Promise handling.\n+        \"\"\"\n+        # This test ensures that the existing Promise handling logic\n+        # continues to work alongside the new SimpleLazyObject handling\n+        \n+        # Test with regular values to ensure Promise path isn't broken\n+        queryset = C.objects.filter(owner=self.user)\n+        results = list(queryset)\n+        assert len(results) == 1\n+        assert results[0] == self.c_instance\n\n--- a/tests/db_functions/test_simple_lazy_object.py\n+++ b/tests/db_functions/test_simple_lazy_object.py\n-# Empty if creating new file\n+import pytest\n+from django.contrib.auth.models import User\n+from django.db import models\n+from django.test import TestCase\n+from django.utils.functional import SimpleLazyObject\n+from django.db.models.fields import IntegerField, CharField, BooleanField\n+\n+\n+class SimpleLazyObjectFieldTest(TestCase):\n+    \"\"\"\n+    Test SimpleLazyObject handling in various field types.\n+    \n+    These tests focus on the get_prep_value method of different field types\n+    to ensure SimpleLazyObject is properly resolved.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        self.user = User.objects.create_user('testuser')\n+    \n+    def test_integer_field_get_prep_value_with_simple_lazy_object(self):\n+        \"\"\"\n+        Test IntegerField.get_prep_value handles SimpleLazyObject correctly.\n+        \n+        This is the core issue - IntegerField should be able to handle\n+        SimpleLazyObject by resolving it first.\n+        \"\"\"\n+        field = IntegerField()\n+        \n+        # Test with SimpleLazyObject containing an integer\n+        lazy_int = SimpleLazyObject(lambda: 42)\n+        \n+        # This should not raise TypeError after the fix\n+        try:\n+            result = field.get_prep_value(lazy_int)\n+            assert result == 42\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"IntegerField should handle SimpleLazyObject, but got: {e}\")\n+            else:\n+                raise\n+    \n+    def test_integer_field_get_prep_value_with_simple_lazy_object_user_pk(self):\n+        \"\"\"\n+        Test IntegerField.get_prep_value with SimpleLazyObject containing User.pk.\n+        \n+        This simulates the real-world scenario from the bug report.\n+        \"\"\"\n+        field = IntegerField()\n+        \n+        # Test with SimpleLazyObject containing a user's primary key\n+        lazy_user_pk = SimpleLazyObject(lambda: self.user.pk)\n+        \n+        try:\n+            result = field.get_prep_value(lazy_user_pk)\n+            assert result == self.user.pk\n+            assert isinstance(result, int)\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"IntegerField should handle SimpleLazyObject with User.pk, but got: {e}\")\n+            else:\n+                raise\n+    \n+    def test_char_field_get_prep_value_with_simple_lazy_object(self):\n+        \"\"\"\n+        Test CharField.get_prep_value handles SimpleLazyObject correctly.\n+        \"\"\"\n+        field = CharField()\n+        \n+        # Test with SimpleLazyObject containing a string\n+        lazy_str = SimpleLazyObject(lambda: \"test string\")\n+        \n+        try:\n+            result = field.get_prep_value(lazy_str)\n+            assert result == \"test string\"\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"CharField should handle SimpleLazyObject, but got: {e}\")\n+            else:\n+                raise\n+    \n+    def test_boolean_field_get_prep_value_with_simple_lazy_object(self):\n+        \"\"\"\n+        Test BooleanField.get_prep_value handles SimpleLazyObject correctly.\n+        \"\"\"\n+        field = BooleanField()\n+        \n+        # Test with SimpleLazyObject containing a boolean\n+        lazy_bool = SimpleLazyObject(lambda: True)\n+        \n+        try:\n+            result = field.get_prep_value(lazy_bool)\n+            assert result is True\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"BooleanField should handle SimpleLazyObject, but got: {e}\")\n+            else:\n+                raise\n+    \n+    def test_field_get_prep_value_with_simple_lazy_object_none(self):\n+        \"\"\"\n+        Test Field.get_prep_value handles SimpleLazyObject containing None.\n+        \"\"\"\n+        field = IntegerField()\n+        \n+        # Test with SimpleLazyObject containing None\n+        lazy_none = SimpleLazyObject(lambda: None)\n+        \n+        try:\n+            result = field.get_prep_value(lazy_none)\n+            assert result is None\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"Field should handle SimpleLazyObject with None, but got: {e}\")\n+            else:\n+                raise\n+    \n+    def test_field_get_prep_value_with_simple_lazy_object_complex_object(self):\n+        \"\"\"\n+        Test Field.get_prep_value handles SimpleLazyObject containing complex objects.\n+        \"\"\"\n+        field = IntegerField()\n+        \n+        # Test with SimpleLazyObject containing a User object (should extract pk)\n+        lazy_user = SimpleLazyObject(lambda: self.user)\n+        \n+        try:\n+            result = field.get_prep_value(lazy_user)\n+            # The result should be the user object itself, which IntegerField\n+            # will then try to convert. This tests the resolution step.\n+            assert result == self.user\n+        except TypeError as e:\n+            if \"SimpleLazyObject\" in str(e):\n+                pytest.fail(f\"Field should handle SimpleLazyObject resolution, but got: {e}\")\n+            else:\n+                # This might fail later in IntegerField processing, which is expected\n+                # if we pass a User object to IntegerField, but the SimpleLazyObject\n+                # should be resolved first\n+                pass\n+    \n+    def test_simple_lazy_object_evaluation_happens_once(self):\n+        \"\"\"\n+        Test that SimpleLazyObject is evaluated only once during get_prep_value.\n+        \"\"\"\n+        call_count = 0\n+        \n+        def lazy_func():\n+            nonlocal call_count\n+            call_count += 1\n+            return 42\n+        \n+        field = IntegerField()\n+        lazy_int = SimpleLazyObject(lazy_func)\n+        \n+        # Call get_prep_value\n+        result = field.get_prep_value(lazy_int)\n+        \n+        # The lazy function should have been called to resolve the value\n+        assert call_count >= 1\n+        assert result == 42\n+    \n+    def test_regular_values_unchanged(self):\n+        \"\"\"\n+        Test that regular (non-SimpleLazyObject) values are processed normally.\n+        \n+        This ensures the fix doesn't break existing functionality.\n+        \"\"\"\n+        field = IntegerField()\n+        \n+        # Test regular integer\n+        result = field.get_prep_value(42)\n+        assert result == 42\n+        \n+        # Test string that should be converted to int\n+        result = field.get_prep_value(\"123\")\n+        assert result == 123\n+        \n+        # Test None\n+        result = field.get_prep_value(None)\n+        assert result is None\n"
}