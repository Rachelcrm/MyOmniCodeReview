{
  "instance_id": "django__django-15277",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/db_functions/test_value_optimization.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.core.validators import MaxLengthValidator\nfrom django.db import models\nfrom django.db.models import Value\nfrom django.db.models.fields import CharField, BinaryField\nfrom django.test import TestCase\n\n\nclass ValueOptimizationTests(TestCase):\n    \"\"\"\n    Test suite for the CharField optimization in Value._resolve_output_field().\n    \n    This tests the fix for the issue where CharField.__init__ unconditionally\n    creates a MaxLengthValidator even when max_length is None, causing\n    performance issues and potential errors.\n    \"\"\"\n\n    def test_value_resolve_output_field_creates_charfield_without_max_length_validator_when_none(self):\n        \"\"\"\n        Test that Value._resolve_output_field() creates a CharField without\n        MaxLengthValidator when max_length is None.\n        \n        This test demonstrates the bug fix - before the fix, a MaxLengthValidator\n        would be created with None as the limit value, causing issues.\n        \"\"\"\n        value = Value('test')\n        output_field = value._resolve_output_field()\n        \n        # The output field should be a CharField\n        self.assertIsInstance(output_field, CharField)\n        \n        # The CharField should not have any MaxLengthValidator when max_length is None\n        max_length_validators = [\n            validator for validator in output_field.validators\n            if isinstance(validator, MaxLengthValidator)\n        ]\n        self.assertEqual(len(max_length_validators), 0)\n        \n        # max_length should be None\n        self.assertIsNone(output_field.max_length)\n\n    def test_charfield_with_explicit_max_length_still_has_validator(self):\n        \"\"\"\n        Test that CharField with explicit max_length still gets MaxLengthValidator.\n        \n        This ensures the fix doesn't break existing functionality for normal\n        CharField usage with max_length specified.\n        \"\"\"\n        field = CharField(max_length=100)\n        \n        # Should have exactly one MaxLengthValidator\n        max_length_validators = [\n            validator for validator in field.validators\n            if isinstance(validator, MaxLengthValidator)\n        ]\n        self.assertEqual(len(max_length_validators), 1)\n        self.assertEqual(max_length_validators[0].limit_value, 100)\n\n    def test_charfield_without_max_length_has_no_validator(self):\n        \"\"\"\n        Test that CharField without max_length has no MaxLengthValidator.\n        \n        This is the core test for the bug fix - CharField() with no max_length\n        should not create a MaxLengthValidator.\n        \"\"\"\n        field = CharField()\n        \n        # Should have no MaxLengthValidator\n        max_length_validators = [\n            validator for validator in field.validators\n            if isinstance(validator, MaxLengthValidator)\n        ]\n        self.assertEqual(len(max_length_validators), 0)\n\n    def test_charfield_with_none_max_length_has_no_validator(self):\n        \"\"\"\n        Test that CharField with explicit max_length=None has no MaxLengthValidator.\n        \"\"\"\n        field = CharField(max_length=None)\n        \n        # Should have no MaxLengthValidator\n        max_length_validators = [\n            validator for validator in field.validators\n            if isinstance(validator, MaxLengthValidator)\n        ]\n        self.assertEqual(len(max_length_validators), 0)\n\n    def test_binaryfield_behavior_unchanged(self):\n        \"\"\"\n        Test that BinaryField behavior remains unchanged as a reference.\n        \n        BinaryField already implements the conditional validator pattern\n        that CharField should follow.\n        \"\"\"\n        # BinaryField without max_length\n        field1 = BinaryField()\n        max_length_validators1 = [\n            validator for validator in field1.validators\n            if isinstance(validator, MaxLengthValidator)\n        ]\n        self.assertEqual(len(max_length_validators1), 0)\n        \n        # BinaryField with max_length\n        field2 = BinaryField(max_length=100)\n        max_length_validators2 = [\n            validator for validator in field2.validators\n            if isinstance(validator, MaxLengthValidator)\n        ]\n        self.assertEqual(len(max_length_validators2), 1)\n        self.assertEqual(max_length_validators2[0].limit_value, 100)\n\n    def test_value_resolve_output_field_performance_improvement(self):\n        \"\"\"\n        Test that demonstrates the performance improvement by avoiding\n        unnecessary validator creation.\n        \n        This test verifies that no MaxLengthValidator is created when\n        Value._resolve_output_field() is called, which was the source\n        of the performance issue.\n        \"\"\"\n        import time\n        \n        # Create multiple Value instances and resolve their output fields\n        values = [Value(f'test_{i}') for i in range(100)]\n        \n        start_time = time.time()\n        output_fields = [value._resolve_output_field() for value in values]\n        end_time = time.time()\n        \n        # Verify all fields are CharField instances without MaxLengthValidator\n        for field in output_fields:\n            self.assertIsInstance(field, CharField)\n            max_length_validators = [\n                validator for validator in field.validators\n                if isinstance(validator, MaxLengthValidator)\n            ]\n            self.assertEqual(len(max_length_validators), 0)\n        \n        # The test should complete quickly (this is more of a smoke test)\n        # The actual performance improvement would be measured with profiling tools\n        self.assertLess(end_time - start_time, 1.0)  # Should complete in under 1 second\n\n    def test_charfield_validator_error_before_fix_simulation(self):\n        \"\"\"\n        Test that simulates the error that would occur before the fix.\n        \n        This test demonstrates what would happen if MaxLengthValidator\n        was created with None as the limit value.\n        \"\"\"\n        # Create a MaxLengthValidator with None (simulating the bug)\n        validator = MaxLengthValidator(None)\n        \n        # This should raise TypeError when trying to validate\n        with self.assertRaises(TypeError):\n            validator('test')\n\n    def test_value_different_types_still_work(self):\n        \"\"\"\n        Test that Value._resolve_output_field() works correctly for different types.\n        \n        This ensures the fix doesn't break other type resolutions.\n        \"\"\"\n        # String value\n        string_value = Value('test')\n        string_field = string_value._resolve_output_field()\n        self.assertIsInstance(string_field, CharField)\n        \n        # Boolean value\n        bool_value = Value(True)\n        bool_field = bool_value._resolve_output_field()\n        self.assertIsInstance(bool_field, models.BooleanField)\n        \n        # Integer value\n        int_value = Value(42)\n        int_field = int_value._resolve_output_field()\n        self.assertIsInstance(int_field, models.IntegerField)\n        \n        # Float value\n        float_value = Value(3.14)\n        float_field = float_value._resolve_output_field()\n        self.assertIsInstance(float_field, models.FloatField)\n\n    def test_charfield_clean_method_works_without_max_length(self):\n        \"\"\"\n        Test that CharField.clean() method works properly when no MaxLengthValidator is present.\n        \n        This ensures that removing the validator doesn't break field validation.\n        \"\"\"\n        field = CharField()\n        \n        # clean() should work without issues\n        try:\n            cleaned_value = field.clean('test', model_instance=None)\n            self.assertEqual(cleaned_value, 'test')\n        except Exception as e:\n            self.fail(f\"CharField.clean() raised an exception: {e}\")\n\n    def test_charfield_with_max_length_validation_still_works(self):\n        \"\"\"\n        Test that CharField with max_length still performs validation correctly.\n        \n        This ensures the fix doesn't break existing validation functionality.\n        \"\"\"\n        field = CharField(max_length=5)\n        \n        # Valid value should pass\n        cleaned_value = field.clean('test', model_instance=None)\n        self.assertEqual(cleaned_value, 'test')\n        \n        # Invalid value should raise ValidationError\n        from django.core.exceptions import ValidationError\n        with self.assertRaises(ValidationError):\n            field.clean('toolong', model_instance=None)\n</patched>\n</file>\n```",
  "patch": "--- a/tests/db_functions/test_value_optimization.py\n+++ b/tests/db_functions/test_value_optimization.py\n-# Empty if creating new file\n+import pytest\n+from django.core.validators import MaxLengthValidator\n+from django.db import models\n+from django.db.models import Value\n+from django.db.models.fields import CharField, BinaryField\n+from django.test import TestCase\n+\n+\n+class ValueOptimizationTests(TestCase):\n+    \"\"\"\n+    Test suite for the CharField optimization in Value._resolve_output_field().\n+    \n+    This tests the fix for the issue where CharField.__init__ unconditionally\n+    creates a MaxLengthValidator even when max_length is None, causing\n+    performance issues and potential errors.\n+    \"\"\"\n+\n+    def test_value_resolve_output_field_creates_charfield_without_max_length_validator_when_none(self):\n+        \"\"\"\n+        Test that Value._resolve_output_field() creates a CharField without\n+        MaxLengthValidator when max_length is None.\n+        \n+        This test demonstrates the bug fix - before the fix, a MaxLengthValidator\n+        would be created with None as the limit value, causing issues.\n+        \"\"\"\n+        value = Value('test')\n+        output_field = value._resolve_output_field()\n+        \n+        # The output field should be a CharField\n+        self.assertIsInstance(output_field, CharField)\n+        \n+        # The CharField should not have any MaxLengthValidator when max_length is None\n+        max_length_validators = [\n+            validator for validator in output_field.validators\n+            if isinstance(validator, MaxLengthValidator)\n+        ]\n+        self.assertEqual(len(max_length_validators), 0)\n+        \n+        # max_length should be None\n+        self.assertIsNone(output_field.max_length)\n+\n+    def test_charfield_with_explicit_max_length_still_has_validator(self):\n+        \"\"\"\n+        Test that CharField with explicit max_length still gets MaxLengthValidator.\n+        \n+        This ensures the fix doesn't break existing functionality for normal\n+        CharField usage with max_length specified.\n+        \"\"\"\n+        field = CharField(max_length=100)\n+        \n+        # Should have exactly one MaxLengthValidator\n+        max_length_validators = [\n+            validator for validator in field.validators\n+            if isinstance(validator, MaxLengthValidator)\n+        ]\n+        self.assertEqual(len(max_length_validators), 1)\n+        self.assertEqual(max_length_validators[0].limit_value, 100)\n+\n+    def test_charfield_without_max_length_has_no_validator(self):\n+        \"\"\"\n+        Test that CharField without max_length has no MaxLengthValidator.\n+        \n+        This is the core test for the bug fix - CharField() with no max_length\n+        should not create a MaxLengthValidator.\n+        \"\"\"\n+        field = CharField()\n+        \n+        # Should have no MaxLengthValidator\n+        max_length_validators = [\n+            validator for validator in field.validators\n+            if isinstance(validator, MaxLengthValidator)\n+        ]\n+        self.assertEqual(len(max_length_validators), 0)\n+\n+    def test_charfield_with_none_max_length_has_no_validator(self):\n+        \"\"\"\n+        Test that CharField with explicit max_length=None has no MaxLengthValidator.\n+        \"\"\"\n+        field = CharField(max_length=None)\n+        \n+        # Should have no MaxLengthValidator\n+        max_length_validators = [\n+            validator for validator in field.validators\n+            if isinstance(validator, MaxLengthValidator)\n+        ]\n+        self.assertEqual(len(max_length_validators), 0)\n+\n+    def test_binaryfield_behavior_unchanged(self):\n+        \"\"\"\n+        Test that BinaryField behavior remains unchanged as a reference.\n+        \n+        BinaryField already implements the conditional validator pattern\n+        that CharField should follow.\n+        \"\"\"\n+        # BinaryField without max_length\n+        field1 = BinaryField()\n+        max_length_validators1 = [\n+            validator for validator in field1.validators\n+            if isinstance(validator, MaxLengthValidator)\n+        ]\n+        self.assertEqual(len(max_length_validators1), 0)\n+        \n+        # BinaryField with max_length\n+        field2 = BinaryField(max_length=100)\n+        max_length_validators2 = [\n+            validator for validator in field2.validators\n+            if isinstance(validator, MaxLengthValidator)\n+        ]\n+        self.assertEqual(len(max_length_validators2), 1)\n+        self.assertEqual(max_length_validators2[0].limit_value, 100)\n+\n+    def test_value_resolve_output_field_performance_improvement(self):\n+        \"\"\"\n+        Test that demonstrates the performance improvement by avoiding\n+        unnecessary validator creation.\n+        \n+        This test verifies that no MaxLengthValidator is created when\n+        Value._resolve_output_field() is called, which was the source\n+        of the performance issue.\n+        \"\"\"\n+        import time\n+        \n+        # Create multiple Value instances and resolve their output fields\n+        values = [Value(f'test_{i}') for i in range(100)]\n+        \n+        start_time = time.time()\n+        output_fields = [value._resolve_output_field() for value in values]\n+        end_time = time.time()\n+        \n+        # Verify all fields are CharField instances without MaxLengthValidator\n+        for field in output_fields:\n+            self.assertIsInstance(field, CharField)\n+            max_length_validators = [\n+                validator for validator in field.validators\n+                if isinstance(validator, MaxLengthValidator)\n+            ]\n+            self.assertEqual(len(max_length_validators), 0)\n+        \n+        # The test should complete quickly (this is more of a smoke test)\n+        # The actual performance improvement would be measured with profiling tools\n+        self.assertLess(end_time - start_time, 1.0)  # Should complete in under 1 second\n+\n+    def test_charfield_validator_error_before_fix_simulation(self):\n+        \"\"\"\n+        Test that simulates the error that would occur before the fix.\n+        \n+        This test demonstrates what would happen if MaxLengthValidator\n+        was created with None as the limit value.\n+        \"\"\"\n+        # Create a MaxLengthValidator with None (simulating the bug)\n+        validator = MaxLengthValidator(None)\n+        \n+        # This should raise TypeError when trying to validate\n+        with self.assertRaises(TypeError):\n+            validator('test')\n+\n+    def test_value_different_types_still_work(self):\n+        \"\"\"\n+        Test that Value._resolve_output_field() works correctly for different types.\n+        \n+        This ensures the fix doesn't break other type resolutions.\n+        \"\"\"\n+        # String value\n+        string_value = Value('test')\n+        string_field = string_value._resolve_output_field()\n+        self.assertIsInstance(string_field, CharField)\n+        \n+        # Boolean value\n+        bool_value = Value(True)\n+        bool_field = bool_value._resolve_output_field()\n+        self.assertIsInstance(bool_field, models.BooleanField)\n+        \n+        # Integer value\n+        int_value = Value(42)\n+        int_field = int_value._resolve_output_field()\n+        self.assertIsInstance(int_field, models.IntegerField)\n+        \n+        # Float value\n+        float_value = Value(3.14)\n+        float_field = float_value._resolve_output_field()\n+        self.assertIsInstance(float_field, models.FloatField)\n+\n+    def test_charfield_clean_method_works_without_max_length(self):\n+        \"\"\"\n+        Test that CharField.clean() method works properly when no MaxLengthValidator is present.\n+        \n+        This ensures that removing the validator doesn't break field validation.\n+        \"\"\"\n+        field = CharField()\n+        \n+        # clean() should work without issues\n+        try:\n+            cleaned_value = field.clean('test', model_instance=None)\n+            self.assertEqual(cleaned_value, 'test')\n+        except Exception as e:\n+            self.fail(f\"CharField.clean() raised an exception: {e}\")\n+\n+    def test_charfield_with_max_length_validation_still_works(self):\n+        \"\"\"\n+        Test that CharField with max_length still performs validation correctly.\n+        \n+        This ensures the fix doesn't break existing validation functionality.\n+        \"\"\"\n+        field = CharField(max_length=5)\n+        \n+        # Valid value should pass\n+        cleaned_value = field.clean('test', model_instance=None)\n+        self.assertEqual(cleaned_value, 'test')\n+        \n+        # Invalid value should raise ValidationError\n+        from django.core.exceptions import ValidationError\n+        with self.assertRaises(ValidationError):\n+            field.clean('toolong', model_instance=None)\n"
}