{
  "instance_id": "django__django-12273",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_inheritance/test_pk_reset.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models\nfrom django.test import TestCase, TransactionTestCase\nfrom django.test.utils import override_settings\n\n\nclass Item(models.Model):\n    \"\"\"Base model with AutoField primary key.\"\"\"\n    uid = models.AutoField(primary_key=True, editable=False)\n    f = models.BooleanField(default=False)\n    \n    def reset(self):\n        \"\"\"Reset primary key and field value.\"\"\"\n        self.uid = None\n        self.f = False\n    \n    class Meta:\n        app_label = 'model_inheritance'\n\n\nclass Derived(Item):\n    \"\"\"Child model inheriting from Item.\"\"\"\n    extra_field = models.CharField(max_length=100, default='test')\n    \n    class Meta:\n        app_label = 'model_inheritance'\n\n\nclass ItemWithUUID(models.Model):\n    \"\"\"Base model with UUIDField primary key.\"\"\"\n    import uuid\n    uid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    f = models.BooleanField(default=False)\n    \n    def reset(self):\n        \"\"\"Reset primary key and field value.\"\"\"\n        self.uid = None\n        self.f = False\n    \n    class Meta:\n        app_label = 'model_inheritance'\n\n\nclass DerivedUUID(ItemWithUUID):\n    \"\"\"Child model inheriting from ItemWithUUID.\"\"\"\n    extra_field = models.CharField(max_length=100, default='test')\n    \n    class Meta:\n        app_label = 'model_inheritance'\n\n\n@override_settings(USE_TZ=False)\nclass PrimaryKeyResetTestCase(TransactionTestCase):\n    \"\"\"Test cases for primary key reset functionality in model inheritance.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        # Ensure tables exist\n        from django.core.management.color import no_style\n        from django.db import connection\n        \n        style = no_style()\n        sql = connection.ops.sql_table_creation_suffix()\n        \n        # Create tables if they don't exist\n        with connection.schema_editor() as schema_editor:\n            if not connection.introspection.table_names():\n                schema_editor.create_model(Item)\n                schema_editor.create_model(Derived)\n                schema_editor.create_model(ItemWithUUID)\n                schema_editor.create_model(DerivedUUID)\n    \n    def test_pk_reset_child_model_autofield_fails_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: resetting pk on child model doesn't work.\n        This test should FAIL before the fix is applied.\n        \"\"\"\n        # Create the first object\n        derived = Derived.objects.create(f=True, extra_field='original')\n        original_pk = derived.pk\n        \n        # Get the object through the parent model and access child\n        item = Item.objects.get(pk=derived.pk)\n        obj1 = item.derived\n        \n        # Reset the primary key - this should create a new object\n        obj1.reset()\n        obj1.extra_field = 'reset'\n        obj1.save()  # This should create a new object, not overwrite the existing one\n        \n        # The bug: the original object gets overwritten instead of creating a new one\n        # After the fix, this assertion should pass\n        try:\n            original_obj = Item.objects.get(pk=original_pk)\n            # If we can still find the original object with f=True, the bug is fixed\n            self.assertTrue(original_obj.f, \"Original object should still exist with f=True\")\n            \n            # There should be two objects now\n            self.assertEqual(Item.objects.count(), 2, \"Should have 2 objects after reset\")\n            self.assertEqual(Derived.objects.count(), 2, \"Should have 2 derived objects after reset\")\n            \n            # The new object should have f=False\n            new_obj = Derived.objects.get(extra_field='reset')\n            self.assertFalse(new_obj.f, \"New object should have f=False\")\n            self.assertNotEqual(new_obj.pk, original_pk, \"New object should have different pk\")\n            \n        except Item.DoesNotExist:\n            # This is the bug - the original object was overwritten\n            self.fail(\"Original object was overwritten instead of creating a new one\")\n    \n    def test_pk_reset_child_model_autofield_after_fix(self):\n        \"\"\"\n        Test that verifies the fix: resetting pk on child model creates new object.\n        This test should PASS after the fix is applied.\n        \"\"\"\n        # Create the first object\n        derived = Derived.objects.create(f=True, extra_field='original')\n        original_pk = derived.pk\n        \n        # Reset the primary key on the child object\n        derived.reset()\n        derived.extra_field = 'new_object'\n        derived.save()  # Should create a new object\n        \n        # Verify original object still exists\n        original_obj = Item.objects.get(pk=original_pk)\n        self.assertTrue(original_obj.f, \"Original object should still exist with f=True\")\n        \n        # Verify new object was created\n        self.assertEqual(Item.objects.count(), 2, \"Should have 2 objects after reset\")\n        self.assertEqual(Derived.objects.count(), 2, \"Should have 2 derived objects after reset\")\n        \n        # Verify new object has correct values\n        new_obj = Derived.objects.get(extra_field='new_object')\n        self.assertFalse(new_obj.f, \"New object should have f=False\")\n        self.assertNotEqual(new_obj.pk, original_pk, \"New object should have different pk\")\n    \n    def test_pk_reset_child_model_uuid_fails_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug with UUID primary keys.\n        This test should FAIL before the fix is applied.\n        \"\"\"\n        # Create the first object\n        derived = DerivedUUID.objects.create(f=True, extra_field='original')\n        original_pk = derived.pk\n        \n        # Get the object through the parent model and access child\n        item = ItemWithUUID.objects.get(pk=derived.pk)\n        obj1 = item.deriveduuid\n        \n        # Reset the primary key - this should create a new object\n        obj1.reset()\n        obj1.extra_field = 'reset'\n        obj1.save()  # This should create a new object, not overwrite the existing one\n        \n        # The bug: the original object gets overwritten instead of creating a new one\n        try:\n            original_obj = ItemWithUUID.objects.get(pk=original_pk)\n            # If we can still find the original object with f=True, the bug is fixed\n            self.assertTrue(original_obj.f, \"Original object should still exist with f=True\")\n            \n            # There should be two objects now\n            self.assertEqual(ItemWithUUID.objects.count(), 2, \"Should have 2 objects after reset\")\n            self.assertEqual(DerivedUUID.objects.count(), 2, \"Should have 2 derived objects after reset\")\n            \n        except ItemWithUUID.DoesNotExist:\n            # This is the bug - the original object was overwritten\n            self.fail(\"Original object was overwritten instead of creating a new one\")\n    \n    def test_pk_reset_direct_child_object(self):\n        \"\"\"\n        Test resetting pk directly on child object (not through parent).\n        \"\"\"\n        # Create the first object\n        derived = Derived.objects.create(f=True, extra_field='original')\n        original_pk = derived.pk\n        \n        # Reset pk directly on child object\n        derived.reset()\n        derived.extra_field = 'direct_reset'\n        derived.save()\n        \n        # Should create new object, original should still exist\n        self.assertEqual(Derived.objects.count(), 2, \"Should have 2 objects after direct reset\")\n        \n        # Original object should still exist\n        original_obj = Derived.objects.get(pk=original_pk)\n        self.assertTrue(original_obj.f, \"Original object should still exist\")\n        self.assertEqual(original_obj.extra_field, 'original')\n        \n        # New object should exist with reset values\n        new_obj = Derived.objects.get(extra_field='direct_reset')\n        self.assertFalse(new_obj.f, \"New object should have f=False\")\n        self.assertNotEqual(new_obj.pk, original_pk, \"New object should have different pk\")\n    \n    def test_pk_reset_multiple_inheritance_levels(self):\n        \"\"\"\n        Test pk reset with multiple levels of inheritance.\n        \"\"\"\n        # Create a third level of inheritance for this test\n        class GrandChild(Derived):\n            grand_field = models.CharField(max_length=50, default='grand')\n            \n            class Meta:\n                app_label = 'model_inheritance'\n        \n        # Create tables for the new model\n        with connection.schema_editor() as schema_editor:\n            schema_editor.create_model(GrandChild)\n        \n        # Create the first object\n        grandchild = GrandChild.objects.create(f=True, extra_field='original', grand_field='first')\n        original_pk = grandchild.pk\n        \n        # Reset pk and save\n        grandchild.uid = None\n        grandchild.f = False\n        grandchild.extra_field = 'new'\n        grandchild.grand_field = 'second'\n        grandchild.save()\n        \n        # Should create new object at all levels\n        self.assertEqual(Item.objects.count(), 2, \"Should have 2 Item objects\")\n        self.assertEqual(Derived.objects.count(), 2, \"Should have 2 Derived objects\")\n        self.assertEqual(GrandChild.objects.count(), 2, \"Should have 2 GrandChild objects\")\n        \n        # Original should still exist\n        original = GrandChild.objects.get(pk=original_pk)\n        self.assertTrue(original.f)\n        self.assertEqual(original.extra_field, 'original')\n        self.assertEqual(original.grand_field, 'first')\n        \n        # New object should exist\n        new_obj = GrandChild.objects.get(grand_field='second')\n        self.assertFalse(new_obj.f)\n        self.assertEqual(new_obj.extra_field, 'new')\n        self.assertNotEqual(new_obj.pk, original_pk)\n    \n    def test_pk_reset_with_force_insert(self):\n        \"\"\"\n        Test that force_insert=True works correctly with pk reset.\n        \"\"\"\n        derived = Derived.objects.create(f=True, extra_field='original')\n        original_pk = derived.pk\n        \n        # Reset pk and save with force_insert\n        derived.uid = None\n        derived.f = False\n        derived.extra_field = 'forced'\n        derived.save(force_insert=True)\n        \n        # Should create new object\n        self.assertEqual(Derived.objects.count(), 2)\n        \n        # Original should still exist\n        original = Derived.objects.get(pk=original_pk)\n        self.assertTrue(original.f)\n        \n        # New object should exist\n        new_obj = Derived.objects.get(extra_field='forced')\n        self.assertFalse(new_obj.f)\n        self.assertNotEqual(new_obj.pk, original_pk)\n    \n    def test_pk_reset_preserves_other_fields(self):\n        \"\"\"\n        Test that resetting pk preserves other field values correctly.\n        \"\"\"\n        derived = Derived.objects.create(f=True, extra_field='preserve_me')\n        \n        # Reset only the pk, keep other fields\n        derived.uid = None\n        derived.save()\n        \n        # Should have 2 objects now\n        self.assertEqual(Derived.objects.count(), 2)\n        \n        # Both objects should have the same extra_field value\n        objects = list(Derived.objects.all())\n        self.assertEqual(len(objects), 2)\n        for obj in objects:\n            self.assertEqual(obj.extra_field, 'preserve_me')\n        \n        # But different pk values\n        self.assertNotEqual(objects[0].pk, objects[1].pk)\n    \n    def test_normal_save_still_works(self):\n        \"\"\"\n        Test that normal save operations (without pk reset) still work correctly.\n        \"\"\"\n        derived = Derived.objects.create(f=True, extra_field='original')\n        original_pk = derived.pk\n        \n        # Modify field and save (without resetting pk)\n        derived.f = False\n        derived.extra_field = 'modified'\n        derived.save()\n        \n        # Should still have only 1 object\n        self.assertEqual(Derived.objects.count(), 1)\n        \n        # Object should be updated, not created new\n        updated_obj = Derived.objects.get(pk=original_pk)\n        self.assertFalse(updated_obj.f)\n        self.assertEqual(updated_obj.extra_field, 'modified')\n\n\n# Additional test to reproduce the exact scenario from the issue\nclass SaveTestCase(TestCase):\n    \"\"\"Reproduce the exact test case from the issue description.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up as described in the issue.\"\"\"\n        # Ensure tables exist\n        with connection.schema_editor() as schema_editor:\n            schema_editor.create_model(Item)\n            schema_editor.create_model(Derived)\n        \n        self.derived = Derived.objects.create(f=True)  # create the first object\n        item = Item.objects.get(pk=self.derived.pk)\n        obj1 = item.derived\n        obj1.reset()\n        obj1.save()  # the first object is overwritten (this is the bug)\n\n    def test_f_true(self):\n        \"\"\"\n        This test demonstrates the bug from the issue.\n        It should FAIL before the fix because the original object gets overwritten.\n        After the fix, this test should PASS because the original object is preserved.\n        \"\"\"\n        # Try to get the original object - this will fail if it was overwritten\n        try:\n            obj = Item.objects.get(pk=self.derived.pk)\n            # The original object should still have f=True\n            self.assertTrue(obj.f, \"Original object should still exist with f=True\")\n        except Item.DoesNotExist:\n            self.fail(\"Original object was overwritten instead of creating a new one\")\n        \n        # There should be 2 objects total now (original + new)\n        self.assertEqual(Item.objects.count(), 2, \"Should have 2 objects after pk reset\")\n</patched>\n</file>\n```",
  "patch": "--- a/tests/model_inheritance/test_pk_reset.py\n+++ b/tests/model_inheritance/test_pk_reset.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models\n+from django.test import TestCase, TransactionTestCase\n+from django.test.utils import override_settings\n+\n+\n+class Item(models.Model):\n+    \"\"\"Base model with AutoField primary key.\"\"\"\n+    uid = models.AutoField(primary_key=True, editable=False)\n+    f = models.BooleanField(default=False)\n+    \n+    def reset(self):\n+        \"\"\"Reset primary key and field value.\"\"\"\n+        self.uid = None\n+        self.f = False\n+    \n+    class Meta:\n+        app_label = 'model_inheritance'\n+\n+\n+class Derived(Item):\n+    \"\"\"Child model inheriting from Item.\"\"\"\n+    extra_field = models.CharField(max_length=100, default='test')\n+    \n+    class Meta:\n+        app_label = 'model_inheritance'\n+\n+\n+class ItemWithUUID(models.Model):\n+    \"\"\"Base model with UUIDField primary key.\"\"\"\n+    import uuid\n+    uid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n+    f = models.BooleanField(default=False)\n+    \n+    def reset(self):\n+        \"\"\"Reset primary key and field value.\"\"\"\n+        self.uid = None\n+        self.f = False\n+    \n+    class Meta:\n+        app_label = 'model_inheritance'\n+\n+\n+class DerivedUUID(ItemWithUUID):\n+    \"\"\"Child model inheriting from ItemWithUUID.\"\"\"\n+    extra_field = models.CharField(max_length=100, default='test')\n+    \n+    class Meta:\n+        app_label = 'model_inheritance'\n+\n+\n+@override_settings(USE_TZ=False)\n+class PrimaryKeyResetTestCase(TransactionTestCase):\n+    \"\"\"Test cases for primary key reset functionality in model inheritance.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        # Ensure tables exist\n+        from django.core.management.color import no_style\n+        from django.db import connection\n+        \n+        style = no_style()\n+        sql = connection.ops.sql_table_creation_suffix()\n+        \n+        # Create tables if they don't exist\n+        with connection.schema_editor() as schema_editor:\n+            if not connection.introspection.table_names():\n+                schema_editor.create_model(Item)\n+                schema_editor.create_model(Derived)\n+                schema_editor.create_model(ItemWithUUID)\n+                schema_editor.create_model(DerivedUUID)\n+    \n+    def test_pk_reset_child_model_autofield_fails_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: resetting pk on child model doesn't work.\n+        This test should FAIL before the fix is applied.\n+        \"\"\"\n+        # Create the first object\n+        derived = Derived.objects.create(f=True, extra_field='original')\n+        original_pk = derived.pk\n+        \n+        # Get the object through the parent model and access child\n+        item = Item.objects.get(pk=derived.pk)\n+        obj1 = item.derived\n+        \n+        # Reset the primary key - this should create a new object\n+        obj1.reset()\n+        obj1.extra_field = 'reset'\n+        obj1.save()  # This should create a new object, not overwrite the existing one\n+        \n+        # The bug: the original object gets overwritten instead of creating a new one\n+        # After the fix, this assertion should pass\n+        try:\n+            original_obj = Item.objects.get(pk=original_pk)\n+            # If we can still find the original object with f=True, the bug is fixed\n+            self.assertTrue(original_obj.f, \"Original object should still exist with f=True\")\n+            \n+            # There should be two objects now\n+            self.assertEqual(Item.objects.count(), 2, \"Should have 2 objects after reset\")\n+            self.assertEqual(Derived.objects.count(), 2, \"Should have 2 derived objects after reset\")\n+            \n+            # The new object should have f=False\n+            new_obj = Derived.objects.get(extra_field='reset')\n+            self.assertFalse(new_obj.f, \"New object should have f=False\")\n+            self.assertNotEqual(new_obj.pk, original_pk, \"New object should have different pk\")\n+            \n+        except Item.DoesNotExist:\n+            # This is the bug - the original object was overwritten\n+            self.fail(\"Original object was overwritten instead of creating a new one\")\n+    \n+    def test_pk_reset_child_model_autofield_after_fix(self):\n+        \"\"\"\n+        Test that verifies the fix: resetting pk on child model creates new object.\n+        This test should PASS after the fix is applied.\n+        \"\"\"\n+        # Create the first object\n+        derived = Derived.objects.create(f=True, extra_field='original')\n+        original_pk = derived.pk\n+        \n+        # Reset the primary key on the child object\n+        derived.reset()\n+        derived.extra_field = 'new_object'\n+        derived.save()  # Should create a new object\n+        \n+        # Verify original object still exists\n+        original_obj = Item.objects.get(pk=original_pk)\n+        self.assertTrue(original_obj.f, \"Original object should still exist with f=True\")\n+        \n+        # Verify new object was created\n+        self.assertEqual(Item.objects.count(), 2, \"Should have 2 objects after reset\")\n+        self.assertEqual(Derived.objects.count(), 2, \"Should have 2 derived objects after reset\")\n+        \n+        # Verify new object has correct values\n+        new_obj = Derived.objects.get(extra_field='new_object')\n+        self.assertFalse(new_obj.f, \"New object should have f=False\")\n+        self.assertNotEqual(new_obj.pk, original_pk, \"New object should have different pk\")\n+    \n+    def test_pk_reset_child_model_uuid_fails_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug with UUID primary keys.\n+        This test should FAIL before the fix is applied.\n+        \"\"\"\n+        # Create the first object\n+        derived = DerivedUUID.objects.create(f=True, extra_field='original')\n+        original_pk = derived.pk\n+        \n+        # Get the object through the parent model and access child\n+        item = ItemWithUUID.objects.get(pk=derived.pk)\n+        obj1 = item.deriveduuid\n+        \n+        # Reset the primary key - this should create a new object\n+        obj1.reset()\n+        obj1.extra_field = 'reset'\n+        obj1.save()  # This should create a new object, not overwrite the existing one\n+        \n+        # The bug: the original object gets overwritten instead of creating a new one\n+        try:\n+            original_obj = ItemWithUUID.objects.get(pk=original_pk)\n+            # If we can still find the original object with f=True, the bug is fixed\n+            self.assertTrue(original_obj.f, \"Original object should still exist with f=True\")\n+            \n+            # There should be two objects now\n+            self.assertEqual(ItemWithUUID.objects.count(), 2, \"Should have 2 objects after reset\")\n+            self.assertEqual(DerivedUUID.objects.count(), 2, \"Should have 2 derived objects after reset\")\n+            \n+        except ItemWithUUID.DoesNotExist:\n+            # This is the bug - the original object was overwritten\n+            self.fail(\"Original object was overwritten instead of creating a new one\")\n+    \n+    def test_pk_reset_direct_child_object(self):\n+        \"\"\"\n+        Test resetting pk directly on child object (not through parent).\n+        \"\"\"\n+        # Create the first object\n+        derived = Derived.objects.create(f=True, extra_field='original')\n+        original_pk = derived.pk\n+        \n+        # Reset pk directly on child object\n+        derived.reset()\n+        derived.extra_field = 'direct_reset'\n+        derived.save()\n+        \n+        # Should create new object, original should still exist\n+        self.assertEqual(Derived.objects.count(), 2, \"Should have 2 objects after direct reset\")\n+        \n+        # Original object should still exist\n+        original_obj = Derived.objects.get(pk=original_pk)\n+        self.assertTrue(original_obj.f, \"Original object should still exist\")\n+        self.assertEqual(original_obj.extra_field, 'original')\n+        \n+        # New object should exist with reset values\n+        new_obj = Derived.objects.get(extra_field='direct_reset')\n+        self.assertFalse(new_obj.f, \"New object should have f=False\")\n+        self.assertNotEqual(new_obj.pk, original_pk, \"New object should have different pk\")\n+    \n+    def test_pk_reset_multiple_inheritance_levels(self):\n+        \"\"\"\n+        Test pk reset with multiple levels of inheritance.\n+        \"\"\"\n+        # Create a third level of inheritance for this test\n+        class GrandChild(Derived):\n+            grand_field = models.CharField(max_length=50, default='grand')\n+            \n+            class Meta:\n+                app_label = 'model_inheritance'\n+        \n+        # Create tables for the new model\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(GrandChild)\n+        \n+        # Create the first object\n+        grandchild = GrandChild.objects.create(f=True, extra_field='original', grand_field='first')\n+        original_pk = grandchild.pk\n+        \n+        # Reset pk and save\n+        grandchild.uid = None\n+        grandchild.f = False\n+        grandchild.extra_field = 'new'\n+        grandchild.grand_field = 'second'\n+        grandchild.save()\n+        \n+        # Should create new object at all levels\n+        self.assertEqual(Item.objects.count(), 2, \"Should have 2 Item objects\")\n+        self.assertEqual(Derived.objects.count(), 2, \"Should have 2 Derived objects\")\n+        self.assertEqual(GrandChild.objects.count(), 2, \"Should have 2 GrandChild objects\")\n+        \n+        # Original should still exist\n+        original = GrandChild.objects.get(pk=original_pk)\n+        self.assertTrue(original.f)\n+        self.assertEqual(original.extra_field, 'original')\n+        self.assertEqual(original.grand_field, 'first')\n+        \n+        # New object should exist\n+        new_obj = GrandChild.objects.get(grand_field='second')\n+        self.assertFalse(new_obj.f)\n+        self.assertEqual(new_obj.extra_field, 'new')\n+        self.assertNotEqual(new_obj.pk, original_pk)\n+    \n+    def test_pk_reset_with_force_insert(self):\n+        \"\"\"\n+        Test that force_insert=True works correctly with pk reset.\n+        \"\"\"\n+        derived = Derived.objects.create(f=True, extra_field='original')\n+        original_pk = derived.pk\n+        \n+        # Reset pk and save with force_insert\n+        derived.uid = None\n+        derived.f = False\n+        derived.extra_field = 'forced'\n+        derived.save(force_insert=True)\n+        \n+        # Should create new object\n+        self.assertEqual(Derived.objects.count(), 2)\n+        \n+        # Original should still exist\n+        original = Derived.objects.get(pk=original_pk)\n+        self.assertTrue(original.f)\n+        \n+        # New object should exist\n+        new_obj = Derived.objects.get(extra_field='forced')\n+        self.assertFalse(new_obj.f)\n+        self.assertNotEqual(new_obj.pk, original_pk)\n+    \n+    def test_pk_reset_preserves_other_fields(self):\n+        \"\"\"\n+        Test that resetting pk preserves other field values correctly.\n+        \"\"\"\n+        derived = Derived.objects.create(f=True, extra_field='preserve_me')\n+        \n+        # Reset only the pk, keep other fields\n+        derived.uid = None\n+        derived.save()\n+        \n+        # Should have 2 objects now\n+        self.assertEqual(Derived.objects.count(), 2)\n+        \n+        # Both objects should have the same extra_field value\n+        objects = list(Derived.objects.all())\n+        self.assertEqual(len(objects), 2)\n+        for obj in objects:\n+            self.assertEqual(obj.extra_field, 'preserve_me')\n+        \n+        # But different pk values\n+        self.assertNotEqual(objects[0].pk, objects[1].pk)\n+    \n+    def test_normal_save_still_works(self):\n+        \"\"\"\n+        Test that normal save operations (without pk reset) still work correctly.\n+        \"\"\"\n+        derived = Derived.objects.create(f=True, extra_field='original')\n+        original_pk = derived.pk\n+        \n+        # Modify field and save (without resetting pk)\n+        derived.f = False\n+        derived.extra_field = 'modified'\n+        derived.save()\n+        \n+        # Should still have only 1 object\n+        self.assertEqual(Derived.objects.count(), 1)\n+        \n+        # Object should be updated, not created new\n+        updated_obj = Derived.objects.get(pk=original_pk)\n+        self.assertFalse(updated_obj.f)\n+        self.assertEqual(updated_obj.extra_field, 'modified')\n+\n+\n+# Additional test to reproduce the exact scenario from the issue\n+class SaveTestCase(TestCase):\n+    \"\"\"Reproduce the exact test case from the issue description.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up as described in the issue.\"\"\"\n+        # Ensure tables exist\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(Item)\n+            schema_editor.create_model(Derived)\n+        \n+        self.derived = Derived.objects.create(f=True)  # create the first object\n+        item = Item.objects.get(pk=self.derived.pk)\n+        obj1 = item.derived\n+        obj1.reset()\n+        obj1.save()  # the first object is overwritten (this is the bug)\n+\n+    def test_f_true(self):\n+        \"\"\"\n+        This test demonstrates the bug from the issue.\n+        It should FAIL before the fix because the original object gets overwritten.\n+        After the fix, this test should PASS because the original object is preserved.\n+        \"\"\"\n+        # Try to get the original object - this will fail if it was overwritten\n+        try:\n+            obj = Item.objects.get(pk=self.derived.pk)\n+            # The original object should still have f=True\n+            self.assertTrue(obj.f, \"Original object should still exist with f=True\")\n+        except Item.DoesNotExist:\n+            self.fail(\"Original object was overwritten instead of creating a new one\")\n+        \n+        # There should be 2 objects total now (original + new)\n+        self.assertEqual(Item.objects.count(), 2, \"Should have 2 objects after pk reset\")\n"
}