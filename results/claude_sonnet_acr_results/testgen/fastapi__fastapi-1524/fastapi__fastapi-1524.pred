{
  "instance_id": "fastapi__fastapi-1524",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_root_model_response.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom typing import List\nfrom fastapi import FastAPI\nfrom fastapi.testclient import TestClient\nfrom pydantic import BaseModel\n\n\nclass RootTestClass(BaseModel):\n    \"\"\"Test model with __root__ field containing a list of strings.\"\"\"\n    __root__: List[str]\n\n\nclass RootTestClassInt(BaseModel):\n    \"\"\"Test model with __root__ field containing an integer.\"\"\"\n    __root__: int\n\n\nclass RootTestClassDict(BaseModel):\n    \"\"\"Test model with __root__ field containing a dictionary.\"\"\"\n    __root__: dict\n\n\nclass NestedRootModel(BaseModel):\n    \"\"\"Test model with __root__ field containing another root model.\"\"\"\n    __root__: RootTestClass\n\n\nclass RegularModel(BaseModel):\n    \"\"\"Regular model for comparison.\"\"\"\n    name: str\n    value: int\n\n\ndef test_root_model_json_serialization():\n    \"\"\"Test that root models serialize correctly with .json() method.\"\"\"\n    # Test list root model\n    response = RootTestClass(__root__=['a', 'b', 'c'])\n    assert response.json() == '[\"a\", \"b\", \"c\"]'\n    \n    # Test int root model\n    int_response = RootTestClassInt(__root__=42)\n    assert int_response.json() == '42'\n    \n    # Test dict root model\n    dict_response = RootTestClassDict(__root__={'key': 'value'})\n    assert dict_response.json() == '{\"key\": \"value\"}'\n\n\ndef test_root_model_dict_method_shows_bug():\n    \"\"\"Test that demonstrates the bug - .dict() method returns __root__ wrapper.\"\"\"\n    response = RootTestClass(__root__=['a', 'b', 'c'])\n    # This shows the bug - dict() returns the __root__ wrapper\n    assert response.dict() == {'__root__': ['a', 'b', 'c']}\n\n\ndef test_root_model_response_in_fastapi():\n    \"\"\"Test that FastAPI correctly handles root models in responses.\"\"\"\n    app = FastAPI()\n\n    @app.get(\"/list\", response_model=RootTestClass)\n    async def get_list():\n        return RootTestClass(__root__=['a', 'b', 'c'])\n\n    @app.get(\"/int\", response_model=RootTestClassInt)\n    async def get_int():\n        return RootTestClassInt(__root__=42)\n\n    @app.get(\"/dict\", response_model=RootTestClassDict)\n    async def get_dict():\n        return RootTestClassDict(__root__={'key': 'value'})\n\n    @app.get(\"/nested\", response_model=NestedRootModel)\n    async def get_nested():\n        inner = RootTestClass(__root__=['x', 'y', 'z'])\n        return NestedRootModel(__root__=inner)\n\n    @app.get(\"/regular\", response_model=RegularModel)\n    async def get_regular():\n        return RegularModel(name=\"test\", value=123)\n\n    client = TestClient(app)\n\n    # Test list root model response\n    response = client.get(\"/list\")\n    assert response.status_code == 200\n    assert response.json() == ['a', 'b', 'c']  # Should be array, not {\"__root__\": [...]}\n\n    # Test int root model response\n    response = client.get(\"/int\")\n    assert response.status_code == 200\n    assert response.json() == 42  # Should be number, not {\"__root__\": 42}\n\n    # Test dict root model response\n    response = client.get(\"/dict\")\n    assert response.status_code == 200\n    assert response.json() == {'key': 'value'}  # Should be object, not {\"__root__\": {...}}\n\n    # Test nested root model response\n    response = client.get(\"/nested\")\n    assert response.status_code == 200\n    assert response.json() == ['x', 'y', 'z']  # Should be array, not nested __root__\n\n    # Test regular model still works\n    response = client.get(\"/regular\")\n    assert response.status_code == 200\n    assert response.json() == {'name': 'test', 'value': 123}\n\n\ndef test_root_model_response_without_response_model():\n    \"\"\"Test that root models work correctly even without explicit response_model.\"\"\"\n    app = FastAPI()\n\n    @app.get(\"/list-no-model\")\n    async def get_list_no_model():\n        return RootTestClass(__root__=['a', 'b', 'c'])\n\n    @app.get(\"/int-no-model\")\n    async def get_int_no_model():\n        return RootTestClassInt(__root__=42)\n\n    client = TestClient(app)\n\n    # Test list root model response without response_model\n    response = client.get(\"/list-no-model\")\n    assert response.status_code == 200\n    assert response.json() == ['a', 'b', 'c']\n\n    # Test int root model response without response_model\n    response = client.get(\"/int-no-model\")\n    assert response.status_code == 200\n    assert response.json() == 42\n\n\ndef test_root_model_in_list_response():\n    \"\"\"Test that root models work correctly when returned in lists.\"\"\"\n    app = FastAPI()\n\n    @app.get(\"/list-of-root-models\")\n    async def get_list_of_root_models():\n        return [\n            RootTestClass(__root__=['a', 'b']),\n            RootTestClass(__root__=['c', 'd']),\n        ]\n\n    client = TestClient(app)\n\n    response = client.get(\"/list-of-root-models\")\n    assert response.status_code == 200\n    assert response.json() == [['a', 'b'], ['c', 'd']]\n\n\ndef test_root_model_mixed_with_regular_models():\n    \"\"\"Test that root models work correctly when mixed with regular models.\"\"\"\n    app = FastAPI()\n\n    @app.get(\"/mixed\")\n    async def get_mixed():\n        return {\n            'regular': RegularModel(name=\"test\", value=123),\n            'root_list': RootTestClass(__root__=['a', 'b']),\n            'root_int': RootTestClassInt(__root__=42),\n        }\n\n    client = TestClient(app)\n\n    response = client.get(\"/mixed\")\n    assert response.status_code == 200\n    expected = {\n        'regular': {'name': 'test', 'value': 123},\n        'root_list': ['a', 'b'],\n        'root_int': 42,\n    }\n    assert response.json() == expected\n\n\ndef test_root_model_edge_cases():\n    \"\"\"Test edge cases for root models.\"\"\"\n    app = FastAPI()\n\n    class EmptyListRootModel(BaseModel):\n        __root__: List[str]\n\n    class NoneRootModel(BaseModel):\n        __root__: str = None\n\n    @app.get(\"/empty-list\")\n    async def get_empty_list():\n        return EmptyListRootModel(__root__=[])\n\n    @app.get(\"/none-value\")\n    async def get_none_value():\n        return NoneRootModel(__root__=None)\n\n    client = TestClient(app)\n\n    # Test empty list\n    response = client.get(\"/empty-list\")\n    assert response.status_code == 200\n    assert response.json() == []\n\n    # Test None value\n    response = client.get(\"/none-value\")\n    assert response.status_code == 200\n    assert response.json() is None\n\n\ndef test_failing_case_before_fix():\n    \"\"\"\n    This test demonstrates the bug that should fail before the fix is applied.\n    It shows that FastAPI currently returns {\"__root__\": value} instead of just value.\n    \"\"\"\n    app = FastAPI()\n\n    @app.get(\"/bug-demo\")\n    async def bug_demo():\n        response = RootTestClass(__root__=['a', 'b', 'c'])\n        # This print shows that pydantic itself handles it correctly\n        print(f\"Pydantic json(): {response.json()}\")  # Should be [\"a\", \"b\", \"c\"]\n        print(f\"Pydantic dict(): {response.dict()}\")  # Shows {\"__root__\": [\"a\", \"b\", \"c\"]}\n        return response\n\n    client = TestClient(app)\n    response = client.get(\"/bug-demo\")\n    \n    # This assertion will fail before the fix, demonstrating the bug\n    # The response will be {\"__root__\": [\"a\", \"b\", \"c\"]} instead of [\"a\", \"b\", \"c\"]\n    assert response.json() == ['a', 'b', 'c'], f\"Expected ['a', 'b', 'c'], got {response.json()}\"\n</patched>\n```\n\n```\n<file>tests/test_encoders_root_model.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom typing import List, Dict, Any\nfrom pydantic import BaseModel\nfrom fastapi.encoders import jsonable_encoder\n\n\nclass RootListModel(BaseModel):\n    \"\"\"Test model with __root__ field containing a list.\"\"\"\n    __root__: List[str]\n\n\nclass RootIntModel(BaseModel):\n    \"\"\"Test model with __root__ field containing an integer.\"\"\"\n    __root__: int\n\n\nclass RootDictModel(BaseModel):\n    \"\"\"Test model with __root__ field containing a dictionary.\"\"\"\n    __root__: Dict[str, Any]\n\n\nclass NestedRootModel(BaseModel):\n    \"\"\"Test model with __root__ field containing another root model.\"\"\"\n    __root__: RootListModel\n\n\nclass RegularModel(BaseModel):\n    \"\"\"Regular model for comparison.\"\"\"\n    name: str\n    value: int\n\n\nclass MixedFieldsModel(BaseModel):\n    \"\"\"Model with both __root__ and other fields (should not be treated as root model).\"\"\"\n    __root__: str\n    other_field: int\n\n\ndef test_jsonable_encoder_with_root_models():\n    \"\"\"Test that jsonable_encoder correctly handles root models.\"\"\"\n    \n    # Test list root model\n    list_model = RootListModel(__root__=['a', 'b', 'c'])\n    encoded = jsonable_encoder(list_model)\n    assert encoded == ['a', 'b', 'c']\n    \n    # Test int root model\n    int_model = RootIntModel(__root__=42)\n    encoded = jsonable_encoder(int_model)\n    assert encoded == 42\n    \n    # Test dict root model\n    dict_model = RootDictModel(__root__={'key': 'value', 'num': 123})\n    encoded = jsonable_encoder(dict_model)\n    assert encoded == {'key': 'value', 'num': 123}\n\n\ndef test_jsonable_encoder_with_nested_root_models():\n    \"\"\"Test that jsonable_encoder correctly handles nested root models.\"\"\"\n    inner_model = RootListModel(__root__=['x', 'y', 'z'])\n    nested_model = NestedRootModel(__root__=inner_model)\n    \n    encoded = jsonable_encoder(nested_model)\n    assert encoded == ['x', 'y', 'z']\n\n\ndef test_jsonable_encoder_with_regular_models():\n    \"\"\"Test that jsonable_encoder still works correctly with regular models.\"\"\"\n    regular_model = RegularModel(name=\"test\", value=123)\n    encoded = jsonable_encoder(regular_model)\n    assert encoded == {'name': 'test', 'value': 123}\n\n\ndef test_jsonable_encoder_with_mixed_fields_model():\n    \"\"\"Test that models with __root__ and other fields are not treated as root models.\"\"\"\n    # This model has both __root__ and other fields, so it should not be treated as a root model\n    mixed_model = MixedFieldsModel(__root__=\"root_value\", other_field=456)\n    encoded = jsonable_encoder(mixed_model)\n    # Should return the full dict, not just the __root__ value\n    assert encoded == {'__root__': 'root_value', 'other_field': 456}\n\n\ndef test_jsonable_encoder_with_root_models_in_containers():\n    \"\"\"Test that jsonable_encoder handles root models inside lists and dicts.\"\"\"\n    \n    # Test list of root models\n    models_list = [\n        RootListModel(__root__=['a', 'b']),\n        RootIntModel(__root__=42),\n        RootDictModel(__root__={'key': 'value'})\n    ]\n    encoded = jsonable_encoder(models_list)\n    assert encoded == [['a', 'b'], 42, {'key': 'value'}]\n    \n    # Test dict containing root models\n    models_dict = {\n        'list_model': RootListModel(__root__=['x', 'y']),\n        'int_model': RootIntModel(__root__=99),\n        'regular_model': RegularModel(name=\"test\", value=123)\n    }\n    encoded = jsonable_encoder(models_dict)\n    assert encoded == {\n        'list_model': ['x', 'y'],\n        'int_model': 99,\n        'regular_model': {'name': 'test', 'value': 123}\n    }\n\n\ndef test_jsonable_encoder_preserves_options():\n    \"\"\"Test that jsonable_encoder preserves encoding options when handling root models.\"\"\"\n    \n    class RootModelWithDefaults(BaseModel):\n        __root__: Dict[str, Any] = {'default': 'value'}\n    \n    model = RootModelWithDefaults()\n    \n    # Test with exclude_defaults=True\n    encoded = jsonable_encoder(model, exclude_defaults=True)\n    # Should still return the root value, respecting the exclude_defaults option\n    assert encoded == {}  # Empty because default value is excluded\n    \n    # Test with exclude_defaults=False\n    encoded = jsonable_encoder(model, exclude_defaults=False)\n    assert encoded == {'default': 'value'}\n\n\ndef test_jsonable_encoder_bug_demonstration():\n    \"\"\"\n    This test demonstrates the bug in jsonable_encoder before the fix.\n    It shows that currently jsonable_encoder returns {\"__root__\": value} instead of value.\n    \"\"\"\n    model = RootListModel(__root__=['a', 'b', 'c'])\n    \n    # Show that pydantic's own methods work correctly\n    assert model.json() == '[\"a\", \"b\", \"c\"]'  # Pydantic handles it correctly\n    assert model.dict() == {'__root__': ['a', 'b', 'c']}  # dict() shows the wrapper\n    \n    # This will fail before the fix - jsonable_encoder currently uses dict()\n    encoded = jsonable_encoder(model)\n    assert encoded == ['a', 'b', 'c'], f\"Expected ['a', 'b', 'c'], got {encoded}\"\n\n\ndef test_jsonable_encoder_edge_cases():\n    \"\"\"Test edge cases for jsonable_encoder with root models.\"\"\"\n    \n    # Test with None value\n    class RootNoneModel(BaseModel):\n        __root__: str = None\n    \n    none_model = RootNoneModel(__root__=None)\n    encoded = jsonable_encoder(none_model)\n    assert encoded is None\n    \n    # Test with empty list\n    empty_list_model = RootListModel(__root__=[])\n    encoded = jsonable_encoder(empty_list_model)\n    assert encoded == []\n    \n    # Test with empty dict\n    empty_dict_model = RootDictModel(__root__={})\n    encoded = jsonable_encoder(empty_dict_model)\n    assert encoded == {}\n\n\ndef test_jsonable_encoder_custom_encoders():\n    \"\"\"Test that custom encoders work with root models.\"\"\"\n    from datetime import datetime\n    \n    class RootDateModel(BaseModel):\n        __root__: datetime\n    \n    test_date = datetime(2023, 1, 1, 12, 0, 0)\n    date_model = RootDateModel(__root__=test_date)\n    \n    # Test with custom encoder\n    custom_encoder = {datetime: lambda dt: dt.isoformat()}\n    encoded = jsonable_encoder(date_model, custom_encoder=custom_encoder)\n    assert encoded == \"2023-01-01T12:00:00\"\n</patched>\n```\n\n```\n<file>tests/test_routing_root_model.",
  "patch": "--- a/tests/test_root_model_response.py\n+++ b/tests/test_root_model_response.py\n-# Empty if creating new file\n+import pytest\n+from typing import List\n+from fastapi import FastAPI\n+from fastapi.testclient import TestClient\n+from pydantic import BaseModel\n+\n+\n+class RootTestClass(BaseModel):\n+    \"\"\"Test model with __root__ field containing a list of strings.\"\"\"\n+    __root__: List[str]\n+\n+\n+class RootTestClassInt(BaseModel):\n+    \"\"\"Test model with __root__ field containing an integer.\"\"\"\n+    __root__: int\n+\n+\n+class RootTestClassDict(BaseModel):\n+    \"\"\"Test model with __root__ field containing a dictionary.\"\"\"\n+    __root__: dict\n+\n+\n+class NestedRootModel(BaseModel):\n+    \"\"\"Test model with __root__ field containing another root model.\"\"\"\n+    __root__: RootTestClass\n+\n+\n+class RegularModel(BaseModel):\n+    \"\"\"Regular model for comparison.\"\"\"\n+    name: str\n+    value: int\n+\n+\n+def test_root_model_json_serialization():\n+    \"\"\"Test that root models serialize correctly with .json() method.\"\"\"\n+    # Test list root model\n+    response = RootTestClass(__root__=['a', 'b', 'c'])\n+    assert response.json() == '[\"a\", \"b\", \"c\"]'\n+    \n+    # Test int root model\n+    int_response = RootTestClassInt(__root__=42)\n+    assert int_response.json() == '42'\n+    \n+    # Test dict root model\n+    dict_response = RootTestClassDict(__root__={'key': 'value'})\n+    assert dict_response.json() == '{\"key\": \"value\"}'\n+\n+\n+def test_root_model_dict_method_shows_bug():\n+    \"\"\"Test that demonstrates the bug - .dict() method returns __root__ wrapper.\"\"\"\n+    response = RootTestClass(__root__=['a', 'b', 'c'])\n+    # This shows the bug - dict() returns the __root__ wrapper\n+    assert response.dict() == {'__root__': ['a', 'b', 'c']}\n+\n+\n+def test_root_model_response_in_fastapi():\n+    \"\"\"Test that FastAPI correctly handles root models in responses.\"\"\"\n+    app = FastAPI()\n+\n+    @app.get(\"/list\", response_model=RootTestClass)\n+    async def get_list():\n+        return RootTestClass(__root__=['a', 'b', 'c'])\n+\n+    @app.get(\"/int\", response_model=RootTestClassInt)\n+    async def get_int():\n+        return RootTestClassInt(__root__=42)\n+\n+    @app.get(\"/dict\", response_model=RootTestClassDict)\n+    async def get_dict():\n+        return RootTestClassDict(__root__={'key': 'value'})\n+\n+    @app.get(\"/nested\", response_model=NestedRootModel)\n+    async def get_nested():\n+        inner = RootTestClass(__root__=['x', 'y', 'z'])\n+        return NestedRootModel(__root__=inner)\n+\n+    @app.get(\"/regular\", response_model=RegularModel)\n+    async def get_regular():\n+        return RegularModel(name=\"test\", value=123)\n+\n+    client = TestClient(app)\n+\n+    # Test list root model response\n+    response = client.get(\"/list\")\n+    assert response.status_code == 200\n+    assert response.json() == ['a', 'b', 'c']  # Should be array, not {\"__root__\": [...]}\n+\n+    # Test int root model response\n+    response = client.get(\"/int\")\n+    assert response.status_code == 200\n+    assert response.json() == 42  # Should be number, not {\"__root__\": 42}\n+\n+    # Test dict root model response\n+    response = client.get(\"/dict\")\n+    assert response.status_code == 200\n+    assert response.json() == {'key': 'value'}  # Should be object, not {\"__root__\": {...}}\n+\n+    # Test nested root model response\n+    response = client.get(\"/nested\")\n+    assert response.status_code == 200\n+    assert response.json() == ['x', 'y', 'z']  # Should be array, not nested __root__\n+\n+    # Test regular model still works\n+    response = client.get(\"/regular\")\n+    assert response.status_code == 200\n+    assert response.json() == {'name': 'test', 'value': 123}\n+\n+\n+def test_root_model_response_without_response_model():\n+    \"\"\"Test that root models work correctly even without explicit response_model.\"\"\"\n+    app = FastAPI()\n+\n+    @app.get(\"/list-no-model\")\n+    async def get_list_no_model():\n+        return RootTestClass(__root__=['a', 'b', 'c'])\n+\n+    @app.get(\"/int-no-model\")\n+    async def get_int_no_model():\n+        return RootTestClassInt(__root__=42)\n+\n+    client = TestClient(app)\n+\n+    # Test list root model response without response_model\n+    response = client.get(\"/list-no-model\")\n+    assert response.status_code == 200\n+    assert response.json() == ['a', 'b', 'c']\n+\n+    # Test int root model response without response_model\n+    response = client.get(\"/int-no-model\")\n+    assert response.status_code == 200\n+    assert response.json() == 42\n+\n+\n+def test_root_model_in_list_response():\n+    \"\"\"Test that root models work correctly when returned in lists.\"\"\"\n+    app = FastAPI()\n+\n+    @app.get(\"/list-of-root-models\")\n+    async def get_list_of_root_models():\n+        return [\n+            RootTestClass(__root__=['a', 'b']),\n+            RootTestClass(__root__=['c', 'd']),\n+        ]\n+\n+    client = TestClient(app)\n+\n+    response = client.get(\"/list-of-root-models\")\n+    assert response.status_code == 200\n+    assert response.json() == [['a', 'b'], ['c', 'd']]\n+\n+\n+def test_root_model_mixed_with_regular_models():\n+    \"\"\"Test that root models work correctly when mixed with regular models.\"\"\"\n+    app = FastAPI()\n+\n+    @app.get(\"/mixed\")\n+    async def get_mixed():\n+        return {\n+            'regular': RegularModel(name=\"test\", value=123),\n+            'root_list': RootTestClass(__root__=['a', 'b']),\n+            'root_int': RootTestClassInt(__root__=42),\n+        }\n+\n+    client = TestClient(app)\n+\n+    response = client.get(\"/mixed\")\n+    assert response.status_code == 200\n+    expected = {\n+        'regular': {'name': 'test', 'value': 123},\n+        'root_list': ['a', 'b'],\n+        'root_int': 42,\n+    }\n+    assert response.json() == expected\n+\n+\n+def test_root_model_edge_cases():\n+    \"\"\"Test edge cases for root models.\"\"\"\n+    app = FastAPI()\n+\n+    class EmptyListRootModel(BaseModel):\n+        __root__: List[str]\n+\n+    class NoneRootModel(BaseModel):\n+        __root__: str = None\n+\n+    @app.get(\"/empty-list\")\n+    async def get_empty_list():\n+        return EmptyListRootModel(__root__=[])\n+\n+    @app.get(\"/none-value\")\n+    async def get_none_value():\n+        return NoneRootModel(__root__=None)\n+\n+    client = TestClient(app)\n+\n+    # Test empty list\n+    response = client.get(\"/empty-list\")\n+    assert response.status_code == 200\n+    assert response.json() == []\n+\n+    # Test None value\n+    response = client.get(\"/none-value\")\n+    assert response.status_code == 200\n+    assert response.json() is None\n+\n+\n+def test_failing_case_before_fix():\n+    \"\"\"\n+    This test demonstrates the bug that should fail before the fix is applied.\n+    It shows that FastAPI currently returns {\"__root__\": value} instead of just value.\n+    \"\"\"\n+    app = FastAPI()\n+\n+    @app.get(\"/bug-demo\")\n+    async def bug_demo():\n+        response = RootTestClass(__root__=['a', 'b', 'c'])\n+        # This print shows that pydantic itself handles it correctly\n+        print(f\"Pydantic json(): {response.json()}\")  # Should be [\"a\", \"b\", \"c\"]\n+        print(f\"Pydantic dict(): {response.dict()}\")  # Shows {\"__root__\": [\"a\", \"b\", \"c\"]}\n+        return response\n+\n+    client = TestClient(app)\n+    response = client.get(\"/bug-demo\")\n+    \n+    # This assertion will fail before the fix, demonstrating the bug\n+    # The response will be {\"__root__\": [\"a\", \"b\", \"c\"]} instead of [\"a\", \"b\", \"c\"]\n+    assert response.json() == ['a', 'b', 'c'], f\"Expected ['a', 'b', 'c'], got {response.json()}\"\n\n--- a/tests/test_encoders_root_model.py\n+++ b/tests/test_encoders_root_model.py\n-# Empty if creating new file\n+import pytest\n+from typing import List, Dict, Any\n+from pydantic import BaseModel\n+from fastapi.encoders import jsonable_encoder\n+\n+\n+class RootListModel(BaseModel):\n+    \"\"\"Test model with __root__ field containing a list.\"\"\"\n+    __root__: List[str]\n+\n+\n+class RootIntModel(BaseModel):\n+    \"\"\"Test model with __root__ field containing an integer.\"\"\"\n+    __root__: int\n+\n+\n+class RootDictModel(BaseModel):\n+    \"\"\"Test model with __root__ field containing a dictionary.\"\"\"\n+    __root__: Dict[str, Any]\n+\n+\n+class NestedRootModel(BaseModel):\n+    \"\"\"Test model with __root__ field containing another root model.\"\"\"\n+    __root__: RootListModel\n+\n+\n+class RegularModel(BaseModel):\n+    \"\"\"Regular model for comparison.\"\"\"\n+    name: str\n+    value: int\n+\n+\n+class MixedFieldsModel(BaseModel):\n+    \"\"\"Model with both __root__ and other fields (should not be treated as root model).\"\"\"\n+    __root__: str\n+    other_field: int\n+\n+\n+def test_jsonable_encoder_with_root_models():\n+    \"\"\"Test that jsonable_encoder correctly handles root models.\"\"\"\n+    \n+    # Test list root model\n+    list_model = RootListModel(__root__=['a', 'b', 'c'])\n+    encoded = jsonable_encoder(list_model)\n+    assert encoded == ['a', 'b', 'c']\n+    \n+    # Test int root model\n+    int_model = RootIntModel(__root__=42)\n+    encoded = jsonable_encoder(int_model)\n+    assert encoded == 42\n+    \n+    # Test dict root model\n+    dict_model = RootDictModel(__root__={'key': 'value', 'num': 123})\n+    encoded = jsonable_encoder(dict_model)\n+    assert encoded == {'key': 'value', 'num': 123}\n+\n+\n+def test_jsonable_encoder_with_nested_root_models():\n+    \"\"\"Test that jsonable_encoder correctly handles nested root models.\"\"\"\n+    inner_model = RootListModel(__root__=['x', 'y', 'z'])\n+    nested_model = NestedRootModel(__root__=inner_model)\n+    \n+    encoded = jsonable_encoder(nested_model)\n+    assert encoded == ['x', 'y', 'z']\n+\n+\n+def test_jsonable_encoder_with_regular_models():\n+    \"\"\"Test that jsonable_encoder still works correctly with regular models.\"\"\"\n+    regular_model = RegularModel(name=\"test\", value=123)\n+    encoded = jsonable_encoder(regular_model)\n+    assert encoded == {'name': 'test', 'value': 123}\n+\n+\n+def test_jsonable_encoder_with_mixed_fields_model():\n+    \"\"\"Test that models with __root__ and other fields are not treated as root models.\"\"\"\n+    # This model has both __root__ and other fields, so it should not be treated as a root model\n+    mixed_model = MixedFieldsModel(__root__=\"root_value\", other_field=456)\n+    encoded = jsonable_encoder(mixed_model)\n+    # Should return the full dict, not just the __root__ value\n+    assert encoded == {'__root__': 'root_value', 'other_field': 456}\n+\n+\n+def test_jsonable_encoder_with_root_models_in_containers():\n+    \"\"\"Test that jsonable_encoder handles root models inside lists and dicts.\"\"\"\n+    \n+    # Test list of root models\n+    models_list = [\n+        RootListModel(__root__=['a', 'b']),\n+        RootIntModel(__root__=42),\n+        RootDictModel(__root__={'key': 'value'})\n+    ]\n+    encoded = jsonable_encoder(models_list)\n+    assert encoded == [['a', 'b'], 42, {'key': 'value'}]\n+    \n+    # Test dict containing root models\n+    models_dict = {\n+        'list_model': RootListModel(__root__=['x', 'y']),\n+        'int_model': RootIntModel(__root__=99),\n+        'regular_model': RegularModel(name=\"test\", value=123)\n+    }\n+    encoded = jsonable_encoder(models_dict)\n+    assert encoded == {\n+        'list_model': ['x', 'y'],\n+        'int_model': 99,\n+        'regular_model': {'name': 'test', 'value': 123}\n+    }\n+\n+\n+def test_jsonable_encoder_preserves_options():\n+    \"\"\"Test that jsonable_encoder preserves encoding options when handling root models.\"\"\"\n+    \n+    class RootModelWithDefaults(BaseModel):\n+        __root__: Dict[str, Any] = {'default': 'value'}\n+    \n+    model = RootModelWithDefaults()\n+    \n+    # Test with exclude_defaults=True\n+    encoded = jsonable_encoder(model, exclude_defaults=True)\n+    # Should still return the root value, respecting the exclude_defaults option\n+    assert encoded == {}  # Empty because default value is excluded\n+    \n+    # Test with exclude_defaults=False\n+    encoded = jsonable_encoder(model, exclude_defaults=False)\n+    assert encoded == {'default': 'value'}\n+\n+\n+def test_jsonable_encoder_bug_demonstration():\n+    \"\"\"\n+    This test demonstrates the bug in jsonable_encoder before the fix.\n+    It shows that currently jsonable_encoder returns {\"__root__\": value} instead of value.\n+    \"\"\"\n+    model = RootListModel(__root__=['a', 'b', 'c'])\n+    \n+    # Show that pydantic's own methods work correctly\n+    assert model.json() == '[\"a\", \"b\", \"c\"]'  # Pydantic handles it correctly\n+    assert model.dict() == {'__root__': ['a', 'b', 'c']}  # dict() shows the wrapper\n+    \n+    # This will fail before the fix - jsonable_encoder currently uses dict()\n+    encoded = jsonable_encoder(model)\n+    assert encoded == ['a', 'b', 'c'], f\"Expected ['a', 'b', 'c'], got {encoded}\"\n+\n+\n+def test_jsonable_encoder_edge_cases():\n+    \"\"\"Test edge cases for jsonable_encoder with root models.\"\"\"\n+    \n+    # Test with None value\n+    class RootNoneModel(BaseModel):\n+        __root__: str = None\n+    \n+    none_model = RootNoneModel(__root__=None)\n+    encoded = jsonable_encoder(none_model)\n+    assert encoded is None\n+    \n+    # Test with empty list\n+    empty_list_model = RootListModel(__root__=[])\n+    encoded = jsonable_encoder(empty_list_model)\n+    assert encoded == []\n+    \n+    # Test with empty dict\n+    empty_dict_model = RootDictModel(__root__={})\n+    encoded = jsonable_encoder(empty_dict_model)\n+    assert encoded == {}\n+\n+\n+def test_jsonable_encoder_custom_encoders():\n+    \"\"\"Test that custom encoders work with root models.\"\"\"\n+    from datetime import datetime\n+    \n+    class RootDateModel(BaseModel):\n+        __root__: datetime\n+    \n+    test_date = datetime(2023, 1, 1, 12, 0, 0)\n+    date_model = RootDateModel(__root__=test_date)\n+    \n+    # Test with custom encoder\n+    custom_encoder = {datetime: lambda dt: dt.isoformat()}\n+    encoded = jsonable_encoder(date_model, custom_encoder=custom_encoder)\n+    assert encoded == \"2023-01-01T12:00:00\"\n"
}