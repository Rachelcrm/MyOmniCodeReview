--- a/sympy/physics/hep/tests/test_gamma_matrices.py
+++ b/sympy/physics/hep/tests/test_gamma_matrices.py
-# Empty if creating new file
+import pytest
+from sympy import S, eye
+from sympy.physics.hep.gamma_matrices import GammaMatrix as G, kahane_simplify, LorentzIndex
+from sympy.tensor.tensor import tensor_indices
+
+
+class TestKahaneSimplifyLeadingMatrices:
+    """Test suite for the kahane_simplify bug with leading uncontracted gamma matrices."""
+    
+    def test_kahane_leading_gamma_matrix_bug_basic(self):
+        """Test the basic case that demonstrates the bug with leading matrices."""
+        mu, nu, rho, sigma = tensor_indices("mu, nu, rho, sigma", LorentzIndex)
+        
+        # Case 1: contracted matrices at the beginning
+        t1 = G(mu)*G(-mu)*G(rho)*G(sigma)
+        r1 = kahane_simplify(t1)
+        expected = 4*G(rho)*G(sigma)
+        
+        # Case 2: contracted matrices at the end (this should give same result)
+        t2 = G(rho)*G(sigma)*G(mu)*G(-mu)
+        r2 = kahane_simplify(t2)
+        
+        # Both should be equal to the expected result
+        assert r1.equals(expected), f"Expected {expected}, got {r1}"
+        assert r2.equals(expected), f"Expected {expected}, got {r2}"
+        
+        # Most importantly, both results should be equal to each other
+        assert r1.equals(r2), f"Results should be equal: {r1} vs {r2}"
+    
+    def test_kahane_leading_gamma_matrix_three_matrices(self):
+        """Test with three leading uncontracted matrices."""
+        mu, nu, rho, sigma, tau = tensor_indices("mu, nu, rho, sigma, tau", LorentzIndex)
+        
+        # Case 1: contracted matrices at the beginning
+        t1 = G(mu)*G(-mu)*G(rho)*G(sigma)*G(tau)
+        r1 = kahane_simplify(t1)
+        expected = 4*G(rho)*G(sigma)*G(tau)
+        
+        # Case 2: contracted matrices at the end
+        t2 = G(rho)*G(sigma)*G(tau)*G(mu)*G(-mu)
+        r2 = kahane_simplify(t2)
+        
+        assert r1.equals(expected), f"Expected {expected}, got {r1}"
+        assert r2.equals(expected), f"Expected {expected}, got {r2}"
+        assert r1.equals(r2), f"Results should be equal: {r1} vs {r2}"
+    
+    def test_kahane_leading_gamma_matrix_single_matrix(self):
+        """Test with single leading uncontracted matrix."""
+        mu, nu, rho = tensor_indices("mu, nu, rho", LorentzIndex)
+        
+        # Case 1: contracted matrices at the beginning
+        t1 = G(mu)*G(-mu)*G(rho)
+        r1 = kahane_simplify(t1)
+        expected = 4*G(rho)
+        
+        # Case 2: contracted matrices at the end
+        t2 = G(rho)*G(mu)*G(-mu)
+        r2 = kahane_simplify(t2)
+        
+        assert r1.equals(expected), f"Expected {expected}, got {r1}"
+        assert r2.equals(expected), f"Expected {expected}, got {r2}"
+        assert r1.equals(r2), f"Results should be equal: {r1} vs {r2}"
+    
+    def test_kahane_multiple_contractions_with_leading_matrices(self):
+        """Test with multiple contractions and leading matrices."""
+        mu, nu, rho, sigma, alpha, beta = tensor_indices("mu, nu, rho, sigma, alpha, beta", LorentzIndex)
+        
+        # Case 1: contracted matrices at the beginning
+        t1 = G(mu)*G(-mu)*G(nu)*G(-nu)*G(rho)*G(sigma)
+        r1 = kahane_simplify(t1)
+        expected = 16*G(rho)*G(sigma)  # 4 * 4 = 16
+        
+        # Case 2: contracted matrices at the end
+        t2 = G(rho)*G(sigma)*G(mu)*G(-mu)*G(nu)*G(-nu)
+        r2 = kahane_simplify(t2)
+        
+        assert r1.equals(expected), f"Expected {expected}, got {r1}"
+        assert r2.equals(expected), f"Expected {expected}, got {r2}"
+        assert r1.equals(r2), f"Results should be equal: {r1} vs {r2}"
+    
+    def test_kahane_no_leading_matrices(self):
+        """Test that expressions without leading matrices work correctly."""
+        mu, nu = tensor_indices("mu, nu", LorentzIndex)
+        
+        # Simple contraction without leading matrices
+        t = G(mu)*G(-mu)
+        r = kahane_simplify(t)
+        expected = 4*eye(4)  # Should be 4 times identity matrix
+        
+        assert r.equals(expected), f"Expected {expected}, got {r}"
+    
+    def test_kahane_no_contractions(self):
+        """Test that expressions without contractions are unchanged."""
+        mu, nu, rho = tensor_indices("mu, nu, rho", LorentzIndex)
+        
+        # No contractions, should return original expression
+        t = G(mu)*G(nu)*G(rho)
+        r = kahane_simplify(t)
+        
+        assert r.equals(t), f"Expected {t}, got {r}"
+    
+    def test_kahane_mixed_leading_and_trailing_matrices(self):
+        """Test with both leading and trailing uncontracted matrices."""
+        mu, nu, rho, sigma, alpha, beta = tensor_indices("mu, nu, rho, sigma, alpha, beta", LorentzIndex)
+        
+        # Leading matrices, contraction, trailing matrices
+        t = G(rho)*G(sigma)*G(mu)*G(-mu)*G(alpha)*G(beta)
+        r = kahane_simplify(t)
+        expected = 4*G(rho)*G(sigma)*G(alpha)*G(beta)
+        
+        assert r.equals(expected), f"Expected {expected}, got {r}"
+    
+    def test_kahane_order_preservation_complex(self):
+        """Test order preservation with a more complex expression."""
+        indices = tensor_indices("mu, nu, rho, sigma, tau, alpha, beta, gamma", LorentzIndex)
+        mu, nu, rho, sigma, tau, alpha, beta, gamma = indices
+        
+        # Complex expression with multiple leading matrices and contractions
+        t1 = G(mu)*G(-mu)*G(nu)*G(-nu)*G(rho)*G(sigma)*G(tau)*G(alpha)*G(beta)
+        r1 = kahane_simplify(t1)
+        expected = 16*G(rho)*G(sigma)*G(tau)*G(alpha)*G(beta)
+        
+        # Same expression with contractions at the end
+        t2 = G(rho)*G(sigma)*G(tau)*G(alpha)*G(beta)*G(mu)*G(-mu)*G(nu)*G(-nu)
+        r2 = kahane_simplify(t2)
+        
+        assert r1.equals(expected), f"Expected {expected}, got {r1}"
+        assert r2.equals(expected), f"Expected {expected}, got {r2}"
+        assert r1.equals(r2), f"Results should be equal: {r1} vs {r2}"
+
+
+def test_kahane_simplify_regression_leading_matrices():
+    """Regression test for the specific bug reported in the issue."""
+    mu, nu, rho, sigma = tensor_indices("mu, nu, rho, sigma", LorentzIndex)
+    
+    # This is the exact test case from the issue
+    t1 = G(mu)*G(-mu)*G(rho)*G(sigma)
+    r1 = kahane_simplify(t1)
+    
+    t2 = G(rho)*G(sigma)*G(mu)*G(-mu)
+    r2 = kahane_simplify(t2)
+    
+    # Both should equal 4*G(rho)*G(sigma)
+    expected = 4*G(rho)*G(sigma)
+    
+    assert r1.equals(expected)
+    assert r2.equals(expected)
+    
+    # This assertion would fail before the fix due to the bug
+    assert r1.equals(r2), "Leading gamma matrices order should be preserved"
