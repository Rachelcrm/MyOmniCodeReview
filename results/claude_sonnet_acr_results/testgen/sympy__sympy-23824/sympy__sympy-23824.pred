{
  "instance_id": "sympy__sympy-23824",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>sympy/physics/hep/tests/test_gamma_matrices.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom sympy import S, eye\nfrom sympy.physics.hep.gamma_matrices import GammaMatrix as G, kahane_simplify, LorentzIndex\nfrom sympy.tensor.tensor import tensor_indices\n\n\nclass TestKahaneSimplifyLeadingMatrices:\n    \"\"\"Test suite for the kahane_simplify bug with leading uncontracted gamma matrices.\"\"\"\n    \n    def test_kahane_leading_gamma_matrix_bug_basic(self):\n        \"\"\"Test the basic case that demonstrates the bug with leading matrices.\"\"\"\n        mu, nu, rho, sigma = tensor_indices(\"mu, nu, rho, sigma\", LorentzIndex)\n        \n        # Case 1: contracted matrices at the beginning\n        t1 = G(mu)*G(-mu)*G(rho)*G(sigma)\n        r1 = kahane_simplify(t1)\n        expected = 4*G(rho)*G(sigma)\n        \n        # Case 2: contracted matrices at the end (this should give same result)\n        t2 = G(rho)*G(sigma)*G(mu)*G(-mu)\n        r2 = kahane_simplify(t2)\n        \n        # Both should be equal to the expected result\n        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n        \n        # Most importantly, both results should be equal to each other\n        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n    \n    def test_kahane_leading_gamma_matrix_three_matrices(self):\n        \"\"\"Test with three leading uncontracted matrices.\"\"\"\n        mu, nu, rho, sigma, tau = tensor_indices(\"mu, nu, rho, sigma, tau\", LorentzIndex)\n        \n        # Case 1: contracted matrices at the beginning\n        t1 = G(mu)*G(-mu)*G(rho)*G(sigma)*G(tau)\n        r1 = kahane_simplify(t1)\n        expected = 4*G(rho)*G(sigma)*G(tau)\n        \n        # Case 2: contracted matrices at the end\n        t2 = G(rho)*G(sigma)*G(tau)*G(mu)*G(-mu)\n        r2 = kahane_simplify(t2)\n        \n        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n    \n    def test_kahane_leading_gamma_matrix_single_matrix(self):\n        \"\"\"Test with single leading uncontracted matrix.\"\"\"\n        mu, nu, rho = tensor_indices(\"mu, nu, rho\", LorentzIndex)\n        \n        # Case 1: contracted matrices at the beginning\n        t1 = G(mu)*G(-mu)*G(rho)\n        r1 = kahane_simplify(t1)\n        expected = 4*G(rho)\n        \n        # Case 2: contracted matrices at the end\n        t2 = G(rho)*G(mu)*G(-mu)\n        r2 = kahane_simplify(t2)\n        \n        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n    \n    def test_kahane_multiple_contractions_with_leading_matrices(self):\n        \"\"\"Test with multiple contractions and leading matrices.\"\"\"\n        mu, nu, rho, sigma, alpha, beta = tensor_indices(\"mu, nu, rho, sigma, alpha, beta\", LorentzIndex)\n        \n        # Case 1: contracted matrices at the beginning\n        t1 = G(mu)*G(-mu)*G(nu)*G(-nu)*G(rho)*G(sigma)\n        r1 = kahane_simplify(t1)\n        expected = 16*G(rho)*G(sigma)  # 4 * 4 = 16\n        \n        # Case 2: contracted matrices at the end\n        t2 = G(rho)*G(sigma)*G(mu)*G(-mu)*G(nu)*G(-nu)\n        r2 = kahane_simplify(t2)\n        \n        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n    \n    def test_kahane_no_leading_matrices(self):\n        \"\"\"Test that expressions without leading matrices work correctly.\"\"\"\n        mu, nu = tensor_indices(\"mu, nu\", LorentzIndex)\n        \n        # Simple contraction without leading matrices\n        t = G(mu)*G(-mu)\n        r = kahane_simplify(t)\n        expected = 4*eye(4)  # Should be 4 times identity matrix\n        \n        assert r.equals(expected), f\"Expected {expected}, got {r}\"\n    \n    def test_kahane_no_contractions(self):\n        \"\"\"Test that expressions without contractions are unchanged.\"\"\"\n        mu, nu, rho = tensor_indices(\"mu, nu, rho\", LorentzIndex)\n        \n        # No contractions, should return original expression\n        t = G(mu)*G(nu)*G(rho)\n        r = kahane_simplify(t)\n        \n        assert r.equals(t), f\"Expected {t}, got {r}\"\n    \n    def test_kahane_mixed_leading_and_trailing_matrices(self):\n        \"\"\"Test with both leading and trailing uncontracted matrices.\"\"\"\n        mu, nu, rho, sigma, alpha, beta = tensor_indices(\"mu, nu, rho, sigma, alpha, beta\", LorentzIndex)\n        \n        # Leading matrices, contraction, trailing matrices\n        t = G(rho)*G(sigma)*G(mu)*G(-mu)*G(alpha)*G(beta)\n        r = kahane_simplify(t)\n        expected = 4*G(rho)*G(sigma)*G(alpha)*G(beta)\n        \n        assert r.equals(expected), f\"Expected {expected}, got {r}\"\n    \n    def test_kahane_order_preservation_complex(self):\n        \"\"\"Test order preservation with a more complex expression.\"\"\"\n        indices = tensor_indices(\"mu, nu, rho, sigma, tau, alpha, beta, gamma\", LorentzIndex)\n        mu, nu, rho, sigma, tau, alpha, beta, gamma = indices\n        \n        # Complex expression with multiple leading matrices and contractions\n        t1 = G(mu)*G(-mu)*G(nu)*G(-nu)*G(rho)*G(sigma)*G(tau)*G(alpha)*G(beta)\n        r1 = kahane_simplify(t1)\n        expected = 16*G(rho)*G(sigma)*G(tau)*G(alpha)*G(beta)\n        \n        # Same expression with contractions at the end\n        t2 = G(rho)*G(sigma)*G(tau)*G(alpha)*G(beta)*G(mu)*G(-mu)*G(nu)*G(-nu)\n        r2 = kahane_simplify(t2)\n        \n        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n\n\ndef test_kahane_simplify_regression_leading_matrices():\n    \"\"\"Regression test for the specific bug reported in the issue.\"\"\"\n    mu, nu, rho, sigma = tensor_indices(\"mu, nu, rho, sigma\", LorentzIndex)\n    \n    # This is the exact test case from the issue\n    t1 = G(mu)*G(-mu)*G(rho)*G(sigma)\n    r1 = kahane_simplify(t1)\n    \n    t2 = G(rho)*G(sigma)*G(mu)*G(-mu)\n    r2 = kahane_simplify(t2)\n    \n    # Both should equal 4*G(rho)*G(sigma)\n    expected = 4*G(rho)*G(sigma)\n    \n    assert r1.equals(expected)\n    assert r2.equals(expected)\n    \n    # This assertion would fail before the fix due to the bug\n    assert r1.equals(r2), \"Leading gamma matrices order should be preserved\"\n</patched>\n</file>\n```",
  "patch": "--- a/sympy/physics/hep/tests/test_gamma_matrices.py\n+++ b/sympy/physics/hep/tests/test_gamma_matrices.py\n-# Empty if creating new file\n+import pytest\n+from sympy import S, eye\n+from sympy.physics.hep.gamma_matrices import GammaMatrix as G, kahane_simplify, LorentzIndex\n+from sympy.tensor.tensor import tensor_indices\n+\n+\n+class TestKahaneSimplifyLeadingMatrices:\n+    \"\"\"Test suite for the kahane_simplify bug with leading uncontracted gamma matrices.\"\"\"\n+    \n+    def test_kahane_leading_gamma_matrix_bug_basic(self):\n+        \"\"\"Test the basic case that demonstrates the bug with leading matrices.\"\"\"\n+        mu, nu, rho, sigma = tensor_indices(\"mu, nu, rho, sigma\", LorentzIndex)\n+        \n+        # Case 1: contracted matrices at the beginning\n+        t1 = G(mu)*G(-mu)*G(rho)*G(sigma)\n+        r1 = kahane_simplify(t1)\n+        expected = 4*G(rho)*G(sigma)\n+        \n+        # Case 2: contracted matrices at the end (this should give same result)\n+        t2 = G(rho)*G(sigma)*G(mu)*G(-mu)\n+        r2 = kahane_simplify(t2)\n+        \n+        # Both should be equal to the expected result\n+        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n+        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n+        \n+        # Most importantly, both results should be equal to each other\n+        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n+    \n+    def test_kahane_leading_gamma_matrix_three_matrices(self):\n+        \"\"\"Test with three leading uncontracted matrices.\"\"\"\n+        mu, nu, rho, sigma, tau = tensor_indices(\"mu, nu, rho, sigma, tau\", LorentzIndex)\n+        \n+        # Case 1: contracted matrices at the beginning\n+        t1 = G(mu)*G(-mu)*G(rho)*G(sigma)*G(tau)\n+        r1 = kahane_simplify(t1)\n+        expected = 4*G(rho)*G(sigma)*G(tau)\n+        \n+        # Case 2: contracted matrices at the end\n+        t2 = G(rho)*G(sigma)*G(tau)*G(mu)*G(-mu)\n+        r2 = kahane_simplify(t2)\n+        \n+        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n+        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n+        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n+    \n+    def test_kahane_leading_gamma_matrix_single_matrix(self):\n+        \"\"\"Test with single leading uncontracted matrix.\"\"\"\n+        mu, nu, rho = tensor_indices(\"mu, nu, rho\", LorentzIndex)\n+        \n+        # Case 1: contracted matrices at the beginning\n+        t1 = G(mu)*G(-mu)*G(rho)\n+        r1 = kahane_simplify(t1)\n+        expected = 4*G(rho)\n+        \n+        # Case 2: contracted matrices at the end\n+        t2 = G(rho)*G(mu)*G(-mu)\n+        r2 = kahane_simplify(t2)\n+        \n+        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n+        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n+        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n+    \n+    def test_kahane_multiple_contractions_with_leading_matrices(self):\n+        \"\"\"Test with multiple contractions and leading matrices.\"\"\"\n+        mu, nu, rho, sigma, alpha, beta = tensor_indices(\"mu, nu, rho, sigma, alpha, beta\", LorentzIndex)\n+        \n+        # Case 1: contracted matrices at the beginning\n+        t1 = G(mu)*G(-mu)*G(nu)*G(-nu)*G(rho)*G(sigma)\n+        r1 = kahane_simplify(t1)\n+        expected = 16*G(rho)*G(sigma)  # 4 * 4 = 16\n+        \n+        # Case 2: contracted matrices at the end\n+        t2 = G(rho)*G(sigma)*G(mu)*G(-mu)*G(nu)*G(-nu)\n+        r2 = kahane_simplify(t2)\n+        \n+        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n+        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n+        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n+    \n+    def test_kahane_no_leading_matrices(self):\n+        \"\"\"Test that expressions without leading matrices work correctly.\"\"\"\n+        mu, nu = tensor_indices(\"mu, nu\", LorentzIndex)\n+        \n+        # Simple contraction without leading matrices\n+        t = G(mu)*G(-mu)\n+        r = kahane_simplify(t)\n+        expected = 4*eye(4)  # Should be 4 times identity matrix\n+        \n+        assert r.equals(expected), f\"Expected {expected}, got {r}\"\n+    \n+    def test_kahane_no_contractions(self):\n+        \"\"\"Test that expressions without contractions are unchanged.\"\"\"\n+        mu, nu, rho = tensor_indices(\"mu, nu, rho\", LorentzIndex)\n+        \n+        # No contractions, should return original expression\n+        t = G(mu)*G(nu)*G(rho)\n+        r = kahane_simplify(t)\n+        \n+        assert r.equals(t), f\"Expected {t}, got {r}\"\n+    \n+    def test_kahane_mixed_leading_and_trailing_matrices(self):\n+        \"\"\"Test with both leading and trailing uncontracted matrices.\"\"\"\n+        mu, nu, rho, sigma, alpha, beta = tensor_indices(\"mu, nu, rho, sigma, alpha, beta\", LorentzIndex)\n+        \n+        # Leading matrices, contraction, trailing matrices\n+        t = G(rho)*G(sigma)*G(mu)*G(-mu)*G(alpha)*G(beta)\n+        r = kahane_simplify(t)\n+        expected = 4*G(rho)*G(sigma)*G(alpha)*G(beta)\n+        \n+        assert r.equals(expected), f\"Expected {expected}, got {r}\"\n+    \n+    def test_kahane_order_preservation_complex(self):\n+        \"\"\"Test order preservation with a more complex expression.\"\"\"\n+        indices = tensor_indices(\"mu, nu, rho, sigma, tau, alpha, beta, gamma\", LorentzIndex)\n+        mu, nu, rho, sigma, tau, alpha, beta, gamma = indices\n+        \n+        # Complex expression with multiple leading matrices and contractions\n+        t1 = G(mu)*G(-mu)*G(nu)*G(-nu)*G(rho)*G(sigma)*G(tau)*G(alpha)*G(beta)\n+        r1 = kahane_simplify(t1)\n+        expected = 16*G(rho)*G(sigma)*G(tau)*G(alpha)*G(beta)\n+        \n+        # Same expression with contractions at the end\n+        t2 = G(rho)*G(sigma)*G(tau)*G(alpha)*G(beta)*G(mu)*G(-mu)*G(nu)*G(-nu)\n+        r2 = kahane_simplify(t2)\n+        \n+        assert r1.equals(expected), f\"Expected {expected}, got {r1}\"\n+        assert r2.equals(expected), f\"Expected {expected}, got {r2}\"\n+        assert r1.equals(r2), f\"Results should be equal: {r1} vs {r2}\"\n+\n+\n+def test_kahane_simplify_regression_leading_matrices():\n+    \"\"\"Regression test for the specific bug reported in the issue.\"\"\"\n+    mu, nu, rho, sigma = tensor_indices(\"mu, nu, rho, sigma\", LorentzIndex)\n+    \n+    # This is the exact test case from the issue\n+    t1 = G(mu)*G(-mu)*G(rho)*G(sigma)\n+    r1 = kahane_simplify(t1)\n+    \n+    t2 = G(rho)*G(sigma)*G(mu)*G(-mu)\n+    r2 = kahane_simplify(t2)\n+    \n+    # Both should equal 4*G(rho)*G(sigma)\n+    expected = 4*G(rho)*G(sigma)\n+    \n+    assert r1.equals(expected)\n+    assert r2.equals(expected)\n+    \n+    # This assertion would fail before the fix due to the bug\n+    assert r1.equals(r2), \"Leading gamma matrices order should be preserved\"\n"
}