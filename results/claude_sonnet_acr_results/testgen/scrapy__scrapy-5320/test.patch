--- a/tests/test_utils_response.py
+++ b/tests/test_utils_response.py
-# Empty if creating new file
+import os
+import tempfile
+import pytest
+from unittest.mock import Mock, patch
+from scrapy.http import HtmlResponse, TextResponse
+from scrapy.utils.response import open_in_browser
+
+
+class TestOpenInBrowser:
+    """Test suite for the open_in_browser function."""
+
+    def test_open_in_browser_head_without_attributes(self):
+        """Test that base tag is injected correctly when head tag has no attributes."""
+        html_content = b"""<!DOCTYPE html>
+<html>
+<head>
+    <title>Test Page</title>
+</head>
+<body>
+    <p>Test content</p>
+    <img src="./assets/image.jpg">
+</body>
+</html>"""
+        
+        response = HtmlResponse(
+            url="https://example.com/test.html",
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        # Mock webbrowser.open to prevent actual browser opening
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            result = open_in_browser(response)
+            
+            # Verify that webbrowser.open was called
+            mock_open.assert_called_once()
+            
+            # Get the file path that was passed to webbrowser.open
+            call_args = mock_open.call_args[0][0]
+            assert call_args.startswith('file://')
+            
+            # Read the temporary file to verify base tag injection
+            file_path = call_args[7:]  # Remove 'file://' prefix
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            # Clean up the temporary file
+            os.unlink(file_path)
+            
+            # Verify base tag was injected
+            expected_base_tag = b'<base href="https://example.com/test.html">'
+            assert expected_base_tag in modified_content
+            assert b'<head><base href="https://example.com/test.html">' in modified_content
+
+    def test_open_in_browser_head_with_attributes_fails_before_fix(self):
+        """Test that demonstrates the bug: base tag injection fails when head has attributes.
+        
+        This test should fail before the fix is applied, demonstrating the bug.
+        """
+        html_content = b"""<!DOCTYPE html>
+<html>
+<head id="main-head" class="header">
+    <title>Test Page</title>
+</head>
+<body>
+    <p>Test content</p>
+    <img src="./assets/image.jpg">
+</body>
+</html>"""
+        
+        response = HtmlResponse(
+            url="https://example.com/test.html",
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        # Mock webbrowser.open to prevent actual browser opening
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            result = open_in_browser(response)
+            
+            # Get the file path that was passed to webbrowser.open
+            call_args = mock_open.call_args[0][0]
+            file_path = call_args[7:]  # Remove 'file://' prefix
+            
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            # Clean up the temporary file
+            os.unlink(file_path)
+            
+            # This assertion will fail before the fix because the base tag
+            # won't be injected when head has attributes
+            expected_base_tag = b'<base href="https://example.com/test.html">'
+            
+            # The bug: base tag is not injected when head has attributes
+            # This test documents the current broken behavior
+            assert expected_base_tag not in modified_content, \
+                "Bug reproduced: base tag not injected when head has attributes"
+
+    def test_open_in_browser_head_with_id_attribute(self):
+        """Test base tag injection when head tag has id attribute."""
+        html_content = b"""<!DOCTYPE html>
+<html>
+<head id="example">
+    <title>Test Page</title>
+</head>
+<body>
+    <p>Test content</p>
+</body>
+</html>"""
+        
+        response = HtmlResponse(
+            url="https://example.com/test.html",
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            open_in_browser(response)
+            
+            call_args = mock_open.call_args[0][0]
+            file_path = call_args[7:]
+            
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            os.unlink(file_path)
+            
+            # After fix, this should pass
+            expected_base_tag = b'<base href="https://example.com/test.html">'
+            assert expected_base_tag in modified_content
+
+    def test_open_in_browser_head_with_multiple_attributes(self):
+        """Test base tag injection when head tag has multiple attributes."""
+        html_content = b"""<!DOCTYPE html>
+<html>
+<head id="main" class="header" data-test="value">
+    <title>Test Page</title>
+</head>
+<body>
+    <p>Test content</p>
+</body>
+</html>"""
+        
+        response = HtmlResponse(
+            url="https://example.com/test.html",
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            open_in_browser(response)
+            
+            call_args = mock_open.call_args[0][0]
+            file_path = call_args[7:]
+            
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            os.unlink(file_path)
+            
+            # After fix, this should pass
+            expected_base_tag = b'<base href="https://example.com/test.html">'
+            assert expected_base_tag in modified_content
+            # Verify original head tag with attributes is preserved
+            assert b'<head id="main" class="header" data-test="value">' in modified_content
+
+    def test_open_in_browser_head_with_newlines_and_attributes(self):
+        """Test base tag injection when head tag has attributes and spans multiple lines."""
+        html_content = b"""<!DOCTYPE html>
+<html>
+<head 
+    id="main" 
+    class="header">
+    <title>Test Page</title>
+</head>
+<body>
+    <p>Test content</p>
+</body>
+</html>"""
+        
+        response = HtmlResponse(
+            url="https://example.com/test.html",
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            open_in_browser(response)
+            
+            call_args = mock_open.call_args[0][0]
+            file_path = call_args[7:]
+            
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            os.unlink(file_path)
+            
+            # After fix, this should pass
+            expected_base_tag = b'<base href="https://example.com/test.html">'
+            assert expected_base_tag in modified_content
+
+    def test_open_in_browser_existing_base_tag_not_duplicated(self):
+        """Test that base tag is not injected if one already exists."""
+        html_content = b"""<!DOCTYPE html>
+<html>
+<head id="example">
+    <base href="https://other.com/">
+    <title>Test Page</title>
+</head>
+<body>
+    <p>Test content</p>
+</body>
+</html>"""
+        
+        response = HtmlResponse(
+            url="https://example.com/test.html",
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            open_in_browser(response)
+            
+            call_args = mock_open.call_args[0][0]
+            file_path = call_args[7:]
+            
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            os.unlink(file_path)
+            
+            # Should not inject another base tag
+            assert modified_content.count(b'<base') == 1
+            # Original base tag should be preserved
+            assert b'<base href="https://other.com/">' in modified_content
+
+    def test_open_in_browser_case_insensitive_head_tag(self):
+        """Test base tag injection with uppercase HEAD tag."""
+        html_content = b"""<!DOCTYPE html>
+<html>
+<HEAD id="example">
+    <title>Test Page</title>
+</HEAD>
+<body>
+    <p>Test content</p>
+</body>
+</html>"""
+        
+        response = HtmlResponse(
+            url="https://example.com/test.html",
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            open_in_browser(response)
+            
+            call_args = mock_open.call_args[0][0]
+            file_path = call_args[7:]
+            
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            os.unlink(file_path)
+            
+            # The current implementation is case-sensitive and looks for lowercase 'head'
+            # This test documents the current behavior - it won't inject for uppercase HEAD
+            expected_base_tag = b'<base href="https://example.com/test.html">'
+            # This will fail with current implementation, which is expected behavior
+            # since HTML is case-insensitive but the current code only handles lowercase
+
+    def test_open_in_browser_text_response(self):
+        """Test that TextResponse works correctly (no base tag injection)."""
+        text_content = b"This is plain text content"
+        
+        response = TextResponse(
+            url="https://example.com/test.txt",
+            body=text_content,
+            encoding='utf-8'
+        )
+        
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            open_in_browser(response)
+            
+            call_args = mock_open.call_args[0][0]
+            file_path = call_args[7:]
+            
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            os.unlink(file_path)
+            
+            # Text response should not be modified
+            assert modified_content == text_content
+
+    def test_open_in_browser_malformed_html(self):
+        """Test behavior with malformed HTML that has no head tag."""
+        html_content = b"""<!DOCTYPE html>
+<html>
+<body>
+    <p>No head tag here</p>
+</body>
+</html>"""
+        
+        response = HtmlResponse(
+            url="https://example.com/test.html",
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            open_in_browser(response)
+            
+            call_args = mock_open.call_args[0][0]
+            file_path = call_args[7:]
+            
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            os.unlink(file_path)
+            
+            # Should not inject base tag if no head tag exists
+            assert b'<base' not in modified_content
+            assert modified_content == html_content
+
+    def test_open_in_browser_custom_openfunc(self):
+        """Test that custom _openfunc parameter works correctly."""
+        html_content = b"""<!DOCTYPE html>
+<html>
+<head>
+    <title>Test</title>
+</head>
+<body>
+    <p>Test</p>
+</body>
+</html>"""
+        
+        response = HtmlResponse(
+            url="https://example.com/test.html",
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        mock_custom_opener = Mock(return_value="custom_result")
+        
+        result = open_in_browser(response, _openfunc=mock_custom_opener)
+        
+        # Verify custom opener was called
+        mock_custom_opener.assert_called_once()
+        assert result == "custom_result"
+        
+        # Clean up the temporary file
+        call_args = mock_custom_opener.call_args[0][0]
+        file_path = call_args[7:]
+        os.unlink(file_path)
+
+    def test_open_in_browser_unicode_url(self):
+        """Test base tag injection with Unicode characters in URL."""
+        html_content = b"""<!DOCTYPE html>
+<html>
+<head id="test">
+    <title>Test</title>
+</head>
+<body>
+    <p>Test</p>
+</body>
+</html>"""
+        
+        # URL with Unicode characters
+        unicode_url = "https://example.com/测试.html"
+        
+        response = HtmlResponse(
+            url=unicode_url,
+            body=html_content,
+            encoding='utf-8'
+        )
+        
+        with patch('webbrowser.open') as mock_open:
+            mock_open.return_value = None
+            open_in_browser(response)
+            
+            call_args = mock_open.call_args[0][0]
+            file_path = call_args[7:]
+            
+            with open(file_path, 'rb') as f:
+                modified_content = f.read()
+            
+            os.unlink(file_path)
+            
+            # After fix, should handle Unicode URLs correctly
+            assert unicode_url.encode('utf-8') in modified_content
