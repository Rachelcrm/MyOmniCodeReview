{
  "instance_id": "scrapy__scrapy-5320",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_utils_response.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport os\nimport tempfile\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom scrapy.http import HtmlResponse, TextResponse\nfrom scrapy.utils.response import open_in_browser\n\n\nclass TestOpenInBrowser:\n    \"\"\"Test suite for the open_in_browser function.\"\"\"\n\n    def test_open_in_browser_head_without_attributes(self):\n        \"\"\"Test that base tag is injected correctly when head tag has no attributes.\"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<head>\n    <title>Test Page</title>\n</head>\n<body>\n    <p>Test content</p>\n    <img src=\"./assets/image.jpg\">\n</body>\n</html>\"\"\"\n        \n        response = HtmlResponse(\n            url=\"https://example.com/test.html\",\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        # Mock webbrowser.open to prevent actual browser opening\n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            result = open_in_browser(response)\n            \n            # Verify that webbrowser.open was called\n            mock_open.assert_called_once()\n            \n            # Get the file path that was passed to webbrowser.open\n            call_args = mock_open.call_args[0][0]\n            assert call_args.startswith('file://')\n            \n            # Read the temporary file to verify base tag injection\n            file_path = call_args[7:]  # Remove 'file://' prefix\n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            # Clean up the temporary file\n            os.unlink(file_path)\n            \n            # Verify base tag was injected\n            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n            assert expected_base_tag in modified_content\n            assert b'<head><base href=\"https://example.com/test.html\">' in modified_content\n\n    def test_open_in_browser_head_with_attributes_fails_before_fix(self):\n        \"\"\"Test that demonstrates the bug: base tag injection fails when head has attributes.\n        \n        This test should fail before the fix is applied, demonstrating the bug.\n        \"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<head id=\"main-head\" class=\"header\">\n    <title>Test Page</title>\n</head>\n<body>\n    <p>Test content</p>\n    <img src=\"./assets/image.jpg\">\n</body>\n</html>\"\"\"\n        \n        response = HtmlResponse(\n            url=\"https://example.com/test.html\",\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        # Mock webbrowser.open to prevent actual browser opening\n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            result = open_in_browser(response)\n            \n            # Get the file path that was passed to webbrowser.open\n            call_args = mock_open.call_args[0][0]\n            file_path = call_args[7:]  # Remove 'file://' prefix\n            \n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            # Clean up the temporary file\n            os.unlink(file_path)\n            \n            # This assertion will fail before the fix because the base tag\n            # won't be injected when head has attributes\n            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n            \n            # The bug: base tag is not injected when head has attributes\n            # This test documents the current broken behavior\n            assert expected_base_tag not in modified_content, \\\n                \"Bug reproduced: base tag not injected when head has attributes\"\n\n    def test_open_in_browser_head_with_id_attribute(self):\n        \"\"\"Test base tag injection when head tag has id attribute.\"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<head id=\"example\">\n    <title>Test Page</title>\n</head>\n<body>\n    <p>Test content</p>\n</body>\n</html>\"\"\"\n        \n        response = HtmlResponse(\n            url=\"https://example.com/test.html\",\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            open_in_browser(response)\n            \n            call_args = mock_open.call_args[0][0]\n            file_path = call_args[7:]\n            \n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            os.unlink(file_path)\n            \n            # After fix, this should pass\n            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n            assert expected_base_tag in modified_content\n\n    def test_open_in_browser_head_with_multiple_attributes(self):\n        \"\"\"Test base tag injection when head tag has multiple attributes.\"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<head id=\"main\" class=\"header\" data-test=\"value\">\n    <title>Test Page</title>\n</head>\n<body>\n    <p>Test content</p>\n</body>\n</html>\"\"\"\n        \n        response = HtmlResponse(\n            url=\"https://example.com/test.html\",\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            open_in_browser(response)\n            \n            call_args = mock_open.call_args[0][0]\n            file_path = call_args[7:]\n            \n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            os.unlink(file_path)\n            \n            # After fix, this should pass\n            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n            assert expected_base_tag in modified_content\n            # Verify original head tag with attributes is preserved\n            assert b'<head id=\"main\" class=\"header\" data-test=\"value\">' in modified_content\n\n    def test_open_in_browser_head_with_newlines_and_attributes(self):\n        \"\"\"Test base tag injection when head tag has attributes and spans multiple lines.\"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<head \n    id=\"main\" \n    class=\"header\">\n    <title>Test Page</title>\n</head>\n<body>\n    <p>Test content</p>\n</body>\n</html>\"\"\"\n        \n        response = HtmlResponse(\n            url=\"https://example.com/test.html\",\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            open_in_browser(response)\n            \n            call_args = mock_open.call_args[0][0]\n            file_path = call_args[7:]\n            \n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            os.unlink(file_path)\n            \n            # After fix, this should pass\n            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n            assert expected_base_tag in modified_content\n\n    def test_open_in_browser_existing_base_tag_not_duplicated(self):\n        \"\"\"Test that base tag is not injected if one already exists.\"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<head id=\"example\">\n    <base href=\"https://other.com/\">\n    <title>Test Page</title>\n</head>\n<body>\n    <p>Test content</p>\n</body>\n</html>\"\"\"\n        \n        response = HtmlResponse(\n            url=\"https://example.com/test.html\",\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            open_in_browser(response)\n            \n            call_args = mock_open.call_args[0][0]\n            file_path = call_args[7:]\n            \n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            os.unlink(file_path)\n            \n            # Should not inject another base tag\n            assert modified_content.count(b'<base') == 1\n            # Original base tag should be preserved\n            assert b'<base href=\"https://other.com/\">' in modified_content\n\n    def test_open_in_browser_case_insensitive_head_tag(self):\n        \"\"\"Test base tag injection with uppercase HEAD tag.\"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<HEAD id=\"example\">\n    <title>Test Page</title>\n</HEAD>\n<body>\n    <p>Test content</p>\n</body>\n</html>\"\"\"\n        \n        response = HtmlResponse(\n            url=\"https://example.com/test.html\",\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            open_in_browser(response)\n            \n            call_args = mock_open.call_args[0][0]\n            file_path = call_args[7:]\n            \n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            os.unlink(file_path)\n            \n            # The current implementation is case-sensitive and looks for lowercase 'head'\n            # This test documents the current behavior - it won't inject for uppercase HEAD\n            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n            # This will fail with current implementation, which is expected behavior\n            # since HTML is case-insensitive but the current code only handles lowercase\n\n    def test_open_in_browser_text_response(self):\n        \"\"\"Test that TextResponse works correctly (no base tag injection).\"\"\"\n        text_content = b\"This is plain text content\"\n        \n        response = TextResponse(\n            url=\"https://example.com/test.txt\",\n            body=text_content,\n            encoding='utf-8'\n        )\n        \n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            open_in_browser(response)\n            \n            call_args = mock_open.call_args[0][0]\n            file_path = call_args[7:]\n            \n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            os.unlink(file_path)\n            \n            # Text response should not be modified\n            assert modified_content == text_content\n\n    def test_open_in_browser_malformed_html(self):\n        \"\"\"Test behavior with malformed HTML that has no head tag.\"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<body>\n    <p>No head tag here</p>\n</body>\n</html>\"\"\"\n        \n        response = HtmlResponse(\n            url=\"https://example.com/test.html\",\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            open_in_browser(response)\n            \n            call_args = mock_open.call_args[0][0]\n            file_path = call_args[7:]\n            \n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            os.unlink(file_path)\n            \n            # Should not inject base tag if no head tag exists\n            assert b'<base' not in modified_content\n            assert modified_content == html_content\n\n    def test_open_in_browser_custom_openfunc(self):\n        \"\"\"Test that custom _openfunc parameter works correctly.\"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<head>\n    <title>Test</title>\n</head>\n<body>\n    <p>Test</p>\n</body>\n</html>\"\"\"\n        \n        response = HtmlResponse(\n            url=\"https://example.com/test.html\",\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        mock_custom_opener = Mock(return_value=\"custom_result\")\n        \n        result = open_in_browser(response, _openfunc=mock_custom_opener)\n        \n        # Verify custom opener was called\n        mock_custom_opener.assert_called_once()\n        assert result == \"custom_result\"\n        \n        # Clean up the temporary file\n        call_args = mock_custom_opener.call_args[0][0]\n        file_path = call_args[7:]\n        os.unlink(file_path)\n\n    def test_open_in_browser_unicode_url(self):\n        \"\"\"Test base tag injection with Unicode characters in URL.\"\"\"\n        html_content = b\"\"\"<!DOCTYPE html>\n<html>\n<head id=\"test\">\n    <title>Test</title>\n</head>\n<body>\n    <p>Test</p>\n</body>\n</html>\"\"\"\n        \n        # URL with Unicode characters\n        unicode_url = \"https://example.com/\u6d4b\u8bd5.html\"\n        \n        response = HtmlResponse(\n            url=unicode_url,\n            body=html_content,\n            encoding='utf-8'\n        )\n        \n        with patch('webbrowser.open') as mock_open:\n            mock_open.return_value = None\n            open_in_browser(response)\n            \n            call_args = mock_open.call_args[0][0]\n            file_path = call_args[7:]\n            \n            with open(file_path, 'rb') as f:\n                modified_content = f.read()\n            \n            os.unlink(file_path)\n            \n            # After fix, should handle Unicode URLs correctly\n            assert unicode_url.encode('utf-8') in modified_content\n</patched>\n```",
  "patch": "--- a/tests/test_utils_response.py\n+++ b/tests/test_utils_response.py\n-# Empty if creating new file\n+import os\n+import tempfile\n+import pytest\n+from unittest.mock import Mock, patch\n+from scrapy.http import HtmlResponse, TextResponse\n+from scrapy.utils.response import open_in_browser\n+\n+\n+class TestOpenInBrowser:\n+    \"\"\"Test suite for the open_in_browser function.\"\"\"\n+\n+    def test_open_in_browser_head_without_attributes(self):\n+        \"\"\"Test that base tag is injected correctly when head tag has no attributes.\"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>Test Page</title>\n+</head>\n+<body>\n+    <p>Test content</p>\n+    <img src=\"./assets/image.jpg\">\n+</body>\n+</html>\"\"\"\n+        \n+        response = HtmlResponse(\n+            url=\"https://example.com/test.html\",\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        # Mock webbrowser.open to prevent actual browser opening\n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            result = open_in_browser(response)\n+            \n+            # Verify that webbrowser.open was called\n+            mock_open.assert_called_once()\n+            \n+            # Get the file path that was passed to webbrowser.open\n+            call_args = mock_open.call_args[0][0]\n+            assert call_args.startswith('file://')\n+            \n+            # Read the temporary file to verify base tag injection\n+            file_path = call_args[7:]  # Remove 'file://' prefix\n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            # Clean up the temporary file\n+            os.unlink(file_path)\n+            \n+            # Verify base tag was injected\n+            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n+            assert expected_base_tag in modified_content\n+            assert b'<head><base href=\"https://example.com/test.html\">' in modified_content\n+\n+    def test_open_in_browser_head_with_attributes_fails_before_fix(self):\n+        \"\"\"Test that demonstrates the bug: base tag injection fails when head has attributes.\n+        \n+        This test should fail before the fix is applied, demonstrating the bug.\n+        \"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<head id=\"main-head\" class=\"header\">\n+    <title>Test Page</title>\n+</head>\n+<body>\n+    <p>Test content</p>\n+    <img src=\"./assets/image.jpg\">\n+</body>\n+</html>\"\"\"\n+        \n+        response = HtmlResponse(\n+            url=\"https://example.com/test.html\",\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        # Mock webbrowser.open to prevent actual browser opening\n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            result = open_in_browser(response)\n+            \n+            # Get the file path that was passed to webbrowser.open\n+            call_args = mock_open.call_args[0][0]\n+            file_path = call_args[7:]  # Remove 'file://' prefix\n+            \n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            # Clean up the temporary file\n+            os.unlink(file_path)\n+            \n+            # This assertion will fail before the fix because the base tag\n+            # won't be injected when head has attributes\n+            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n+            \n+            # The bug: base tag is not injected when head has attributes\n+            # This test documents the current broken behavior\n+            assert expected_base_tag not in modified_content, \\\n+                \"Bug reproduced: base tag not injected when head has attributes\"\n+\n+    def test_open_in_browser_head_with_id_attribute(self):\n+        \"\"\"Test base tag injection when head tag has id attribute.\"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<head id=\"example\">\n+    <title>Test Page</title>\n+</head>\n+<body>\n+    <p>Test content</p>\n+</body>\n+</html>\"\"\"\n+        \n+        response = HtmlResponse(\n+            url=\"https://example.com/test.html\",\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            open_in_browser(response)\n+            \n+            call_args = mock_open.call_args[0][0]\n+            file_path = call_args[7:]\n+            \n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            os.unlink(file_path)\n+            \n+            # After fix, this should pass\n+            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n+            assert expected_base_tag in modified_content\n+\n+    def test_open_in_browser_head_with_multiple_attributes(self):\n+        \"\"\"Test base tag injection when head tag has multiple attributes.\"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<head id=\"main\" class=\"header\" data-test=\"value\">\n+    <title>Test Page</title>\n+</head>\n+<body>\n+    <p>Test content</p>\n+</body>\n+</html>\"\"\"\n+        \n+        response = HtmlResponse(\n+            url=\"https://example.com/test.html\",\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            open_in_browser(response)\n+            \n+            call_args = mock_open.call_args[0][0]\n+            file_path = call_args[7:]\n+            \n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            os.unlink(file_path)\n+            \n+            # After fix, this should pass\n+            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n+            assert expected_base_tag in modified_content\n+            # Verify original head tag with attributes is preserved\n+            assert b'<head id=\"main\" class=\"header\" data-test=\"value\">' in modified_content\n+\n+    def test_open_in_browser_head_with_newlines_and_attributes(self):\n+        \"\"\"Test base tag injection when head tag has attributes and spans multiple lines.\"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<head \n+    id=\"main\" \n+    class=\"header\">\n+    <title>Test Page</title>\n+</head>\n+<body>\n+    <p>Test content</p>\n+</body>\n+</html>\"\"\"\n+        \n+        response = HtmlResponse(\n+            url=\"https://example.com/test.html\",\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            open_in_browser(response)\n+            \n+            call_args = mock_open.call_args[0][0]\n+            file_path = call_args[7:]\n+            \n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            os.unlink(file_path)\n+            \n+            # After fix, this should pass\n+            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n+            assert expected_base_tag in modified_content\n+\n+    def test_open_in_browser_existing_base_tag_not_duplicated(self):\n+        \"\"\"Test that base tag is not injected if one already exists.\"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<head id=\"example\">\n+    <base href=\"https://other.com/\">\n+    <title>Test Page</title>\n+</head>\n+<body>\n+    <p>Test content</p>\n+</body>\n+</html>\"\"\"\n+        \n+        response = HtmlResponse(\n+            url=\"https://example.com/test.html\",\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            open_in_browser(response)\n+            \n+            call_args = mock_open.call_args[0][0]\n+            file_path = call_args[7:]\n+            \n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            os.unlink(file_path)\n+            \n+            # Should not inject another base tag\n+            assert modified_content.count(b'<base') == 1\n+            # Original base tag should be preserved\n+            assert b'<base href=\"https://other.com/\">' in modified_content\n+\n+    def test_open_in_browser_case_insensitive_head_tag(self):\n+        \"\"\"Test base tag injection with uppercase HEAD tag.\"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<HEAD id=\"example\">\n+    <title>Test Page</title>\n+</HEAD>\n+<body>\n+    <p>Test content</p>\n+</body>\n+</html>\"\"\"\n+        \n+        response = HtmlResponse(\n+            url=\"https://example.com/test.html\",\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            open_in_browser(response)\n+            \n+            call_args = mock_open.call_args[0][0]\n+            file_path = call_args[7:]\n+            \n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            os.unlink(file_path)\n+            \n+            # The current implementation is case-sensitive and looks for lowercase 'head'\n+            # This test documents the current behavior - it won't inject for uppercase HEAD\n+            expected_base_tag = b'<base href=\"https://example.com/test.html\">'\n+            # This will fail with current implementation, which is expected behavior\n+            # since HTML is case-insensitive but the current code only handles lowercase\n+\n+    def test_open_in_browser_text_response(self):\n+        \"\"\"Test that TextResponse works correctly (no base tag injection).\"\"\"\n+        text_content = b\"This is plain text content\"\n+        \n+        response = TextResponse(\n+            url=\"https://example.com/test.txt\",\n+            body=text_content,\n+            encoding='utf-8'\n+        )\n+        \n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            open_in_browser(response)\n+            \n+            call_args = mock_open.call_args[0][0]\n+            file_path = call_args[7:]\n+            \n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            os.unlink(file_path)\n+            \n+            # Text response should not be modified\n+            assert modified_content == text_content\n+\n+    def test_open_in_browser_malformed_html(self):\n+        \"\"\"Test behavior with malformed HTML that has no head tag.\"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<body>\n+    <p>No head tag here</p>\n+</body>\n+</html>\"\"\"\n+        \n+        response = HtmlResponse(\n+            url=\"https://example.com/test.html\",\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            open_in_browser(response)\n+            \n+            call_args = mock_open.call_args[0][0]\n+            file_path = call_args[7:]\n+            \n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            os.unlink(file_path)\n+            \n+            # Should not inject base tag if no head tag exists\n+            assert b'<base' not in modified_content\n+            assert modified_content == html_content\n+\n+    def test_open_in_browser_custom_openfunc(self):\n+        \"\"\"Test that custom _openfunc parameter works correctly.\"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>Test</title>\n+</head>\n+<body>\n+    <p>Test</p>\n+</body>\n+</html>\"\"\"\n+        \n+        response = HtmlResponse(\n+            url=\"https://example.com/test.html\",\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        mock_custom_opener = Mock(return_value=\"custom_result\")\n+        \n+        result = open_in_browser(response, _openfunc=mock_custom_opener)\n+        \n+        # Verify custom opener was called\n+        mock_custom_opener.assert_called_once()\n+        assert result == \"custom_result\"\n+        \n+        # Clean up the temporary file\n+        call_args = mock_custom_opener.call_args[0][0]\n+        file_path = call_args[7:]\n+        os.unlink(file_path)\n+\n+    def test_open_in_browser_unicode_url(self):\n+        \"\"\"Test base tag injection with Unicode characters in URL.\"\"\"\n+        html_content = b\"\"\"<!DOCTYPE html>\n+<html>\n+<head id=\"test\">\n+    <title>Test</title>\n+</head>\n+<body>\n+    <p>Test</p>\n+</body>\n+</html>\"\"\"\n+        \n+        # URL with Unicode characters\n+        unicode_url = \"https://example.com/\u6d4b\u8bd5.html\"\n+        \n+        response = HtmlResponse(\n+            url=unicode_url,\n+            body=html_content,\n+            encoding='utf-8'\n+        )\n+        \n+        with patch('webbrowser.open') as mock_open:\n+            mock_open.return_value = None\n+            open_in_browser(response)\n+            \n+            call_args = mock_open.call_args[0][0]\n+            file_path = call_args[7:]\n+            \n+            with open(file_path, 'rb') as f:\n+                modified_content = f.read()\n+            \n+            os.unlink(file_path)\n+            \n+            # After fix, should handle Unicode URLs correctly\n+            assert unicode_url.encode('utf-8') in modified_content\n"
}