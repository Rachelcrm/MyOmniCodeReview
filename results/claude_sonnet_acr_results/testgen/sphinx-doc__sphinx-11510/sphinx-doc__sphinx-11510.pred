{
  "instance_id": "sphinx-doc__sphinx-11510",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_directive_include_source_read.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom pathlib import Path\nimport tempfile\nimport shutil\nfrom sphinx.application import Sphinx\nfrom sphinx.util.docutils import docutils_namespace\nfrom sphinx.testing.util import SphinxTestApp\nfrom sphinx.testing.path import path\nimport os\n\n\nclass TestIncludeSourceReadEvent:\n    \"\"\"Test that the source-read event is properly emitted for included files.\"\"\"\n\n    @pytest.fixture\n    def temp_sphinx_project(self, tmp_path):\n        \"\"\"Create a temporary Sphinx project for testing.\"\"\"\n        srcdir = tmp_path / \"source\"\n        outdir = tmp_path / \"build\"\n        doctreedir = tmp_path / \"doctrees\"\n        confdir = srcdir\n        \n        srcdir.mkdir()\n        outdir.mkdir()\n        doctreedir.mkdir()\n        \n        # Create conf.py\n        conf_content = '''\nimport sys\nimport os\nsys.path.insert(0, os.path.abspath('.'))\n\nextensions = ['test_extension']\n'''\n        (srcdir / \"conf.py\").write_text(conf_content)\n        \n        # Create test extension\n        extension_content = '''\nfrom sphinx.application import Sphinx\n\n__version__ = '1.0'\n\n# Track which files had their source modified\nmodified_files = []\n\ndef subst_vars_replace(app: Sphinx, docname, source):\n    \"\"\"Replace &REPLACE_ME; with REPLACED in source.\"\"\"\n    result = source[0]\n    if \"&REPLACE_ME;\" in result:\n        result = result.replace(\"&REPLACE_ME;\", \"REPLACED\")\n        source[0] = result\n        modified_files.append(docname)\n\ndef setup(app: Sphinx):\n    app.connect('source-read', subst_vars_replace)\n    return dict(\n        version=__version__,\n        parallel_read_safe=True,\n        parallel_write_safe=True\n    )\n'''\n        (srcdir / \"test_extension.py\").write_text(extension_content)\n        \n        return {\n            'srcdir': srcdir,\n            'outdir': outdir,\n            'doctreedir': doctreedir,\n            'confdir': confdir\n        }\n\n    def test_source_read_event_not_emitted_for_included_files_bug(self, temp_sphinx_project):\n        \"\"\"Test that demonstrates the bug: source-read event is not properly applied to included files.\"\"\"\n        srcdir = temp_sphinx_project['srcdir']\n        outdir = temp_sphinx_project['outdir']\n        \n        # Create main document\n        index_content = '''\nThis is a test\n==============\n\n.. include:: something-to-include.rst\n\n&REPLACE_ME;\n'''\n        (srcdir / \"index.rst\").write_text(index_content)\n        \n        # Create included document\n        include_content = '''\nTesting\n=======\n\n&REPLACE_ME;\n'''\n        (srcdir / \"something-to-include.rst\").write_text(include_content)\n        \n        # Build the documentation\n        with docutils_namespace():\n            app = SphinxTestApp(\n                srcdir=str(srcdir),\n                builddir=str(outdir),\n                confdir=str(srcdir)\n            )\n            app.build()\n            \n            # Read the generated HTML\n            html_file = outdir / \"html\" / \"index.html\"\n            if html_file.exists():\n                html_content = html_file.read_text()\n            else:\n                # Fallback to check doctree or other output\n                html_content = \"\"\n                for html_file in (outdir / \"html\").glob(\"*.html\"):\n                    html_content += html_file.read_text()\n            \n            # This test demonstrates the bug: the included file's &REPLACE_ME; is NOT replaced\n            # The main file's &REPLACE_ME; should be replaced, but the included file's should not be\n            # This shows that source-read event is not properly emitted for included files\n            assert \"REPLACED\" in html_content  # Main file replacement works\n            assert \"&amp;REPLACE_ME;\" in html_content  # Included file replacement fails (bug)\n\n    def test_source_read_event_called_for_included_files_tracking(self, temp_sphinx_project):\n        \"\"\"Test that source-read event is called for included files but changes don't take effect.\"\"\"\n        srcdir = temp_sphinx_project['srcdir']\n        outdir = temp_sphinx_project['outdir']\n        \n        # Create tracking extension\n        tracking_extension_content = '''\nfrom sphinx.application import Sphinx\n\n__version__ = '1.0'\n\n# Track all source-read events\nsource_read_calls = []\n\ndef track_source_read(app: Sphinx, docname, source):\n    \"\"\"Track all source-read events.\"\"\"\n    source_read_calls.append({\n        'docname': docname,\n        'original_content': source[0],\n        'has_replace_me': '&REPLACE_ME;' in source[0]\n    })\n    # Try to modify the source\n    if \"&REPLACE_ME;\" in source[0]:\n        source[0] = source[0].replace(\"&REPLACE_ME;\", \"REPLACED\")\n\ndef setup(app: Sphinx):\n    app.connect('source-read', track_source_read)\n    return dict(\n        version=__version__,\n        parallel_read_safe=True,\n        parallel_write_safe=True\n    )\n'''\n        (srcdir / \"test_extension.py\").write_text(tracking_extension_content)\n        \n        # Create main document\n        index_content = '''\nMain Document\n=============\n\n.. include:: included.rst\n\nMain content: &REPLACE_ME;\n'''\n        (srcdir / \"index.rst\").write_text(index_content)\n        \n        # Create included document\n        include_content = '''\nIncluded Section\n================\n\nIncluded content: &REPLACE_ME;\n'''\n        (srcdir / \"included.rst\").write_text(include_content)\n        \n        # Build the documentation\n        with docutils_namespace():\n            app = SphinxTestApp(\n                srcdir=str(srcdir),\n                builddir=str(outdir),\n                confdir=str(srcdir)\n            )\n            app.build()\n            \n            # Import the tracking data from the extension\n            import sys\n            if str(srcdir) not in sys.path:\n                sys.path.insert(0, str(srcdir))\n            \n            try:\n                import test_extension\n                calls = test_extension.source_read_calls\n                \n                # Verify that source-read was called for both files\n                docnames = [call['docname'] for call in calls]\n                assert 'index' in docnames\n                assert 'included' in docnames\n                \n                # Verify that both files had &REPLACE_ME; content\n                for call in calls:\n                    if call['docname'] in ['index', 'included']:\n                        assert call['has_replace_me'], f\"File {call['docname']} should have &REPLACE_ME;\"\n                        \n            except ImportError:\n                # If we can't import the extension, skip this verification\n                pass\n\n    def test_include_with_standard_docutils_syntax(self, temp_sphinx_project):\n        \"\"\"Test that standard docutils includes (with < >) are not affected.\"\"\"\n        srcdir = temp_sphinx_project['srcdir']\n        outdir = temp_sphinx_project['outdir']\n        \n        # Create main document with standard docutils include syntax\n        index_content = '''\nStandard Include Test\n====================\n\n.. include:: <stdin>\n\nRegular content: &REPLACE_ME;\n'''\n        (srcdir / \"index.rst\").write_text(index_content)\n        \n        # Build should not fail even with non-existent <stdin>\n        with docutils_namespace():\n            app = SphinxTestApp(\n                srcdir=str(srcdir),\n                builddir=str(outdir),\n                confdir=str(srcdir)\n            )\n            # This should not raise an exception\n            app.build()\n\n    def test_include_with_absolute_path_processing(self, temp_sphinx_project):\n        \"\"\"Test that include directive properly processes absolute paths.\"\"\"\n        srcdir = temp_sphinx_project['srcdir']\n        outdir = temp_sphinx_project['outdir']\n        \n        # Create subdirectory\n        subdir = srcdir / \"subdir\"\n        subdir.mkdir()\n        \n        # Create main document\n        index_content = '''\nPath Processing Test\n===================\n\n.. include:: /subdir/nested.rst\n\nMain content: &REPLACE_ME;\n'''\n        (srcdir / \"index.rst\").write_text(index_content)\n        \n        # Create nested document\n        nested_content = '''\nNested Content\n==============\n\nNested: &REPLACE_ME;\n'''\n        (subdir / \"nested.rst\").write_text(nested_content)\n        \n        # Build the documentation\n        with docutils_namespace():\n            app = SphinxTestApp(\n                srcdir=str(srcdir),\n                builddir=str(outdir),\n                confdir=str(srcdir)\n            )\n            app.build()\n            \n            # Verify the build completed without errors\n            # The exact behavior depends on the fix implementation\n\n    def test_multiple_nested_includes(self, temp_sphinx_project):\n        \"\"\"Test source-read event with multiple levels of nested includes.\"\"\"\n        srcdir = temp_sphinx_project['srcdir']\n        outdir = temp_sphinx_project['outdir']\n        \n        # Create main document\n        index_content = '''\nNested Includes Test\n===================\n\n.. include:: level1.rst\n\nMain: &REPLACE_ME;\n'''\n        (srcdir / \"index.rst\").write_text(index_content)\n        \n        # Create level 1 include\n        level1_content = '''\nLevel 1\n=======\n\n.. include:: level2.rst\n\nLevel 1: &REPLACE_ME;\n'''\n        (srcdir / \"level1.rst\").write_text(level1_content)\n        \n        # Create level 2 include\n        level2_content = '''\nLevel 2\n=======\n\nLevel 2: &REPLACE_ME;\n'''\n        (srcdir / \"level2.rst\").write_text(level2_content)\n        \n        # Build the documentation\n        with docutils_namespace():\n            app = SphinxTestApp(\n                srcdir=str(srcdir),\n                builddir=str(outdir),\n                confdir=str(srcdir)\n            )\n            app.build()\n            \n            # Read the generated HTML\n            html_files = list((outdir / \"html\").glob(\"*.html\"))\n            html_content = \"\"\n            for html_file in html_files:\n                html_content += html_file.read_text()\n            \n            # Count occurrences - this test shows the current buggy behavior\n            # After fix, all &REPLACE_ME; should become REPLACED\n            replaced_count = html_content.count(\"REPLACED\")\n            unreplaced_count = html_content.count(\"&amp;REPLACE_ME;\")\n            \n            # Currently, only the main file gets replaced (bug)\n            # After fix, all files should be replaced\n            assert replaced_count >= 1  # At least main file works\n            # The bug is that unreplaced_count > 0 for included files\n\n    def test_include_with_source_read_modification_should_work_after_fix(self, temp_sphinx_project):\n        \"\"\"Test that after the fix, included files are properly modified by source-read events.\"\"\"\n        srcdir = temp_sphinx_project['srcdir']\n        outdir = temp_sphinx_project['outdir']\n        \n        # Create main document\n        index_content = '''\nFixed Include Test\n=================\n\n.. include:: to-be-modified.rst\n\nMain content: &REPLACE_ME;\n'''\n        (srcdir / \"index.rst\").write_text(index_content)\n        \n        # Create included document with content that should be modified\n        include_content = '''\nIncluded Content\n===============\n\nThis should be modified: &REPLACE_ME;\n\nMultiple replacements: &REPLACE_ME; and &REPLACE_ME;\n'''\n        (srcdir / \"to-be-modified.rst\").write_text(include_content)\n        \n        # Build the documentation\n        with docutils_namespace():\n            app = SphinxTestApp(\n                srcdir=str(srcdir),\n                builddir=str(outdir),\n                confdir=str(srcdir)\n            )\n            app.build()\n            \n            # Read the generated HTML\n            html_files = list((outdir / \"html\").glob(\"*.html\"))\n            html_content = \"\"\n            for html_file in html_files:\n                html_content += html_file.read_text()\n            \n            # This test will fail before the fix and pass after the fix\n            # Before fix: included file's &REPLACE_ME; won't be replaced\n            # After fix: all &REPLACE_ME; should be replaced with REPLACED\n            \n            # Count total expected replacements (4 total: 1 in main + 3 in included)\n            expected_replacements = 4\n            actual_replacements = html_content.count(\"REPLACED\")\n            unreplaced = html_content.count(\"&amp;REPLACE_ME;\")\n            \n            # This assertion will fail before the fix (showing the bug)\n            # and should pass after the fix\n            assert actual_replacements == expected_replacements, \\\n                f\"Expected {expected_replacements} replacements, got {actual_replacements}. \" \\\n                f\"Unreplaced: {unreplaced}\"\n            assert unreplaced == 0, \\\n                f\"Found {unreplaced} unreplaced &REPLACE_ME; tokens\"\n</patched>\n```",
  "patch": "--- a/tests/test_directive_include_source_read.py\n+++ b/tests/test_directive_include_source_read.py\n-# Empty if creating new file\n+import pytest\n+from pathlib import Path\n+import tempfile\n+import shutil\n+from sphinx.application import Sphinx\n+from sphinx.util.docutils import docutils_namespace\n+from sphinx.testing.util import SphinxTestApp\n+from sphinx.testing.path import path\n+import os\n+\n+\n+class TestIncludeSourceReadEvent:\n+    \"\"\"Test that the source-read event is properly emitted for included files.\"\"\"\n+\n+    @pytest.fixture\n+    def temp_sphinx_project(self, tmp_path):\n+        \"\"\"Create a temporary Sphinx project for testing.\"\"\"\n+        srcdir = tmp_path / \"source\"\n+        outdir = tmp_path / \"build\"\n+        doctreedir = tmp_path / \"doctrees\"\n+        confdir = srcdir\n+        \n+        srcdir.mkdir()\n+        outdir.mkdir()\n+        doctreedir.mkdir()\n+        \n+        # Create conf.py\n+        conf_content = '''\n+import sys\n+import os\n+sys.path.insert(0, os.path.abspath('.'))\n+\n+extensions = ['test_extension']\n+'''\n+        (srcdir / \"conf.py\").write_text(conf_content)\n+        \n+        # Create test extension\n+        extension_content = '''\n+from sphinx.application import Sphinx\n+\n+__version__ = '1.0'\n+\n+# Track which files had their source modified\n+modified_files = []\n+\n+def subst_vars_replace(app: Sphinx, docname, source):\n+    \"\"\"Replace &REPLACE_ME; with REPLACED in source.\"\"\"\n+    result = source[0]\n+    if \"&REPLACE_ME;\" in result:\n+        result = result.replace(\"&REPLACE_ME;\", \"REPLACED\")\n+        source[0] = result\n+        modified_files.append(docname)\n+\n+def setup(app: Sphinx):\n+    app.connect('source-read', subst_vars_replace)\n+    return dict(\n+        version=__version__,\n+        parallel_read_safe=True,\n+        parallel_write_safe=True\n+    )\n+'''\n+        (srcdir / \"test_extension.py\").write_text(extension_content)\n+        \n+        return {\n+            'srcdir': srcdir,\n+            'outdir': outdir,\n+            'doctreedir': doctreedir,\n+            'confdir': confdir\n+        }\n+\n+    def test_source_read_event_not_emitted_for_included_files_bug(self, temp_sphinx_project):\n+        \"\"\"Test that demonstrates the bug: source-read event is not properly applied to included files.\"\"\"\n+        srcdir = temp_sphinx_project['srcdir']\n+        outdir = temp_sphinx_project['outdir']\n+        \n+        # Create main document\n+        index_content = '''\n+This is a test\n+==============\n+\n+.. include:: something-to-include.rst\n+\n+&REPLACE_ME;\n+'''\n+        (srcdir / \"index.rst\").write_text(index_content)\n+        \n+        # Create included document\n+        include_content = '''\n+Testing\n+=======\n+\n+&REPLACE_ME;\n+'''\n+        (srcdir / \"something-to-include.rst\").write_text(include_content)\n+        \n+        # Build the documentation\n+        with docutils_namespace():\n+            app = SphinxTestApp(\n+                srcdir=str(srcdir),\n+                builddir=str(outdir),\n+                confdir=str(srcdir)\n+            )\n+            app.build()\n+            \n+            # Read the generated HTML\n+            html_file = outdir / \"html\" / \"index.html\"\n+            if html_file.exists():\n+                html_content = html_file.read_text()\n+            else:\n+                # Fallback to check doctree or other output\n+                html_content = \"\"\n+                for html_file in (outdir / \"html\").glob(\"*.html\"):\n+                    html_content += html_file.read_text()\n+            \n+            # This test demonstrates the bug: the included file's &REPLACE_ME; is NOT replaced\n+            # The main file's &REPLACE_ME; should be replaced, but the included file's should not be\n+            # This shows that source-read event is not properly emitted for included files\n+            assert \"REPLACED\" in html_content  # Main file replacement works\n+            assert \"&amp;REPLACE_ME;\" in html_content  # Included file replacement fails (bug)\n+\n+    def test_source_read_event_called_for_included_files_tracking(self, temp_sphinx_project):\n+        \"\"\"Test that source-read event is called for included files but changes don't take effect.\"\"\"\n+        srcdir = temp_sphinx_project['srcdir']\n+        outdir = temp_sphinx_project['outdir']\n+        \n+        # Create tracking extension\n+        tracking_extension_content = '''\n+from sphinx.application import Sphinx\n+\n+__version__ = '1.0'\n+\n+# Track all source-read events\n+source_read_calls = []\n+\n+def track_source_read(app: Sphinx, docname, source):\n+    \"\"\"Track all source-read events.\"\"\"\n+    source_read_calls.append({\n+        'docname': docname,\n+        'original_content': source[0],\n+        'has_replace_me': '&REPLACE_ME;' in source[0]\n+    })\n+    # Try to modify the source\n+    if \"&REPLACE_ME;\" in source[0]:\n+        source[0] = source[0].replace(\"&REPLACE_ME;\", \"REPLACED\")\n+\n+def setup(app: Sphinx):\n+    app.connect('source-read', track_source_read)\n+    return dict(\n+        version=__version__,\n+        parallel_read_safe=True,\n+        parallel_write_safe=True\n+    )\n+'''\n+        (srcdir / \"test_extension.py\").write_text(tracking_extension_content)\n+        \n+        # Create main document\n+        index_content = '''\n+Main Document\n+=============\n+\n+.. include:: included.rst\n+\n+Main content: &REPLACE_ME;\n+'''\n+        (srcdir / \"index.rst\").write_text(index_content)\n+        \n+        # Create included document\n+        include_content = '''\n+Included Section\n+================\n+\n+Included content: &REPLACE_ME;\n+'''\n+        (srcdir / \"included.rst\").write_text(include_content)\n+        \n+        # Build the documentation\n+        with docutils_namespace():\n+            app = SphinxTestApp(\n+                srcdir=str(srcdir),\n+                builddir=str(outdir),\n+                confdir=str(srcdir)\n+            )\n+            app.build()\n+            \n+            # Import the tracking data from the extension\n+            import sys\n+            if str(srcdir) not in sys.path:\n+                sys.path.insert(0, str(srcdir))\n+            \n+            try:\n+                import test_extension\n+                calls = test_extension.source_read_calls\n+                \n+                # Verify that source-read was called for both files\n+                docnames = [call['docname'] for call in calls]\n+                assert 'index' in docnames\n+                assert 'included' in docnames\n+                \n+                # Verify that both files had &REPLACE_ME; content\n+                for call in calls:\n+                    if call['docname'] in ['index', 'included']:\n+                        assert call['has_replace_me'], f\"File {call['docname']} should have &REPLACE_ME;\"\n+                        \n+            except ImportError:\n+                # If we can't import the extension, skip this verification\n+                pass\n+\n+    def test_include_with_standard_docutils_syntax(self, temp_sphinx_project):\n+        \"\"\"Test that standard docutils includes (with < >) are not affected.\"\"\"\n+        srcdir = temp_sphinx_project['srcdir']\n+        outdir = temp_sphinx_project['outdir']\n+        \n+        # Create main document with standard docutils include syntax\n+        index_content = '''\n+Standard Include Test\n+====================\n+\n+.. include:: <stdin>\n+\n+Regular content: &REPLACE_ME;\n+'''\n+        (srcdir / \"index.rst\").write_text(index_content)\n+        \n+        # Build should not fail even with non-existent <stdin>\n+        with docutils_namespace():\n+            app = SphinxTestApp(\n+                srcdir=str(srcdir),\n+                builddir=str(outdir),\n+                confdir=str(srcdir)\n+            )\n+            # This should not raise an exception\n+            app.build()\n+\n+    def test_include_with_absolute_path_processing(self, temp_sphinx_project):\n+        \"\"\"Test that include directive properly processes absolute paths.\"\"\"\n+        srcdir = temp_sphinx_project['srcdir']\n+        outdir = temp_sphinx_project['outdir']\n+        \n+        # Create subdirectory\n+        subdir = srcdir / \"subdir\"\n+        subdir.mkdir()\n+        \n+        # Create main document\n+        index_content = '''\n+Path Processing Test\n+===================\n+\n+.. include:: /subdir/nested.rst\n+\n+Main content: &REPLACE_ME;\n+'''\n+        (srcdir / \"index.rst\").write_text(index_content)\n+        \n+        # Create nested document\n+        nested_content = '''\n+Nested Content\n+==============\n+\n+Nested: &REPLACE_ME;\n+'''\n+        (subdir / \"nested.rst\").write_text(nested_content)\n+        \n+        # Build the documentation\n+        with docutils_namespace():\n+            app = SphinxTestApp(\n+                srcdir=str(srcdir),\n+                builddir=str(outdir),\n+                confdir=str(srcdir)\n+            )\n+            app.build()\n+            \n+            # Verify the build completed without errors\n+            # The exact behavior depends on the fix implementation\n+\n+    def test_multiple_nested_includes(self, temp_sphinx_project):\n+        \"\"\"Test source-read event with multiple levels of nested includes.\"\"\"\n+        srcdir = temp_sphinx_project['srcdir']\n+        outdir = temp_sphinx_project['outdir']\n+        \n+        # Create main document\n+        index_content = '''\n+Nested Includes Test\n+===================\n+\n+.. include:: level1.rst\n+\n+Main: &REPLACE_ME;\n+'''\n+        (srcdir / \"index.rst\").write_text(index_content)\n+        \n+        # Create level 1 include\n+        level1_content = '''\n+Level 1\n+=======\n+\n+.. include:: level2.rst\n+\n+Level 1: &REPLACE_ME;\n+'''\n+        (srcdir / \"level1.rst\").write_text(level1_content)\n+        \n+        # Create level 2 include\n+        level2_content = '''\n+Level 2\n+=======\n+\n+Level 2: &REPLACE_ME;\n+'''\n+        (srcdir / \"level2.rst\").write_text(level2_content)\n+        \n+        # Build the documentation\n+        with docutils_namespace():\n+            app = SphinxTestApp(\n+                srcdir=str(srcdir),\n+                builddir=str(outdir),\n+                confdir=str(srcdir)\n+            )\n+            app.build()\n+            \n+            # Read the generated HTML\n+            html_files = list((outdir / \"html\").glob(\"*.html\"))\n+            html_content = \"\"\n+            for html_file in html_files:\n+                html_content += html_file.read_text()\n+            \n+            # Count occurrences - this test shows the current buggy behavior\n+            # After fix, all &REPLACE_ME; should become REPLACED\n+            replaced_count = html_content.count(\"REPLACED\")\n+            unreplaced_count = html_content.count(\"&amp;REPLACE_ME;\")\n+            \n+            # Currently, only the main file gets replaced (bug)\n+            # After fix, all files should be replaced\n+            assert replaced_count >= 1  # At least main file works\n+            # The bug is that unreplaced_count > 0 for included files\n+\n+    def test_include_with_source_read_modification_should_work_after_fix(self, temp_sphinx_project):\n+        \"\"\"Test that after the fix, included files are properly modified by source-read events.\"\"\"\n+        srcdir = temp_sphinx_project['srcdir']\n+        outdir = temp_sphinx_project['outdir']\n+        \n+        # Create main document\n+        index_content = '''\n+Fixed Include Test\n+=================\n+\n+.. include:: to-be-modified.rst\n+\n+Main content: &REPLACE_ME;\n+'''\n+        (srcdir / \"index.rst\").write_text(index_content)\n+        \n+        # Create included document with content that should be modified\n+        include_content = '''\n+Included Content\n+===============\n+\n+This should be modified: &REPLACE_ME;\n+\n+Multiple replacements: &REPLACE_ME; and &REPLACE_ME;\n+'''\n+        (srcdir / \"to-be-modified.rst\").write_text(include_content)\n+        \n+        # Build the documentation\n+        with docutils_namespace():\n+            app = SphinxTestApp(\n+                srcdir=str(srcdir),\n+                builddir=str(outdir),\n+                confdir=str(srcdir)\n+            )\n+            app.build()\n+            \n+            # Read the generated HTML\n+            html_files = list((outdir / \"html\").glob(\"*.html\"))\n+            html_content = \"\"\n+            for html_file in html_files:\n+                html_content += html_file.read_text()\n+            \n+            # This test will fail before the fix and pass after the fix\n+            # Before fix: included file's &REPLACE_ME; won't be replaced\n+            # After fix: all &REPLACE_ME; should be replaced with REPLACED\n+            \n+            # Count total expected replacements (4 total: 1 in main + 3 in included)\n+            expected_replacements = 4\n+            actual_replacements = html_content.count(\"REPLACED\")\n+            unreplaced = html_content.count(\"&amp;REPLACE_ME;\")\n+            \n+            # This assertion will fail before the fix (showing the bug)\n+            # and should pass after the fix\n+            assert actual_replacements == expected_replacements, \\\n+                f\"Expected {expected_replacements} replacements, got {actual_replacements}. \" \\\n+                f\"Unreplaced: {unreplaced}\"\n+            assert unreplaced == 0, \\\n+                f\"Found {unreplaced} unreplaced &REPLACE_ME; tokens\"\n"
}