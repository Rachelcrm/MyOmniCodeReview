{
  "instance_id": "scrapy__scrapy-6540",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_utils_misc.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom scrapy.utils.misc import build_from_crawler, create_instance\nfrom scrapy.crawler import Crawler\nfrom scrapy.settings import Settings\nfrom scrapy.exceptions import ScrapyDeprecationWarning\n\n\nclass MockClass:\n    \"\"\"Mock class for testing build functions.\"\"\"\n    \n    def __init__(self, value=None):\n        self.value = value\n    \n    @classmethod\n    def from_crawler(cls, crawler):\n        return cls(value=\"from_crawler\")\n    \n    @classmethod\n    def from_settings(cls, settings):\n        return cls(value=\"from_settings\")\n\n\nclass MockClassOnlyFromSettings:\n    \"\"\"Mock class that only has from_settings method.\"\"\"\n    \n    def __init__(self, value=None):\n        self.value = value\n    \n    @classmethod\n    def from_settings(cls, settings):\n        return cls(value=\"from_settings\")\n\n\nclass MockClassNoMethods:\n    \"\"\"Mock class with no special constructor methods.\"\"\"\n    \n    def __init__(self, value=None):\n        self.value = value\n\n\nclass TestBuildFromCrawler:\n    \"\"\"Test build_from_crawler function behavior.\"\"\"\n    \n    def test_build_from_crawler_uses_from_crawler_when_available(self):\n        \"\"\"Test that build_from_crawler uses from_crawler method when available.\"\"\"\n        crawler = Mock(spec=Crawler)\n        \n        instance = build_from_crawler(MockClass, crawler)\n        \n        assert instance.value == \"from_crawler\"\n    \n    def test_build_from_crawler_falls_back_to_from_settings(self):\n        \"\"\"Test that build_from_crawler falls back to from_settings when from_crawler not available.\"\"\"\n        crawler = Mock(spec=Crawler)\n        crawler.settings = Mock(spec=Settings)\n        \n        instance = build_from_crawler(MockClassOnlyFromSettings, crawler)\n        \n        assert instance.value == \"from_settings\"\n    \n    def test_build_from_crawler_falls_back_to_constructor(self):\n        \"\"\"Test that build_from_crawler falls back to regular constructor when no special methods.\"\"\"\n        crawler = Mock(spec=Crawler)\n        \n        instance = build_from_crawler(MockClassNoMethods, crawler, value=\"constructor\")\n        \n        assert instance.value == \"constructor\"\n    \n    def test_build_from_crawler_passes_args_and_kwargs(self):\n        \"\"\"Test that build_from_crawler passes additional args and kwargs.\"\"\"\n        class MockWithArgs:\n            def __init__(self, arg1, arg2, kwarg1=None):\n                self.arg1 = arg1\n                self.arg2 = arg2\n                self.kwarg1 = kwarg1\n        \n        crawler = Mock(spec=Crawler)\n        \n        instance = build_from_crawler(MockWithArgs, crawler, \"test1\", \"test2\", kwarg1=\"test3\")\n        \n        assert instance.arg1 == \"test1\"\n        assert instance.arg2 == \"test2\"\n        assert instance.kwarg1 == \"test3\"\n    \n    def test_build_from_crawler_raises_type_error_when_none_returned(self):\n        \"\"\"Test that build_from_crawler raises TypeError when constructor returns None.\"\"\"\n        class MockReturnsNone:\n            @classmethod\n            def from_crawler(cls, crawler):\n                return None\n        \n        crawler = Mock(spec=Crawler)\n        \n        with pytest.raises(TypeError, match=\"MockReturnsNone.from_crawler returned None\"):\n            build_from_crawler(MockReturnsNone, crawler)\n\n\nclass TestBuildFromSettingsRemoval:\n    \"\"\"Test that build_from_settings function is removed.\"\"\"\n    \n    def test_build_from_settings_function_does_not_exist(self):\n        \"\"\"Test that build_from_settings function is no longer available.\"\"\"\n        from scrapy.utils import misc\n        \n        # This test should fail before the fix is applied\n        assert not hasattr(misc, 'build_from_settings'), \\\n            \"build_from_settings function should be removed\"\n    \n    def test_build_from_settings_import_fails(self):\n        \"\"\"Test that importing build_from_settings fails.\"\"\"\n        with pytest.raises(ImportError):\n            from scrapy.utils.misc import build_from_settings\n\n\nclass TestCreateInstanceDeprecation:\n    \"\"\"Test create_instance deprecation warning.\"\"\"\n    \n    def test_create_instance_warns_only_about_build_from_crawler(self):\n        \"\"\"Test that create_instance deprecation warning only mentions build_from_crawler.\"\"\"\n        crawler = Mock(spec=Crawler)\n        settings = Mock(spec=Settings)\n        \n        with pytest.warns(ScrapyDeprecationWarning) as warning_info:\n            create_instance(MockClass, settings, crawler)\n        \n        warning_message = str(warning_info[0].message)\n        assert \"build_from_crawler()\" in warning_message\n        # This test should fail before the fix - it should not mention build_from_settings\n        assert \"build_from_settings()\" not in warning_message, \\\n            \"Deprecation warning should not mention build_from_settings\"\n    \n    def test_create_instance_still_works_with_crawler(self):\n        \"\"\"Test that create_instance still works when crawler is provided.\"\"\"\n        crawler = Mock(spec=Crawler)\n        settings = Mock(spec=Settings)\n        \n        with pytest.warns(ScrapyDeprecationWarning):\n            instance = create_instance(MockClass, settings, crawler)\n        \n        assert instance.value == \"from_crawler\"\n    \n    def test_create_instance_works_with_settings_only_when_no_from_crawler(self):\n        \"\"\"Test that create_instance works with settings only when class has no from_crawler.\"\"\"\n        settings = Mock(spec=Settings)\n        \n        with pytest.warns(ScrapyDeprecationWarning):\n            instance = create_instance(MockClassOnlyFromSettings, settings, None)\n        \n        assert instance.value == \"from_settings\"\n\n\nclass TestBuildFromCrawlerDocstring:\n    \"\"\"Test that build_from_crawler has correct docstring.\"\"\"\n    \n    def test_build_from_crawler_docstring_mentions_from_settings_fallback(self):\n        \"\"\"Test that build_from_crawler docstring properly documents from_settings fallback.\"\"\"\n        docstring = build_from_crawler.__doc__\n        \n        # The docstring should mention the fallback to from_settings method\n        assert \"from_settings\" in docstring.lower(), \\\n            \"Docstring should mention fallback to from_settings method\"\n        \n        # Should mention it's a constructor method, not the build_from_settings function\n        assert \"from_settings\" in docstring and \"method\" in docstring.lower(), \\\n            \"Docstring should clarify it falls back to from_settings method\"\n</patched>\n</file>\n```\n\n```\n<file>tests/test_middleware.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom scrapy.middleware import MiddlewareManager\nfrom scrapy.crawler import Crawler\nfrom scrapy.settings import Settings\nfrom scrapy.exceptions import NotConfigured\n\n\nclass MockMiddleware:\n    \"\"\"Mock middleware class for testing.\"\"\"\n    \n    def __init__(self, value=None):\n        self.value = value\n    \n    @classmethod\n    def from_crawler(cls, crawler):\n        return cls(value=\"from_crawler\")\n    \n    @classmethod\n    def from_settings(cls, settings):\n        return cls(value=\"from_settings\")\n\n\nclass MockMiddlewareOnlyFromSettings:\n    \"\"\"Mock middleware that only has from_settings method.\"\"\"\n    \n    def __init__(self, value=None):\n        self.value = value\n    \n    @classmethod\n    def from_settings(cls, settings):\n        return cls(value=\"from_settings\")\n\n\nclass MockMiddlewareNotConfigured:\n    \"\"\"Mock middleware that raises NotConfigured.\"\"\"\n    \n    @classmethod\n    def from_crawler(cls, crawler):\n        raise NotConfigured(\"Test not configured\")\n\n\nclass TestMiddlewareManagerFromSettings:\n    \"\"\"Test MiddlewareManager.from_settings method behavior.\"\"\"\n    \n    def test_from_settings_requires_crawler_parameter(self):\n        \"\"\"Test that from_settings method requires a Crawler instance.\"\"\"\n        settings = Mock(spec=Settings)\n        crawler = Mock(spec=Crawler)\n        \n        # This should work with crawler provided\n        with patch.object(MiddlewareManager, '_get_mwlist_from_settings', return_value=[]):\n            manager = MiddlewareManager.from_settings(settings, crawler)\n            assert isinstance(manager, MiddlewareManager)\n    \n    def test_from_settings_signature_requires_crawler(self):\n        \"\"\"Test that from_settings method signature requires crawler parameter.\"\"\"\n        import inspect\n        \n        sig = inspect.signature(MiddlewareManager.from_settings)\n        params = sig.parameters\n        \n        # After the fix, crawler should be required (not optional)\n        assert 'crawler' in params\n        crawler_param = params['crawler']\n        \n        # This test should fail before the fix - crawler should not have a default value\n        assert crawler_param.default == inspect.Parameter.empty, \\\n            \"crawler parameter should be required, not optional\"\n    \n    @patch('scrapy.middleware.load_object')\n    @patch('scrapy.middleware.build_from_crawler')\n    def test_from_settings_always_uses_build_from_crawler(self, mock_build_from_crawler, mock_load_object):\n        \"\"\"Test that from_settings always uses build_from_crawler, never build_from_settings.\"\"\"\n        settings = Mock(spec=Settings)\n        crawler = Mock(spec=Crawler)\n        \n        # Setup mocks\n        mock_load_object.return_value = MockMiddleware\n        mock_build_from_crawler.return_value = MockMiddleware(value=\"test\")\n        \n        with patch.object(MiddlewareManager, '_get_mwlist_from_settings', \n                         return_value=['test.middleware.MockMiddleware']):\n            MiddlewareManager.from_settings(settings, crawler)\n        \n        # Should call build_from_crawler, not build_from_settings\n        mock_build_from_crawler.assert_called_once_with(MockMiddleware, crawler)\n    \n    @patch('scrapy.middleware.load_object')\n    @patch('scrapy.middleware.build_from_crawler')\n    def test_from_settings_handles_not_configured_middleware(self, mock_build_from_crawler, mock_load_object):\n        \"\"\"Test that from_settings properly handles NotConfigured exceptions.\"\"\"\n        settings = Mock(spec=Settings)\n        crawler = Mock(spec=Crawler)\n        \n        # Setup mocks\n        mock_load_object.return_value = MockMiddlewareNotConfigured\n        mock_build_from_crawler.side_effect = NotConfigured(\"Test not configured\")\n        \n        with patch.object(MiddlewareManager, '_get_mwlist_from_settings', \n                         return_value=['test.middleware.MockMiddlewareNotConfigured']):\n            manager = MiddlewareManager.from_settings(settings, crawler)\n        \n        # Should create empty manager when middleware is not configured\n        assert len(manager._middlewares) == 0\n    \n    def test_from_settings_no_build_from_settings_usage(self):\n        \"\"\"Test that from_settings method doesn't use build_from_settings function.\"\"\"\n        import inspect\n        \n        # Get the source code of the from_settings method\n        source = inspect.getsource(MiddlewareManager.from_settings)\n        \n        # This test should fail before the fix - build_from_settings should not be used\n        assert 'build_from_settings' not in source, \\\n            \"from_settings method should not use build_from_settings function\"\n\n\nclass TestMiddlewareManagerFromCrawler:\n    \"\"\"Test MiddlewareManager.from_crawler method behavior.\"\"\"\n    \n    def test_from_crawler_calls_from_settings_with_crawler(self):\n        \"\"\"Test that from_crawler properly calls from_settings with crawler.\"\"\"\n        crawler = Mock(spec=Crawler)\n        crawler.settings = Mock(spec=Settings)\n        \n        with patch.object(MiddlewareManager, 'from_settings') as mock_from_settings:\n            mock_from_settings.return_value = MiddlewareManager()\n            \n            MiddlewareManager.from_crawler(crawler)\n            \n            # Should call from_settings with both settings and crawler\n            mock_from_settings.assert_called_once_with(crawler.settings, crawler)\n\n\nclass TestMiddlewareManagerIntegration:\n    \"\"\"Integration tests for MiddlewareManager.\"\"\"\n    \n    def test_middleware_manager_creation_with_real_middleware(self):\n        \"\"\"Test creating MiddlewareManager with real middleware classes.\"\"\"\n        from scrapy.downloadermiddlewares.useragent import UserAgentMiddleware\n        \n        settings = Settings({\n            'DOWNLOADER_MIDDLEWARES': {\n                'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': 500,\n            },\n            'USER_AGENT': 'Test Agent'\n        })\n        crawler = Mock(spec=Crawler)\n        crawler.settings = settings\n        \n        # This should work without issues\n        manager = MiddlewareManager.from_settings(settings, crawler)\n        assert isinstance(manager, MiddlewareManager)\n    \n    def test_middleware_manager_backward_compatibility(self):\n        \"\"\"Test that existing code using from_crawler still works.\"\"\"\n        settings = Settings({\n            'DOWNLOADER_MIDDLEWARES': {},\n        })\n        crawler = Mock(spec=Crawler)\n        crawler.settings = settings\n        \n        # from_crawler should still work as before\n        manager = MiddlewareManager.from_crawler(crawler)\n        assert isinstance(manager, MiddlewareManager)\n</patched>\n</file>\n```\n\n```\n<file>tests/test_build_from_settings_removal.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom scrapy.crawler import Crawler\nfrom scrapy.settings import Settings\n\n\nclass TestBuildFromSettingsRemovalIntegration:\n    \"\"\"Integration tests to ensure build_from_settings is completely removed.\"\"\"\n    \n    def test_build_from_settings_not_in_misc_module(self):\n        \"\"\"Test that build_from_settings is not available in misc module.\"\"\"\n        from scrapy.utils import misc\n        \n        # Should not have build_from_settings function\n        assert not hasattr(misc, 'build_from_settings'), \\\n            \"build_from_settings should be completely removed from misc module\"\n    \n    def test_build_from_settings_not_importable(self):\n        \"\"\"Test that build_from_settings cannot be imported.\"\"\"\n        with pytest.raises(ImportError):\n            from scrapy.utils.misc import build_from_settings\n    \n    def test_build_from_settings_not_in_all(self):\n        \"\"\"Test that build_from_settings is not in __all__ if it exists.\"\"\"\n        from scrapy.utils import misc\n        \n        if hasattr(misc, '__all__'):\n            assert 'build_from_settings' not in misc.__all__, \\\n                \"build_from_settings should not be in __all__\"\n    \n    def test_no_references_to_build_from_settings_in_middleware(self):\n        \"\"\"Test that middleware.py doesn't reference build_from_settings.\"\"\"\n        import inspect\n        from scrapy import middleware\n        \n        # Get source of the entire middleware module\n        source = inspect.getsource(middleware)\n        \n        # Should not contain any references to build_from_settings\n        assert 'build_from_settings' not in source, \\\n            \"middleware.py should not contain any references to build_from_settings\"\n    \n    def test_middleware_manager_only_uses_build_from_crawler(self):\n        \"\"\"Test that MiddlewareManager only uses build_from_crawler.\"\"\"\n        import inspect\n        from scrapy.middleware import MiddlewareManager\n        \n        # Get source of from_settings method\n        source = inspect.getsource(MiddlewareManager.from_settings)\n        \n        # Should use build_from_crawler but not build_from_settings\n        assert 'build_from_crawler' in source, \\\n            \"MiddlewareManager.from_settings should use build_from_crawler\"\n        assert 'buil",
  "patch": "--- a/tests/test_utils_misc.py\n+++ b/tests/test_utils_misc.py\n+import pytest\n+from unittest.mock import Mock, patch\n+from scrapy.utils.misc import build_from_crawler, create_instance\n+from scrapy.crawler import Crawler\n+from scrapy.settings import Settings\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+\n+\n+class MockClass:\n+    \"\"\"Mock class for testing build functions.\"\"\"\n+    \n+    def __init__(self, value=None):\n+        self.value = value\n+    \n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        return cls(value=\"from_crawler\")\n+    \n+    @classmethod\n+    def from_settings(cls, settings):\n+        return cls(value=\"from_settings\")\n+\n+\n+class MockClassOnlyFromSettings:\n+    \"\"\"Mock class that only has from_settings method.\"\"\"\n+    \n+    def __init__(self, value=None):\n+        self.value = value\n+    \n+    @classmethod\n+    def from_settings(cls, settings):\n+        return cls(value=\"from_settings\")\n+\n+\n+class MockClassNoMethods:\n+    \"\"\"Mock class with no special constructor methods.\"\"\"\n+    \n+    def __init__(self, value=None):\n+        self.value = value\n+\n+\n+class TestBuildFromCrawler:\n+    \"\"\"Test build_from_crawler function behavior.\"\"\"\n+    \n+    def test_build_from_crawler_uses_from_crawler_when_available(self):\n+        \"\"\"Test that build_from_crawler uses from_crawler method when available.\"\"\"\n+        crawler = Mock(spec=Crawler)\n+        \n+        instance = build_from_crawler(MockClass, crawler)\n+        \n+        assert instance.value == \"from_crawler\"\n+    \n+    def test_build_from_crawler_falls_back_to_from_settings(self):\n+        \"\"\"Test that build_from_crawler falls back to from_settings when from_crawler not available.\"\"\"\n+        crawler = Mock(spec=Crawler)\n+        crawler.settings = Mock(spec=Settings)\n+        \n+        instance = build_from_crawler(MockClassOnlyFromSettings, crawler)\n+        \n+        assert instance.value == \"from_settings\"\n+    \n+    def test_build_from_crawler_falls_back_to_constructor(self):\n+        \"\"\"Test that build_from_crawler falls back to regular constructor when no special methods.\"\"\"\n+        crawler = Mock(spec=Crawler)\n+        \n+        instance = build_from_crawler(MockClassNoMethods, crawler, value=\"constructor\")\n+        \n+        assert instance.value == \"constructor\"\n+    \n+    def test_build_from_crawler_passes_args_and_kwargs(self):\n+        \"\"\"Test that build_from_crawler passes additional args and kwargs.\"\"\"\n+        class MockWithArgs:\n+            def __init__(self, arg1, arg2, kwarg1=None):\n+                self.arg1 = arg1\n+                self.arg2 = arg2\n+                self.kwarg1 = kwarg1\n+        \n+        crawler = Mock(spec=Crawler)\n+        \n+        instance = build_from_crawler(MockWithArgs, crawler, \"test1\", \"test2\", kwarg1=\"test3\")\n+        \n+        assert instance.arg1 == \"test1\"\n+        assert instance.arg2 == \"test2\"\n+        assert instance.kwarg1 == \"test3\"\n+    \n+    def test_build_from_crawler_raises_type_error_when_none_returned(self):\n+        \"\"\"Test that build_from_crawler raises TypeError when constructor returns None.\"\"\"\n+        class MockReturnsNone:\n+            @classmethod\n+            def from_crawler(cls, crawler):\n+                return None\n+        \n+        crawler = Mock(spec=Crawler)\n+        \n+        with pytest.raises(TypeError, match=\"MockReturnsNone.from_crawler returned None\"):\n+            build_from_crawler(MockReturnsNone, crawler)\n+\n+\n+class TestBuildFromSettingsRemoval:\n+    \"\"\"Test that build_from_settings function is removed.\"\"\"\n+    \n+    def test_build_from_settings_function_does_not_exist(self):\n+        \"\"\"Test that build_from_settings function is no longer available.\"\"\"\n+        from scrapy.utils import misc\n+        \n+        # This test should fail before the fix is applied\n+        assert not hasattr(misc, 'build_from_settings'), \\\n+            \"build_from_settings function should be removed\"\n+    \n+    def test_build_from_settings_import_fails(self):\n+        \"\"\"Test that importing build_from_settings fails.\"\"\"\n+        with pytest.raises(ImportError):\n+            from scrapy.utils.misc import build_from_settings\n+\n+\n+class TestCreateInstanceDeprecation:\n+    \"\"\"Test create_instance deprecation warning.\"\"\"\n+    \n+    def test_create_instance_warns_only_about_build_from_crawler(self):\n+        \"\"\"Test that create_instance deprecation warning only mentions build_from_crawler.\"\"\"\n+        crawler = Mock(spec=Crawler)\n+        settings = Mock(spec=Settings)\n+        \n+        with pytest.warns(ScrapyDeprecationWarning) as warning_info:\n+            create_instance(MockClass, settings, crawler)\n+        \n+        warning_message = str(warning_info[0].message)\n+        assert \"build_from_crawler()\" in warning_message\n+        # This test should fail before the fix - it should not mention build_from_settings\n+        assert \"build_from_settings()\" not in warning_message, \\\n+            \"Deprecation warning should not mention build_from_settings\"\n+    \n+    def test_create_instance_still_works_with_crawler(self):\n+        \"\"\"Test that create_instance still works when crawler is provided.\"\"\"\n+        crawler = Mock(spec=Crawler)\n+        settings = Mock(spec=Settings)\n+        \n+        with pytest.warns(ScrapyDeprecationWarning):\n+            instance = create_instance(MockClass, settings, crawler)\n+        \n+        assert instance.value == \"from_crawler\"\n+    \n+    def test_create_instance_works_with_settings_only_when_no_from_crawler(self):\n+        \"\"\"Test that create_instance works with settings only when class has no from_crawler.\"\"\"\n+        settings = Mock(spec=Settings)\n+        \n+        with pytest.warns(ScrapyDeprecationWarning):\n+            instance = create_instance(MockClassOnlyFromSettings, settings, None)\n+        \n+        assert instance.value == \"from_settings\"\n+\n+\n+class TestBuildFromCrawlerDocstring:\n+    \"\"\"Test that build_from_crawler has correct docstring.\"\"\"\n+    \n+    def test_build_from_crawler_docstring_mentions_from_settings_fallback(self):\n+        \"\"\"Test that build_from_crawler docstring properly documents from_settings fallback.\"\"\"\n+        docstring = build_from_crawler.__doc__\n+        \n+        # The docstring should mention the fallback to from_settings method\n+        assert \"from_settings\" in docstring.lower(), \\\n+            \"Docstring should mention fallback to from_settings method\"\n+        \n+        # Should mention it's a constructor method, not the build_from_settings function\n+        assert \"from_settings\" in docstring and \"method\" in docstring.lower(), \\\n+            \"Docstring should clarify it falls back to from_settings method\"\n\n--- a/tests/test_middleware.py\n+++ b/tests/test_middleware.py\n+import pytest\n+from unittest.mock import Mock, patch\n+from scrapy.middleware import MiddlewareManager\n+from scrapy.crawler import Crawler\n+from scrapy.settings import Settings\n+from scrapy.exceptions import NotConfigured\n+\n+\n+class MockMiddleware:\n+    \"\"\"Mock middleware class for testing.\"\"\"\n+    \n+    def __init__(self, value=None):\n+        self.value = value\n+    \n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        return cls(value=\"from_crawler\")\n+    \n+    @classmethod\n+    def from_settings(cls, settings):\n+        return cls(value=\"from_settings\")\n+\n+\n+class MockMiddlewareOnlyFromSettings:\n+    \"\"\"Mock middleware that only has from_settings method.\"\"\"\n+    \n+    def __init__(self, value=None):\n+        self.value = value\n+    \n+    @classmethod\n+    def from_settings(cls, settings):\n+        return cls(value=\"from_settings\")\n+\n+\n+class MockMiddlewareNotConfigured:\n+    \"\"\"Mock middleware that raises NotConfigured.\"\"\"\n+    \n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        raise NotConfigured(\"Test not configured\")\n+\n+\n+class TestMiddlewareManagerFromSettings:\n+    \"\"\"Test MiddlewareManager.from_settings method behavior.\"\"\"\n+    \n+    def test_from_settings_requires_crawler_parameter(self):\n+        \"\"\"Test that from_settings method requires a Crawler instance.\"\"\"\n+        settings = Mock(spec=Settings)\n+        crawler = Mock(spec=Crawler)\n+        \n+        # This should work with crawler provided\n+        with patch.object(MiddlewareManager, '_get_mwlist_from_settings', return_value=[]):\n+            manager = MiddlewareManager.from_settings(settings, crawler)\n+            assert isinstance(manager, MiddlewareManager)\n+    \n+    def test_from_settings_signature_requires_crawler(self):\n+        \"\"\"Test that from_settings method signature requires crawler parameter.\"\"\"\n+        import inspect\n+        \n+        sig = inspect.signature(MiddlewareManager.from_settings)\n+        params = sig.parameters\n+        \n+        # After the fix, crawler should be required (not optional)\n+        assert 'crawler' in params\n+        crawler_param = params['crawler']\n+        \n+        # This test should fail before the fix - crawler should not have a default value\n+        assert crawler_param.default == inspect.Parameter.empty, \\\n+            \"crawler parameter should be required, not optional\"\n+    \n+    @patch('scrapy.middleware.load_object')\n+    @patch('scrapy.middleware.build_from_crawler')\n+    def test_from_settings_always_uses_build_from_crawler(self, mock_build_from_crawler, mock_load_object):\n+        \"\"\"Test that from_settings always uses build_from_crawler, never build_from_settings.\"\"\"\n+        settings = Mock(spec=Settings)\n+        crawler = Mock(spec=Crawler)\n+        \n+        # Setup mocks\n+        mock_load_object.return_value = MockMiddleware\n+        mock_build_from_crawler.return_value = MockMiddleware(value=\"test\")\n+        \n+        with patch.object(MiddlewareManager, '_get_mwlist_from_settings', \n+                         return_value=['test.middleware.MockMiddleware']):\n+            MiddlewareManager.from_settings(settings, crawler)\n+        \n+        # Should call build_from_crawler, not build_from_settings\n+        mock_build_from_crawler.assert_called_once_with(MockMiddleware, crawler)\n+    \n+    @patch('scrapy.middleware.load_object')\n+    @patch('scrapy.middleware.build_from_crawler')\n+    def test_from_settings_handles_not_configured_middleware(self, mock_build_from_crawler, mock_load_object):\n+        \"\"\"Test that from_settings properly handles NotConfigured exceptions.\"\"\"\n+        settings = Mock(spec=Settings)\n+        crawler = Mock(spec=Crawler)\n+        \n+        # Setup mocks\n+        mock_load_object.return_value = MockMiddlewareNotConfigured\n+        mock_build_from_crawler.side_effect = NotConfigured(\"Test not configured\")\n+        \n+        with patch.object(MiddlewareManager, '_get_mwlist_from_settings', \n+                         return_value=['test.middleware.MockMiddlewareNotConfigured']):\n+            manager = MiddlewareManager.from_settings(settings, crawler)\n+        \n+        # Should create empty manager when middleware is not configured\n+        assert len(manager._middlewares) == 0\n+    \n+    def test_from_settings_no_build_from_settings_usage(self):\n+        \"\"\"Test that from_settings method doesn't use build_from_settings function.\"\"\"\n+        import inspect\n+        \n+        # Get the source code of the from_settings method\n+        source = inspect.getsource(MiddlewareManager.from_settings)\n+        \n+        # This test should fail before the fix - build_from_settings should not be used\n+        assert 'build_from_settings' not in source, \\\n+            \"from_settings method should not use build_from_settings function\"\n+\n+\n+class TestMiddlewareManagerFromCrawler:\n+    \"\"\"Test MiddlewareManager.from_crawler method behavior.\"\"\"\n+    \n+    def test_from_crawler_calls_from_settings_with_crawler(self):\n+        \"\"\"Test that from_crawler properly calls from_settings with crawler.\"\"\"\n+        crawler = Mock(spec=Crawler)\n+        crawler.settings = Mock(spec=Settings)\n+        \n+        with patch.object(MiddlewareManager, 'from_settings') as mock_from_settings:\n+            mock_from_settings.return_value = MiddlewareManager()\n+            \n+            MiddlewareManager.from_crawler(crawler)\n+            \n+            # Should call from_settings with both settings and crawler\n+            mock_from_settings.assert_called_once_with(crawler.settings, crawler)\n+\n+\n+class TestMiddlewareManagerIntegration:\n+    \"\"\"Integration tests for MiddlewareManager.\"\"\"\n+    \n+    def test_middleware_manager_creation_with_real_middleware(self):\n+        \"\"\"Test creating MiddlewareManager with real middleware classes.\"\"\"\n+        from scrapy.downloadermiddlewares.useragent import UserAgentMiddleware\n+        \n+        settings = Settings({\n+            'DOWNLOADER_MIDDLEWARES': {\n+                'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': 500,\n+            },\n+            'USER_AGENT': 'Test Agent'\n+        })\n+        crawler = Mock(spec=Crawler)\n+        crawler.settings = settings\n+        \n+        # This should work without issues\n+        manager = MiddlewareManager.from_settings(settings, crawler)\n+        assert isinstance(manager, MiddlewareManager)\n+    \n+    def test_middleware_manager_backward_compatibility(self):\n+        \"\"\"Test that existing code using from_crawler still works.\"\"\"\n+        settings = Settings({\n+            'DOWNLOADER_MIDDLEWARES': {},\n+        })\n+        crawler = Mock(spec=Crawler)\n+        crawler.settings = settings\n+        \n+        # from_crawler should still work as before\n+        manager = MiddlewareManager.from_crawler(crawler)\n+        assert isinstance(manager, MiddlewareManager)\n"
}