{
  "instance_id": "django__django-13109",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_fields/test_foreignkey_validation.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.forms import ModelForm\nfrom django.test import TestCase\n\n\nclass ArticleManager(models.Manager):\n    \"\"\"Custom manager that filters out archived articles.\"\"\"\n    def get_queryset(self):\n        qs = super().get_queryset()\n        return qs.filter(archived=False)\n\n\nclass Article(models.Model):\n    \"\"\"Test model with custom manager that filters archived articles.\"\"\"\n    title = models.CharField(max_length=100)\n    archived = models.BooleanField(default=False)\n    \n    # Don't include archived articles by default\n    objects = ArticleManager()\n    \n    class Meta:\n        app_label = 'model_fields'\n\n\nclass FavoriteArticle(models.Model):\n    \"\"\"Model with ForeignKey to Article.\"\"\"\n    article = models.ForeignKey(Article, on_delete=models.CASCADE)\n    \n    class Meta:\n        app_label = 'model_fields'\n\n\nclass FavoriteArticleForm(ModelForm):\n    \"\"\"Form that allows selecting archived articles using base manager.\"\"\"\n    class Meta:\n        model = FavoriteArticle\n        fields = '__all__'\n    \n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Use the base manager instead of the default manager to allow archived articles\n        self.fields['article'].queryset = Article._base_manager.all()\n\n\nclass TestForeignKeyValidationWithCustomManager(TestCase):\n    \"\"\"Test suite for ForeignKey validation with custom managers.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        # Create a regular article (not archived)\n        self.regular_article = Article.objects.create(\n            title=\"Regular Article\",\n            archived=False\n        )\n        \n        # Create an archived article using base manager\n        self.archived_article = Article._base_manager.create(\n            title=\"Archived Article\", \n            archived=True\n        )\n    \n    def test_regular_article_accessible_via_default_manager(self):\n        \"\"\"Test that regular articles are accessible via default manager.\"\"\"\n        # Regular article should be found by default manager\n        assert Article.objects.filter(id=self.regular_article.id).exists()\n        \n    def test_archived_article_not_accessible_via_default_manager(self):\n        \"\"\"Test that archived articles are not accessible via default manager.\"\"\"\n        # Archived article should NOT be found by default manager\n        assert not Article.objects.filter(id=self.archived_article.id).exists()\n        \n    def test_archived_article_accessible_via_base_manager(self):\n        \"\"\"Test that archived articles are accessible via base manager.\"\"\"\n        # Archived article should be found by base manager\n        assert Article._base_manager.filter(id=self.archived_article.id).exists()\n    \n    def test_foreignkey_validation_fails_with_archived_article_before_fix(self):\n        \"\"\"Test that ForeignKey validation fails for archived articles (demonstrates the bug).\"\"\"\n        # Create a FavoriteArticle instance with archived article\n        favorite = FavoriteArticle(article=self.archived_article)\n        \n        # This should raise ValidationError because ForeignKey.validate() \n        # uses _default_manager which filters out archived articles\n        with pytest.raises(ValidationError) as exc_info:\n            favorite.full_clean()\n        \n        # Verify the error message mentions the article doesn't exist\n        error_msg = str(exc_info.value)\n        assert \"does not exist\" in error_msg\n        assert str(self.archived_article.id) in error_msg\n    \n    def test_foreignkey_validation_passes_with_regular_article(self):\n        \"\"\"Test that ForeignKey validation passes for regular articles.\"\"\"\n        # Create a FavoriteArticle instance with regular article\n        favorite = FavoriteArticle(article=self.regular_article)\n        \n        # This should not raise any ValidationError\n        try:\n            favorite.full_clean()\n        except ValidationError:\n            pytest.fail(\"Validation should pass for regular articles\")\n    \n    def test_form_queryset_includes_archived_articles(self):\n        \"\"\"Test that the form queryset includes archived articles.\"\"\"\n        form = FavoriteArticleForm()\n        \n        # Form queryset should include both regular and archived articles\n        queryset_ids = list(form.fields['article'].queryset.values_list('id', flat=True))\n        assert self.regular_article.id in queryset_ids\n        assert self.archived_article.id in queryset_ids\n    \n    def test_form_validation_fails_with_archived_article_before_fix(self):\n        \"\"\"Test that form validation fails when selecting archived article (demonstrates the bug).\"\"\"\n        # Try to create form with archived article selected\n        form_data = {'article': self.archived_article.id}\n        form = FavoriteArticleForm(data=form_data)\n        \n        # Form should be invalid because ForeignKey validation uses _default_manager\n        assert not form.is_valid()\n        \n        # Should have validation error on article field\n        assert 'article' in form.errors\n        error_msg = str(form.errors['article'])\n        assert \"does not exist\" in error_msg\n    \n    def test_form_validation_passes_with_regular_article(self):\n        \"\"\"Test that form validation passes when selecting regular article.\"\"\"\n        # Try to create form with regular article selected\n        form_data = {'article': self.regular_article.id}\n        form = FavoriteArticleForm(data=form_data)\n        \n        # Form should be valid\n        assert form.is_valid(), f\"Form errors: {form.errors}\"\n    \n    def test_foreignkey_validation_with_none_value(self):\n        \"\"\"Test that ForeignKey validation handles None values correctly.\"\"\"\n        # Create a FavoriteArticle instance with None article (if field allows null)\n        favorite = FavoriteArticle(article=None)\n        \n        # This should raise ValidationError for required field\n        with pytest.raises(ValidationError):\n            favorite.full_clean()\n    \n    def test_foreignkey_validation_with_nonexistent_id(self):\n        \"\"\"Test that ForeignKey validation fails for non-existent IDs.\"\"\"\n        # Use an ID that doesn't exist in either manager\n        nonexistent_id = 99999\n        \n        # Verify the ID doesn't exist in either manager\n        assert not Article.objects.filter(id=nonexistent_id).exists()\n        assert not Article._base_manager.filter(id=nonexistent_id).exists()\n        \n        # Create FavoriteArticle with non-existent article ID\n        favorite = FavoriteArticle(article_id=nonexistent_id)\n        \n        # This should raise ValidationError\n        with pytest.raises(ValidationError) as exc_info:\n            favorite.full_clean()\n        \n        error_msg = str(exc_info.value)\n        assert \"does not exist\" in error_msg\n        assert str(nonexistent_id) in error_msg\n\n\nclass TestForeignKeyValidationAfterFix(TestCase):\n    \"\"\"Test suite to verify the fix works correctly.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        # Create a regular article (not archived)\n        self.regular_article = Article.objects.create(\n            title=\"Regular Article\",\n            archived=False\n        )\n        \n        # Create an archived article using base manager\n        self.archived_article = Article._base_manager.create(\n            title=\"Archived Article\", \n            archived=True\n        )\n    \n    def test_foreignkey_validation_passes_with_archived_article_after_fix(self):\n        \"\"\"Test that ForeignKey validation passes for archived articles after fix.\"\"\"\n        # This test will pass after the fix is applied\n        # Create a FavoriteArticle instance with archived article\n        favorite = FavoriteArticle(article=self.archived_article)\n        \n        # After fix, this should not raise ValidationError because \n        # ForeignKey.validate() will use _base_manager\n        try:\n            favorite.full_clean()\n        except ValidationError as e:\n            # If this fails, it means the fix hasn't been applied yet\n            pytest.fail(f\"Validation should pass for archived articles after fix. Error: {e}\")\n    \n    def test_form_validation_passes_with_archived_article_after_fix(self):\n        \"\"\"Test that form validation passes when selecting archived article after fix.\"\"\"\n        # Try to create form with archived article selected\n        form_data = {'article': self.archived_article.id}\n        form = FavoriteArticleForm(data=form_data)\n        \n        # After fix, form should be valid\n        assert form.is_valid(), f\"Form should be valid after fix. Errors: {form.errors}\"\n    \n    def test_fix_preserves_existing_functionality(self):\n        \"\"\"Test that the fix preserves all existing functionality.\"\"\"\n        # Regular articles should still validate correctly\n        favorite_regular = FavoriteArticle(article=self.regular_article)\n        try:\n            favorite_regular.full_clean()\n        except ValidationError:\n            pytest.fail(\"Fix should preserve validation for regular articles\")\n        \n        # Non-existent articles should still fail validation\n        nonexistent_id = 99999\n        favorite_nonexistent = FavoriteArticle(article_id=nonexistent_id)\n        with pytest.raises(ValidationError):\n            favorite_nonexistent.full_clean()\n        \n        # None values should still be handled correctly\n        favorite_none = FavoriteArticle(article=None)\n        with pytest.raises(ValidationError):\n            favorite_none.full_clean()\n\n\nclass TestEdgeCases(TestCase):\n    \"\"\"Test edge cases for ForeignKey validation.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        self.regular_article = Article.objects.create(\n            title=\"Regular Article\",\n            archived=False\n        )\n        \n        self.archived_article = Article._base_manager.create(\n            title=\"Archived Article\", \n            archived=True\n        )\n    \n    def test_validation_with_custom_to_field(self):\n        \"\"\"Test validation works with custom to_field parameter.\"\"\"\n        # This tests that the fix works even when ForeignKey uses a custom to_field\n        # For this test, we'll use the existing setup since Article uses default pk\n        \n        favorite = FavoriteArticle(article=self.archived_article)\n        \n        # The validation should use the correct field name for lookup\n        # This will pass after the fix is applied\n        try:\n            favorite.full_clean()\n        except ValidationError as e:\n            # Expected to fail before fix\n            assert \"does not exist\" in str(e)\n    \n    def test_validation_preserves_limit_choices_to(self):\n        \"\"\"Test that validation still respects limit_choices_to after fix.\"\"\"\n        # This test ensures that the fix doesn't break limit_choices_to functionality\n        # Since our test models don't use limit_choices_to, this is a basic test\n        \n        favorite = FavoriteArticle(article=self.regular_article)\n        try:\n            favorite.full_clean()\n        except ValidationError:\n            pytest.fail(\"Validation should work with limit_choices_to\")\n    \n    def test_validation_with_database_routing(self):\n        \"\"\"Test that validation respects database routing after fix.\"\"\"\n        # This test ensures the fix preserves database routing functionality\n        # The using() call should still work correctly\n        \n        favorite = FavoriteArticle(article=self.regular_article)\n        try:\n            favorite.full_clean()\n        except ValidationError:\n            pytest.fail(\"Validation should work with database routing\")\n</patched>\n```",
  "patch": "--- a/tests/model_fields/test_foreignkey_validation.py\n+++ b/tests/model_fields/test_foreignkey_validation.py\n-# Empty if creating new file\n+import pytest\n+from django.core.exceptions import ValidationError\n+from django.db import models\n+from django.forms import ModelForm\n+from django.test import TestCase\n+\n+\n+class ArticleManager(models.Manager):\n+    \"\"\"Custom manager that filters out archived articles.\"\"\"\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        return qs.filter(archived=False)\n+\n+\n+class Article(models.Model):\n+    \"\"\"Test model with custom manager that filters archived articles.\"\"\"\n+    title = models.CharField(max_length=100)\n+    archived = models.BooleanField(default=False)\n+    \n+    # Don't include archived articles by default\n+    objects = ArticleManager()\n+    \n+    class Meta:\n+        app_label = 'model_fields'\n+\n+\n+class FavoriteArticle(models.Model):\n+    \"\"\"Model with ForeignKey to Article.\"\"\"\n+    article = models.ForeignKey(Article, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'model_fields'\n+\n+\n+class FavoriteArticleForm(ModelForm):\n+    \"\"\"Form that allows selecting archived articles using base manager.\"\"\"\n+    class Meta:\n+        model = FavoriteArticle\n+        fields = '__all__'\n+    \n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        # Use the base manager instead of the default manager to allow archived articles\n+        self.fields['article'].queryset = Article._base_manager.all()\n+\n+\n+class TestForeignKeyValidationWithCustomManager(TestCase):\n+    \"\"\"Test suite for ForeignKey validation with custom managers.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        # Create a regular article (not archived)\n+        self.regular_article = Article.objects.create(\n+            title=\"Regular Article\",\n+            archived=False\n+        )\n+        \n+        # Create an archived article using base manager\n+        self.archived_article = Article._base_manager.create(\n+            title=\"Archived Article\", \n+            archived=True\n+        )\n+    \n+    def test_regular_article_accessible_via_default_manager(self):\n+        \"\"\"Test that regular articles are accessible via default manager.\"\"\"\n+        # Regular article should be found by default manager\n+        assert Article.objects.filter(id=self.regular_article.id).exists()\n+        \n+    def test_archived_article_not_accessible_via_default_manager(self):\n+        \"\"\"Test that archived articles are not accessible via default manager.\"\"\"\n+        # Archived article should NOT be found by default manager\n+        assert not Article.objects.filter(id=self.archived_article.id).exists()\n+        \n+    def test_archived_article_accessible_via_base_manager(self):\n+        \"\"\"Test that archived articles are accessible via base manager.\"\"\"\n+        # Archived article should be found by base manager\n+        assert Article._base_manager.filter(id=self.archived_article.id).exists()\n+    \n+    def test_foreignkey_validation_fails_with_archived_article_before_fix(self):\n+        \"\"\"Test that ForeignKey validation fails for archived articles (demonstrates the bug).\"\"\"\n+        # Create a FavoriteArticle instance with archived article\n+        favorite = FavoriteArticle(article=self.archived_article)\n+        \n+        # This should raise ValidationError because ForeignKey.validate() \n+        # uses _default_manager which filters out archived articles\n+        with pytest.raises(ValidationError) as exc_info:\n+            favorite.full_clean()\n+        \n+        # Verify the error message mentions the article doesn't exist\n+        error_msg = str(exc_info.value)\n+        assert \"does not exist\" in error_msg\n+        assert str(self.archived_article.id) in error_msg\n+    \n+    def test_foreignkey_validation_passes_with_regular_article(self):\n+        \"\"\"Test that ForeignKey validation passes for regular articles.\"\"\"\n+        # Create a FavoriteArticle instance with regular article\n+        favorite = FavoriteArticle(article=self.regular_article)\n+        \n+        # This should not raise any ValidationError\n+        try:\n+            favorite.full_clean()\n+        except ValidationError:\n+            pytest.fail(\"Validation should pass for regular articles\")\n+    \n+    def test_form_queryset_includes_archived_articles(self):\n+        \"\"\"Test that the form queryset includes archived articles.\"\"\"\n+        form = FavoriteArticleForm()\n+        \n+        # Form queryset should include both regular and archived articles\n+        queryset_ids = list(form.fields['article'].queryset.values_list('id', flat=True))\n+        assert self.regular_article.id in queryset_ids\n+        assert self.archived_article.id in queryset_ids\n+    \n+    def test_form_validation_fails_with_archived_article_before_fix(self):\n+        \"\"\"Test that form validation fails when selecting archived article (demonstrates the bug).\"\"\"\n+        # Try to create form with archived article selected\n+        form_data = {'article': self.archived_article.id}\n+        form = FavoriteArticleForm(data=form_data)\n+        \n+        # Form should be invalid because ForeignKey validation uses _default_manager\n+        assert not form.is_valid()\n+        \n+        # Should have validation error on article field\n+        assert 'article' in form.errors\n+        error_msg = str(form.errors['article'])\n+        assert \"does not exist\" in error_msg\n+    \n+    def test_form_validation_passes_with_regular_article(self):\n+        \"\"\"Test that form validation passes when selecting regular article.\"\"\"\n+        # Try to create form with regular article selected\n+        form_data = {'article': self.regular_article.id}\n+        form = FavoriteArticleForm(data=form_data)\n+        \n+        # Form should be valid\n+        assert form.is_valid(), f\"Form errors: {form.errors}\"\n+    \n+    def test_foreignkey_validation_with_none_value(self):\n+        \"\"\"Test that ForeignKey validation handles None values correctly.\"\"\"\n+        # Create a FavoriteArticle instance with None article (if field allows null)\n+        favorite = FavoriteArticle(article=None)\n+        \n+        # This should raise ValidationError for required field\n+        with pytest.raises(ValidationError):\n+            favorite.full_clean()\n+    \n+    def test_foreignkey_validation_with_nonexistent_id(self):\n+        \"\"\"Test that ForeignKey validation fails for non-existent IDs.\"\"\"\n+        # Use an ID that doesn't exist in either manager\n+        nonexistent_id = 99999\n+        \n+        # Verify the ID doesn't exist in either manager\n+        assert not Article.objects.filter(id=nonexistent_id).exists()\n+        assert not Article._base_manager.filter(id=nonexistent_id).exists()\n+        \n+        # Create FavoriteArticle with non-existent article ID\n+        favorite = FavoriteArticle(article_id=nonexistent_id)\n+        \n+        # This should raise ValidationError\n+        with pytest.raises(ValidationError) as exc_info:\n+            favorite.full_clean()\n+        \n+        error_msg = str(exc_info.value)\n+        assert \"does not exist\" in error_msg\n+        assert str(nonexistent_id) in error_msg\n+\n+\n+class TestForeignKeyValidationAfterFix(TestCase):\n+    \"\"\"Test suite to verify the fix works correctly.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        # Create a regular article (not archived)\n+        self.regular_article = Article.objects.create(\n+            title=\"Regular Article\",\n+            archived=False\n+        )\n+        \n+        # Create an archived article using base manager\n+        self.archived_article = Article._base_manager.create(\n+            title=\"Archived Article\", \n+            archived=True\n+        )\n+    \n+    def test_foreignkey_validation_passes_with_archived_article_after_fix(self):\n+        \"\"\"Test that ForeignKey validation passes for archived articles after fix.\"\"\"\n+        # This test will pass after the fix is applied\n+        # Create a FavoriteArticle instance with archived article\n+        favorite = FavoriteArticle(article=self.archived_article)\n+        \n+        # After fix, this should not raise ValidationError because \n+        # ForeignKey.validate() will use _base_manager\n+        try:\n+            favorite.full_clean()\n+        except ValidationError as e:\n+            # If this fails, it means the fix hasn't been applied yet\n+            pytest.fail(f\"Validation should pass for archived articles after fix. Error: {e}\")\n+    \n+    def test_form_validation_passes_with_archived_article_after_fix(self):\n+        \"\"\"Test that form validation passes when selecting archived article after fix.\"\"\"\n+        # Try to create form with archived article selected\n+        form_data = {'article': self.archived_article.id}\n+        form = FavoriteArticleForm(data=form_data)\n+        \n+        # After fix, form should be valid\n+        assert form.is_valid(), f\"Form should be valid after fix. Errors: {form.errors}\"\n+    \n+    def test_fix_preserves_existing_functionality(self):\n+        \"\"\"Test that the fix preserves all existing functionality.\"\"\"\n+        # Regular articles should still validate correctly\n+        favorite_regular = FavoriteArticle(article=self.regular_article)\n+        try:\n+            favorite_regular.full_clean()\n+        except ValidationError:\n+            pytest.fail(\"Fix should preserve validation for regular articles\")\n+        \n+        # Non-existent articles should still fail validation\n+        nonexistent_id = 99999\n+        favorite_nonexistent = FavoriteArticle(article_id=nonexistent_id)\n+        with pytest.raises(ValidationError):\n+            favorite_nonexistent.full_clean()\n+        \n+        # None values should still be handled correctly\n+        favorite_none = FavoriteArticle(article=None)\n+        with pytest.raises(ValidationError):\n+            favorite_none.full_clean()\n+\n+\n+class TestEdgeCases(TestCase):\n+    \"\"\"Test edge cases for ForeignKey validation.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        self.regular_article = Article.objects.create(\n+            title=\"Regular Article\",\n+            archived=False\n+        )\n+        \n+        self.archived_article = Article._base_manager.create(\n+            title=\"Archived Article\", \n+            archived=True\n+        )\n+    \n+    def test_validation_with_custom_to_field(self):\n+        \"\"\"Test validation works with custom to_field parameter.\"\"\"\n+        # This tests that the fix works even when ForeignKey uses a custom to_field\n+        # For this test, we'll use the existing setup since Article uses default pk\n+        \n+        favorite = FavoriteArticle(article=self.archived_article)\n+        \n+        # The validation should use the correct field name for lookup\n+        # This will pass after the fix is applied\n+        try:\n+            favorite.full_clean()\n+        except ValidationError as e:\n+            # Expected to fail before fix\n+            assert \"does not exist\" in str(e)\n+    \n+    def test_validation_preserves_limit_choices_to(self):\n+        \"\"\"Test that validation still respects limit_choices_to after fix.\"\"\"\n+        # This test ensures that the fix doesn't break limit_choices_to functionality\n+        # Since our test models don't use limit_choices_to, this is a basic test\n+        \n+        favorite = FavoriteArticle(article=self.regular_article)\n+        try:\n+            favorite.full_clean()\n+        except ValidationError:\n+            pytest.fail(\"Validation should work with limit_choices_to\")\n+    \n+    def test_validation_with_database_routing(self):\n+        \"\"\"Test that validation respects database routing after fix.\"\"\"\n+        # This test ensures the fix preserves database routing functionality\n+        # The using() call should still work correctly\n+        \n+        favorite = FavoriteArticle(article=self.regular_article)\n+        try:\n+            favorite.full_clean()\n+        except ValidationError:\n+            pytest.fail(\"Validation should work with database routing\")\n"
}