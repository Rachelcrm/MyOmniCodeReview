{
  "instance_id": "django__django-16100",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/admin_views/test_changelist_transaction.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib.admin import ModelAdmin\nfrom django.contrib.admin.sites import AdminSite\nfrom django.contrib.auth.models import User\nfrom django.db import IntegrityError, transaction\nfrom django.http import HttpRequest\nfrom django.test import TestCase, TransactionTestCase\nfrom django.test.client import RequestFactory\nfrom django.urls import reverse\nfrom unittest.mock import Mock, patch\n\nfrom .models import Article\n\n\nclass MockException(Exception):\n    \"\"\"Custom exception for testing transaction rollback.\"\"\"\n    pass\n\n\nclass ArticleAdmin(ModelAdmin):\n    list_display = ['title', 'content', 'author']\n    list_editable = ['content', 'author']\n\n\nclass ChangelistTransactionTestCase(TransactionTestCase):\n    \"\"\"\n    Test transaction handling in changelist_view for list_editable processing.\n    Uses TransactionTestCase to properly test transaction behavior.\n    \"\"\"\n    \n    def setUp(self):\n        self.factory = RequestFactory()\n        self.site = AdminSite()\n        self.admin = ArticleAdmin(Article, self.site)\n        \n        # Create test user\n        self.user = User.objects.create_superuser(\n            username='admin',\n            email='admin@test.com',\n            password='password'\n        )\n        \n        # Create test articles\n        self.article1 = Article.objects.create(\n            title='Article 1',\n            content='Content 1',\n            author='Author 1'\n        )\n        self.article2 = Article.objects.create(\n            title='Article 2', \n            content='Content 2',\n            author='Author 2'\n        )\n\n    def test_changelist_list_editable_without_transaction_fails_partially(self):\n        \"\"\"\n        Test that demonstrates the bug: without transaction wrapping,\n        if an error occurs during list_editable processing, some changes\n        may be saved while others are not, leading to inconsistent state.\n        This test should fail before the fix is applied.\n        \"\"\"\n        # Prepare POST data for list_editable form submission\n        post_data = {\n            '_save': 'Save',\n            'form-TOTAL_FORMS': '2',\n            'form-INITIAL_FORMS': '2',\n            'form-MIN_NUM_FORMS': '0',\n            'form-MAX_NUM_FORMS': '1000',\n            f'form-0-id': str(self.article1.id),\n            f'form-0-content': 'Updated Content 1',\n            f'form-0-author': 'Updated Author 1',\n            f'form-1-id': str(self.article2.id),\n            f'form-1-content': 'Updated Content 2',\n            f'form-1-author': 'Updated Author 2',\n        }\n        \n        request = self.factory.post('/admin/admin_views/article/', post_data)\n        request.user = self.user\n        \n        # Mock save_model to raise exception on second article\n        original_save_model = self.admin.save_model\n        call_count = 0\n        \n        def mock_save_model(request, obj, form, change):\n            nonlocal call_count\n            call_count += 1\n            if call_count == 2:  # Fail on second save\n                raise MockException(\"Simulated save error\")\n            return original_save_model(request, obj, form, change)\n        \n        with patch.object(self.admin, 'save_model', side_effect=mock_save_model):\n            with pytest.raises(MockException):\n                self.admin.changelist_view(request)\n        \n        # Refresh from database\n        self.article1.refresh_from_db()\n        self.article2.refresh_from_db()\n        \n        # Without transaction, first article would be updated but second wouldn't\n        # This demonstrates the bug - partial updates occur\n        # After the fix, both should remain unchanged due to rollback\n        assert self.article1.content == 'Updated Content 1'  # This shows the bug\n        assert self.article2.content == 'Content 2'  # This remains unchanged\n\n    def test_changelist_list_editable_with_transaction_rolls_back_all_changes(self):\n        \"\"\"\n        Test that with proper transaction handling, if an error occurs during\n        list_editable processing, ALL changes are rolled back.\n        This test should pass after the fix is applied.\n        \"\"\"\n        # Store original values\n        original_content1 = self.article1.content\n        original_content2 = self.article2.content\n        original_author1 = self.article1.author\n        original_author2 = self.article2.author\n        \n        # Prepare POST data for list_editable form submission\n        post_data = {\n            '_save': 'Save',\n            'form-TOTAL_FORMS': '2',\n            'form-INITIAL_FORMS': '2',\n            'form-MIN_NUM_FORMS': '0',\n            'form-MAX_NUM_FORMS': '1000',\n            f'form-0-id': str(self.article1.id),\n            f'form-0-content': 'Updated Content 1',\n            f'form-0-author': 'Updated Author 1',\n            f'form-1-id': str(self.article2.id),\n            f'form-1-content': 'Updated Content 2',\n            f'form-1-author': 'Updated Author 2',\n        }\n        \n        request = self.factory.post('/admin/admin_views/article/', post_data)\n        request.user = self.user\n        \n        # Mock save_related to raise exception on second article\n        original_save_related = self.admin.save_related\n        call_count = 0\n        \n        def mock_save_related(request, form, formsets, change):\n            nonlocal call_count\n            call_count += 1\n            if call_count == 2:  # Fail on second save_related\n                raise MockException(\"Simulated save_related error\")\n            return original_save_related(request, form, formsets, change)\n        \n        with patch.object(self.admin, 'save_related', side_effect=mock_save_related):\n            with pytest.raises(MockException):\n                self.admin.changelist_view(request)\n        \n        # Refresh from database\n        self.article1.refresh_from_db()\n        self.article2.refresh_from_db()\n        \n        # With proper transaction handling, both articles should remain unchanged\n        assert self.article1.content == original_content1\n        assert self.article1.author == original_author1\n        assert self.article2.content == original_content2\n        assert self.article2.author == original_author2\n\n    def test_changelist_list_editable_successful_save_commits_all_changes(self):\n        \"\"\"\n        Test that when list_editable processing succeeds, all changes are committed.\n        \"\"\"\n        # Prepare POST data for list_editable form submission\n        post_data = {\n            '_save': 'Save',\n            'form-TOTAL_FORMS': '2',\n            'form-INITIAL_FORMS': '2',\n            'form-MIN_NUM_FORMS': '0',\n            'form-MAX_NUM_FORMS': '1000',\n            f'form-0-id': str(self.article1.id),\n            f'form-0-content': 'Successfully Updated Content 1',\n            f'form-0-author': 'Successfully Updated Author 1',\n            f'form-1-id': str(self.article2.id),\n            f'form-1-content': 'Successfully Updated Content 2',\n            f'form-1-author': 'Successfully Updated Author 2',\n        }\n        \n        request = self.factory.post('/admin/admin_views/article/', post_data)\n        request.user = self.user\n        \n        # This should succeed without exceptions\n        response = self.admin.changelist_view(request)\n        \n        # Refresh from database\n        self.article1.refresh_from_db()\n        self.article2.refresh_from_db()\n        \n        # All changes should be committed\n        assert self.article1.content == 'Successfully Updated Content 1'\n        assert self.article1.author == 'Successfully Updated Author 1'\n        assert self.article2.content == 'Successfully Updated Content 2'\n        assert self.article2.author == 'Successfully Updated Author 2'\n\n    def test_changelist_list_editable_form_validation_error_no_database_changes(self):\n        \"\"\"\n        Test that when form validation fails, no database changes occur.\n        \"\"\"\n        # Store original values\n        original_content1 = self.article1.content\n        original_content2 = self.article2.content\n        \n        # Prepare POST data with invalid form data (missing required field)\n        post_data = {\n            '_save': 'Save',\n            'form-TOTAL_FORMS': '2',\n            'form-INITIAL_FORMS': '2',\n            'form-MIN_NUM_FORMS': '0',\n            'form-MAX_NUM_FORMS': '1000',\n            f'form-0-id': str(self.article1.id),\n            f'form-0-content': '',  # Empty content should cause validation error\n            f'form-0-author': 'Updated Author 1',\n            f'form-1-id': str(self.article2.id),\n            f'form-1-content': 'Updated Content 2',\n            f'form-1-author': 'Updated Author 2',\n        }\n        \n        request = self.factory.post('/admin/admin_views/article/', post_data)\n        request.user = self.user\n        \n        # This should handle validation errors gracefully\n        response = self.admin.changelist_view(request)\n        \n        # Refresh from database\n        self.article1.refresh_from_db()\n        self.article2.refresh_from_db()\n        \n        # No changes should be made due to validation failure\n        assert self.article1.content == original_content1\n        assert self.article2.content == original_content2\n\n    def test_changelist_list_editable_log_change_error_rolls_back(self):\n        \"\"\"\n        Test that if log_change fails, all database changes are rolled back.\n        \"\"\"\n        # Store original values\n        original_content1 = self.article1.content\n        original_author1 = self.article1.author\n        \n        # Prepare POST data for single article update\n        post_data = {\n            '_save': 'Save',\n            'form-TOTAL_FORMS': '1',\n            'form-INITIAL_FORMS': '1',\n            'form-MIN_NUM_FORMS': '0',\n            'form-MAX_NUM_FORMS': '1000',\n            f'form-0-id': str(self.article1.id),\n            f'form-0-content': 'Updated Content 1',\n            f'form-0-author': 'Updated Author 1',\n        }\n        \n        request = self.factory.post('/admin/admin_views/article/', post_data)\n        request.user = self.user\n        \n        # Mock log_change to raise exception\n        with patch.object(self.admin, 'log_change', side_effect=MockException(\"Log change failed\")):\n            with pytest.raises(MockException):\n                self.admin.changelist_view(request)\n        \n        # Refresh from database\n        self.article1.refresh_from_db()\n        \n        # Changes should be rolled back due to log_change failure\n        assert self.article1.content == original_content1\n        assert self.article1.author == original_author1\n\n    def test_changelist_non_list_editable_request_not_affected(self):\n        \"\"\"\n        Test that non-list_editable requests (GET, actions, etc.) are not affected\n        by transaction changes.\n        \"\"\"\n        # Test GET request\n        request = self.factory.get('/admin/admin_views/article/')\n        request.user = self.user\n        \n        response = self.admin.changelist_view(request)\n        assert response.status_code == 200\n        \n        # Test POST without _save (action)\n        post_data = {\n            'action': 'delete_selected',\n            '_selected_action': [str(self.article1.id)],\n        }\n        request = self.factory.post('/admin/admin_views/article/', post_data)\n        request.user = self.user\n        \n        # This should work normally without transaction interference\n        response = self.admin.changelist_view(request)\n        # Response could be redirect or template response depending on action\n\n\nclass ChangelistTransactionIntegrationTest(TestCase):\n    \"\"\"\n    Integration tests using Django's test client to test the full request/response cycle.\n    \"\"\"\n    \n    def setUp(self):\n        self.user = User.objects.create_superuser(\n            username='admin',\n            email='admin@test.com', \n            password='password'\n        )\n        self.client.login(username='admin', password='password')\n        \n        self.article1 = Article.objects.create(\n            title='Article 1',\n            content='Content 1',\n            author='Author 1'\n        )\n        self.article2 = Article.objects.create(\n            title='Article 2',\n            content='Content 2', \n            author='Author 2'\n        )\n\n    def test_changelist_list_editable_integration_successful_update(self):\n        \"\"\"\n        Integration test for successful list_editable update through admin interface.\n        \"\"\"\n        url = reverse('admin:admin_views_article_changelist')\n        \n        # First get the changelist to get the formset data\n        response = self.client.get(url)\n        assert response.status_code == 200\n        \n        # Submit list_editable changes\n        post_data = {\n            '_save': 'Save',\n            'form-TOTAL_FORMS': '2',\n            'form-INITIAL_FORMS': '2',\n            'form-MIN_NUM_FORMS': '0',\n            'form-MAX_NUM_FORMS': '1000',\n            f'form-0-id': str(self.article1.id),\n            f'form-0-content': 'Integration Updated Content 1',\n            f'form-0-author': 'Integration Updated Author 1',\n            f'form-1-id': str(self.article2.id),\n            f'form-1-content': 'Integration Updated Content 2',\n            f'form-1-author': 'Integration Updated Author 2',\n        }\n        \n        response = self.client.post(url, post_data)\n        \n        # Should redirect after successful save\n        assert response.status_code == 302\n        \n        # Verify changes were saved\n        self.article1.refresh_from_db()\n        self.article2.refresh_from_db()\n        \n        assert self.article1.content == 'Integration Updated Content 1'\n        assert self.article1.author == 'Integration Updated Author 1'\n        assert self.article2.content == 'Integration Updated Content 2'\n        assert self.article2.author == 'Integration Updated Author 2'\n</patched>\n```\n\n```\n<file>tests/admin_views/models.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nfrom django.db import models\n\n\nclass Article(models.Model):\n    \"\"\"Test model for changelist transaction testing.\"\"\"\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    author = models.CharField(max_length=50)\n    \n    def __str__(self):\n        return self.title\n    \n    class Meta:\n        app_label = 'admin_views'\n</patched>\n```\n\n```\n<file>tests/admin_views/admin.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nfrom django.contrib import admin\nfrom .models import Article\n\n\n@admin.register(Article)\nclass ArticleAdmin(admin.ModelAdmin):\n    list_display = ['title', 'content', 'author']\n    list_editable = ['content', 'author']\n</patched>\n```\n\n```\n<file>tests/admin_views/test_changelist_transaction_edge_cases.py</file>",
  "patch": "--- a/tests/admin_views/test_changelist_transaction.py\n+++ b/tests/admin_views/test_changelist_transaction.py\n-# Empty if creating new file\n+import pytest\n+from django.contrib.admin import ModelAdmin\n+from django.contrib.admin.sites import AdminSite\n+from django.contrib.auth.models import User\n+from django.db import IntegrityError, transaction\n+from django.http import HttpRequest\n+from django.test import TestCase, TransactionTestCase\n+from django.test.client import RequestFactory\n+from django.urls import reverse\n+from unittest.mock import Mock, patch\n+\n+from .models import Article\n+\n+\n+class MockException(Exception):\n+    \"\"\"Custom exception for testing transaction rollback.\"\"\"\n+    pass\n+\n+\n+class ArticleAdmin(ModelAdmin):\n+    list_display = ['title', 'content', 'author']\n+    list_editable = ['content', 'author']\n+\n+\n+class ChangelistTransactionTestCase(TransactionTestCase):\n+    \"\"\"\n+    Test transaction handling in changelist_view for list_editable processing.\n+    Uses TransactionTestCase to properly test transaction behavior.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        self.factory = RequestFactory()\n+        self.site = AdminSite()\n+        self.admin = ArticleAdmin(Article, self.site)\n+        \n+        # Create test user\n+        self.user = User.objects.create_superuser(\n+            username='admin',\n+            email='admin@test.com',\n+            password='password'\n+        )\n+        \n+        # Create test articles\n+        self.article1 = Article.objects.create(\n+            title='Article 1',\n+            content='Content 1',\n+            author='Author 1'\n+        )\n+        self.article2 = Article.objects.create(\n+            title='Article 2', \n+            content='Content 2',\n+            author='Author 2'\n+        )\n+\n+    def test_changelist_list_editable_without_transaction_fails_partially(self):\n+        \"\"\"\n+        Test that demonstrates the bug: without transaction wrapping,\n+        if an error occurs during list_editable processing, some changes\n+        may be saved while others are not, leading to inconsistent state.\n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        # Prepare POST data for list_editable form submission\n+        post_data = {\n+            '_save': 'Save',\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            f'form-0-id': str(self.article1.id),\n+            f'form-0-content': 'Updated Content 1',\n+            f'form-0-author': 'Updated Author 1',\n+            f'form-1-id': str(self.article2.id),\n+            f'form-1-content': 'Updated Content 2',\n+            f'form-1-author': 'Updated Author 2',\n+        }\n+        \n+        request = self.factory.post('/admin/admin_views/article/', post_data)\n+        request.user = self.user\n+        \n+        # Mock save_model to raise exception on second article\n+        original_save_model = self.admin.save_model\n+        call_count = 0\n+        \n+        def mock_save_model(request, obj, form, change):\n+            nonlocal call_count\n+            call_count += 1\n+            if call_count == 2:  # Fail on second save\n+                raise MockException(\"Simulated save error\")\n+            return original_save_model(request, obj, form, change)\n+        \n+        with patch.object(self.admin, 'save_model', side_effect=mock_save_model):\n+            with pytest.raises(MockException):\n+                self.admin.changelist_view(request)\n+        \n+        # Refresh from database\n+        self.article1.refresh_from_db()\n+        self.article2.refresh_from_db()\n+        \n+        # Without transaction, first article would be updated but second wouldn't\n+        # This demonstrates the bug - partial updates occur\n+        # After the fix, both should remain unchanged due to rollback\n+        assert self.article1.content == 'Updated Content 1'  # This shows the bug\n+        assert self.article2.content == 'Content 2'  # This remains unchanged\n+\n+    def test_changelist_list_editable_with_transaction_rolls_back_all_changes(self):\n+        \"\"\"\n+        Test that with proper transaction handling, if an error occurs during\n+        list_editable processing, ALL changes are rolled back.\n+        This test should pass after the fix is applied.\n+        \"\"\"\n+        # Store original values\n+        original_content1 = self.article1.content\n+        original_content2 = self.article2.content\n+        original_author1 = self.article1.author\n+        original_author2 = self.article2.author\n+        \n+        # Prepare POST data for list_editable form submission\n+        post_data = {\n+            '_save': 'Save',\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            f'form-0-id': str(self.article1.id),\n+            f'form-0-content': 'Updated Content 1',\n+            f'form-0-author': 'Updated Author 1',\n+            f'form-1-id': str(self.article2.id),\n+            f'form-1-content': 'Updated Content 2',\n+            f'form-1-author': 'Updated Author 2',\n+        }\n+        \n+        request = self.factory.post('/admin/admin_views/article/', post_data)\n+        request.user = self.user\n+        \n+        # Mock save_related to raise exception on second article\n+        original_save_related = self.admin.save_related\n+        call_count = 0\n+        \n+        def mock_save_related(request, form, formsets, change):\n+            nonlocal call_count\n+            call_count += 1\n+            if call_count == 2:  # Fail on second save_related\n+                raise MockException(\"Simulated save_related error\")\n+            return original_save_related(request, form, formsets, change)\n+        \n+        with patch.object(self.admin, 'save_related', side_effect=mock_save_related):\n+            with pytest.raises(MockException):\n+                self.admin.changelist_view(request)\n+        \n+        # Refresh from database\n+        self.article1.refresh_from_db()\n+        self.article2.refresh_from_db()\n+        \n+        # With proper transaction handling, both articles should remain unchanged\n+        assert self.article1.content == original_content1\n+        assert self.article1.author == original_author1\n+        assert self.article2.content == original_content2\n+        assert self.article2.author == original_author2\n+\n+    def test_changelist_list_editable_successful_save_commits_all_changes(self):\n+        \"\"\"\n+        Test that when list_editable processing succeeds, all changes are committed.\n+        \"\"\"\n+        # Prepare POST data for list_editable form submission\n+        post_data = {\n+            '_save': 'Save',\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            f'form-0-id': str(self.article1.id),\n+            f'form-0-content': 'Successfully Updated Content 1',\n+            f'form-0-author': 'Successfully Updated Author 1',\n+            f'form-1-id': str(self.article2.id),\n+            f'form-1-content': 'Successfully Updated Content 2',\n+            f'form-1-author': 'Successfully Updated Author 2',\n+        }\n+        \n+        request = self.factory.post('/admin/admin_views/article/', post_data)\n+        request.user = self.user\n+        \n+        # This should succeed without exceptions\n+        response = self.admin.changelist_view(request)\n+        \n+        # Refresh from database\n+        self.article1.refresh_from_db()\n+        self.article2.refresh_from_db()\n+        \n+        # All changes should be committed\n+        assert self.article1.content == 'Successfully Updated Content 1'\n+        assert self.article1.author == 'Successfully Updated Author 1'\n+        assert self.article2.content == 'Successfully Updated Content 2'\n+        assert self.article2.author == 'Successfully Updated Author 2'\n+\n+    def test_changelist_list_editable_form_validation_error_no_database_changes(self):\n+        \"\"\"\n+        Test that when form validation fails, no database changes occur.\n+        \"\"\"\n+        # Store original values\n+        original_content1 = self.article1.content\n+        original_content2 = self.article2.content\n+        \n+        # Prepare POST data with invalid form data (missing required field)\n+        post_data = {\n+            '_save': 'Save',\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            f'form-0-id': str(self.article1.id),\n+            f'form-0-content': '',  # Empty content should cause validation error\n+            f'form-0-author': 'Updated Author 1',\n+            f'form-1-id': str(self.article2.id),\n+            f'form-1-content': 'Updated Content 2',\n+            f'form-1-author': 'Updated Author 2',\n+        }\n+        \n+        request = self.factory.post('/admin/admin_views/article/', post_data)\n+        request.user = self.user\n+        \n+        # This should handle validation errors gracefully\n+        response = self.admin.changelist_view(request)\n+        \n+        # Refresh from database\n+        self.article1.refresh_from_db()\n+        self.article2.refresh_from_db()\n+        \n+        # No changes should be made due to validation failure\n+        assert self.article1.content == original_content1\n+        assert self.article2.content == original_content2\n+\n+    def test_changelist_list_editable_log_change_error_rolls_back(self):\n+        \"\"\"\n+        Test that if log_change fails, all database changes are rolled back.\n+        \"\"\"\n+        # Store original values\n+        original_content1 = self.article1.content\n+        original_author1 = self.article1.author\n+        \n+        # Prepare POST data for single article update\n+        post_data = {\n+            '_save': 'Save',\n+            'form-TOTAL_FORMS': '1',\n+            'form-INITIAL_FORMS': '1',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            f'form-0-id': str(self.article1.id),\n+            f'form-0-content': 'Updated Content 1',\n+            f'form-0-author': 'Updated Author 1',\n+        }\n+        \n+        request = self.factory.post('/admin/admin_views/article/', post_data)\n+        request.user = self.user\n+        \n+        # Mock log_change to raise exception\n+        with patch.object(self.admin, 'log_change', side_effect=MockException(\"Log change failed\")):\n+            with pytest.raises(MockException):\n+                self.admin.changelist_view(request)\n+        \n+        # Refresh from database\n+        self.article1.refresh_from_db()\n+        \n+        # Changes should be rolled back due to log_change failure\n+        assert self.article1.content == original_content1\n+        assert self.article1.author == original_author1\n+\n+    def test_changelist_non_list_editable_request_not_affected(self):\n+        \"\"\"\n+        Test that non-list_editable requests (GET, actions, etc.) are not affected\n+        by transaction changes.\n+        \"\"\"\n+        # Test GET request\n+        request = self.factory.get('/admin/admin_views/article/')\n+        request.user = self.user\n+        \n+        response = self.admin.changelist_view(request)\n+        assert response.status_code == 200\n+        \n+        # Test POST without _save (action)\n+        post_data = {\n+            'action': 'delete_selected',\n+            '_selected_action': [str(self.article1.id)],\n+        }\n+        request = self.factory.post('/admin/admin_views/article/', post_data)\n+        request.user = self.user\n+        \n+        # This should work normally without transaction interference\n+        response = self.admin.changelist_view(request)\n+        # Response could be redirect or template response depending on action\n+\n+\n+class ChangelistTransactionIntegrationTest(TestCase):\n+    \"\"\"\n+    Integration tests using Django's test client to test the full request/response cycle.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        self.user = User.objects.create_superuser(\n+            username='admin',\n+            email='admin@test.com', \n+            password='password'\n+        )\n+        self.client.login(username='admin', password='password')\n+        \n+        self.article1 = Article.objects.create(\n+            title='Article 1',\n+            content='Content 1',\n+            author='Author 1'\n+        )\n+        self.article2 = Article.objects.create(\n+            title='Article 2',\n+            content='Content 2', \n+            author='Author 2'\n+        )\n+\n+    def test_changelist_list_editable_integration_successful_update(self):\n+        \"\"\"\n+        Integration test for successful list_editable update through admin interface.\n+        \"\"\"\n+        url = reverse('admin:admin_views_article_changelist')\n+        \n+        # First get the changelist to get the formset data\n+        response = self.client.get(url)\n+        assert response.status_code == 200\n+        \n+        # Submit list_editable changes\n+        post_data = {\n+            '_save': 'Save',\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            f'form-0-id': str(self.article1.id),\n+            f'form-0-content': 'Integration Updated Content 1',\n+            f'form-0-author': 'Integration Updated Author 1',\n+            f'form-1-id': str(self.article2.id),\n+            f'form-1-content': 'Integration Updated Content 2',\n+            f'form-1-author': 'Integration Updated Author 2',\n+        }\n+        \n+        response = self.client.post(url, post_data)\n+        \n+        # Should redirect after successful save\n+        assert response.status_code == 302\n+        \n+        # Verify changes were saved\n+        self.article1.refresh_from_db()\n+        self.article2.refresh_from_db()\n+        \n+        assert self.article1.content == 'Integration Updated Content 1'\n+        assert self.article1.author == 'Integration Updated Author 1'\n+        assert self.article2.content == 'Integration Updated Content 2'\n+        assert self.article2.author == 'Integration Updated Author 2'\n\n--- a/tests/admin_views/models.py\n+++ b/tests/admin_views/models.py\n-# Empty if creating new file\n+from django.db import models\n+\n+\n+class Article(models.Model):\n+    \"\"\"Test model for changelist transaction testing.\"\"\"\n+    title = models.CharField(max_length=100)\n+    content = models.TextField()\n+    author = models.CharField(max_length=50)\n+    \n+    def __str__(self):\n+        return self.title\n+    \n+    class Meta:\n+        app_label = 'admin_views'\n\n--- a/tests/admin_views/admin.py\n+++ b/tests/admin_views/admin.py\n-# Empty if creating new file\n+from django.contrib import admin\n+from .models import Article\n+\n+\n+@admin.register(Article)\n+class ArticleAdmin(admin.ModelAdmin):\n+    list_display = ['title', 'content', 'author']\n+    list_editable = ['content', 'author']\n"
}