{
  "instance_id": "django__django-11603",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/aggregation/test_distinct_aggregates.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.core.exceptions import FieldError\nfrom django.db import models\nfrom django.db.models import Avg, Count, Max, Min, Sum\nfrom django.test import TestCase, override_settings\nfrom django.test.utils import isolate_apps\n\n\n@isolate_apps('aggregation')\nclass DistinctAggregateTests(TestCase):\n    \"\"\"Test DISTINCT support for aggregate functions.\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        \n        # Create test model\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            value = models.IntegerField()\n            score = models.DecimalField(max_digits=10, decimal_places=2)\n            \n            class Meta:\n                app_label = 'aggregation'\n        \n        cls.TestModel = TestModel\n        \n        # Create the table\n        with cls._get_connection().schema_editor() as schema_editor:\n            schema_editor.create_model(cls.TestModel)\n    \n    @classmethod\n    def tearDownClass(cls):\n        # Drop the table\n        with cls._get_connection().schema_editor() as schema_editor:\n            schema_editor.delete_model(cls.TestModel)\n        super().tearDownClass()\n    \n    @classmethod\n    def _get_connection(cls):\n        from django.db import connection\n        return connection\n    \n    def setUp(self):\n        # Create test data with duplicates to test DISTINCT functionality\n        self.TestModel.objects.create(name='A', value=10, score=10.5)\n        self.TestModel.objects.create(name='B', value=20, score=20.5)\n        self.TestModel.objects.create(name='A', value=10, score=10.5)  # Duplicate\n        self.TestModel.objects.create(name='C', value=30, score=30.5)\n        self.TestModel.objects.create(name='B', value=20, score=20.5)  # Duplicate\n    \n    def tearDown(self):\n        self.TestModel.objects.all().delete()\n    \n    def test_avg_allows_distinct_parameter(self):\n        \"\"\"Test that Avg aggregate accepts distinct=True parameter without raising TypeError.\"\"\"\n        # This should not raise an exception\n        try:\n            avg_agg = Avg('value', distinct=True)\n            self.assertTrue(avg_agg.allow_distinct)\n            self.assertTrue(avg_agg.distinct)\n        except TypeError as e:\n            self.fail(f\"Avg should allow distinct parameter, but raised: {e}\")\n    \n    def test_sum_allows_distinct_parameter(self):\n        \"\"\"Test that Sum aggregate accepts distinct=True parameter without raising TypeError.\"\"\"\n        # This should not raise an exception\n        try:\n            sum_agg = Sum('value', distinct=True)\n            self.assertTrue(sum_agg.allow_distinct)\n            self.assertTrue(sum_agg.distinct)\n        except TypeError as e:\n            self.fail(f\"Sum should allow distinct parameter, but raised: {e}\")\n    \n    def test_min_allows_distinct_parameter(self):\n        \"\"\"Test that Min aggregate accepts distinct=True parameter without raising TypeError.\"\"\"\n        # This should not raise an exception\n        try:\n            min_agg = Min('value', distinct=True)\n            self.assertTrue(min_agg.allow_distinct)\n            self.assertTrue(min_agg.distinct)\n        except TypeError as e:\n            self.fail(f\"Min should allow distinct parameter, but raised: {e}\")\n    \n    def test_max_allows_distinct_parameter(self):\n        \"\"\"Test that Max aggregate accepts distinct=True parameter without raising TypeError.\"\"\"\n        # This should not raise an exception\n        try:\n            max_agg = Max('value', distinct=True)\n            self.assertTrue(max_agg.allow_distinct)\n            self.assertTrue(max_agg.distinct)\n        except TypeError as e:\n            self.fail(f\"Max should allow distinct parameter, but raised: {e}\")\n    \n    def test_avg_distinct_false_before_fix(self):\n        \"\"\"Test that demonstrates the bug - Avg should raise TypeError with distinct=True before fix.\"\"\"\n        # This test should fail before the fix is applied\n        with self.assertRaises(TypeError) as cm:\n            Avg('value', distinct=True)\n        self.assertIn(\"does not allow distinct\", str(cm.exception))\n    \n    def test_sum_distinct_false_before_fix(self):\n        \"\"\"Test that demonstrates the bug - Sum should raise TypeError with distinct=True before fix.\"\"\"\n        # This test should fail before the fix is applied\n        with self.assertRaises(TypeError) as cm:\n            Sum('value', distinct=True)\n        self.assertIn(\"does not allow distinct\", str(cm.exception))\n    \n    def test_min_distinct_false_before_fix(self):\n        \"\"\"Test that demonstrates the bug - Min should raise TypeError with distinct=True before fix.\"\"\"\n        # This test should fail before the fix is applied\n        with self.assertRaises(TypeError) as cm:\n            Min('value', distinct=True)\n        self.assertIn(\"does not allow distinct\", str(cm.exception))\n    \n    def test_max_distinct_false_before_fix(self):\n        \"\"\"Test that demonstrates the bug - Max should raise TypeError with distinct=True before fix.\"\"\"\n        # This test should fail before the fix is applied\n        with self.assertRaises(TypeError) as cm:\n            Max('value', distinct=True)\n        self.assertIn(\"does not allow distinct\", str(cm.exception))\n    \n    def test_avg_distinct_sql_generation(self):\n        \"\"\"Test that Avg with distinct=True generates correct SQL.\"\"\"\n        avg_agg = Avg('value', distinct=True)\n        # Test SQL generation\n        from django.db import connection\n        compiler = self.TestModel.objects.all().query.get_compiler(connection.alias)\n        sql, params = avg_agg.as_sql(compiler, connection)\n        self.assertIn('AVG(DISTINCT', sql)\n    \n    def test_sum_distinct_sql_generation(self):\n        \"\"\"Test that Sum with distinct=True generates correct SQL.\"\"\"\n        sum_agg = Sum('value', distinct=True)\n        # Test SQL generation\n        from django.db import connection\n        compiler = self.TestModel.objects.all().query.get_compiler(connection.alias)\n        sql, params = sum_agg.as_sql(compiler, connection)\n        self.assertIn('SUM(DISTINCT', sql)\n    \n    def test_min_distinct_sql_generation(self):\n        \"\"\"Test that Min with distinct=True generates correct SQL.\"\"\"\n        min_agg = Min('value', distinct=True)\n        # Test SQL generation\n        from django.db import connection\n        compiler = self.TestModel.objects.all().query.get_compiler(connection.alias)\n        sql, params = min_agg.as_sql(compiler, connection)\n        self.assertIn('MIN(DISTINCT', sql)\n    \n    def test_max_distinct_sql_generation(self):\n        \"\"\"Test that Max with distinct=True generates correct SQL.\"\"\"\n        max_agg = Max('value', distinct=True)\n        # Test SQL generation\n        from django.db import connection\n        compiler = self.TestModel.objects.all().query.get_compiler(connection.alias)\n        sql, params = max_agg.as_sql(compiler, connection)\n        self.assertIn('MAX(DISTINCT', sql)\n    \n    def test_avg_distinct_functionality(self):\n        \"\"\"Test that Avg with distinct=True works correctly in queries.\"\"\"\n        # Test with regular avg (should include duplicates)\n        regular_avg = self.TestModel.objects.aggregate(avg_val=Avg('value'))['avg_val']\n        \n        # Test with distinct avg (should exclude duplicates)\n        distinct_avg = self.TestModel.objects.aggregate(avg_val=Avg('value', distinct=True))['avg_val']\n        \n        # With our test data: values are [10, 20, 10, 30, 20]\n        # Regular avg: (10+20+10+30+20)/5 = 18\n        # Distinct avg: (10+20+30)/3 = 20\n        self.assertEqual(float(regular_avg), 18.0)\n        self.assertEqual(float(distinct_avg), 20.0)\n    \n    def test_sum_distinct_functionality(self):\n        \"\"\"Test that Sum with distinct=True works correctly in queries.\"\"\"\n        # Test with regular sum (should include duplicates)\n        regular_sum = self.TestModel.objects.aggregate(sum_val=Sum('value'))['sum_val']\n        \n        # Test with distinct sum (should exclude duplicates)\n        distinct_sum = self.TestModel.objects.aggregate(sum_val=Sum('value', distinct=True))['sum_val']\n        \n        # With our test data: values are [10, 20, 10, 30, 20]\n        # Regular sum: 10+20+10+30+20 = 90\n        # Distinct sum: 10+20+30 = 60\n        self.assertEqual(regular_sum, 90)\n        self.assertEqual(distinct_sum, 60)\n    \n    def test_min_max_distinct_functionality(self):\n        \"\"\"Test that Min/Max with distinct=True work correctly (though functionally equivalent).\"\"\"\n        # Test Min\n        regular_min = self.TestModel.objects.aggregate(min_val=Min('value'))['min_val']\n        distinct_min = self.TestModel.objects.aggregate(min_val=Min('value', distinct=True))['min_val']\n        self.assertEqual(regular_min, distinct_min)\n        self.assertEqual(regular_min, 10)\n        \n        # Test Max\n        regular_max = self.TestModel.objects.aggregate(max_val=Max('value'))['max_val']\n        distinct_max = self.TestModel.objects.aggregate(max_val=Max('value', distinct=True))['max_val']\n        self.assertEqual(regular_max, distinct_max)\n        self.assertEqual(regular_max, 30)\n    \n    def test_count_distinct_still_works(self):\n        \"\"\"Test that Count with distinct=True still works (regression test).\"\"\"\n        # Count should already support distinct\n        regular_count = self.TestModel.objects.aggregate(count_val=Count('value'))['count_val']\n        distinct_count = self.TestModel.objects.aggregate(count_val=Count('value', distinct=True))['count_val']\n        \n        # With our test data: values are [10, 20, 10, 30, 20]\n        # Regular count: 5\n        # Distinct count: 3 (10, 20, 30)\n        self.assertEqual(regular_count, 5)\n        self.assertEqual(distinct_count, 3)\n    \n    def test_aggregates_without_distinct_still_work(self):\n        \"\"\"Test that aggregates without distinct parameter still work normally.\"\"\"\n        # Test that existing functionality is preserved\n        results = self.TestModel.objects.aggregate(\n            avg_val=Avg('value'),\n            sum_val=Sum('value'),\n            min_val=Min('value'),\n            max_val=Max('value'),\n            count_val=Count('value')\n        )\n        \n        self.assertEqual(float(results['avg_val']), 18.0)\n        self.assertEqual(results['sum_val'], 90)\n        self.assertEqual(results['min_val'], 10)\n        self.assertEqual(results['max_val'], 30)\n        self.assertEqual(results['count_val'], 5)\n    \n    def test_distinct_false_parameter(self):\n        \"\"\"Test that distinct=False works correctly.\"\"\"\n        # Test that explicitly setting distinct=False works\n        avg_agg = Avg('value', distinct=False)\n        sum_agg = Sum('value', distinct=False)\n        min_agg = Min('value', distinct=False)\n        max_agg = Max('value', distinct=False)\n        \n        self.assertFalse(avg_agg.distinct)\n        self.assertFalse(sum_agg.distinct)\n        self.assertFalse(min_agg.distinct)\n        self.assertFalse(max_agg.distinct)\n    \n    def test_repr_includes_distinct(self):\n        \"\"\"Test that the repr of aggregates includes distinct when True.\"\"\"\n        avg_agg = Avg('value', distinct=True)\n        sum_agg = Sum('value', distinct=True)\n        min_agg = Min('value', distinct=True)\n        max_agg = Max('value', distinct=True)\n        \n        # The _get_repr_options method should include distinct in the representation\n        self.assertIn('distinct', avg_agg._get_repr_options())\n        self.assertIn('distinct', sum_agg._get_repr_options())\n        self.assertIn('distinct', min_agg._get_repr_options())\n        self.assertIn('distinct', max_agg._get_repr_options())\n    \n    def test_edge_case_empty_queryset(self):\n        \"\"\"Test distinct aggregates with empty queryset.\"\"\"\n        # Clear all data\n        self.TestModel.objects.all().delete()\n        \n        results = self.TestModel.objects.aggregate(\n            avg_val=Avg('value', distinct=True),\n            sum_val=Sum('value', distinct=True),\n            min_val=Min('value', distinct=True),\n            max_val=Max('value', distinct=True)\n        )\n        \n        # All should be None for empty queryset\n        self.assertIsNone(results['avg_val'])\n        self.assertIsNone(results['sum_val'])\n        self.assertIsNone(results['min_val'])\n        self.assertIsNone(results['max_val'])\n    \n    def test_edge_case_single_value(self):\n        \"\"\"Test distinct aggregates with single value.\"\"\"\n        # Clear all data and add single record\n        self.TestModel.objects.all().delete()\n        self.TestModel.objects.create(name='Single', value=42, score=42.0)\n        \n        results = self.TestModel.objects.aggregate(\n            avg_val=Avg('value', distinct=True),\n            sum_val=Sum('value', distinct=True),\n            min_val=Min('value', distinct=True),\n            max_val=Max('value', distinct=True)\n        )\n        \n        self.assertEqual(float(results['avg_val']), 42.0)\n        self.assertEqual(results['sum_val'], 42)\n        self.assertEqual(results['min_val'], 42)\n        self.assertEqual(results['max_val'], 42)\n    \n    def test_edge_case_all_same_values(self):\n        \"\"\"Test distinct aggregates when all values are the same.\"\"\"\n        # Clear all data and add records with same value\n        self.TestModel.objects.all().delete()\n        for i in range(5):\n            self.TestModel.objects.create(name=f'Same{i}', value=100, score=100.0)\n        \n        results = self.TestModel.objects.aggregate(\n            avg_val=Avg('value', distinct=True),\n            sum_val=Sum('value', distinct=True),\n            min_val=Min('value', distinct=True),\n            max_val=Max('value', distinct=True),\n            count_val=Count('value', distinct=True)\n        )\n        \n        # With all same values, distinct should give single value results\n        self.assertEqual(float(results['avg_val']), 100.0)\n        self.assertEqual(results['sum_val'], 100)  # Only one distinct value\n        self.assertEqual(results['min_val'], 100)\n        self.assertEqual(results['max_val'], 100)\n        self.assertEqual(results['count_val'], 1)  # Only one distinct value\n</patched>\n```",
  "patch": "--- a/tests/aggregation/test_distinct_aggregates.py\n+++ b/tests/aggregation/test_distinct_aggregates.py\n-# Empty if creating new file\n+import pytest\n+from django.core.exceptions import FieldError\n+from django.db import models\n+from django.db.models import Avg, Count, Max, Min, Sum\n+from django.test import TestCase, override_settings\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps('aggregation')\n+class DistinctAggregateTests(TestCase):\n+    \"\"\"Test DISTINCT support for aggregate functions.\"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        \n+        # Create test model\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            value = models.IntegerField()\n+            score = models.DecimalField(max_digits=10, decimal_places=2)\n+            \n+            class Meta:\n+                app_label = 'aggregation'\n+        \n+        cls.TestModel = TestModel\n+        \n+        # Create the table\n+        with cls._get_connection().schema_editor() as schema_editor:\n+            schema_editor.create_model(cls.TestModel)\n+    \n+    @classmethod\n+    def tearDownClass(cls):\n+        # Drop the table\n+        with cls._get_connection().schema_editor() as schema_editor:\n+            schema_editor.delete_model(cls.TestModel)\n+        super().tearDownClass()\n+    \n+    @classmethod\n+    def _get_connection(cls):\n+        from django.db import connection\n+        return connection\n+    \n+    def setUp(self):\n+        # Create test data with duplicates to test DISTINCT functionality\n+        self.TestModel.objects.create(name='A', value=10, score=10.5)\n+        self.TestModel.objects.create(name='B', value=20, score=20.5)\n+        self.TestModel.objects.create(name='A', value=10, score=10.5)  # Duplicate\n+        self.TestModel.objects.create(name='C', value=30, score=30.5)\n+        self.TestModel.objects.create(name='B', value=20, score=20.5)  # Duplicate\n+    \n+    def tearDown(self):\n+        self.TestModel.objects.all().delete()\n+    \n+    def test_avg_allows_distinct_parameter(self):\n+        \"\"\"Test that Avg aggregate accepts distinct=True parameter without raising TypeError.\"\"\"\n+        # This should not raise an exception\n+        try:\n+            avg_agg = Avg('value', distinct=True)\n+            self.assertTrue(avg_agg.allow_distinct)\n+            self.assertTrue(avg_agg.distinct)\n+        except TypeError as e:\n+            self.fail(f\"Avg should allow distinct parameter, but raised: {e}\")\n+    \n+    def test_sum_allows_distinct_parameter(self):\n+        \"\"\"Test that Sum aggregate accepts distinct=True parameter without raising TypeError.\"\"\"\n+        # This should not raise an exception\n+        try:\n+            sum_agg = Sum('value', distinct=True)\n+            self.assertTrue(sum_agg.allow_distinct)\n+            self.assertTrue(sum_agg.distinct)\n+        except TypeError as e:\n+            self.fail(f\"Sum should allow distinct parameter, but raised: {e}\")\n+    \n+    def test_min_allows_distinct_parameter(self):\n+        \"\"\"Test that Min aggregate accepts distinct=True parameter without raising TypeError.\"\"\"\n+        # This should not raise an exception\n+        try:\n+            min_agg = Min('value', distinct=True)\n+            self.assertTrue(min_agg.allow_distinct)\n+            self.assertTrue(min_agg.distinct)\n+        except TypeError as e:\n+            self.fail(f\"Min should allow distinct parameter, but raised: {e}\")\n+    \n+    def test_max_allows_distinct_parameter(self):\n+        \"\"\"Test that Max aggregate accepts distinct=True parameter without raising TypeError.\"\"\"\n+        # This should not raise an exception\n+        try:\n+            max_agg = Max('value', distinct=True)\n+            self.assertTrue(max_agg.allow_distinct)\n+            self.assertTrue(max_agg.distinct)\n+        except TypeError as e:\n+            self.fail(f\"Max should allow distinct parameter, but raised: {e}\")\n+    \n+    def test_avg_distinct_false_before_fix(self):\n+        \"\"\"Test that demonstrates the bug - Avg should raise TypeError with distinct=True before fix.\"\"\"\n+        # This test should fail before the fix is applied\n+        with self.assertRaises(TypeError) as cm:\n+            Avg('value', distinct=True)\n+        self.assertIn(\"does not allow distinct\", str(cm.exception))\n+    \n+    def test_sum_distinct_false_before_fix(self):\n+        \"\"\"Test that demonstrates the bug - Sum should raise TypeError with distinct=True before fix.\"\"\"\n+        # This test should fail before the fix is applied\n+        with self.assertRaises(TypeError) as cm:\n+            Sum('value', distinct=True)\n+        self.assertIn(\"does not allow distinct\", str(cm.exception))\n+    \n+    def test_min_distinct_false_before_fix(self):\n+        \"\"\"Test that demonstrates the bug - Min should raise TypeError with distinct=True before fix.\"\"\"\n+        # This test should fail before the fix is applied\n+        with self.assertRaises(TypeError) as cm:\n+            Min('value', distinct=True)\n+        self.assertIn(\"does not allow distinct\", str(cm.exception))\n+    \n+    def test_max_distinct_false_before_fix(self):\n+        \"\"\"Test that demonstrates the bug - Max should raise TypeError with distinct=True before fix.\"\"\"\n+        # This test should fail before the fix is applied\n+        with self.assertRaises(TypeError) as cm:\n+            Max('value', distinct=True)\n+        self.assertIn(\"does not allow distinct\", str(cm.exception))\n+    \n+    def test_avg_distinct_sql_generation(self):\n+        \"\"\"Test that Avg with distinct=True generates correct SQL.\"\"\"\n+        avg_agg = Avg('value', distinct=True)\n+        # Test SQL generation\n+        from django.db import connection\n+        compiler = self.TestModel.objects.all().query.get_compiler(connection.alias)\n+        sql, params = avg_agg.as_sql(compiler, connection)\n+        self.assertIn('AVG(DISTINCT', sql)\n+    \n+    def test_sum_distinct_sql_generation(self):\n+        \"\"\"Test that Sum with distinct=True generates correct SQL.\"\"\"\n+        sum_agg = Sum('value', distinct=True)\n+        # Test SQL generation\n+        from django.db import connection\n+        compiler = self.TestModel.objects.all().query.get_compiler(connection.alias)\n+        sql, params = sum_agg.as_sql(compiler, connection)\n+        self.assertIn('SUM(DISTINCT', sql)\n+    \n+    def test_min_distinct_sql_generation(self):\n+        \"\"\"Test that Min with distinct=True generates correct SQL.\"\"\"\n+        min_agg = Min('value', distinct=True)\n+        # Test SQL generation\n+        from django.db import connection\n+        compiler = self.TestModel.objects.all().query.get_compiler(connection.alias)\n+        sql, params = min_agg.as_sql(compiler, connection)\n+        self.assertIn('MIN(DISTINCT', sql)\n+    \n+    def test_max_distinct_sql_generation(self):\n+        \"\"\"Test that Max with distinct=True generates correct SQL.\"\"\"\n+        max_agg = Max('value', distinct=True)\n+        # Test SQL generation\n+        from django.db import connection\n+        compiler = self.TestModel.objects.all().query.get_compiler(connection.alias)\n+        sql, params = max_agg.as_sql(compiler, connection)\n+        self.assertIn('MAX(DISTINCT', sql)\n+    \n+    def test_avg_distinct_functionality(self):\n+        \"\"\"Test that Avg with distinct=True works correctly in queries.\"\"\"\n+        # Test with regular avg (should include duplicates)\n+        regular_avg = self.TestModel.objects.aggregate(avg_val=Avg('value'))['avg_val']\n+        \n+        # Test with distinct avg (should exclude duplicates)\n+        distinct_avg = self.TestModel.objects.aggregate(avg_val=Avg('value', distinct=True))['avg_val']\n+        \n+        # With our test data: values are [10, 20, 10, 30, 20]\n+        # Regular avg: (10+20+10+30+20)/5 = 18\n+        # Distinct avg: (10+20+30)/3 = 20\n+        self.assertEqual(float(regular_avg), 18.0)\n+        self.assertEqual(float(distinct_avg), 20.0)\n+    \n+    def test_sum_distinct_functionality(self):\n+        \"\"\"Test that Sum with distinct=True works correctly in queries.\"\"\"\n+        # Test with regular sum (should include duplicates)\n+        regular_sum = self.TestModel.objects.aggregate(sum_val=Sum('value'))['sum_val']\n+        \n+        # Test with distinct sum (should exclude duplicates)\n+        distinct_sum = self.TestModel.objects.aggregate(sum_val=Sum('value', distinct=True))['sum_val']\n+        \n+        # With our test data: values are [10, 20, 10, 30, 20]\n+        # Regular sum: 10+20+10+30+20 = 90\n+        # Distinct sum: 10+20+30 = 60\n+        self.assertEqual(regular_sum, 90)\n+        self.assertEqual(distinct_sum, 60)\n+    \n+    def test_min_max_distinct_functionality(self):\n+        \"\"\"Test that Min/Max with distinct=True work correctly (though functionally equivalent).\"\"\"\n+        # Test Min\n+        regular_min = self.TestModel.objects.aggregate(min_val=Min('value'))['min_val']\n+        distinct_min = self.TestModel.objects.aggregate(min_val=Min('value', distinct=True))['min_val']\n+        self.assertEqual(regular_min, distinct_min)\n+        self.assertEqual(regular_min, 10)\n+        \n+        # Test Max\n+        regular_max = self.TestModel.objects.aggregate(max_val=Max('value'))['max_val']\n+        distinct_max = self.TestModel.objects.aggregate(max_val=Max('value', distinct=True))['max_val']\n+        self.assertEqual(regular_max, distinct_max)\n+        self.assertEqual(regular_max, 30)\n+    \n+    def test_count_distinct_still_works(self):\n+        \"\"\"Test that Count with distinct=True still works (regression test).\"\"\"\n+        # Count should already support distinct\n+        regular_count = self.TestModel.objects.aggregate(count_val=Count('value'))['count_val']\n+        distinct_count = self.TestModel.objects.aggregate(count_val=Count('value', distinct=True))['count_val']\n+        \n+        # With our test data: values are [10, 20, 10, 30, 20]\n+        # Regular count: 5\n+        # Distinct count: 3 (10, 20, 30)\n+        self.assertEqual(regular_count, 5)\n+        self.assertEqual(distinct_count, 3)\n+    \n+    def test_aggregates_without_distinct_still_work(self):\n+        \"\"\"Test that aggregates without distinct parameter still work normally.\"\"\"\n+        # Test that existing functionality is preserved\n+        results = self.TestModel.objects.aggregate(\n+            avg_val=Avg('value'),\n+            sum_val=Sum('value'),\n+            min_val=Min('value'),\n+            max_val=Max('value'),\n+            count_val=Count('value')\n+        )\n+        \n+        self.assertEqual(float(results['avg_val']), 18.0)\n+        self.assertEqual(results['sum_val'], 90)\n+        self.assertEqual(results['min_val'], 10)\n+        self.assertEqual(results['max_val'], 30)\n+        self.assertEqual(results['count_val'], 5)\n+    \n+    def test_distinct_false_parameter(self):\n+        \"\"\"Test that distinct=False works correctly.\"\"\"\n+        # Test that explicitly setting distinct=False works\n+        avg_agg = Avg('value', distinct=False)\n+        sum_agg = Sum('value', distinct=False)\n+        min_agg = Min('value', distinct=False)\n+        max_agg = Max('value', distinct=False)\n+        \n+        self.assertFalse(avg_agg.distinct)\n+        self.assertFalse(sum_agg.distinct)\n+        self.assertFalse(min_agg.distinct)\n+        self.assertFalse(max_agg.distinct)\n+    \n+    def test_repr_includes_distinct(self):\n+        \"\"\"Test that the repr of aggregates includes distinct when True.\"\"\"\n+        avg_agg = Avg('value', distinct=True)\n+        sum_agg = Sum('value', distinct=True)\n+        min_agg = Min('value', distinct=True)\n+        max_agg = Max('value', distinct=True)\n+        \n+        # The _get_repr_options method should include distinct in the representation\n+        self.assertIn('distinct', avg_agg._get_repr_options())\n+        self.assertIn('distinct', sum_agg._get_repr_options())\n+        self.assertIn('distinct', min_agg._get_repr_options())\n+        self.assertIn('distinct', max_agg._get_repr_options())\n+    \n+    def test_edge_case_empty_queryset(self):\n+        \"\"\"Test distinct aggregates with empty queryset.\"\"\"\n+        # Clear all data\n+        self.TestModel.objects.all().delete()\n+        \n+        results = self.TestModel.objects.aggregate(\n+            avg_val=Avg('value', distinct=True),\n+            sum_val=Sum('value', distinct=True),\n+            min_val=Min('value', distinct=True),\n+            max_val=Max('value', distinct=True)\n+        )\n+        \n+        # All should be None for empty queryset\n+        self.assertIsNone(results['avg_val'])\n+        self.assertIsNone(results['sum_val'])\n+        self.assertIsNone(results['min_val'])\n+        self.assertIsNone(results['max_val'])\n+    \n+    def test_edge_case_single_value(self):\n+        \"\"\"Test distinct aggregates with single value.\"\"\"\n+        # Clear all data and add single record\n+        self.TestModel.objects.all().delete()\n+        self.TestModel.objects.create(name='Single', value=42, score=42.0)\n+        \n+        results = self.TestModel.objects.aggregate(\n+            avg_val=Avg('value', distinct=True),\n+            sum_val=Sum('value', distinct=True),\n+            min_val=Min('value', distinct=True),\n+            max_val=Max('value', distinct=True)\n+        )\n+        \n+        self.assertEqual(float(results['avg_val']), 42.0)\n+        self.assertEqual(results['sum_val'], 42)\n+        self.assertEqual(results['min_val'], 42)\n+        self.assertEqual(results['max_val'], 42)\n+    \n+    def test_edge_case_all_same_values(self):\n+        \"\"\"Test distinct aggregates when all values are the same.\"\"\"\n+        # Clear all data and add records with same value\n+        self.TestModel.objects.all().delete()\n+        for i in range(5):\n+            self.TestModel.objects.create(name=f'Same{i}', value=100, score=100.0)\n+        \n+        results = self.TestModel.objects.aggregate(\n+            avg_val=Avg('value', distinct=True),\n+            sum_val=Sum('value', distinct=True),\n+            min_val=Min('value', distinct=True),\n+            max_val=Max('value', distinct=True),\n+            count_val=Count('value', distinct=True)\n+        )\n+        \n+        # With all same values, distinct should give single value results\n+        self.assertEqual(float(results['avg_val']), 100.0)\n+        self.assertEqual(results['sum_val'], 100)  # Only one distinct value\n+        self.assertEqual(results['min_val'], 100)\n+        self.assertEqual(results['max_val'], 100)\n+        self.assertEqual(results['count_val'], 1)  # Only one distinct value\n"
}