{
  "instance_id": "django__django-14999",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/migrations/test_operations.py</file>\n<original>\n# This will be added to the existing test file\n</original>\n<patched>\nimport pytest\nfrom django.db import connection, models\nfrom django.db.migrations.operations import RenameModel\nfrom django.db.migrations.state import ProjectState\nfrom django.test import TestCase, override_settings\nfrom django.test.utils import isolate_apps\n\n\nclass RenameModelWithDbTableTests(TestCase):\n    \"\"\"\n    Test that RenameModel operations with custom db_table are no-ops.\n    \"\"\"\n\n    def setUp(self):\n        self.schema_editor = connection.schema_editor()\n\n    def test_rename_model_with_same_db_table_is_noop(self):\n        \"\"\"\n        Test that renaming a model with a custom db_table that doesn't change\n        should not perform any database operations.\n        \"\"\"\n        # Create initial state with a model that has custom db_table\n        project_state = ProjectState()\n        project_state.add_model(\n            models.Model(\n                'TestModel',\n                tuple(),\n                {\n                    '__module__': 'test_app.models',\n                    'Meta': type('Meta', (), {'db_table': 'custom_table_name'}),\n                }\n            )\n        )\n\n        # Create target state with renamed model but same db_table\n        new_state = project_state.clone()\n        new_state.rename_model('test_app', 'TestModel', 'RenamedTestModel')\n\n        # Get the models from both states\n        old_model = project_state.apps.get_model('test_app', 'TestModel')\n        new_model = new_state.apps.get_model('test_app', 'RenamedTestModel')\n\n        # Verify both models have the same db_table\n        self.assertEqual(old_model._meta.db_table, 'custom_table_name')\n        self.assertEqual(new_model._meta.db_table, 'custom_table_name')\n        self.assertEqual(old_model._meta.db_table, new_model._meta.db_table)\n\n        # Mock the schema_editor to track calls\n        with self.schema_editor as editor:\n            original_alter_db_table = editor.alter_db_table\n            alter_db_table_calls = []\n\n            def mock_alter_db_table(*args, **kwargs):\n                alter_db_table_calls.append((args, kwargs))\n                return original_alter_db_table(*args, **kwargs)\n\n            editor.alter_db_table = mock_alter_db_table\n\n            # Execute the RenameModel operation\n            operation = RenameModel('TestModel', 'RenamedTestModel')\n            operation.database_forwards('test_app', editor, project_state, new_state)\n\n            # With the fix, no alter_db_table calls should be made\n            # This test will fail before the fix is applied\n            self.assertEqual(len(alter_db_table_calls), 0, \n                           \"RenameModel with same db_table should not call alter_db_table\")\n\n    def test_rename_model_with_different_db_table_performs_operations(self):\n        \"\"\"\n        Test that renaming a model where the db_table actually changes\n        still performs the necessary database operations.\n        \"\"\"\n        # Create initial state with default db_table (app_label_model_name)\n        project_state = ProjectState()\n        project_state.add_model(\n            models.Model(\n                'TestModel',\n                tuple(),\n                {\n                    '__module__': 'test_app.models',\n                    'Meta': type('Meta', (), {}),  # No custom db_table\n                }\n            )\n        )\n\n        # Create target state with renamed model (different db_table)\n        new_state = project_state.clone()\n        new_state.rename_model('test_app', 'TestModel', 'RenamedTestModel')\n\n        # Get the models from both states\n        old_model = project_state.apps.get_model('test_app', 'TestModel')\n        new_model = new_state.apps.get_model('test_app', 'RenamedTestModel')\n\n        # Verify the models have different db_table values\n        self.assertEqual(old_model._meta.db_table, 'test_app_testmodel')\n        self.assertEqual(new_model._meta.db_table, 'test_app_renamedtestmodel')\n        self.assertNotEqual(old_model._meta.db_table, new_model._meta.db_table)\n\n        # Mock the schema_editor to track calls\n        with self.schema_editor as editor:\n            original_alter_db_table = editor.alter_db_table\n            alter_db_table_calls = []\n\n            def mock_alter_db_table(*args, **kwargs):\n                alter_db_table_calls.append((args, kwargs))\n                return original_alter_db_table(*args, **kwargs)\n\n            editor.alter_db_table = mock_alter_db_table\n\n            # Execute the RenameModel operation\n            operation = RenameModel('TestModel', 'RenamedTestModel')\n            operation.database_forwards('test_app', editor, project_state, new_state)\n\n            # Should perform database operations when db_table changes\n            self.assertGreater(len(alter_db_table_calls), 0,\n                             \"RenameModel with different db_table should call alter_db_table\")\n\n    def test_rename_model_with_custom_db_table_and_foreign_keys(self):\n        \"\"\"\n        Test that RenameModel with custom db_table doesn't affect foreign key constraints\n        when the table name doesn't change.\n        \"\"\"\n        # Create initial state with two models, one referencing the other\n        project_state = ProjectState()\n        \n        # Referenced model with custom db_table\n        project_state.add_model(\n            models.Model(\n                'ReferencedModel',\n                tuple(),\n                {\n                    '__module__': 'test_app.models',\n                    'Meta': type('Meta', (), {'db_table': 'custom_referenced_table'}),\n                }\n            )\n        )\n        \n        # Referencing model\n        project_state.add_model(\n            models.Model(\n                'ReferencingModel',\n                (\n                    ('referenced', models.ForeignKey('ReferencedModel', on_delete=models.CASCADE)),\n                ),\n                {\n                    '__module__': 'test_app.models',\n                    'Meta': type('Meta', (), {}),\n                }\n            )\n        )\n\n        # Create target state with renamed referenced model but same db_table\n        new_state = project_state.clone()\n        new_state.rename_model('test_app', 'ReferencedModel', 'RenamedReferencedModel')\n\n        # Get the models from both states\n        old_model = project_state.apps.get_model('test_app', 'ReferencedModel')\n        new_model = new_state.apps.get_model('test_app', 'RenamedReferencedModel')\n\n        # Verify both models have the same db_table\n        self.assertEqual(old_model._meta.db_table, 'custom_referenced_table')\n        self.assertEqual(new_model._meta.db_table, 'custom_referenced_table')\n\n        # Mock the schema_editor to track foreign key operations\n        with self.schema_editor as editor:\n            original_alter_field = editor.alter_field\n            alter_field_calls = []\n\n            def mock_alter_field(*args, **kwargs):\n                alter_field_calls.append((args, kwargs))\n                return original_alter_field(*args, **kwargs)\n\n            editor.alter_field = mock_alter_field\n\n            # Execute the RenameModel operation\n            operation = RenameModel('ReferencedModel', 'RenamedReferencedModel')\n            operation.database_forwards('test_app', editor, project_state, new_state)\n\n            # With the fix, no alter_field calls should be made for foreign keys\n            # since the referenced table name doesn't change\n            self.assertEqual(len(alter_field_calls), 0,\n                           \"RenameModel with same db_table should not alter foreign key fields\")\n\n    def test_rename_model_with_custom_db_table_and_m2m_fields(self):\n        \"\"\"\n        Test that RenameModel with custom db_table doesn't affect M2M tables\n        when the model table name doesn't change.\n        \"\"\"\n        # Create initial state with model having M2M field and custom db_table\n        project_state = ProjectState()\n        \n        # Target model for M2M\n        project_state.add_model(\n            models.Model(\n                'TargetModel',\n                tuple(),\n                {\n                    '__module__': 'test_app.models',\n                    'Meta': type('Meta', (), {}),\n                }\n            )\n        )\n        \n        # Model with M2M field and custom db_table\n        project_state.add_model(\n            models.Model(\n                'ModelWithM2M',\n                (\n                    ('targets', models.ManyToManyField('TargetModel')),\n                ),\n                {\n                    '__module__': 'test_app.models',\n                    'Meta': type('Meta', (), {'db_table': 'custom_m2m_table'}),\n                }\n            )\n        )\n\n        # Create target state with renamed model but same db_table\n        new_state = project_state.clone()\n        new_state.rename_model('test_app', 'ModelWithM2M', 'RenamedModelWithM2M')\n\n        # Get the models from both states\n        old_model = project_state.apps.get_model('test_app', 'ModelWithM2M')\n        new_model = new_state.apps.get_model('test_app', 'RenamedModelWithM2M')\n\n        # Verify both models have the same db_table\n        self.assertEqual(old_model._meta.db_table, 'custom_m2m_table')\n        self.assertEqual(new_model._meta.db_table, 'custom_m2m_table')\n\n        # Mock the schema_editor to track M2M table operations\n        with self.schema_editor as editor:\n            original_alter_db_table = editor.alter_db_table\n            original_alter_field = editor.alter_field\n            alter_db_table_calls = []\n            alter_field_calls = []\n\n            def mock_alter_db_table(*args, **kwargs):\n                alter_db_table_calls.append((args, kwargs))\n                return original_alter_db_table(*args, **kwargs)\n\n            def mock_alter_field(*args, **kwargs):\n                alter_field_calls.append((args, kwargs))\n                return original_alter_field(*args, **kwargs)\n\n            editor.alter_db_table = mock_alter_db_table\n            editor.alter_field = mock_alter_field\n\n            # Execute the RenameModel operation\n            operation = RenameModel('ModelWithM2M', 'RenamedModelWithM2M')\n            operation.database_forwards('test_app', editor, project_state, new_state)\n\n            # With the fix, no M2M table operations should be performed\n            # since the main table name doesn't change\n            self.assertEqual(len(alter_db_table_calls), 0,\n                           \"RenameModel with same db_table should not alter M2M tables\")\n            self.assertEqual(len(alter_field_calls), 0,\n                           \"RenameModel with same db_table should not alter M2M fields\")\n\n    @isolate_apps('test_app')\n    def test_rename_model_noop_integration(self):\n        \"\"\"\n        Integration test to verify the complete behavior of RenameModel\n        with custom db_table in a realistic scenario.\n        \"\"\"\n        # Define a model with custom db_table\n        class TestModel(models.Model):\n            name = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n                db_table = 'my_custom_table'\n\n        # Create the table\n        with connection.schema_editor() as editor:\n            editor.create_model(TestModel)\n\n        try:\n            # Verify table exists with custom name\n            table_names = connection.introspection.table_names()\n            self.assertIn('my_custom_table', table_names)\n            self.assertNotIn('test_app_testmodel', table_names)\n\n            # Create states for the operation\n            project_state = ProjectState()\n            project_state.add_model(TestModel)\n\n            new_state = project_state.clone()\n            new_state.rename_model('test_app', 'TestModel', 'RenamedTestModel')\n\n            # Execute the rename operation\n            operation = RenameModel('TestModel', 'RenamedTestModel')\n            with connection.schema_editor() as editor:\n                operation.database_forwards('test_app', editor, project_state, new_state)\n\n            # Verify the table still exists with the same name\n            table_names_after = connection.introspection.table_names()\n            self.assertIn('my_custom_table', table_names_after)\n            self.assertNotIn('test_app_renamedtestmodel', table_names_after)\n            \n            # Table names should be identical before and after\n            self.assertEqual(set(table_names), set(table_names_after))\n\n        finally:\n            # Clean up\n            with connection.schema_editor() as editor:\n                editor.delete_model(TestModel)\n</patched>\n```",
  "patch": "--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n-# This will be added to the existing test file\n+import pytest\n+from django.db import connection, models\n+from django.db.migrations.operations import RenameModel\n+from django.db.migrations.state import ProjectState\n+from django.test import TestCase, override_settings\n+from django.test.utils import isolate_apps\n+\n+\n+class RenameModelWithDbTableTests(TestCase):\n+    \"\"\"\n+    Test that RenameModel operations with custom db_table are no-ops.\n+    \"\"\"\n+\n+    def setUp(self):\n+        self.schema_editor = connection.schema_editor()\n+\n+    def test_rename_model_with_same_db_table_is_noop(self):\n+        \"\"\"\n+        Test that renaming a model with a custom db_table that doesn't change\n+        should not perform any database operations.\n+        \"\"\"\n+        # Create initial state with a model that has custom db_table\n+        project_state = ProjectState()\n+        project_state.add_model(\n+            models.Model(\n+                'TestModel',\n+                tuple(),\n+                {\n+                    '__module__': 'test_app.models',\n+                    'Meta': type('Meta', (), {'db_table': 'custom_table_name'}),\n+                }\n+            )\n+        )\n+\n+        # Create target state with renamed model but same db_table\n+        new_state = project_state.clone()\n+        new_state.rename_model('test_app', 'TestModel', 'RenamedTestModel')\n+\n+        # Get the models from both states\n+        old_model = project_state.apps.get_model('test_app', 'TestModel')\n+        new_model = new_state.apps.get_model('test_app', 'RenamedTestModel')\n+\n+        # Verify both models have the same db_table\n+        self.assertEqual(old_model._meta.db_table, 'custom_table_name')\n+        self.assertEqual(new_model._meta.db_table, 'custom_table_name')\n+        self.assertEqual(old_model._meta.db_table, new_model._meta.db_table)\n+\n+        # Mock the schema_editor to track calls\n+        with self.schema_editor as editor:\n+            original_alter_db_table = editor.alter_db_table\n+            alter_db_table_calls = []\n+\n+            def mock_alter_db_table(*args, **kwargs):\n+                alter_db_table_calls.append((args, kwargs))\n+                return original_alter_db_table(*args, **kwargs)\n+\n+            editor.alter_db_table = mock_alter_db_table\n+\n+            # Execute the RenameModel operation\n+            operation = RenameModel('TestModel', 'RenamedTestModel')\n+            operation.database_forwards('test_app', editor, project_state, new_state)\n+\n+            # With the fix, no alter_db_table calls should be made\n+            # This test will fail before the fix is applied\n+            self.assertEqual(len(alter_db_table_calls), 0, \n+                           \"RenameModel with same db_table should not call alter_db_table\")\n+\n+    def test_rename_model_with_different_db_table_performs_operations(self):\n+        \"\"\"\n+        Test that renaming a model where the db_table actually changes\n+        still performs the necessary database operations.\n+        \"\"\"\n+        # Create initial state with default db_table (app_label_model_name)\n+        project_state = ProjectState()\n+        project_state.add_model(\n+            models.Model(\n+                'TestModel',\n+                tuple(),\n+                {\n+                    '__module__': 'test_app.models',\n+                    'Meta': type('Meta', (), {}),  # No custom db_table\n+                }\n+            )\n+        )\n+\n+        # Create target state with renamed model (different db_table)\n+        new_state = project_state.clone()\n+        new_state.rename_model('test_app', 'TestModel', 'RenamedTestModel')\n+\n+        # Get the models from both states\n+        old_model = project_state.apps.get_model('test_app', 'TestModel')\n+        new_model = new_state.apps.get_model('test_app', 'RenamedTestModel')\n+\n+        # Verify the models have different db_table values\n+        self.assertEqual(old_model._meta.db_table, 'test_app_testmodel')\n+        self.assertEqual(new_model._meta.db_table, 'test_app_renamedtestmodel')\n+        self.assertNotEqual(old_model._meta.db_table, new_model._meta.db_table)\n+\n+        # Mock the schema_editor to track calls\n+        with self.schema_editor as editor:\n+            original_alter_db_table = editor.alter_db_table\n+            alter_db_table_calls = []\n+\n+            def mock_alter_db_table(*args, **kwargs):\n+                alter_db_table_calls.append((args, kwargs))\n+                return original_alter_db_table(*args, **kwargs)\n+\n+            editor.alter_db_table = mock_alter_db_table\n+\n+            # Execute the RenameModel operation\n+            operation = RenameModel('TestModel', 'RenamedTestModel')\n+            operation.database_forwards('test_app', editor, project_state, new_state)\n+\n+            # Should perform database operations when db_table changes\n+            self.assertGreater(len(alter_db_table_calls), 0,\n+                             \"RenameModel with different db_table should call alter_db_table\")\n+\n+    def test_rename_model_with_custom_db_table_and_foreign_keys(self):\n+        \"\"\"\n+        Test that RenameModel with custom db_table doesn't affect foreign key constraints\n+        when the table name doesn't change.\n+        \"\"\"\n+        # Create initial state with two models, one referencing the other\n+        project_state = ProjectState()\n+        \n+        # Referenced model with custom db_table\n+        project_state.add_model(\n+            models.Model(\n+                'ReferencedModel',\n+                tuple(),\n+                {\n+                    '__module__': 'test_app.models',\n+                    'Meta': type('Meta', (), {'db_table': 'custom_referenced_table'}),\n+                }\n+            )\n+        )\n+        \n+        # Referencing model\n+        project_state.add_model(\n+            models.Model(\n+                'ReferencingModel',\n+                (\n+                    ('referenced', models.ForeignKey('ReferencedModel', on_delete=models.CASCADE)),\n+                ),\n+                {\n+                    '__module__': 'test_app.models',\n+                    'Meta': type('Meta', (), {}),\n+                }\n+            )\n+        )\n+\n+        # Create target state with renamed referenced model but same db_table\n+        new_state = project_state.clone()\n+        new_state.rename_model('test_app', 'ReferencedModel', 'RenamedReferencedModel')\n+\n+        # Get the models from both states\n+        old_model = project_state.apps.get_model('test_app', 'ReferencedModel')\n+        new_model = new_state.apps.get_model('test_app', 'RenamedReferencedModel')\n+\n+        # Verify both models have the same db_table\n+        self.assertEqual(old_model._meta.db_table, 'custom_referenced_table')\n+        self.assertEqual(new_model._meta.db_table, 'custom_referenced_table')\n+\n+        # Mock the schema_editor to track foreign key operations\n+        with self.schema_editor as editor:\n+            original_alter_field = editor.alter_field\n+            alter_field_calls = []\n+\n+            def mock_alter_field(*args, **kwargs):\n+                alter_field_calls.append((args, kwargs))\n+                return original_alter_field(*args, **kwargs)\n+\n+            editor.alter_field = mock_alter_field\n+\n+            # Execute the RenameModel operation\n+            operation = RenameModel('ReferencedModel', 'RenamedReferencedModel')\n+            operation.database_forwards('test_app', editor, project_state, new_state)\n+\n+            # With the fix, no alter_field calls should be made for foreign keys\n+            # since the referenced table name doesn't change\n+            self.assertEqual(len(alter_field_calls), 0,\n+                           \"RenameModel with same db_table should not alter foreign key fields\")\n+\n+    def test_rename_model_with_custom_db_table_and_m2m_fields(self):\n+        \"\"\"\n+        Test that RenameModel with custom db_table doesn't affect M2M tables\n+        when the model table name doesn't change.\n+        \"\"\"\n+        # Create initial state with model having M2M field and custom db_table\n+        project_state = ProjectState()\n+        \n+        # Target model for M2M\n+        project_state.add_model(\n+            models.Model(\n+                'TargetModel',\n+                tuple(),\n+                {\n+                    '__module__': 'test_app.models',\n+                    'Meta': type('Meta', (), {}),\n+                }\n+            )\n+        )\n+        \n+        # Model with M2M field and custom db_table\n+        project_state.add_model(\n+            models.Model(\n+                'ModelWithM2M',\n+                (\n+                    ('targets', models.ManyToManyField('TargetModel')),\n+                ),\n+                {\n+                    '__module__': 'test_app.models',\n+                    'Meta': type('Meta', (), {'db_table': 'custom_m2m_table'}),\n+                }\n+            )\n+        )\n+\n+        # Create target state with renamed model but same db_table\n+        new_state = project_state.clone()\n+        new_state.rename_model('test_app', 'ModelWithM2M', 'RenamedModelWithM2M')\n+\n+        # Get the models from both states\n+        old_model = project_state.apps.get_model('test_app', 'ModelWithM2M')\n+        new_model = new_state.apps.get_model('test_app', 'RenamedModelWithM2M')\n+\n+        # Verify both models have the same db_table\n+        self.assertEqual(old_model._meta.db_table, 'custom_m2m_table')\n+        self.assertEqual(new_model._meta.db_table, 'custom_m2m_table')\n+\n+        # Mock the schema_editor to track M2M table operations\n+        with self.schema_editor as editor:\n+            original_alter_db_table = editor.alter_db_table\n+            original_alter_field = editor.alter_field\n+            alter_db_table_calls = []\n+            alter_field_calls = []\n+\n+            def mock_alter_db_table(*args, **kwargs):\n+                alter_db_table_calls.append((args, kwargs))\n+                return original_alter_db_table(*args, **kwargs)\n+\n+            def mock_alter_field(*args, **kwargs):\n+                alter_field_calls.append((args, kwargs))\n+                return original_alter_field(*args, **kwargs)\n+\n+            editor.alter_db_table = mock_alter_db_table\n+            editor.alter_field = mock_alter_field\n+\n+            # Execute the RenameModel operation\n+            operation = RenameModel('ModelWithM2M', 'RenamedModelWithM2M')\n+            operation.database_forwards('test_app', editor, project_state, new_state)\n+\n+            # With the fix, no M2M table operations should be performed\n+            # since the main table name doesn't change\n+            self.assertEqual(len(alter_db_table_calls), 0,\n+                           \"RenameModel with same db_table should not alter M2M tables\")\n+            self.assertEqual(len(alter_field_calls), 0,\n+                           \"RenameModel with same db_table should not alter M2M fields\")\n+\n+    @isolate_apps('test_app')\n+    def test_rename_model_noop_integration(self):\n+        \"\"\"\n+        Integration test to verify the complete behavior of RenameModel\n+        with custom db_table in a realistic scenario.\n+        \"\"\"\n+        # Define a model with custom db_table\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+                db_table = 'my_custom_table'\n+\n+        # Create the table\n+        with connection.schema_editor() as editor:\n+            editor.create_model(TestModel)\n+\n+        try:\n+            # Verify table exists with custom name\n+            table_names = connection.introspection.table_names()\n+            self.assertIn('my_custom_table', table_names)\n+            self.assertNotIn('test_app_testmodel', table_names)\n+\n+            # Create states for the operation\n+            project_state = ProjectState()\n+            project_state.add_model(TestModel)\n+\n+            new_state = project_state.clone()\n+            new_state.rename_model('test_app', 'TestModel', 'RenamedTestModel')\n+\n+            # Execute the rename operation\n+            operation = RenameModel('TestModel', 'RenamedTestModel')\n+            with connection.schema_editor() as editor:\n+                operation.database_forwards('test_app', editor, project_state, new_state)\n+\n+            # Verify the table still exists with the same name\n+            table_names_after = connection.introspection.table_names()\n+            self.assertIn('my_custom_table', table_names_after)\n+            self.assertNotIn('test_app_renamedtestmodel', table_names_after)\n+            \n+            # Table names should be identical before and after\n+            self.assertEqual(set(table_names), set(table_names_after))\n+\n+        finally:\n+            # Clean up\n+            with connection.schema_editor() as editor:\n+                editor.delete_model(TestModel)\n"
}