{
  "instance_id": "sympy__sympy-15349",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>sympy/algebras/tests/test_quaternion_rotation_matrix.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom sympy import symbols, cos, sin, pi, trigsimp, sqrt, Matrix, simplify\nfrom sympy.algebras.quaternion import Quaternion\n\n\nclass TestQuaternionRotationMatrix:\n    \"\"\"Test suite for Quaternion.to_rotation_matrix() method.\"\"\"\n\n    def test_rotation_around_x_axis_bug_reproduction(self):\n        \"\"\"\n        Test that reproduces the bug described in the issue.\n        This test should fail before the fix is applied.\n        \n        For a rotation around x-axis by angle x, the quaternion is:\n        q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n        \n        The expected rotation matrix should be:\n        [[1,      0,       0],\n         [0, cos(x), -sin(x)],\n         [0, sin(x),  cos(x)]]\n        \n        But the buggy implementation produces:\n        [[1,      0,      0],\n         [0, cos(x), sin(x)],\n         [0, sin(x), cos(x)]]\n        \"\"\"\n        x = symbols('x')\n        q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n        result = trigsimp(q.to_rotation_matrix())\n        \n        # Expected correct rotation matrix for rotation around x-axis\n        expected = Matrix([\n            [1,      0,       0],\n            [0, cos(x), -sin(x)],\n            [0, sin(x),  cos(x)]\n        ])\n        \n        # This assertion should pass after the fix\n        assert result == expected, f\"Expected {expected}, but got {result}\"\n\n    def test_rotation_around_y_axis(self):\n        \"\"\"Test rotation around y-axis.\"\"\"\n        x = symbols('x')\n        q = Quaternion(cos(x/2), 0, sin(x/2), 0)\n        result = trigsimp(q.to_rotation_matrix())\n        \n        expected = Matrix([\n            [cos(x),  0, sin(x)],\n            [     0,  1,      0],\n            [-sin(x), 0, cos(x)]\n        ])\n        \n        assert result == expected\n\n    def test_rotation_around_z_axis(self):\n        \"\"\"Test rotation around z-axis.\"\"\"\n        x = symbols('x')\n        q = Quaternion(cos(x/2), 0, 0, sin(x/2))\n        result = trigsimp(q.to_rotation_matrix())\n        \n        expected = Matrix([\n            [cos(x), -sin(x), 0],\n            [sin(x),  cos(x), 0],\n            [     0,       0, 1]\n        ])\n        \n        assert result == expected\n\n    def test_identity_quaternion(self):\n        \"\"\"Test that identity quaternion produces identity matrix.\"\"\"\n        q = Quaternion(1, 0, 0, 0)\n        result = q.to_rotation_matrix()\n        \n        expected = Matrix([\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ])\n        \n        assert result == expected\n\n    def test_90_degree_rotations(self):\n        \"\"\"Test specific 90-degree rotations around each axis.\"\"\"\n        # 90-degree rotation around x-axis\n        q_x = Quaternion(cos(pi/4), sin(pi/4), 0, 0)\n        result_x = simplify(q_x.to_rotation_matrix())\n        expected_x = Matrix([\n            [1,  0,  0],\n            [0,  0, -1],\n            [0,  1,  0]\n        ])\n        assert result_x == expected_x\n\n        # 90-degree rotation around y-axis\n        q_y = Quaternion(cos(pi/4), 0, sin(pi/4), 0)\n        result_y = simplify(q_y.to_rotation_matrix())\n        expected_y = Matrix([\n            [ 0, 0, 1],\n            [ 0, 1, 0],\n            [-1, 0, 0]\n        ])\n        assert result_y == expected_y\n\n        # 90-degree rotation around z-axis\n        q_z = Quaternion(cos(pi/4), 0, 0, sin(pi/4))\n        result_z = simplify(q_z.to_rotation_matrix())\n        expected_z = Matrix([\n            [0, -1, 0],\n            [1,  0, 0],\n            [0,  0, 1]\n        ])\n        assert result_z == expected_z\n\n    def test_180_degree_rotations(self):\n        \"\"\"Test 180-degree rotations around each axis.\"\"\"\n        # 180-degree rotation around x-axis\n        q_x = Quaternion(0, 1, 0, 0)\n        result_x = q_x.to_rotation_matrix()\n        expected_x = Matrix([\n            [1,  0,  0],\n            [0, -1,  0],\n            [0,  0, -1]\n        ])\n        assert result_x == expected_x\n\n        # 180-degree rotation around y-axis\n        q_y = Quaternion(0, 0, 1, 0)\n        result_y = q_y.to_rotation_matrix()\n        expected_y = Matrix([\n            [-1, 0,  0],\n            [ 0, 1,  0],\n            [ 0, 0, -1]\n        ])\n        assert result_y == expected_y\n\n        # 180-degree rotation around z-axis\n        q_z = Quaternion(0, 0, 0, 1)\n        result_z = q_z.to_rotation_matrix()\n        expected_z = Matrix([\n            [-1,  0, 0],\n            [ 0, -1, 0],\n            [ 0,  0, 1]\n        ])\n        assert result_z == expected_z\n\n    def test_arbitrary_unit_quaternion(self):\n        \"\"\"Test with an arbitrary normalized quaternion.\"\"\"\n        # Quaternion representing rotation around axis (1,1,1) by 120 degrees\n        q = Quaternion(1, 1, 1, 1).normalize()\n        result = q.to_rotation_matrix()\n        \n        # The result should be orthogonal (R * R.T = I)\n        identity = simplify(result * result.T)\n        expected_identity = Matrix([\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ])\n        assert identity == expected_identity\n        \n        # The determinant should be 1\n        assert simplify(result.det()) == 1\n\n    def test_quaternion_with_point_transformation(self):\n        \"\"\"Test 4x4 transformation matrix generation.\"\"\"\n        x = symbols('x')\n        q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n        point = (1, 1, 1)\n        result = trigsimp(q.to_rotation_matrix(point))\n        \n        # Should be a 4x4 matrix\n        assert result.shape == (4, 4)\n        \n        # Bottom row should be [0, 0, 0, 1]\n        assert result[3, :] == Matrix([[0, 0, 0, 1]])\n        \n        # Top-left 3x3 should be the same as the 3x3 rotation matrix\n        rotation_3x3 = trigsimp(q.to_rotation_matrix())\n        assert result[:3, :3] == rotation_3x3\n\n    def test_conjugate_quaternion_inverse_rotation(self):\n        \"\"\"Test that conjugate quaternion produces inverse rotation.\"\"\"\n        x = symbols('x')\n        q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n        q_conj = q._eval_conjugate()\n        \n        R = q.to_rotation_matrix()\n        R_inv = q_conj.to_rotation_matrix()\n        \n        # R * R_inv should be identity\n        identity = simplify(R * R_inv)\n        expected_identity = Matrix([\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ])\n        assert identity == expected_identity\n\n    def test_edge_case_zero_vector_components(self):\n        \"\"\"Test edge cases with zero vector components.\"\"\"\n        # Pure scalar quaternion (no rotation)\n        q1 = Quaternion(1, 0, 0, 0)\n        result1 = q1.to_rotation_matrix()\n        expected1 = Matrix([\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ])\n        assert result1 == expected1\n\n        # Quaternion with only one non-zero vector component\n        q2 = Quaternion(sqrt(2)/2, sqrt(2)/2, 0, 0)  # 90-degree rotation around x\n        result2 = simplify(q2.to_rotation_matrix())\n        expected2 = Matrix([\n            [1,  0,  0],\n            [0,  0, -1],\n            [0,  1,  0]\n        ])\n        assert result2 == expected2\n\n    def test_numerical_consistency(self):\n        \"\"\"Test numerical consistency with specific values.\"\"\"\n        # Test with pi/6 rotation around x-axis\n        q = Quaternion(cos(pi/12), sin(pi/12), 0, 0)\n        result = q.to_rotation_matrix()\n        \n        # Check that the matrix is orthogonal\n        product = simplify(result * result.T)\n        identity = Matrix([\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ])\n        assert product == identity\n        \n        # Check determinant is 1\n        assert simplify(result.det()) == 1\n</patched>\n```",
  "patch": "--- a/sympy/algebras/tests/test_quaternion_rotation_matrix.py\n+++ b/sympy/algebras/tests/test_quaternion_rotation_matrix.py\n-# Empty if creating new file\n+import pytest\n+from sympy import symbols, cos, sin, pi, trigsimp, sqrt, Matrix, simplify\n+from sympy.algebras.quaternion import Quaternion\n+\n+\n+class TestQuaternionRotationMatrix:\n+    \"\"\"Test suite for Quaternion.to_rotation_matrix() method.\"\"\"\n+\n+    def test_rotation_around_x_axis_bug_reproduction(self):\n+        \"\"\"\n+        Test that reproduces the bug described in the issue.\n+        This test should fail before the fix is applied.\n+        \n+        For a rotation around x-axis by angle x, the quaternion is:\n+        q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+        \n+        The expected rotation matrix should be:\n+        [[1,      0,       0],\n+         [0, cos(x), -sin(x)],\n+         [0, sin(x),  cos(x)]]\n+        \n+        But the buggy implementation produces:\n+        [[1,      0,      0],\n+         [0, cos(x), sin(x)],\n+         [0, sin(x), cos(x)]]\n+        \"\"\"\n+        x = symbols('x')\n+        q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+        result = trigsimp(q.to_rotation_matrix())\n+        \n+        # Expected correct rotation matrix for rotation around x-axis\n+        expected = Matrix([\n+            [1,      0,       0],\n+            [0, cos(x), -sin(x)],\n+            [0, sin(x),  cos(x)]\n+        ])\n+        \n+        # This assertion should pass after the fix\n+        assert result == expected, f\"Expected {expected}, but got {result}\"\n+\n+    def test_rotation_around_y_axis(self):\n+        \"\"\"Test rotation around y-axis.\"\"\"\n+        x = symbols('x')\n+        q = Quaternion(cos(x/2), 0, sin(x/2), 0)\n+        result = trigsimp(q.to_rotation_matrix())\n+        \n+        expected = Matrix([\n+            [cos(x),  0, sin(x)],\n+            [     0,  1,      0],\n+            [-sin(x), 0, cos(x)]\n+        ])\n+        \n+        assert result == expected\n+\n+    def test_rotation_around_z_axis(self):\n+        \"\"\"Test rotation around z-axis.\"\"\"\n+        x = symbols('x')\n+        q = Quaternion(cos(x/2), 0, 0, sin(x/2))\n+        result = trigsimp(q.to_rotation_matrix())\n+        \n+        expected = Matrix([\n+            [cos(x), -sin(x), 0],\n+            [sin(x),  cos(x), 0],\n+            [     0,       0, 1]\n+        ])\n+        \n+        assert result == expected\n+\n+    def test_identity_quaternion(self):\n+        \"\"\"Test that identity quaternion produces identity matrix.\"\"\"\n+        q = Quaternion(1, 0, 0, 0)\n+        result = q.to_rotation_matrix()\n+        \n+        expected = Matrix([\n+            [1, 0, 0],\n+            [0, 1, 0],\n+            [0, 0, 1]\n+        ])\n+        \n+        assert result == expected\n+\n+    def test_90_degree_rotations(self):\n+        \"\"\"Test specific 90-degree rotations around each axis.\"\"\"\n+        # 90-degree rotation around x-axis\n+        q_x = Quaternion(cos(pi/4), sin(pi/4), 0, 0)\n+        result_x = simplify(q_x.to_rotation_matrix())\n+        expected_x = Matrix([\n+            [1,  0,  0],\n+            [0,  0, -1],\n+            [0,  1,  0]\n+        ])\n+        assert result_x == expected_x\n+\n+        # 90-degree rotation around y-axis\n+        q_y = Quaternion(cos(pi/4), 0, sin(pi/4), 0)\n+        result_y = simplify(q_y.to_rotation_matrix())\n+        expected_y = Matrix([\n+            [ 0, 0, 1],\n+            [ 0, 1, 0],\n+            [-1, 0, 0]\n+        ])\n+        assert result_y == expected_y\n+\n+        # 90-degree rotation around z-axis\n+        q_z = Quaternion(cos(pi/4), 0, 0, sin(pi/4))\n+        result_z = simplify(q_z.to_rotation_matrix())\n+        expected_z = Matrix([\n+            [0, -1, 0],\n+            [1,  0, 0],\n+            [0,  0, 1]\n+        ])\n+        assert result_z == expected_z\n+\n+    def test_180_degree_rotations(self):\n+        \"\"\"Test 180-degree rotations around each axis.\"\"\"\n+        # 180-degree rotation around x-axis\n+        q_x = Quaternion(0, 1, 0, 0)\n+        result_x = q_x.to_rotation_matrix()\n+        expected_x = Matrix([\n+            [1,  0,  0],\n+            [0, -1,  0],\n+            [0,  0, -1]\n+        ])\n+        assert result_x == expected_x\n+\n+        # 180-degree rotation around y-axis\n+        q_y = Quaternion(0, 0, 1, 0)\n+        result_y = q_y.to_rotation_matrix()\n+        expected_y = Matrix([\n+            [-1, 0,  0],\n+            [ 0, 1,  0],\n+            [ 0, 0, -1]\n+        ])\n+        assert result_y == expected_y\n+\n+        # 180-degree rotation around z-axis\n+        q_z = Quaternion(0, 0, 0, 1)\n+        result_z = q_z.to_rotation_matrix()\n+        expected_z = Matrix([\n+            [-1,  0, 0],\n+            [ 0, -1, 0],\n+            [ 0,  0, 1]\n+        ])\n+        assert result_z == expected_z\n+\n+    def test_arbitrary_unit_quaternion(self):\n+        \"\"\"Test with an arbitrary normalized quaternion.\"\"\"\n+        # Quaternion representing rotation around axis (1,1,1) by 120 degrees\n+        q = Quaternion(1, 1, 1, 1).normalize()\n+        result = q.to_rotation_matrix()\n+        \n+        # The result should be orthogonal (R * R.T = I)\n+        identity = simplify(result * result.T)\n+        expected_identity = Matrix([\n+            [1, 0, 0],\n+            [0, 1, 0],\n+            [0, 0, 1]\n+        ])\n+        assert identity == expected_identity\n+        \n+        # The determinant should be 1\n+        assert simplify(result.det()) == 1\n+\n+    def test_quaternion_with_point_transformation(self):\n+        \"\"\"Test 4x4 transformation matrix generation.\"\"\"\n+        x = symbols('x')\n+        q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+        point = (1, 1, 1)\n+        result = trigsimp(q.to_rotation_matrix(point))\n+        \n+        # Should be a 4x4 matrix\n+        assert result.shape == (4, 4)\n+        \n+        # Bottom row should be [0, 0, 0, 1]\n+        assert result[3, :] == Matrix([[0, 0, 0, 1]])\n+        \n+        # Top-left 3x3 should be the same as the 3x3 rotation matrix\n+        rotation_3x3 = trigsimp(q.to_rotation_matrix())\n+        assert result[:3, :3] == rotation_3x3\n+\n+    def test_conjugate_quaternion_inverse_rotation(self):\n+        \"\"\"Test that conjugate quaternion produces inverse rotation.\"\"\"\n+        x = symbols('x')\n+        q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+        q_conj = q._eval_conjugate()\n+        \n+        R = q.to_rotation_matrix()\n+        R_inv = q_conj.to_rotation_matrix()\n+        \n+        # R * R_inv should be identity\n+        identity = simplify(R * R_inv)\n+        expected_identity = Matrix([\n+            [1, 0, 0],\n+            [0, 1, 0],\n+            [0, 0, 1]\n+        ])\n+        assert identity == expected_identity\n+\n+    def test_edge_case_zero_vector_components(self):\n+        \"\"\"Test edge cases with zero vector components.\"\"\"\n+        # Pure scalar quaternion (no rotation)\n+        q1 = Quaternion(1, 0, 0, 0)\n+        result1 = q1.to_rotation_matrix()\n+        expected1 = Matrix([\n+            [1, 0, 0],\n+            [0, 1, 0],\n+            [0, 0, 1]\n+        ])\n+        assert result1 == expected1\n+\n+        # Quaternion with only one non-zero vector component\n+        q2 = Quaternion(sqrt(2)/2, sqrt(2)/2, 0, 0)  # 90-degree rotation around x\n+        result2 = simplify(q2.to_rotation_matrix())\n+        expected2 = Matrix([\n+            [1,  0,  0],\n+            [0,  0, -1],\n+            [0,  1,  0]\n+        ])\n+        assert result2 == expected2\n+\n+    def test_numerical_consistency(self):\n+        \"\"\"Test numerical consistency with specific values.\"\"\"\n+        # Test with pi/6 rotation around x-axis\n+        q = Quaternion(cos(pi/12), sin(pi/12), 0, 0)\n+        result = q.to_rotation_matrix()\n+        \n+        # Check that the matrix is orthogonal\n+        product = simplify(result * result.T)\n+        identity = Matrix([\n+            [1, 0, 0],\n+            [0, 1, 0],\n+            [0, 0, 1]\n+        ])\n+        assert product == identity\n+        \n+        # Check determinant is 1\n+        assert simplify(result.det()) == 1\n"
}