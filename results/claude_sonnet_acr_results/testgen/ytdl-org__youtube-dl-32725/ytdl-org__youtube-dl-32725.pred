{
  "instance_id": "ytdl-org__youtube-dl-32725",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>test/test_filemoon.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport pytest\nimport re\nfrom youtube_dl.extractor.filemoon import FileMoonIE\nfrom youtube_dl.utils import RegexNotFoundError, decode_packed_codes, js_to_json\n\n\nclass TestFileMoonIE:\n    \"\"\"Test suite for FileMoon extractor focusing on jwplayer source extraction.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Setup test fixtures.\"\"\"\n        self.ie = FileMoonIE()\n        \n    def test_jwplayer_regex_fails_with_current_pattern(self):\n        \"\"\"Test that demonstrates the bug - current regex pattern fails on new format.\"\"\"\n        # Simulate the unpacked JavaScript that might be found on current filemoon.sx\n        unpacked_js_new_format = '''\n        var player = jwplayer(\"video-player\");\n        player.setup({\n            width: \"100%\",\n            height: \"100%\",\n            autostart: false,\n            sources: [{\n                file: \"https://example.com/video.mp4\",\n                type: \"mp4\",\n                label: \"720p\"\n            }],\n            tracks: []\n        });\n        '''\n        \n        # Current regex pattern from the extractor\n        current_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\(\\s*\\{\\s*sources\\s*:\\s*(.*?])'\n        \n        # This should fail to match the new format\n        match = re.search(current_pattern, unpacked_js_new_format)\n        assert match is None, \"Current regex should fail on new format\"\n        \n    def test_jwplayer_regex_fails_with_properties_before_sources(self):\n        \"\"\"Test that current regex fails when other properties come before sources.\"\"\"\n        unpacked_js_with_props_first = '''\n        player.setup({\n            width: \"100%\",\n            height: \"100%\",\n            sources: [{\"file\": \"https://example.com/video.mp4\", \"type\": \"mp4\"}]\n        });\n        '''\n        \n        current_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\(\\s*\\{\\s*sources\\s*:\\s*(.*?])'\n        match = re.search(current_pattern, unpacked_js_with_props_first)\n        assert match is None, \"Current regex should fail when sources is not first property\"\n        \n    def test_jwplayer_regex_works_with_original_format(self):\n        \"\"\"Test that current regex works with the original expected format.\"\"\"\n        unpacked_js_original_format = '''\n        player.setup({sources: [{\"file\": \"https://example.com/video.mp4\", \"type\": \"mp4\"}]});\n        '''\n        \n        current_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\(\\s*\\{\\s*sources\\s*:\\s*(.*?])'\n        match = re.search(current_pattern, unpacked_js_original_format)\n        assert match is not None, \"Current regex should work with original format\"\n        assert '\"file\": \"https://example.com/video.mp4\"' in match.group(1)\n        \n    def test_improved_jwplayer_regex_handles_new_format(self):\n        \"\"\"Test that an improved regex pattern can handle the new format.\"\"\"\n        unpacked_js_new_format = '''\n        var player = jwplayer(\"video-player\");\n        player.setup({\n            width: \"100%\",\n            height: \"100%\",\n            autostart: false,\n            sources: [{\n                file: \"https://example.com/video.mp4\",\n                type: \"mp4\",\n                label: \"720p\"\n            }],\n            tracks: []\n        });\n        '''\n        \n        # Improved regex pattern that looks for sources anywhere in the setup call\n        improved_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n        match = re.search(improved_pattern, unpacked_js_new_format)\n        assert match is not None, \"Improved regex should handle new format\"\n        assert '\"file\": \"https://example.com/video.mp4\"' in match.group(1)\n        \n    def test_improved_jwplayer_regex_handles_properties_before_sources(self):\n        \"\"\"Test that improved regex handles other properties before sources.\"\"\"\n        unpacked_js_with_props_first = '''\n        player.setup({\n            width: \"100%\",\n            height: \"100%\",\n            sources: [{\"file\": \"https://example.com/video.mp4\", \"type\": \"mp4\"}],\n            autostart: false\n        });\n        '''\n        \n        improved_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n        match = re.search(improved_pattern, unpacked_js_with_props_first)\n        assert match is not None, \"Improved regex should handle properties before sources\"\n        assert '\"file\": \"https://example.com/video.mp4\"' in match.group(1)\n        \n    def test_improved_jwplayer_regex_maintains_backward_compatibility(self):\n        \"\"\"Test that improved regex still works with original format.\"\"\"\n        unpacked_js_original_format = '''\n        player.setup({sources: [{\"file\": \"https://example.com/video.mp4\", \"type\": \"mp4\"}]});\n        '''\n        \n        improved_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n        match = re.search(improved_pattern, unpacked_js_original_format)\n        assert match is not None, \"Improved regex should maintain backward compatibility\"\n        assert '\"file\": \"https://example.com/video.mp4\"' in match.group(1)\n        \n    def test_multiple_fallback_patterns(self):\n        \"\"\"Test using multiple fallback patterns for maximum compatibility.\"\"\"\n        test_cases = [\n            # Original format\n            'player.setup({sources: [{\"file\": \"test.mp4\"}]});',\n            # Properties before sources\n            'player.setup({width: \"100%\", sources: [{\"file\": \"test.mp4\"}]});',\n            # Multiline with extra whitespace\n            '''player.setup({\n                width: \"100%\",\n                sources: [{\"file\": \"test.mp4\"}]\n            });''',\n            # Different variable name\n            'jwplayer(\"id\").setup({sources: [{\"file\": \"test.mp4\"}]});'\n        ]\n        \n        fallback_patterns = [\n            r'(?s)player\\s*\\.\\s*setup\\s*\\(\\s*\\{\\s*sources\\s*:\\s*(\\[.*?\\])',  # Original\n            r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])',     # Improved\n            r'(?s)jwplayer\\([^)]*\\)\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])',  # jwplayer() call\n            r'(?s)sources\\s*:\\s*(\\[.*?\\])'  # Just find sources anywhere\n        ]\n        \n        for test_js in test_cases:\n            found_match = False\n            for pattern in fallback_patterns:\n                match = re.search(pattern, test_js)\n                if match:\n                    assert '\"file\": \"test.mp4\"' in match.group(1)\n                    found_match = True\n                    break\n            assert found_match, f\"No pattern matched for: {test_js}\"\n            \n    def test_real_extract_with_mock_webpage_old_format(self, mocker):\n        \"\"\"Test _real_extract with mocked webpage containing old format.\"\"\"\n        # Mock the webpage download\n        mock_webpage = '''\n        <script>\n        eval(function(p,a,c,k,e,d){return p}('player.setup({sources:[{\"file\":\"test.mp4\"}]});',0,0,''.split('|'),0,{}))\n        </script>\n        '''\n        \n        mocker.patch.object(self.ie, '_download_webpage', return_value=mock_webpage)\n        mocker.patch.object(self.ie, '_match_id', return_value='test_id')\n        mocker.patch('youtube_dl.extractor.filemoon.decode_packed_codes', \n                    return_value='player.setup({sources:[{\"file\":\"test.mp4\",\"type\":\"mp4\"}]});')\n        mocker.patch.object(self.ie, '_parse_jwplayer_formats', return_value=[{'url': 'test.mp4'}])\n        mocker.patch.object(self.ie, '_generic_title', return_value='Test Video')\n        \n        # This should work with the original format\n        result = self.ie._real_extract('https://filemoon.sx/e/test_id')\n        assert result['id'] == 'test_id'\n        assert result['title'] == 'Test Video'\n        \n    def test_real_extract_fails_with_new_format_current_regex(self, mocker):\n        \"\"\"Test that _real_extract fails with new format using current regex.\"\"\"\n        # Mock the webpage download with new format\n        mock_webpage = '''\n        <script>\n        eval(function(p,a,c,k,e,d){return p}('var player = jwplayer(\"id\"); player.setup({width:\"100%\",sources:[{\"file\":\"test.mp4\"}]});',0,0,''.split('|'),0,{}))\n        </script>\n        '''\n        \n        mocker.patch.object(self.ie, '_download_webpage', return_value=mock_webpage)\n        mocker.patch.object(self.ie, '_match_id', return_value='test_id')\n        mocker.patch('youtube_dl.extractor.filemoon.decode_packed_codes', \n                    return_value='var player = jwplayer(\"id\"); player.setup({width:\"100%\",sources:[{\"file\":\"test.mp4\",\"type\":\"mp4\"}]});')\n        \n        # This should fail with RegexNotFoundError due to current regex\n        with pytest.raises(RegexNotFoundError) as exc_info:\n            self.ie._real_extract('https://filemoon.sx/e/test_id')\n        \n        assert 'Unable to extract jwplayer sources' in str(exc_info.value)\n        \n    def test_edge_case_empty_sources_array(self):\n        \"\"\"Test handling of empty sources array.\"\"\"\n        unpacked_js_empty_sources = 'player.setup({sources: []});'\n        \n        pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n        match = re.search(pattern, unpacked_js_empty_sources)\n        assert match is not None\n        assert match.group(1) == '[]'\n        \n    def test_edge_case_malformed_javascript(self):\n        \"\"\"Test handling of malformed JavaScript.\"\"\"\n        malformed_js_cases = [\n            'player.setup({sources:',  # Incomplete\n            'player.setup({sources: [}',  # Malformed array\n            'player.setup(sources: [])',  # Missing braces\n            ''  # Empty string\n        ]\n        \n        pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n        \n        for malformed_js in malformed_js_cases:\n            match = re.search(pattern, malformed_js)\n            # Should not match malformed JavaScript\n            assert match is None, f\"Should not match malformed JS: {malformed_js}\"\n            \n    def test_edge_case_nested_objects_in_sources(self):\n        \"\"\"Test handling of complex nested objects in sources array.\"\"\"\n        complex_sources_js = '''\n        player.setup({\n            sources: [{\n                file: \"test.mp4\",\n                tracks: [\n                    {kind: \"captions\", file: \"captions.vtt\"}\n                ],\n                metadata: {\n                    title: \"Test Video\",\n                    nested: {\n                        property: \"value\"\n                    }\n                }\n            }]\n        });\n        '''\n        \n        pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n        match = re.search(pattern, complex_sources_js)\n        assert match is not None\n        sources_content = match.group(1)\n        assert 'file: \"test.mp4\"' in sources_content\n        assert 'tracks:' in sources_content\n        assert 'metadata:' in sources_content\n</patched>\n```",
  "patch": "--- a/test/test_filemoon.py\n+++ b/test/test_filemoon.py\n-# Empty if creating new file\n+# coding: utf-8\n+from __future__ import unicode_literals\n+\n+import pytest\n+import re\n+from youtube_dl.extractor.filemoon import FileMoonIE\n+from youtube_dl.utils import RegexNotFoundError, decode_packed_codes, js_to_json\n+\n+\n+class TestFileMoonIE:\n+    \"\"\"Test suite for FileMoon extractor focusing on jwplayer source extraction.\"\"\"\n+    \n+    def setup_method(self):\n+        \"\"\"Setup test fixtures.\"\"\"\n+        self.ie = FileMoonIE()\n+        \n+    def test_jwplayer_regex_fails_with_current_pattern(self):\n+        \"\"\"Test that demonstrates the bug - current regex pattern fails on new format.\"\"\"\n+        # Simulate the unpacked JavaScript that might be found on current filemoon.sx\n+        unpacked_js_new_format = '''\n+        var player = jwplayer(\"video-player\");\n+        player.setup({\n+            width: \"100%\",\n+            height: \"100%\",\n+            autostart: false,\n+            sources: [{\n+                file: \"https://example.com/video.mp4\",\n+                type: \"mp4\",\n+                label: \"720p\"\n+            }],\n+            tracks: []\n+        });\n+        '''\n+        \n+        # Current regex pattern from the extractor\n+        current_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\(\\s*\\{\\s*sources\\s*:\\s*(.*?])'\n+        \n+        # This should fail to match the new format\n+        match = re.search(current_pattern, unpacked_js_new_format)\n+        assert match is None, \"Current regex should fail on new format\"\n+        \n+    def test_jwplayer_regex_fails_with_properties_before_sources(self):\n+        \"\"\"Test that current regex fails when other properties come before sources.\"\"\"\n+        unpacked_js_with_props_first = '''\n+        player.setup({\n+            width: \"100%\",\n+            height: \"100%\",\n+            sources: [{\"file\": \"https://example.com/video.mp4\", \"type\": \"mp4\"}]\n+        });\n+        '''\n+        \n+        current_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\(\\s*\\{\\s*sources\\s*:\\s*(.*?])'\n+        match = re.search(current_pattern, unpacked_js_with_props_first)\n+        assert match is None, \"Current regex should fail when sources is not first property\"\n+        \n+    def test_jwplayer_regex_works_with_original_format(self):\n+        \"\"\"Test that current regex works with the original expected format.\"\"\"\n+        unpacked_js_original_format = '''\n+        player.setup({sources: [{\"file\": \"https://example.com/video.mp4\", \"type\": \"mp4\"}]});\n+        '''\n+        \n+        current_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\(\\s*\\{\\s*sources\\s*:\\s*(.*?])'\n+        match = re.search(current_pattern, unpacked_js_original_format)\n+        assert match is not None, \"Current regex should work with original format\"\n+        assert '\"file\": \"https://example.com/video.mp4\"' in match.group(1)\n+        \n+    def test_improved_jwplayer_regex_handles_new_format(self):\n+        \"\"\"Test that an improved regex pattern can handle the new format.\"\"\"\n+        unpacked_js_new_format = '''\n+        var player = jwplayer(\"video-player\");\n+        player.setup({\n+            width: \"100%\",\n+            height: \"100%\",\n+            autostart: false,\n+            sources: [{\n+                file: \"https://example.com/video.mp4\",\n+                type: \"mp4\",\n+                label: \"720p\"\n+            }],\n+            tracks: []\n+        });\n+        '''\n+        \n+        # Improved regex pattern that looks for sources anywhere in the setup call\n+        improved_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n+        match = re.search(improved_pattern, unpacked_js_new_format)\n+        assert match is not None, \"Improved regex should handle new format\"\n+        assert '\"file\": \"https://example.com/video.mp4\"' in match.group(1)\n+        \n+    def test_improved_jwplayer_regex_handles_properties_before_sources(self):\n+        \"\"\"Test that improved regex handles other properties before sources.\"\"\"\n+        unpacked_js_with_props_first = '''\n+        player.setup({\n+            width: \"100%\",\n+            height: \"100%\",\n+            sources: [{\"file\": \"https://example.com/video.mp4\", \"type\": \"mp4\"}],\n+            autostart: false\n+        });\n+        '''\n+        \n+        improved_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n+        match = re.search(improved_pattern, unpacked_js_with_props_first)\n+        assert match is not None, \"Improved regex should handle properties before sources\"\n+        assert '\"file\": \"https://example.com/video.mp4\"' in match.group(1)\n+        \n+    def test_improved_jwplayer_regex_maintains_backward_compatibility(self):\n+        \"\"\"Test that improved regex still works with original format.\"\"\"\n+        unpacked_js_original_format = '''\n+        player.setup({sources: [{\"file\": \"https://example.com/video.mp4\", \"type\": \"mp4\"}]});\n+        '''\n+        \n+        improved_pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n+        match = re.search(improved_pattern, unpacked_js_original_format)\n+        assert match is not None, \"Improved regex should maintain backward compatibility\"\n+        assert '\"file\": \"https://example.com/video.mp4\"' in match.group(1)\n+        \n+    def test_multiple_fallback_patterns(self):\n+        \"\"\"Test using multiple fallback patterns for maximum compatibility.\"\"\"\n+        test_cases = [\n+            # Original format\n+            'player.setup({sources: [{\"file\": \"test.mp4\"}]});',\n+            # Properties before sources\n+            'player.setup({width: \"100%\", sources: [{\"file\": \"test.mp4\"}]});',\n+            # Multiline with extra whitespace\n+            '''player.setup({\n+                width: \"100%\",\n+                sources: [{\"file\": \"test.mp4\"}]\n+            });''',\n+            # Different variable name\n+            'jwplayer(\"id\").setup({sources: [{\"file\": \"test.mp4\"}]});'\n+        ]\n+        \n+        fallback_patterns = [\n+            r'(?s)player\\s*\\.\\s*setup\\s*\\(\\s*\\{\\s*sources\\s*:\\s*(\\[.*?\\])',  # Original\n+            r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])',     # Improved\n+            r'(?s)jwplayer\\([^)]*\\)\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])',  # jwplayer() call\n+            r'(?s)sources\\s*:\\s*(\\[.*?\\])'  # Just find sources anywhere\n+        ]\n+        \n+        for test_js in test_cases:\n+            found_match = False\n+            for pattern in fallback_patterns:\n+                match = re.search(pattern, test_js)\n+                if match:\n+                    assert '\"file\": \"test.mp4\"' in match.group(1)\n+                    found_match = True\n+                    break\n+            assert found_match, f\"No pattern matched for: {test_js}\"\n+            \n+    def test_real_extract_with_mock_webpage_old_format(self, mocker):\n+        \"\"\"Test _real_extract with mocked webpage containing old format.\"\"\"\n+        # Mock the webpage download\n+        mock_webpage = '''\n+        <script>\n+        eval(function(p,a,c,k,e,d){return p}('player.setup({sources:[{\"file\":\"test.mp4\"}]});',0,0,''.split('|'),0,{}))\n+        </script>\n+        '''\n+        \n+        mocker.patch.object(self.ie, '_download_webpage', return_value=mock_webpage)\n+        mocker.patch.object(self.ie, '_match_id', return_value='test_id')\n+        mocker.patch('youtube_dl.extractor.filemoon.decode_packed_codes', \n+                    return_value='player.setup({sources:[{\"file\":\"test.mp4\",\"type\":\"mp4\"}]});')\n+        mocker.patch.object(self.ie, '_parse_jwplayer_formats', return_value=[{'url': 'test.mp4'}])\n+        mocker.patch.object(self.ie, '_generic_title', return_value='Test Video')\n+        \n+        # This should work with the original format\n+        result = self.ie._real_extract('https://filemoon.sx/e/test_id')\n+        assert result['id'] == 'test_id'\n+        assert result['title'] == 'Test Video'\n+        \n+    def test_real_extract_fails_with_new_format_current_regex(self, mocker):\n+        \"\"\"Test that _real_extract fails with new format using current regex.\"\"\"\n+        # Mock the webpage download with new format\n+        mock_webpage = '''\n+        <script>\n+        eval(function(p,a,c,k,e,d){return p}('var player = jwplayer(\"id\"); player.setup({width:\"100%\",sources:[{\"file\":\"test.mp4\"}]});',0,0,''.split('|'),0,{}))\n+        </script>\n+        '''\n+        \n+        mocker.patch.object(self.ie, '_download_webpage', return_value=mock_webpage)\n+        mocker.patch.object(self.ie, '_match_id', return_value='test_id')\n+        mocker.patch('youtube_dl.extractor.filemoon.decode_packed_codes', \n+                    return_value='var player = jwplayer(\"id\"); player.setup({width:\"100%\",sources:[{\"file\":\"test.mp4\",\"type\":\"mp4\"}]});')\n+        \n+        # This should fail with RegexNotFoundError due to current regex\n+        with pytest.raises(RegexNotFoundError) as exc_info:\n+            self.ie._real_extract('https://filemoon.sx/e/test_id')\n+        \n+        assert 'Unable to extract jwplayer sources' in str(exc_info.value)\n+        \n+    def test_edge_case_empty_sources_array(self):\n+        \"\"\"Test handling of empty sources array.\"\"\"\n+        unpacked_js_empty_sources = 'player.setup({sources: []});'\n+        \n+        pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n+        match = re.search(pattern, unpacked_js_empty_sources)\n+        assert match is not None\n+        assert match.group(1) == '[]'\n+        \n+    def test_edge_case_malformed_javascript(self):\n+        \"\"\"Test handling of malformed JavaScript.\"\"\"\n+        malformed_js_cases = [\n+            'player.setup({sources:',  # Incomplete\n+            'player.setup({sources: [}',  # Malformed array\n+            'player.setup(sources: [])',  # Missing braces\n+            ''  # Empty string\n+        ]\n+        \n+        pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n+        \n+        for malformed_js in malformed_js_cases:\n+            match = re.search(pattern, malformed_js)\n+            # Should not match malformed JavaScript\n+            assert match is None, f\"Should not match malformed JS: {malformed_js}\"\n+            \n+    def test_edge_case_nested_objects_in_sources(self):\n+        \"\"\"Test handling of complex nested objects in sources array.\"\"\"\n+        complex_sources_js = '''\n+        player.setup({\n+            sources: [{\n+                file: \"test.mp4\",\n+                tracks: [\n+                    {kind: \"captions\", file: \"captions.vtt\"}\n+                ],\n+                metadata: {\n+                    title: \"Test Video\",\n+                    nested: {\n+                        property: \"value\"\n+                    }\n+                }\n+            }]\n+        });\n+        '''\n+        \n+        pattern = r'(?s)player\\s*\\.\\s*setup\\s*\\([^}]*sources\\s*:\\s*(\\[.*?\\])'\n+        match = re.search(pattern, complex_sources_js)\n+        assert match is not None\n+        sources_content = match.group(1)\n+        assert 'file: \"test.mp4\"' in sources_content\n+        assert 'tracks:' in sources_content\n+        assert 'metadata:' in sources_content\n"
}