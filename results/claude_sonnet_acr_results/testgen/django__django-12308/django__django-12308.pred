{
  "instance_id": "django__django-12308",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/admin_utils/test_display_for_field.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport json\nimport pytest\nfrom django.contrib.admin.utils import display_for_field\nfrom django.db import models\nfrom django.forms.fields import InvalidJSONInput\nfrom django.test import TestCase\n\n\nclass TestJSONFieldDisplayForField(TestCase):\n    \"\"\"Test cases for JSONField display in admin when readonly.\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        self.empty_value_display = '-'\n        \n        # Create a mock JSONField instance\n        self.json_field = models.JSONField()\n        \n    def test_display_for_field_json_dict_value(self):\n        \"\"\"Test that JSONField dict values are displayed as valid JSON strings.\"\"\"\n        value = {\"foo\": \"bar\", \"nested\": {\"key\": \"value\"}}\n        \n        result = display_for_field(value, self.json_field, self.empty_value_display)\n        \n        # Should return valid JSON string, not Python dict representation\n        expected = '{\"foo\": \"bar\", \"nested\": {\"key\": \"value\"}}'\n        self.assertEqual(result, expected)\n        \n        # Verify it's valid JSON\n        self.assertEqual(json.loads(result), value)\n        \n    def test_display_for_field_json_list_value(self):\n        \"\"\"Test that JSONField list values are displayed as valid JSON strings.\"\"\"\n        value = [1, 2, {\"key\": \"value\"}, \"string\"]\n        \n        result = display_for_field(value, self.json_field, self.empty_value_display)\n        \n        # Should return valid JSON string\n        expected = '[1, 2, {\"key\": \"value\"}, \"string\"]'\n        self.assertEqual(result, expected)\n        \n        # Verify it's valid JSON\n        self.assertEqual(json.loads(result), value)\n        \n    def test_display_for_field_json_string_value(self):\n        \"\"\"Test that JSONField string values are displayed as valid JSON strings.\"\"\"\n        value = \"simple string\"\n        \n        result = display_for_field(value, self.json_field, self.empty_value_display)\n        \n        # Should return valid JSON string with quotes\n        expected = '\"simple string\"'\n        self.assertEqual(result, expected)\n        \n        # Verify it's valid JSON\n        self.assertEqual(json.loads(result), value)\n        \n    def test_display_for_field_json_number_value(self):\n        \"\"\"Test that JSONField number values are displayed as valid JSON strings.\"\"\"\n        value = 42\n        \n        result = display_for_field(value, self.json_field, self.empty_value_display)\n        \n        # Should return valid JSON string\n        expected = '42'\n        self.assertEqual(result, expected)\n        \n        # Verify it's valid JSON\n        self.assertEqual(json.loads(result), value)\n        \n    def test_display_for_field_json_boolean_value(self):\n        \"\"\"Test that JSONField boolean values are displayed as valid JSON strings.\"\"\"\n        value = True\n        \n        result = display_for_field(value, self.json_field, self.empty_value_display)\n        \n        # Should return valid JSON string (lowercase 'true')\n        expected = 'true'\n        self.assertEqual(result, expected)\n        \n        # Verify it's valid JSON\n        self.assertEqual(json.loads(result), value)\n        \n    def test_display_for_field_json_null_value(self):\n        \"\"\"Test that JSONField null values are displayed correctly.\"\"\"\n        value = None\n        \n        result = display_for_field(value, self.json_field, self.empty_value_display)\n        \n        # Should return empty_value_display for None\n        self.assertEqual(result, self.empty_value_display)\n        \n    def test_display_for_field_json_with_custom_encoder(self):\n        \"\"\"Test that JSONField with custom encoder works correctly.\"\"\"\n        import decimal\n        \n        class DecimalEncoder(json.JSONEncoder):\n            def default(self, obj):\n                if isinstance(obj, decimal.Decimal):\n                    return float(obj)\n                return super().default(obj)\n        \n        json_field_with_encoder = models.JSONField(encoder=DecimalEncoder)\n        value = {\"price\": decimal.Decimal(\"19.99\")}\n        \n        result = display_for_field(value, json_field_with_encoder, self.empty_value_display)\n        \n        # Should use the custom encoder\n        expected = '{\"price\": 19.99}'\n        self.assertEqual(result, expected)\n        \n    def test_display_for_field_json_invalid_json_input(self):\n        \"\"\"Test that InvalidJSONInput is handled correctly.\"\"\"\n        # This test demonstrates the bug - before the fix, this would fail\n        # because display_for_field doesn't handle JSONField specially\n        \n        # Simulate what happens when forms.JSONField.bound_data encounters invalid JSON\n        invalid_json_value = InvalidJSONInput('{\"invalid\": json}')\n        \n        result = display_for_field(invalid_json_value, self.json_field, self.empty_value_display)\n        \n        # Should return the raw string value for InvalidJSONInput\n        expected = '{\"invalid\": json}'\n        self.assertEqual(result, expected)\n        \n    def test_display_for_field_json_complex_nested_structure(self):\n        \"\"\"Test that complex nested JSON structures are displayed correctly.\"\"\"\n        value = {\n            \"users\": [\n                {\"id\": 1, \"name\": \"John\", \"active\": True},\n                {\"id\": 2, \"name\": \"Jane\", \"active\": False}\n            ],\n            \"metadata\": {\n                \"total\": 2,\n                \"page\": 1,\n                \"filters\": None\n            }\n        }\n        \n        result = display_for_field(value, self.json_field, self.empty_value_display)\n        \n        # Should return valid JSON string\n        parsed_result = json.loads(result)\n        self.assertEqual(parsed_result, value)\n        \n        # Verify specific formatting (JSON uses double quotes, not single quotes)\n        self.assertIn('\"users\":', result)\n        self.assertIn('\"name\": \"John\"', result)\n        self.assertIn('\"active\": true', result)  # JSON boolean is lowercase\n        self.assertIn('\"active\": false', result)\n        \n    def test_display_for_field_preserves_other_field_types(self):\n        \"\"\"Test that the fix doesn't break existing functionality for other field types.\"\"\"\n        # Test that other field types still work as expected\n        \n        # BooleanField\n        bool_field = models.BooleanField()\n        result = display_for_field(True, bool_field, self.empty_value_display)\n        # This should use the _boolean_icon, but we'll just check it's not JSON formatted\n        self.assertNotEqual(result, 'true')  # Should not be JSON formatted\n        \n        # CharField\n        char_field = models.CharField()\n        result = display_for_field(\"test string\", char_field, self.empty_value_display)\n        self.assertEqual(result, \"test string\")  # Should not be JSON formatted\n        \n        # IntegerField\n        int_field = models.IntegerField()\n        result = display_for_field(42, int_field, self.empty_value_display)\n        # Should be formatted as number, not JSON\n        self.assertIsInstance(result, str)\n        \n    def test_display_for_field_json_demonstrates_bug_before_fix(self):\n        \"\"\"\n        This test demonstrates the bug that exists before the fix is applied.\n        \n        Before the fix, JSONField values fall through to display_for_value(),\n        which calls str() on the value, resulting in Python dict representation\n        with single quotes instead of valid JSON with double quotes.\n        \"\"\"\n        value = {\"foo\": \"bar\"}\n        \n        # This test will fail before the fix is applied\n        result = display_for_field(value, self.json_field, self.empty_value_display)\n        \n        # The bug: without the fix, this would return \"{'foo': 'bar'}\" (Python dict repr)\n        # With the fix: this should return '{\"foo\": \"bar\"}' (valid JSON)\n        \n        # Test that result is valid JSON (this will fail before fix)\n        try:\n            parsed = json.loads(result)\n            self.assertEqual(parsed, value)\n        except json.JSONDecodeError:\n            self.fail(f\"Result '{result}' is not valid JSON. This indicates the bug is present.\")\n            \n        # Test that result uses double quotes, not single quotes\n        self.assertIn('\"foo\":', result)\n        self.assertIn('\"bar\"', result)\n        self.assertNotIn(\"'foo':\", result)\n        self.assertNotIn(\"'bar'\", result)\n</patched>\n```",
  "patch": "--- a/tests/admin_utils/test_display_for_field.py\n+++ b/tests/admin_utils/test_display_for_field.py\n-# Empty if creating new file\n+import json\n+import pytest\n+from django.contrib.admin.utils import display_for_field\n+from django.db import models\n+from django.forms.fields import InvalidJSONInput\n+from django.test import TestCase\n+\n+\n+class TestJSONFieldDisplayForField(TestCase):\n+    \"\"\"Test cases for JSONField display in admin when readonly.\"\"\"\n+\n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        self.empty_value_display = '-'\n+        \n+        # Create a mock JSONField instance\n+        self.json_field = models.JSONField()\n+        \n+    def test_display_for_field_json_dict_value(self):\n+        \"\"\"Test that JSONField dict values are displayed as valid JSON strings.\"\"\"\n+        value = {\"foo\": \"bar\", \"nested\": {\"key\": \"value\"}}\n+        \n+        result = display_for_field(value, self.json_field, self.empty_value_display)\n+        \n+        # Should return valid JSON string, not Python dict representation\n+        expected = '{\"foo\": \"bar\", \"nested\": {\"key\": \"value\"}}'\n+        self.assertEqual(result, expected)\n+        \n+        # Verify it's valid JSON\n+        self.assertEqual(json.loads(result), value)\n+        \n+    def test_display_for_field_json_list_value(self):\n+        \"\"\"Test that JSONField list values are displayed as valid JSON strings.\"\"\"\n+        value = [1, 2, {\"key\": \"value\"}, \"string\"]\n+        \n+        result = display_for_field(value, self.json_field, self.empty_value_display)\n+        \n+        # Should return valid JSON string\n+        expected = '[1, 2, {\"key\": \"value\"}, \"string\"]'\n+        self.assertEqual(result, expected)\n+        \n+        # Verify it's valid JSON\n+        self.assertEqual(json.loads(result), value)\n+        \n+    def test_display_for_field_json_string_value(self):\n+        \"\"\"Test that JSONField string values are displayed as valid JSON strings.\"\"\"\n+        value = \"simple string\"\n+        \n+        result = display_for_field(value, self.json_field, self.empty_value_display)\n+        \n+        # Should return valid JSON string with quotes\n+        expected = '\"simple string\"'\n+        self.assertEqual(result, expected)\n+        \n+        # Verify it's valid JSON\n+        self.assertEqual(json.loads(result), value)\n+        \n+    def test_display_for_field_json_number_value(self):\n+        \"\"\"Test that JSONField number values are displayed as valid JSON strings.\"\"\"\n+        value = 42\n+        \n+        result = display_for_field(value, self.json_field, self.empty_value_display)\n+        \n+        # Should return valid JSON string\n+        expected = '42'\n+        self.assertEqual(result, expected)\n+        \n+        # Verify it's valid JSON\n+        self.assertEqual(json.loads(result), value)\n+        \n+    def test_display_for_field_json_boolean_value(self):\n+        \"\"\"Test that JSONField boolean values are displayed as valid JSON strings.\"\"\"\n+        value = True\n+        \n+        result = display_for_field(value, self.json_field, self.empty_value_display)\n+        \n+        # Should return valid JSON string (lowercase 'true')\n+        expected = 'true'\n+        self.assertEqual(result, expected)\n+        \n+        # Verify it's valid JSON\n+        self.assertEqual(json.loads(result), value)\n+        \n+    def test_display_for_field_json_null_value(self):\n+        \"\"\"Test that JSONField null values are displayed correctly.\"\"\"\n+        value = None\n+        \n+        result = display_for_field(value, self.json_field, self.empty_value_display)\n+        \n+        # Should return empty_value_display for None\n+        self.assertEqual(result, self.empty_value_display)\n+        \n+    def test_display_for_field_json_with_custom_encoder(self):\n+        \"\"\"Test that JSONField with custom encoder works correctly.\"\"\"\n+        import decimal\n+        \n+        class DecimalEncoder(json.JSONEncoder):\n+            def default(self, obj):\n+                if isinstance(obj, decimal.Decimal):\n+                    return float(obj)\n+                return super().default(obj)\n+        \n+        json_field_with_encoder = models.JSONField(encoder=DecimalEncoder)\n+        value = {\"price\": decimal.Decimal(\"19.99\")}\n+        \n+        result = display_for_field(value, json_field_with_encoder, self.empty_value_display)\n+        \n+        # Should use the custom encoder\n+        expected = '{\"price\": 19.99}'\n+        self.assertEqual(result, expected)\n+        \n+    def test_display_for_field_json_invalid_json_input(self):\n+        \"\"\"Test that InvalidJSONInput is handled correctly.\"\"\"\n+        # This test demonstrates the bug - before the fix, this would fail\n+        # because display_for_field doesn't handle JSONField specially\n+        \n+        # Simulate what happens when forms.JSONField.bound_data encounters invalid JSON\n+        invalid_json_value = InvalidJSONInput('{\"invalid\": json}')\n+        \n+        result = display_for_field(invalid_json_value, self.json_field, self.empty_value_display)\n+        \n+        # Should return the raw string value for InvalidJSONInput\n+        expected = '{\"invalid\": json}'\n+        self.assertEqual(result, expected)\n+        \n+    def test_display_for_field_json_complex_nested_structure(self):\n+        \"\"\"Test that complex nested JSON structures are displayed correctly.\"\"\"\n+        value = {\n+            \"users\": [\n+                {\"id\": 1, \"name\": \"John\", \"active\": True},\n+                {\"id\": 2, \"name\": \"Jane\", \"active\": False}\n+            ],\n+            \"metadata\": {\n+                \"total\": 2,\n+                \"page\": 1,\n+                \"filters\": None\n+            }\n+        }\n+        \n+        result = display_for_field(value, self.json_field, self.empty_value_display)\n+        \n+        # Should return valid JSON string\n+        parsed_result = json.loads(result)\n+        self.assertEqual(parsed_result, value)\n+        \n+        # Verify specific formatting (JSON uses double quotes, not single quotes)\n+        self.assertIn('\"users\":', result)\n+        self.assertIn('\"name\": \"John\"', result)\n+        self.assertIn('\"active\": true', result)  # JSON boolean is lowercase\n+        self.assertIn('\"active\": false', result)\n+        \n+    def test_display_for_field_preserves_other_field_types(self):\n+        \"\"\"Test that the fix doesn't break existing functionality for other field types.\"\"\"\n+        # Test that other field types still work as expected\n+        \n+        # BooleanField\n+        bool_field = models.BooleanField()\n+        result = display_for_field(True, bool_field, self.empty_value_display)\n+        # This should use the _boolean_icon, but we'll just check it's not JSON formatted\n+        self.assertNotEqual(result, 'true')  # Should not be JSON formatted\n+        \n+        # CharField\n+        char_field = models.CharField()\n+        result = display_for_field(\"test string\", char_field, self.empty_value_display)\n+        self.assertEqual(result, \"test string\")  # Should not be JSON formatted\n+        \n+        # IntegerField\n+        int_field = models.IntegerField()\n+        result = display_for_field(42, int_field, self.empty_value_display)\n+        # Should be formatted as number, not JSON\n+        self.assertIsInstance(result, str)\n+        \n+    def test_display_for_field_json_demonstrates_bug_before_fix(self):\n+        \"\"\"\n+        This test demonstrates the bug that exists before the fix is applied.\n+        \n+        Before the fix, JSONField values fall through to display_for_value(),\n+        which calls str() on the value, resulting in Python dict representation\n+        with single quotes instead of valid JSON with double quotes.\n+        \"\"\"\n+        value = {\"foo\": \"bar\"}\n+        \n+        # This test will fail before the fix is applied\n+        result = display_for_field(value, self.json_field, self.empty_value_display)\n+        \n+        # The bug: without the fix, this would return \"{'foo': 'bar'}\" (Python dict repr)\n+        # With the fix: this should return '{\"foo\": \"bar\"}' (valid JSON)\n+        \n+        # Test that result is valid JSON (this will fail before fix)\n+        try:\n+            parsed = json.loads(result)\n+            self.assertEqual(parsed, value)\n+        except json.JSONDecodeError:\n+            self.fail(f\"Result '{result}' is not valid JSON. This indicates the bug is present.\")\n+            \n+        # Test that result uses double quotes, not single quotes\n+        self.assertIn('\"foo\":', result)\n+        self.assertIn('\"bar\"', result)\n+        self.assertNotIn(\"'foo':\", result)\n+        self.assertNotIn(\"'bar'\", result)\n"
}