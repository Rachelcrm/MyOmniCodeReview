{
  "instance_id": "django__django-15127",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/messages_tests/test_level_tags_override_settings.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib.messages import constants\nfrom django.contrib.messages.storage.base import Message\nfrom django.test import TestCase, override_settings\n\n\nclass LevelTagsOverrideSettingsTest(TestCase):\n    \"\"\"Test that LEVEL_TAGS are updated when using @override_settings.\"\"\"\n\n    def test_level_tag_with_default_settings(self):\n        \"\"\"Test that level_tag works with default MESSAGE_TAGS.\"\"\"\n        message = Message(constants.INFO, \"Test message\")\n        self.assertEqual(message.level_tag, \"info\")\n        \n        message = Message(constants.ERROR, \"Error message\")\n        self.assertEqual(message.level_tag, \"error\")\n        \n        message = Message(constants.WARNING, \"Warning message\")\n        self.assertEqual(message.level_tag, \"warning\")\n\n    def test_level_tag_with_unknown_level_returns_empty_string(self):\n        \"\"\"Test that level_tag returns empty string for unknown levels.\"\"\"\n        # Use a level that doesn't exist in DEFAULT_TAGS\n        unknown_level = 999\n        message = Message(unknown_level, \"Unknown level message\")\n        self.assertEqual(message.level_tag, \"\")\n\n    @override_settings(MESSAGE_TAGS={\n        constants.INFO: 'custom-info',\n        constants.ERROR: 'custom-error',\n        constants.WARNING: 'custom-warning',\n        50: 'custom-level',  # Custom level\n    })\n    def test_level_tag_with_override_settings_custom_tags(self):\n        \"\"\"Test that level_tag uses custom MESSAGE_TAGS from override_settings.\"\"\"\n        # This test should fail before the fix and pass after\n        message = Message(constants.INFO, \"Test message\")\n        self.assertEqual(message.level_tag, \"custom-info\")\n        \n        message = Message(constants.ERROR, \"Error message\")\n        self.assertEqual(message.level_tag, \"custom-error\")\n        \n        message = Message(constants.WARNING, \"Warning message\")\n        self.assertEqual(message.level_tag, \"custom-warning\")\n        \n        # Test custom level\n        message = Message(50, \"Custom level message\")\n        self.assertEqual(message.level_tag, \"custom-level\")\n\n    @override_settings(MESSAGE_TAGS={\n        constants.INFO: 'overridden-info',\n    })\n    def test_level_tag_with_partial_override_settings(self):\n        \"\"\"Test that level_tag merges custom MESSAGE_TAGS with DEFAULT_TAGS.\"\"\"\n        # Custom tag should be used\n        message = Message(constants.INFO, \"Info message\")\n        self.assertEqual(message.level_tag, \"overridden-info\")\n        \n        # Default tags should still work for non-overridden levels\n        message = Message(constants.ERROR, \"Error message\")\n        self.assertEqual(message.level_tag, \"error\")\n        \n        message = Message(constants.WARNING, \"Warning message\")\n        self.assertEqual(message.level_tag, \"warning\")\n\n    @override_settings(MESSAGE_TAGS={})\n    def test_level_tag_with_empty_override_settings(self):\n        \"\"\"Test that level_tag falls back to DEFAULT_TAGS when MESSAGE_TAGS is empty.\"\"\"\n        message = Message(constants.INFO, \"Test message\")\n        self.assertEqual(message.level_tag, \"info\")\n        \n        message = Message(constants.ERROR, \"Error message\")\n        self.assertEqual(message.level_tag, \"error\")\n\n    def test_level_tag_updates_dynamically_across_multiple_overrides(self):\n        \"\"\"Test that level_tag updates correctly across multiple override_settings contexts.\"\"\"\n        # Test with default settings first\n        message = Message(constants.INFO, \"Test message\")\n        self.assertEqual(message.level_tag, \"info\")\n        \n        # Test with first override\n        with override_settings(MESSAGE_TAGS={constants.INFO: 'first-override'}):\n            self.assertEqual(message.level_tag, \"first-override\")\n            \n            # Test with nested override\n            with override_settings(MESSAGE_TAGS={constants.INFO: 'nested-override'}):\n                self.assertEqual(message.level_tag, \"nested-override\")\n            \n            # Should revert to first override\n            self.assertEqual(message.level_tag, \"first-override\")\n        \n        # Should revert to default\n        self.assertEqual(message.level_tag, \"info\")\n\n    @override_settings(MESSAGE_TAGS={\n        10: 'debug-custom',\n        20: 'info-custom', \n        25: 'success-custom',\n        30: 'warning-custom',\n        40: 'error-custom',\n    })\n    def test_level_tag_with_all_default_levels_overridden(self):\n        \"\"\"Test that level_tag works when all default levels are overridden.\"\"\"\n        test_cases = [\n            (constants.DEBUG, 'debug-custom'),\n            (constants.INFO, 'info-custom'),\n            (constants.SUCCESS, 'success-custom'),\n            (constants.WARNING, 'warning-custom'),\n            (constants.ERROR, 'error-custom'),\n        ]\n        \n        for level, expected_tag in test_cases:\n            with self.subTest(level=level, expected_tag=expected_tag):\n                message = Message(level, f\"Test message for level {level}\")\n                self.assertEqual(message.level_tag, expected_tag)\n\n    def test_level_tag_consistency_with_utils_get_level_tags(self):\n        \"\"\"Test that level_tag is consistent with utils.get_level_tags().\"\"\"\n        from django.contrib.messages import utils\n        \n        # Test with default settings\n        level_tags = utils.get_level_tags()\n        for level in [constants.DEBUG, constants.INFO, constants.SUCCESS, \n                     constants.WARNING, constants.ERROR]:\n            message = Message(level, \"Test message\")\n            expected_tag = level_tags.get(level, '')\n            self.assertEqual(message.level_tag, expected_tag)\n\n    @override_settings(MESSAGE_TAGS={constants.INFO: 'test-tag'})\n    def test_level_tag_consistency_with_utils_get_level_tags_override(self):\n        \"\"\"Test that level_tag is consistent with utils.get_level_tags() under override_settings.\"\"\"\n        from django.contrib.messages import utils\n        \n        # Test with override settings\n        level_tags = utils.get_level_tags()\n        message = Message(constants.INFO, \"Test message\")\n        expected_tag = level_tags.get(constants.INFO, '')\n        self.assertEqual(message.level_tag, expected_tag)\n        self.assertEqual(message.level_tag, 'test-tag')\n\n\nclass LevelTagsBugReproductionTest(TestCase):\n    \"\"\"Test that reproduces the original bug before the fix.\"\"\"\n\n    def test_bug_reproduction_level_tag_empty_with_override_settings(self):\n        \"\"\"\n        This test reproduces the original bug where level_tag returns empty string\n        when using @override_settings with custom MESSAGE_TAGS.\n        \n        Before the fix: This test should fail because level_tag returns ''\n        After the fix: This test should pass because level_tag returns 'custom-info'\n        \"\"\"\n        @override_settings(MESSAGE_TAGS={constants.INFO: 'custom-info'})\n        def test_with_override():\n            message = Message(constants.INFO, \"Test message\")\n            # Before fix: message.level_tag would be '' (empty string)\n            # After fix: message.level_tag should be 'custom-info'\n            return message.level_tag\n        \n        result = test_with_override()\n        self.assertEqual(result, 'custom-info', \n                        \"level_tag should return 'custom-info' when MESSAGE_TAGS is overridden\")\n\n    def test_bug_reproduction_multiple_messages_with_override(self):\n        \"\"\"Test multiple messages with different levels under override_settings.\"\"\"\n        @override_settings(MESSAGE_TAGS={\n            constants.INFO: 'custom-info',\n            constants.ERROR: 'custom-error',\n            50: 'custom-level-50'\n        })\n        def test_multiple_messages():\n            messages = [\n                Message(constants.INFO, \"Info message\"),\n                Message(constants.ERROR, \"Error message\"), \n                Message(50, \"Custom level message\"),\n                Message(constants.WARNING, \"Warning message\"),  # Should use default\n            ]\n            return [(msg.level, msg.level_tag) for msg in messages]\n        \n        results = test_multiple_messages()\n        expected = [\n            (constants.INFO, 'custom-info'),\n            (constants.ERROR, 'custom-error'),\n            (50, 'custom-level-50'),\n            (constants.WARNING, 'warning'),  # Default tag\n        ]\n        \n        self.assertEqual(results, expected)\n</patched>\n```",
  "patch": "--- a/tests/messages_tests/test_level_tags_override_settings.py\n+++ b/tests/messages_tests/test_level_tags_override_settings.py\n-# Empty if creating new file\n+import pytest\n+from django.contrib.messages import constants\n+from django.contrib.messages.storage.base import Message\n+from django.test import TestCase, override_settings\n+\n+\n+class LevelTagsOverrideSettingsTest(TestCase):\n+    \"\"\"Test that LEVEL_TAGS are updated when using @override_settings.\"\"\"\n+\n+    def test_level_tag_with_default_settings(self):\n+        \"\"\"Test that level_tag works with default MESSAGE_TAGS.\"\"\"\n+        message = Message(constants.INFO, \"Test message\")\n+        self.assertEqual(message.level_tag, \"info\")\n+        \n+        message = Message(constants.ERROR, \"Error message\")\n+        self.assertEqual(message.level_tag, \"error\")\n+        \n+        message = Message(constants.WARNING, \"Warning message\")\n+        self.assertEqual(message.level_tag, \"warning\")\n+\n+    def test_level_tag_with_unknown_level_returns_empty_string(self):\n+        \"\"\"Test that level_tag returns empty string for unknown levels.\"\"\"\n+        # Use a level that doesn't exist in DEFAULT_TAGS\n+        unknown_level = 999\n+        message = Message(unknown_level, \"Unknown level message\")\n+        self.assertEqual(message.level_tag, \"\")\n+\n+    @override_settings(MESSAGE_TAGS={\n+        constants.INFO: 'custom-info',\n+        constants.ERROR: 'custom-error',\n+        constants.WARNING: 'custom-warning',\n+        50: 'custom-level',  # Custom level\n+    })\n+    def test_level_tag_with_override_settings_custom_tags(self):\n+        \"\"\"Test that level_tag uses custom MESSAGE_TAGS from override_settings.\"\"\"\n+        # This test should fail before the fix and pass after\n+        message = Message(constants.INFO, \"Test message\")\n+        self.assertEqual(message.level_tag, \"custom-info\")\n+        \n+        message = Message(constants.ERROR, \"Error message\")\n+        self.assertEqual(message.level_tag, \"custom-error\")\n+        \n+        message = Message(constants.WARNING, \"Warning message\")\n+        self.assertEqual(message.level_tag, \"custom-warning\")\n+        \n+        # Test custom level\n+        message = Message(50, \"Custom level message\")\n+        self.assertEqual(message.level_tag, \"custom-level\")\n+\n+    @override_settings(MESSAGE_TAGS={\n+        constants.INFO: 'overridden-info',\n+    })\n+    def test_level_tag_with_partial_override_settings(self):\n+        \"\"\"Test that level_tag merges custom MESSAGE_TAGS with DEFAULT_TAGS.\"\"\"\n+        # Custom tag should be used\n+        message = Message(constants.INFO, \"Info message\")\n+        self.assertEqual(message.level_tag, \"overridden-info\")\n+        \n+        # Default tags should still work for non-overridden levels\n+        message = Message(constants.ERROR, \"Error message\")\n+        self.assertEqual(message.level_tag, \"error\")\n+        \n+        message = Message(constants.WARNING, \"Warning message\")\n+        self.assertEqual(message.level_tag, \"warning\")\n+\n+    @override_settings(MESSAGE_TAGS={})\n+    def test_level_tag_with_empty_override_settings(self):\n+        \"\"\"Test that level_tag falls back to DEFAULT_TAGS when MESSAGE_TAGS is empty.\"\"\"\n+        message = Message(constants.INFO, \"Test message\")\n+        self.assertEqual(message.level_tag, \"info\")\n+        \n+        message = Message(constants.ERROR, \"Error message\")\n+        self.assertEqual(message.level_tag, \"error\")\n+\n+    def test_level_tag_updates_dynamically_across_multiple_overrides(self):\n+        \"\"\"Test that level_tag updates correctly across multiple override_settings contexts.\"\"\"\n+        # Test with default settings first\n+        message = Message(constants.INFO, \"Test message\")\n+        self.assertEqual(message.level_tag, \"info\")\n+        \n+        # Test with first override\n+        with override_settings(MESSAGE_TAGS={constants.INFO: 'first-override'}):\n+            self.assertEqual(message.level_tag, \"first-override\")\n+            \n+            # Test with nested override\n+            with override_settings(MESSAGE_TAGS={constants.INFO: 'nested-override'}):\n+                self.assertEqual(message.level_tag, \"nested-override\")\n+            \n+            # Should revert to first override\n+            self.assertEqual(message.level_tag, \"first-override\")\n+        \n+        # Should revert to default\n+        self.assertEqual(message.level_tag, \"info\")\n+\n+    @override_settings(MESSAGE_TAGS={\n+        10: 'debug-custom',\n+        20: 'info-custom', \n+        25: 'success-custom',\n+        30: 'warning-custom',\n+        40: 'error-custom',\n+    })\n+    def test_level_tag_with_all_default_levels_overridden(self):\n+        \"\"\"Test that level_tag works when all default levels are overridden.\"\"\"\n+        test_cases = [\n+            (constants.DEBUG, 'debug-custom'),\n+            (constants.INFO, 'info-custom'),\n+            (constants.SUCCESS, 'success-custom'),\n+            (constants.WARNING, 'warning-custom'),\n+            (constants.ERROR, 'error-custom'),\n+        ]\n+        \n+        for level, expected_tag in test_cases:\n+            with self.subTest(level=level, expected_tag=expected_tag):\n+                message = Message(level, f\"Test message for level {level}\")\n+                self.assertEqual(message.level_tag, expected_tag)\n+\n+    def test_level_tag_consistency_with_utils_get_level_tags(self):\n+        \"\"\"Test that level_tag is consistent with utils.get_level_tags().\"\"\"\n+        from django.contrib.messages import utils\n+        \n+        # Test with default settings\n+        level_tags = utils.get_level_tags()\n+        for level in [constants.DEBUG, constants.INFO, constants.SUCCESS, \n+                     constants.WARNING, constants.ERROR]:\n+            message = Message(level, \"Test message\")\n+            expected_tag = level_tags.get(level, '')\n+            self.assertEqual(message.level_tag, expected_tag)\n+\n+    @override_settings(MESSAGE_TAGS={constants.INFO: 'test-tag'})\n+    def test_level_tag_consistency_with_utils_get_level_tags_override(self):\n+        \"\"\"Test that level_tag is consistent with utils.get_level_tags() under override_settings.\"\"\"\n+        from django.contrib.messages import utils\n+        \n+        # Test with override settings\n+        level_tags = utils.get_level_tags()\n+        message = Message(constants.INFO, \"Test message\")\n+        expected_tag = level_tags.get(constants.INFO, '')\n+        self.assertEqual(message.level_tag, expected_tag)\n+        self.assertEqual(message.level_tag, 'test-tag')\n+\n+\n+class LevelTagsBugReproductionTest(TestCase):\n+    \"\"\"Test that reproduces the original bug before the fix.\"\"\"\n+\n+    def test_bug_reproduction_level_tag_empty_with_override_settings(self):\n+        \"\"\"\n+        This test reproduces the original bug where level_tag returns empty string\n+        when using @override_settings with custom MESSAGE_TAGS.\n+        \n+        Before the fix: This test should fail because level_tag returns ''\n+        After the fix: This test should pass because level_tag returns 'custom-info'\n+        \"\"\"\n+        @override_settings(MESSAGE_TAGS={constants.INFO: 'custom-info'})\n+        def test_with_override():\n+            message = Message(constants.INFO, \"Test message\")\n+            # Before fix: message.level_tag would be '' (empty string)\n+            # After fix: message.level_tag should be 'custom-info'\n+            return message.level_tag\n+        \n+        result = test_with_override()\n+        self.assertEqual(result, 'custom-info', \n+                        \"level_tag should return 'custom-info' when MESSAGE_TAGS is overridden\")\n+\n+    def test_bug_reproduction_multiple_messages_with_override(self):\n+        \"\"\"Test multiple messages with different levels under override_settings.\"\"\"\n+        @override_settings(MESSAGE_TAGS={\n+            constants.INFO: 'custom-info',\n+            constants.ERROR: 'custom-error',\n+            50: 'custom-level-50'\n+        })\n+        def test_multiple_messages():\n+            messages = [\n+                Message(constants.INFO, \"Info message\"),\n+                Message(constants.ERROR, \"Error message\"), \n+                Message(50, \"Custom level message\"),\n+                Message(constants.WARNING, \"Warning message\"),  # Should use default\n+            ]\n+            return [(msg.level, msg.level_tag) for msg in messages]\n+        \n+        results = test_multiple_messages()\n+        expected = [\n+            (constants.INFO, 'custom-info'),\n+            (constants.ERROR, 'custom-error'),\n+            (50, 'custom-level-50'),\n+            (constants.WARNING, 'warning'),  # Default tag\n+        ]\n+        \n+        self.assertEqual(results, expected)\n"
}