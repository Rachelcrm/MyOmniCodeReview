{
  "instance_id": "pytest-dev__pytest-7432",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>testing/test_skipping.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nimport textwrap\nfrom _pytest.pytester import Pytester\n\n\nclass TestSkipLocationReporting:\n    \"\"\"Test that skip location reporting works correctly with --runxfail option.\"\"\"\n\n    def test_skip_location_without_runxfail(self, pytester: Pytester) -> None:\n        \"\"\"Test that @pytest.mark.skip reports correct location without --runxfail.\"\"\"\n        pytester.makepyfile(\n            test_skip=\"\"\"\n            import pytest\n            \n            @pytest.mark.skip\n            def test_skip_location():\n                assert 0\n            \"\"\"\n        )\n        \n        result = pytester.runpytest(\"-rs\")\n        result.assert_outcomes(skipped=1)\n        \n        # Should report the test file location, not pytest internal location\n        assert \"test_skip.py:4: unconditional skip\" in result.stdout.str()\n        assert \"skipping.py\" not in result.stdout.str()\n\n    def test_skip_location_with_runxfail_should_not_break(self, pytester: Pytester) -> None:\n        \"\"\"Test that @pytest.mark.skip reports correct location WITH --runxfail (this should fail before fix).\"\"\"\n        pytester.makepyfile(\n            test_skip=\"\"\"\n            import pytest\n            \n            @pytest.mark.skip\n            def test_skip_location():\n                assert 0\n            \"\"\"\n        )\n        \n        result = pytester.runpytest(\"-rs\", \"--runxfail\")\n        result.assert_outcomes(skipped=1)\n        \n        # Should still report the test file location, not pytest internal location\n        # This test will fail before the fix is applied\n        assert \"test_skip.py:4: unconditional skip\" in result.stdout.str()\n        assert \"skipping.py\" not in result.stdout.str()\n\n    def test_skipif_location_without_runxfail(self, pytester: Pytester) -> None:\n        \"\"\"Test that @pytest.mark.skipif reports correct location without --runxfail.\"\"\"\n        pytester.makepyfile(\n            test_skipif=\"\"\"\n            import pytest\n            \n            @pytest.mark.skipif(True, reason=\"always skip\")\n            def test_skipif_location():\n                assert 0\n            \"\"\"\n        )\n        \n        result = pytester.runpytest(\"-rs\")\n        result.assert_outcomes(skipped=1)\n        \n        # Should report the test file location, not pytest internal location\n        assert \"test_skipif.py:4: always skip\" in result.stdout.str()\n        assert \"skipping.py\" not in result.stdout.str()\n\n    def test_skipif_location_with_runxfail_should_not_break(self, pytester: Pytester) -> None:\n        \"\"\"Test that @pytest.mark.skipif reports correct location WITH --runxfail (this should fail before fix).\"\"\"\n        pytester.makepyfile(\n            test_skipif=\"\"\"\n            import pytest\n            \n            @pytest.mark.skipif(True, reason=\"always skip\")\n            def test_skipif_location():\n                assert 0\n            \"\"\"\n        )\n        \n        result = pytester.runpytest(\"-rs\", \"--runxfail\")\n        result.assert_outcomes(skipped=1)\n        \n        # Should still report the test file location, not pytest internal location\n        # This test will fail before the fix is applied\n        assert \"test_skipif.py:4: always skip\" in result.stdout.str()\n        assert \"skipping.py\" not in result.stdout.str()\n\n    def test_skip_with_reason_location_with_runxfail(self, pytester: Pytester) -> None:\n        \"\"\"Test that @pytest.mark.skip with reason reports correct location WITH --runxfail.\"\"\"\n        pytester.makepyfile(\n            test_skip_reason=\"\"\"\n            import pytest\n            \n            @pytest.mark.skip(reason=\"custom reason\")\n            def test_skip_with_reason():\n                assert 0\n            \"\"\"\n        )\n        \n        result = pytester.runpytest(\"-rs\", \"--runxfail\")\n        result.assert_outcomes(skipped=1)\n        \n        # Should report the test file location with custom reason\n        assert \"test_skip_reason.py:4: custom reason\" in result.stdout.str()\n        assert \"skipping.py\" not in result.stdout.str()\n\n    def test_xfail_not_affected_by_fix(self, pytester: Pytester) -> None:\n        \"\"\"Test that xfail behavior is not affected by the skip location fix.\"\"\"\n        pytester.makepyfile(\n            test_xfail=\"\"\"\n            import pytest\n            \n            @pytest.mark.xfail(reason=\"expected to fail\")\n            def test_xfail_location():\n                assert 0\n            \"\"\"\n        )\n        \n        # Test without --runxfail (should be xfailed)\n        result = pytester.runpytest(\"-rx\")\n        result.assert_outcomes(xfailed=1)\n        \n        # Test with --runxfail (should be failed)\n        result = pytester.runpytest(\"--runxfail\")\n        result.assert_outcomes(failed=1)\n\n    def test_mixed_skip_and_xfail_with_runxfail(self, pytester: Pytester) -> None:\n        \"\"\"Test that both skip and xfail work correctly together with --runxfail.\"\"\"\n        pytester.makepyfile(\n            test_mixed=\"\"\"\n            import pytest\n            \n            @pytest.mark.skip(reason=\"skip this\")\n            def test_skip_one():\n                assert 0\n                \n            @pytest.mark.xfail(reason=\"expected to fail\")\n            def test_xfail_one():\n                assert 0\n                \n            @pytest.mark.skipif(True, reason=\"conditional skip\")\n            def test_skipif_one():\n                assert 0\n            \"\"\"\n        )\n        \n        result = pytester.runpytest(\"-rs\", \"-rx\", \"--runxfail\")\n        result.assert_outcomes(skipped=2, failed=1)\n        \n        # Check that skip locations are reported correctly\n        stdout = result.stdout.str()\n        assert \"test_mixed.py:4: skip this\" in stdout\n        assert \"test_mixed.py:12: conditional skip\" in stdout\n        assert \"skipping.py\" not in stdout\n\n    def test_programmatic_skip_not_affected(self, pytester: Pytester) -> None:\n        \"\"\"Test that programmatic pytest.skip() calls are not affected by the fix.\"\"\"\n        pytester.makepyfile(\n            test_programmatic=\"\"\"\n            import pytest\n            \n            def test_programmatic_skip():\n                pytest.skip(\"programmatic skip\")\n                assert 0\n            \"\"\"\n        )\n        \n        result = pytester.runpytest(\"-rs\", \"--runxfail\")\n        result.assert_outcomes(skipped=1)\n        \n        # Programmatic skips should still show the internal location\n        # because they're not marked with @pytest.mark.skip\n        stdout = result.stdout.str()\n        # This should show the pytest internal location, not the test file\n        assert \"skipping.py\" in stdout or \"programmatic skip\" in stdout\n</patched>\n```",
  "patch": "--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n-# Empty if creating new file\n+import pytest\n+import textwrap\n+from _pytest.pytester import Pytester\n+\n+\n+class TestSkipLocationReporting:\n+    \"\"\"Test that skip location reporting works correctly with --runxfail option.\"\"\"\n+\n+    def test_skip_location_without_runxfail(self, pytester: Pytester) -> None:\n+        \"\"\"Test that @pytest.mark.skip reports correct location without --runxfail.\"\"\"\n+        pytester.makepyfile(\n+            test_skip=\"\"\"\n+            import pytest\n+            \n+            @pytest.mark.skip\n+            def test_skip_location():\n+                assert 0\n+            \"\"\"\n+        )\n+        \n+        result = pytester.runpytest(\"-rs\")\n+        result.assert_outcomes(skipped=1)\n+        \n+        # Should report the test file location, not pytest internal location\n+        assert \"test_skip.py:4: unconditional skip\" in result.stdout.str()\n+        assert \"skipping.py\" not in result.stdout.str()\n+\n+    def test_skip_location_with_runxfail_should_not_break(self, pytester: Pytester) -> None:\n+        \"\"\"Test that @pytest.mark.skip reports correct location WITH --runxfail (this should fail before fix).\"\"\"\n+        pytester.makepyfile(\n+            test_skip=\"\"\"\n+            import pytest\n+            \n+            @pytest.mark.skip\n+            def test_skip_location():\n+                assert 0\n+            \"\"\"\n+        )\n+        \n+        result = pytester.runpytest(\"-rs\", \"--runxfail\")\n+        result.assert_outcomes(skipped=1)\n+        \n+        # Should still report the test file location, not pytest internal location\n+        # This test will fail before the fix is applied\n+        assert \"test_skip.py:4: unconditional skip\" in result.stdout.str()\n+        assert \"skipping.py\" not in result.stdout.str()\n+\n+    def test_skipif_location_without_runxfail(self, pytester: Pytester) -> None:\n+        \"\"\"Test that @pytest.mark.skipif reports correct location without --runxfail.\"\"\"\n+        pytester.makepyfile(\n+            test_skipif=\"\"\"\n+            import pytest\n+            \n+            @pytest.mark.skipif(True, reason=\"always skip\")\n+            def test_skipif_location():\n+                assert 0\n+            \"\"\"\n+        )\n+        \n+        result = pytester.runpytest(\"-rs\")\n+        result.assert_outcomes(skipped=1)\n+        \n+        # Should report the test file location, not pytest internal location\n+        assert \"test_skipif.py:4: always skip\" in result.stdout.str()\n+        assert \"skipping.py\" not in result.stdout.str()\n+\n+    def test_skipif_location_with_runxfail_should_not_break(self, pytester: Pytester) -> None:\n+        \"\"\"Test that @pytest.mark.skipif reports correct location WITH --runxfail (this should fail before fix).\"\"\"\n+        pytester.makepyfile(\n+            test_skipif=\"\"\"\n+            import pytest\n+            \n+            @pytest.mark.skipif(True, reason=\"always skip\")\n+            def test_skipif_location():\n+                assert 0\n+            \"\"\"\n+        )\n+        \n+        result = pytester.runpytest(\"-rs\", \"--runxfail\")\n+        result.assert_outcomes(skipped=1)\n+        \n+        # Should still report the test file location, not pytest internal location\n+        # This test will fail before the fix is applied\n+        assert \"test_skipif.py:4: always skip\" in result.stdout.str()\n+        assert \"skipping.py\" not in result.stdout.str()\n+\n+    def test_skip_with_reason_location_with_runxfail(self, pytester: Pytester) -> None:\n+        \"\"\"Test that @pytest.mark.skip with reason reports correct location WITH --runxfail.\"\"\"\n+        pytester.makepyfile(\n+            test_skip_reason=\"\"\"\n+            import pytest\n+            \n+            @pytest.mark.skip(reason=\"custom reason\")\n+            def test_skip_with_reason():\n+                assert 0\n+            \"\"\"\n+        )\n+        \n+        result = pytester.runpytest(\"-rs\", \"--runxfail\")\n+        result.assert_outcomes(skipped=1)\n+        \n+        # Should report the test file location with custom reason\n+        assert \"test_skip_reason.py:4: custom reason\" in result.stdout.str()\n+        assert \"skipping.py\" not in result.stdout.str()\n+\n+    def test_xfail_not_affected_by_fix(self, pytester: Pytester) -> None:\n+        \"\"\"Test that xfail behavior is not affected by the skip location fix.\"\"\"\n+        pytester.makepyfile(\n+            test_xfail=\"\"\"\n+            import pytest\n+            \n+            @pytest.mark.xfail(reason=\"expected to fail\")\n+            def test_xfail_location():\n+                assert 0\n+            \"\"\"\n+        )\n+        \n+        # Test without --runxfail (should be xfailed)\n+        result = pytester.runpytest(\"-rx\")\n+        result.assert_outcomes(xfailed=1)\n+        \n+        # Test with --runxfail (should be failed)\n+        result = pytester.runpytest(\"--runxfail\")\n+        result.assert_outcomes(failed=1)\n+\n+    def test_mixed_skip_and_xfail_with_runxfail(self, pytester: Pytester) -> None:\n+        \"\"\"Test that both skip and xfail work correctly together with --runxfail.\"\"\"\n+        pytester.makepyfile(\n+            test_mixed=\"\"\"\n+            import pytest\n+            \n+            @pytest.mark.skip(reason=\"skip this\")\n+            def test_skip_one():\n+                assert 0\n+                \n+            @pytest.mark.xfail(reason=\"expected to fail\")\n+            def test_xfail_one():\n+                assert 0\n+                \n+            @pytest.mark.skipif(True, reason=\"conditional skip\")\n+            def test_skipif_one():\n+                assert 0\n+            \"\"\"\n+        )\n+        \n+        result = pytester.runpytest(\"-rs\", \"-rx\", \"--runxfail\")\n+        result.assert_outcomes(skipped=2, failed=1)\n+        \n+        # Check that skip locations are reported correctly\n+        stdout = result.stdout.str()\n+        assert \"test_mixed.py:4: skip this\" in stdout\n+        assert \"test_mixed.py:12: conditional skip\" in stdout\n+        assert \"skipping.py\" not in stdout\n+\n+    def test_programmatic_skip_not_affected(self, pytester: Pytester) -> None:\n+        \"\"\"Test that programmatic pytest.skip() calls are not affected by the fix.\"\"\"\n+        pytester.makepyfile(\n+            test_programmatic=\"\"\"\n+            import pytest\n+            \n+            def test_programmatic_skip():\n+                pytest.skip(\"programmatic skip\")\n+                assert 0\n+            \"\"\"\n+        )\n+        \n+        result = pytester.runpytest(\"-rs\", \"--runxfail\")\n+        result.assert_outcomes(skipped=1)\n+        \n+        # Programmatic skips should still show the internal location\n+        # because they're not marked with @pytest.mark.skip\n+        stdout = result.stdout.str()\n+        # This should show the pytest internal location, not the test file\n+        assert \"skipping.py\" in stdout or \"programmatic skip\" in stdout\n"
}