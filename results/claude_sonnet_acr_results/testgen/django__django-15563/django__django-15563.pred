{
  "instance_id": "django__django-15563",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/queries/test_multiple_inheritance_update.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models\nfrom django.test import TestCase, TransactionTestCase\nfrom django.test.utils import isolate_apps\n\n\n@isolate_apps('queries')\nclass MultipleInheritanceUpdateTests(TransactionTestCase):\n    \"\"\"\n    Test queryset update behavior with multiple inheritance.\n    \n    This test reproduces the bug where updating a child class that inherits\n    from multiple parent classes incorrectly updates the wrong parent records.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test models for multiple inheritance scenario.\"\"\"\n        \n        class Base(models.Model):\n            base_id = models.AutoField(primary_key=True)\n            field_base = models.IntegerField()\n            \n            class Meta:\n                app_label = 'queries'\n        \n        class OtherBase(models.Model):\n            otherbase_id = models.AutoField(primary_key=True)\n            field_otherbase = models.IntegerField()\n            \n            class Meta:\n                app_label = 'queries'\n        \n        class Child(Base, OtherBase):\n            class Meta:\n                app_label = 'queries'\n        \n        self.Base = Base\n        self.OtherBase = OtherBase\n        self.Child = Child\n        \n        # Create tables\n        from django.db import connection\n        with connection.schema_editor() as schema_editor:\n            schema_editor.create_model(Base)\n            schema_editor.create_model(OtherBase)\n            schema_editor.create_model(Child)\n    \n    def tearDown(self):\n        \"\"\"Clean up test tables.\"\"\"\n        from django.db import connection\n        with connection.schema_editor() as schema_editor:\n            schema_editor.delete_model(self.Child)\n            schema_editor.delete_model(self.OtherBase)\n            schema_editor.delete_model(self.Base)\n    \n    def test_multiple_inheritance_update_bug_reproduction(self):\n        \"\"\"\n        Test that reproduces the bug where Child.objects.update() \n        incorrectly modifies OtherBase records instead of Child records.\n        \n        This test should FAIL before the fix is applied, demonstrating the bug.\n        \"\"\"\n        # Create some OtherBase records that should NOT be affected\n        otherbase1 = self.OtherBase.objects.create(field_otherbase=100)\n        otherbase2 = self.OtherBase.objects.create(field_otherbase=101)\n        \n        # Create Child records\n        child1 = self.Child.objects.create(field_base=0, field_otherbase=0)\n        child2 = self.Child.objects.create(field_base=1, field_otherbase=1)\n        \n        # Verify initial state\n        self.assertEqual(self.OtherBase.objects.get(pk=1).field_otherbase, 100)\n        self.assertEqual(self.OtherBase.objects.get(pk=2).field_otherbase, 101)\n        self.assertEqual(self.Child.objects.get(pk=1).field_otherbase, 0)\n        self.assertEqual(self.Child.objects.get(pk=2).field_otherbase, 1)\n        \n        # This update should only affect Child records, not OtherBase records\n        updated_count = self.Child.objects.update(field_otherbase=55)\n        self.assertEqual(updated_count, 2)\n        \n        # Check that Child records were updated correctly\n        child1.refresh_from_db()\n        child2.refresh_from_db()\n        self.assertEqual(child1.field_otherbase, 55)\n        self.assertEqual(child2.field_otherbase, 55)\n        \n        # CRITICAL: OtherBase records should NOT have been modified\n        # This assertion will FAIL before the fix, demonstrating the bug\n        otherbase1.refresh_from_db()\n        otherbase2.refresh_from_db()\n        self.assertEqual(otherbase1.field_otherbase, 100, \n                        \"Bug: OtherBase record was incorrectly modified by Child update\")\n        self.assertEqual(otherbase2.field_otherbase, 101,\n                        \"Bug: OtherBase record was incorrectly modified by Child update\")\n    \n    def test_multiple_inheritance_update_base_field(self):\n        \"\"\"\n        Test updating a field from the first parent (Base) works correctly.\n        This should work correctly both before and after the fix.\n        \"\"\"\n        # Create Child records\n        child1 = self.Child.objects.create(field_base=10, field_otherbase=20)\n        child2 = self.Child.objects.create(field_base=11, field_otherbase=21)\n        \n        # Update field from first parent\n        updated_count = self.Child.objects.update(field_base=99)\n        self.assertEqual(updated_count, 2)\n        \n        # Verify updates\n        child1.refresh_from_db()\n        child2.refresh_from_db()\n        self.assertEqual(child1.field_base, 99)\n        self.assertEqual(child2.field_base, 99)\n        # Other fields should remain unchanged\n        self.assertEqual(child1.field_otherbase, 20)\n        self.assertEqual(child2.field_otherbase, 21)\n    \n    def test_multiple_inheritance_update_both_fields(self):\n        \"\"\"\n        Test updating fields from both parents simultaneously.\n        \"\"\"\n        # Create Child records\n        child1 = self.Child.objects.create(field_base=10, field_otherbase=20)\n        child2 = self.Child.objects.create(field_base=11, field_otherbase=21)\n        \n        # Update fields from both parents\n        updated_count = self.Child.objects.update(field_base=88, field_otherbase=77)\n        self.assertEqual(updated_count, 2)\n        \n        # Verify updates\n        child1.refresh_from_db()\n        child2.refresh_from_db()\n        self.assertEqual(child1.field_base, 88)\n        self.assertEqual(child1.field_otherbase, 77)\n        self.assertEqual(child2.field_base, 88)\n        self.assertEqual(child2.field_otherbase, 77)\n    \n    def test_multiple_inheritance_update_with_filter(self):\n        \"\"\"\n        Test updating with filters to ensure only specific Child records are updated.\n        \"\"\"\n        # Create some OtherBase records that should NOT be affected\n        otherbase1 = self.OtherBase.objects.create(field_otherbase=200)\n        \n        # Create Child records\n        child1 = self.Child.objects.create(field_base=10, field_otherbase=30)\n        child2 = self.Child.objects.create(field_base=20, field_otherbase=40)\n        \n        # Update only Child records where field_base=10\n        updated_count = self.Child.objects.filter(field_base=10).update(field_otherbase=66)\n        self.assertEqual(updated_count, 1)\n        \n        # Verify only child1 was updated\n        child1.refresh_from_db()\n        child2.refresh_from_db()\n        self.assertEqual(child1.field_otherbase, 66)\n        self.assertEqual(child2.field_otherbase, 40)  # Should remain unchanged\n        \n        # Verify OtherBase record was not affected\n        otherbase1.refresh_from_db()\n        self.assertEqual(otherbase1.field_otherbase, 200)\n    \n    def test_multiple_inheritance_update_empty_queryset(self):\n        \"\"\"\n        Test updating an empty queryset doesn't cause issues.\n        \"\"\"\n        # Create some records but don't match any with the filter\n        self.Child.objects.create(field_base=10, field_otherbase=30)\n        \n        # Update with filter that matches nothing\n        updated_count = self.Child.objects.filter(field_base=999).update(field_otherbase=55)\n        self.assertEqual(updated_count, 0)\n    \n    def test_multiple_inheritance_update_edge_case_no_related_updates(self):\n        \"\"\"\n        Test updating only fields from the main parent (no related updates needed).\n        \"\"\"\n        # Create Child records\n        child1 = self.Child.objects.create(field_base=10, field_otherbase=20)\n        \n        # Update only field from main parent (Base)\n        updated_count = self.Child.objects.update(field_base=99)\n        self.assertEqual(updated_count, 1)\n        \n        # Verify update\n        child1.refresh_from_db()\n        self.assertEqual(child1.field_base, 99)\n        self.assertEqual(child1.field_otherbase, 20)  # Should remain unchanged\n\n\n@isolate_apps('queries')  \nclass TripleInheritanceUpdateTests(TransactionTestCase):\n    \"\"\"\n    Test queryset update behavior with triple inheritance to ensure\n    the fix works for more complex inheritance hierarchies.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test models for triple inheritance scenario.\"\"\"\n        \n        class FirstParent(models.Model):\n            first_id = models.AutoField(primary_key=True)\n            field_first = models.IntegerField()\n            \n            class Meta:\n                app_label = 'queries'\n        \n        class SecondParent(models.Model):\n            second_id = models.AutoField(primary_key=True)\n            field_second = models.IntegerField()\n            \n            class Meta:\n                app_label = 'queries'\n                \n        class ThirdParent(models.Model):\n            third_id = models.AutoField(primary_key=True)\n            field_third = models.IntegerField()\n            \n            class Meta:\n                app_label = 'queries'\n        \n        class TripleChild(FirstParent, SecondParent, ThirdParent):\n            class Meta:\n                app_label = 'queries'\n        \n        self.FirstParent = FirstParent\n        self.SecondParent = SecondParent\n        self.ThirdParent = ThirdParent\n        self.TripleChild = TripleChild\n        \n        # Create tables\n        from django.db import connection\n        with connection.schema_editor() as schema_editor:\n            schema_editor.create_model(FirstParent)\n            schema_editor.create_model(SecondParent)\n            schema_editor.create_model(ThirdParent)\n            schema_editor.create_model(TripleChild)\n    \n    def tearDown(self):\n        \"\"\"Clean up test tables.\"\"\"\n        from django.db import connection\n        with connection.schema_editor() as schema_editor:\n            schema_editor.delete_model(self.TripleChild)\n            schema_editor.delete_model(self.ThirdParent)\n            schema_editor.delete_model(self.SecondParent)\n            schema_editor.delete_model(self.FirstParent)\n    \n    def test_triple_inheritance_update_second_parent(self):\n        \"\"\"\n        Test updating fields from the second parent in triple inheritance.\n        \"\"\"\n        # Create standalone parent records that should NOT be affected\n        second_parent = self.SecondParent.objects.create(field_second=500)\n        third_parent = self.ThirdParent.objects.create(field_third=600)\n        \n        # Create TripleChild record\n        child = self.TripleChild.objects.create(\n            field_first=1, field_second=2, field_third=3\n        )\n        \n        # Update field from second parent\n        updated_count = self.TripleChild.objects.update(field_second=222)\n        self.assertEqual(updated_count, 1)\n        \n        # Verify child was updated\n        child.refresh_from_db()\n        self.assertEqual(child.field_second, 222)\n        self.assertEqual(child.field_first, 1)   # Should remain unchanged\n        self.assertEqual(child.field_third, 3)   # Should remain unchanged\n        \n        # Verify standalone parent records were NOT affected\n        second_parent.refresh_from_db()\n        third_parent.refresh_from_db()\n        self.assertEqual(second_parent.field_second, 500)\n        self.assertEqual(third_parent.field_third, 600)\n    \n    def test_triple_inheritance_update_third_parent(self):\n        \"\"\"\n        Test updating fields from the third parent in triple inheritance.\n        \"\"\"\n        # Create standalone parent records that should NOT be affected\n        second_parent = self.SecondParent.objects.create(field_second=500)\n        third_parent = self.ThirdParent.objects.create(field_third=600)\n        \n        # Create TripleChild record\n        child = self.TripleChild.objects.create(\n            field_first=1, field_second=2, field_third=3\n        )\n        \n        # Update field from third parent\n        updated_count = self.TripleChild.objects.update(field_third=333)\n        self.assertEqual(updated_count, 1)\n        \n        # Verify child was updated\n        child.refresh_from_db()\n        self.assertEqual(child.field_third, 333)\n        self.assertEqual(child.field_first, 1)   # Should remain unchanged\n        self.assertEqual(child.field_second, 2)  # Should remain unchanged\n        \n        # Verify standalone parent records were NOT affected\n        second_parent.refresh_from_db()\n        third_parent.refresh_from_db()\n        self.assertEqual(second_parent.field_second, 500)\n        self.assertEqual(third_parent.field_third, 600)\n    \n    def test_triple_inheritance_update_all_fields(self):\n        \"\"\"\n        Test updating fields from all three parents simultaneously.\n        \"\"\"\n        # Create TripleChild record\n        child = self.TripleChild.objects.create(\n            field_first=10, field_second=20, field_third=30\n        )\n        \n        # Update fields from all parents\n        updated_count = self.TripleChild.objects.update(\n            field_first=111, field_second=222, field_third=333\n        )\n        self.assertEqual(updated_count, 1)\n        \n        # Verify all fields were updated\n        child.refresh_from_db()\n        self.assertEqual(child.field_first, 111)\n        self.assertEqual(child.field_second, 222)\n        self.assertEqual(child.field_third, 333)\n</patched>\n```",
  "patch": "--- a/tests/queries/test_multiple_inheritance_update.py\n+++ b/tests/queries/test_multiple_inheritance_update.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models\n+from django.test import TestCase, TransactionTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps('queries')\n+class MultipleInheritanceUpdateTests(TransactionTestCase):\n+    \"\"\"\n+    Test queryset update behavior with multiple inheritance.\n+    \n+    This test reproduces the bug where updating a child class that inherits\n+    from multiple parent classes incorrectly updates the wrong parent records.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test models for multiple inheritance scenario.\"\"\"\n+        \n+        class Base(models.Model):\n+            base_id = models.AutoField(primary_key=True)\n+            field_base = models.IntegerField()\n+            \n+            class Meta:\n+                app_label = 'queries'\n+        \n+        class OtherBase(models.Model):\n+            otherbase_id = models.AutoField(primary_key=True)\n+            field_otherbase = models.IntegerField()\n+            \n+            class Meta:\n+                app_label = 'queries'\n+        \n+        class Child(Base, OtherBase):\n+            class Meta:\n+                app_label = 'queries'\n+        \n+        self.Base = Base\n+        self.OtherBase = OtherBase\n+        self.Child = Child\n+        \n+        # Create tables\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(Base)\n+            schema_editor.create_model(OtherBase)\n+            schema_editor.create_model(Child)\n+    \n+    def tearDown(self):\n+        \"\"\"Clean up test tables.\"\"\"\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.delete_model(self.Child)\n+            schema_editor.delete_model(self.OtherBase)\n+            schema_editor.delete_model(self.Base)\n+    \n+    def test_multiple_inheritance_update_bug_reproduction(self):\n+        \"\"\"\n+        Test that reproduces the bug where Child.objects.update() \n+        incorrectly modifies OtherBase records instead of Child records.\n+        \n+        This test should FAIL before the fix is applied, demonstrating the bug.\n+        \"\"\"\n+        # Create some OtherBase records that should NOT be affected\n+        otherbase1 = self.OtherBase.objects.create(field_otherbase=100)\n+        otherbase2 = self.OtherBase.objects.create(field_otherbase=101)\n+        \n+        # Create Child records\n+        child1 = self.Child.objects.create(field_base=0, field_otherbase=0)\n+        child2 = self.Child.objects.create(field_base=1, field_otherbase=1)\n+        \n+        # Verify initial state\n+        self.assertEqual(self.OtherBase.objects.get(pk=1).field_otherbase, 100)\n+        self.assertEqual(self.OtherBase.objects.get(pk=2).field_otherbase, 101)\n+        self.assertEqual(self.Child.objects.get(pk=1).field_otherbase, 0)\n+        self.assertEqual(self.Child.objects.get(pk=2).field_otherbase, 1)\n+        \n+        # This update should only affect Child records, not OtherBase records\n+        updated_count = self.Child.objects.update(field_otherbase=55)\n+        self.assertEqual(updated_count, 2)\n+        \n+        # Check that Child records were updated correctly\n+        child1.refresh_from_db()\n+        child2.refresh_from_db()\n+        self.assertEqual(child1.field_otherbase, 55)\n+        self.assertEqual(child2.field_otherbase, 55)\n+        \n+        # CRITICAL: OtherBase records should NOT have been modified\n+        # This assertion will FAIL before the fix, demonstrating the bug\n+        otherbase1.refresh_from_db()\n+        otherbase2.refresh_from_db()\n+        self.assertEqual(otherbase1.field_otherbase, 100, \n+                        \"Bug: OtherBase record was incorrectly modified by Child update\")\n+        self.assertEqual(otherbase2.field_otherbase, 101,\n+                        \"Bug: OtherBase record was incorrectly modified by Child update\")\n+    \n+    def test_multiple_inheritance_update_base_field(self):\n+        \"\"\"\n+        Test updating a field from the first parent (Base) works correctly.\n+        This should work correctly both before and after the fix.\n+        \"\"\"\n+        # Create Child records\n+        child1 = self.Child.objects.create(field_base=10, field_otherbase=20)\n+        child2 = self.Child.objects.create(field_base=11, field_otherbase=21)\n+        \n+        # Update field from first parent\n+        updated_count = self.Child.objects.update(field_base=99)\n+        self.assertEqual(updated_count, 2)\n+        \n+        # Verify updates\n+        child1.refresh_from_db()\n+        child2.refresh_from_db()\n+        self.assertEqual(child1.field_base, 99)\n+        self.assertEqual(child2.field_base, 99)\n+        # Other fields should remain unchanged\n+        self.assertEqual(child1.field_otherbase, 20)\n+        self.assertEqual(child2.field_otherbase, 21)\n+    \n+    def test_multiple_inheritance_update_both_fields(self):\n+        \"\"\"\n+        Test updating fields from both parents simultaneously.\n+        \"\"\"\n+        # Create Child records\n+        child1 = self.Child.objects.create(field_base=10, field_otherbase=20)\n+        child2 = self.Child.objects.create(field_base=11, field_otherbase=21)\n+        \n+        # Update fields from both parents\n+        updated_count = self.Child.objects.update(field_base=88, field_otherbase=77)\n+        self.assertEqual(updated_count, 2)\n+        \n+        # Verify updates\n+        child1.refresh_from_db()\n+        child2.refresh_from_db()\n+        self.assertEqual(child1.field_base, 88)\n+        self.assertEqual(child1.field_otherbase, 77)\n+        self.assertEqual(child2.field_base, 88)\n+        self.assertEqual(child2.field_otherbase, 77)\n+    \n+    def test_multiple_inheritance_update_with_filter(self):\n+        \"\"\"\n+        Test updating with filters to ensure only specific Child records are updated.\n+        \"\"\"\n+        # Create some OtherBase records that should NOT be affected\n+        otherbase1 = self.OtherBase.objects.create(field_otherbase=200)\n+        \n+        # Create Child records\n+        child1 = self.Child.objects.create(field_base=10, field_otherbase=30)\n+        child2 = self.Child.objects.create(field_base=20, field_otherbase=40)\n+        \n+        # Update only Child records where field_base=10\n+        updated_count = self.Child.objects.filter(field_base=10).update(field_otherbase=66)\n+        self.assertEqual(updated_count, 1)\n+        \n+        # Verify only child1 was updated\n+        child1.refresh_from_db()\n+        child2.refresh_from_db()\n+        self.assertEqual(child1.field_otherbase, 66)\n+        self.assertEqual(child2.field_otherbase, 40)  # Should remain unchanged\n+        \n+        # Verify OtherBase record was not affected\n+        otherbase1.refresh_from_db()\n+        self.assertEqual(otherbase1.field_otherbase, 200)\n+    \n+    def test_multiple_inheritance_update_empty_queryset(self):\n+        \"\"\"\n+        Test updating an empty queryset doesn't cause issues.\n+        \"\"\"\n+        # Create some records but don't match any with the filter\n+        self.Child.objects.create(field_base=10, field_otherbase=30)\n+        \n+        # Update with filter that matches nothing\n+        updated_count = self.Child.objects.filter(field_base=999).update(field_otherbase=55)\n+        self.assertEqual(updated_count, 0)\n+    \n+    def test_multiple_inheritance_update_edge_case_no_related_updates(self):\n+        \"\"\"\n+        Test updating only fields from the main parent (no related updates needed).\n+        \"\"\"\n+        # Create Child records\n+        child1 = self.Child.objects.create(field_base=10, field_otherbase=20)\n+        \n+        # Update only field from main parent (Base)\n+        updated_count = self.Child.objects.update(field_base=99)\n+        self.assertEqual(updated_count, 1)\n+        \n+        # Verify update\n+        child1.refresh_from_db()\n+        self.assertEqual(child1.field_base, 99)\n+        self.assertEqual(child1.field_otherbase, 20)  # Should remain unchanged\n+\n+\n+@isolate_apps('queries')  \n+class TripleInheritanceUpdateTests(TransactionTestCase):\n+    \"\"\"\n+    Test queryset update behavior with triple inheritance to ensure\n+    the fix works for more complex inheritance hierarchies.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test models for triple inheritance scenario.\"\"\"\n+        \n+        class FirstParent(models.Model):\n+            first_id = models.AutoField(primary_key=True)\n+            field_first = models.IntegerField()\n+            \n+            class Meta:\n+                app_label = 'queries'\n+        \n+        class SecondParent(models.Model):\n+            second_id = models.AutoField(primary_key=True)\n+            field_second = models.IntegerField()\n+            \n+            class Meta:\n+                app_label = 'queries'\n+                \n+        class ThirdParent(models.Model):\n+            third_id = models.AutoField(primary_key=True)\n+            field_third = models.IntegerField()\n+            \n+            class Meta:\n+                app_label = 'queries'\n+        \n+        class TripleChild(FirstParent, SecondParent, ThirdParent):\n+            class Meta:\n+                app_label = 'queries'\n+        \n+        self.FirstParent = FirstParent\n+        self.SecondParent = SecondParent\n+        self.ThirdParent = ThirdParent\n+        self.TripleChild = TripleChild\n+        \n+        # Create tables\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(FirstParent)\n+            schema_editor.create_model(SecondParent)\n+            schema_editor.create_model(ThirdParent)\n+            schema_editor.create_model(TripleChild)\n+    \n+    def tearDown(self):\n+        \"\"\"Clean up test tables.\"\"\"\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.delete_model(self.TripleChild)\n+            schema_editor.delete_model(self.ThirdParent)\n+            schema_editor.delete_model(self.SecondParent)\n+            schema_editor.delete_model(self.FirstParent)\n+    \n+    def test_triple_inheritance_update_second_parent(self):\n+        \"\"\"\n+        Test updating fields from the second parent in triple inheritance.\n+        \"\"\"\n+        # Create standalone parent records that should NOT be affected\n+        second_parent = self.SecondParent.objects.create(field_second=500)\n+        third_parent = self.ThirdParent.objects.create(field_third=600)\n+        \n+        # Create TripleChild record\n+        child = self.TripleChild.objects.create(\n+            field_first=1, field_second=2, field_third=3\n+        )\n+        \n+        # Update field from second parent\n+        updated_count = self.TripleChild.objects.update(field_second=222)\n+        self.assertEqual(updated_count, 1)\n+        \n+        # Verify child was updated\n+        child.refresh_from_db()\n+        self.assertEqual(child.field_second, 222)\n+        self.assertEqual(child.field_first, 1)   # Should remain unchanged\n+        self.assertEqual(child.field_third, 3)   # Should remain unchanged\n+        \n+        # Verify standalone parent records were NOT affected\n+        second_parent.refresh_from_db()\n+        third_parent.refresh_from_db()\n+        self.assertEqual(second_parent.field_second, 500)\n+        self.assertEqual(third_parent.field_third, 600)\n+    \n+    def test_triple_inheritance_update_third_parent(self):\n+        \"\"\"\n+        Test updating fields from the third parent in triple inheritance.\n+        \"\"\"\n+        # Create standalone parent records that should NOT be affected\n+        second_parent = self.SecondParent.objects.create(field_second=500)\n+        third_parent = self.ThirdParent.objects.create(field_third=600)\n+        \n+        # Create TripleChild record\n+        child = self.TripleChild.objects.create(\n+            field_first=1, field_second=2, field_third=3\n+        )\n+        \n+        # Update field from third parent\n+        updated_count = self.TripleChild.objects.update(field_third=333)\n+        self.assertEqual(updated_count, 1)\n+        \n+        # Verify child was updated\n+        child.refresh_from_db()\n+        self.assertEqual(child.field_third, 333)\n+        self.assertEqual(child.field_first, 1)   # Should remain unchanged\n+        self.assertEqual(child.field_second, 2)  # Should remain unchanged\n+        \n+        # Verify standalone parent records were NOT affected\n+        second_parent.refresh_from_db()\n+        third_parent.refresh_from_db()\n+        self.assertEqual(second_parent.field_second, 500)\n+        self.assertEqual(third_parent.field_third, 600)\n+    \n+    def test_triple_inheritance_update_all_fields(self):\n+        \"\"\"\n+        Test updating fields from all three parents simultaneously.\n+        \"\"\"\n+        # Create TripleChild record\n+        child = self.TripleChild.objects.create(\n+            field_first=10, field_second=20, field_third=30\n+        )\n+        \n+        # Update fields from all parents\n+        updated_count = self.TripleChild.objects.update(\n+            field_first=111, field_second=222, field_third=333\n+        )\n+        self.assertEqual(updated_count, 1)\n+        \n+        # Verify all fields were updated\n+        child.refresh_from_db()\n+        self.assertEqual(child.field_first, 111)\n+        self.assertEqual(child.field_second, 222)\n+        self.assertEqual(child.field_third, 333)\n"
}