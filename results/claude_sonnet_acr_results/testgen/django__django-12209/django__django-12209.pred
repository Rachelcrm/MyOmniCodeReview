{
  "instance_id": "django__django-12209",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_save_pk_default/test_save_with_explicit_pk.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nfrom uuid import uuid4\nfrom django.db import models, IntegrityError\nfrom django.test import TestCase, TransactionTestCase\nfrom django.db import transaction\n\n\nclass SampleUUID(models.Model):\n    \"\"\"Model with UUID primary key that has a default value.\"\"\"\n    id = models.UUIDField(primary_key=True, default=uuid4)\n    name = models.CharField(blank=True, max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n\n\nclass SampleUUIDNoDefault(models.Model):\n    \"\"\"Model with UUID primary key that has no default value.\"\"\"\n    id = models.UUIDField(primary_key=True)\n    name = models.CharField(blank=True, max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n\n\nclass SampleAutoField(models.Model):\n    \"\"\"Model with AutoField primary key (has implicit default).\"\"\"\n    name = models.CharField(blank=True, max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n\n\nclass TestSaveWithExplicitPK(TransactionTestCase):\n    \"\"\"Test saving model instances with explicit pk values when pk field has a default.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Create tables for test models.\"\"\"\n        from django.db import connection\n        from django.core.management.color import no_style\n        from django.core.management.sql import sql_create_index\n        \n        style = no_style()\n        \n        # Create tables for our test models\n        with connection.schema_editor() as schema_editor:\n            schema_editor.create_model(SampleUUID)\n            schema_editor.create_model(SampleUUIDNoDefault)\n            schema_editor.create_model(SampleAutoField)\n    \n    def tearDown(self):\n        \"\"\"Drop tables for test models.\"\"\"\n        from django.db import connection\n        \n        with connection.schema_editor() as schema_editor:\n            schema_editor.delete_model(SampleUUID)\n            schema_editor.delete_model(SampleUUIDNoDefault)\n            schema_editor.delete_model(SampleAutoField)\n    \n    def test_save_with_explicit_pk_should_update_existing_object(self):\n        \"\"\"\n        Test that saving a model instance with an explicit pk value\n        should UPDATE an existing object, not INSERT a new one.\n        This reproduces the bug described in the issue.\n        \"\"\"\n        # Create an initial object\n        s0 = SampleUUID.objects.create()\n        original_id = s0.id\n        original_name = s0.name\n        \n        # Create a new instance with the same pk but different data\n        s1 = SampleUUID(pk=s0.pk, name='Test 1')\n        \n        # This should UPDATE the existing object, not INSERT a new one\n        s1.save()\n        \n        # Verify that only one object exists with the given pk\n        objects = SampleUUID.objects.filter(pk=original_id)\n        assert objects.count() == 1\n        \n        # Verify that the object was updated\n        updated_object = objects.first()\n        assert updated_object.id == original_id\n        assert updated_object.name == 'Test 1'\n        \n        # Verify total count hasn't increased\n        assert SampleUUID.objects.count() == 1\n    \n    def test_save_with_explicit_pk_nonexistent_object_should_insert(self):\n        \"\"\"\n        Test that saving a model instance with an explicit pk value\n        that doesn't exist should INSERT a new object.\n        \"\"\"\n        # Generate a UUID that doesn't exist in the database\n        new_id = uuid4()\n        \n        # Create an instance with explicit pk\n        s1 = SampleUUID(pk=new_id, name='New Object')\n        s1.save()\n        \n        # Verify the object was created\n        assert SampleUUID.objects.filter(pk=new_id).exists()\n        created_object = SampleUUID.objects.get(pk=new_id)\n        assert created_object.name == 'New Object'\n        assert SampleUUID.objects.count() == 1\n    \n    def test_save_without_explicit_pk_should_insert_with_default(self):\n        \"\"\"\n        Test that saving a model instance without an explicit pk value\n        should INSERT with the default value (existing behavior should be preserved).\n        \"\"\"\n        # Create an instance without explicit pk\n        s1 = SampleUUID(name='Auto PK')\n        s1.save()\n        \n        # Verify the object was created with a generated UUID\n        assert s1.pk is not None\n        assert SampleUUID.objects.filter(pk=s1.pk).exists()\n        created_object = SampleUUID.objects.get(pk=s1.pk)\n        assert created_object.name == 'Auto PK'\n        assert SampleUUID.objects.count() == 1\n    \n    def test_save_with_explicit_pk_no_default_field_should_work(self):\n        \"\"\"\n        Test that the behavior works correctly for pk fields without defaults.\n        This should work the same way regardless of the bug fix.\n        \"\"\"\n        # Generate a UUID for testing\n        test_id = uuid4()\n        \n        # Create an instance with explicit pk (no default on field)\n        s1 = SampleUUIDNoDefault(pk=test_id, name='No Default')\n        s1.save()\n        \n        # Create another instance with same pk but different data\n        s2 = SampleUUIDNoDefault(pk=test_id, name='Updated')\n        s2.save()\n        \n        # Verify that the object was updated, not duplicated\n        objects = SampleUUIDNoDefault.objects.filter(pk=test_id)\n        assert objects.count() == 1\n        updated_object = objects.first()\n        assert updated_object.name == 'Updated'\n        assert SampleUUIDNoDefault.objects.count() == 1\n    \n    def test_multiple_saves_with_explicit_pk_should_update(self):\n        \"\"\"\n        Test that multiple saves with the same explicit pk should\n        continue to update the same object.\n        \"\"\"\n        # Create initial object\n        s0 = SampleUUID.objects.create(name='Initial')\n        original_id = s0.pk\n        \n        # Update multiple times with explicit pk\n        for i in range(3):\n            s_update = SampleUUID(pk=original_id, name=f'Update {i}')\n            s_update.save()\n        \n        # Verify only one object exists\n        assert SampleUUID.objects.count() == 1\n        final_object = SampleUUID.objects.get(pk=original_id)\n        assert final_object.name == 'Update 2'\n    \n    def test_force_insert_with_explicit_pk_should_fail_if_exists(self):\n        \"\"\"\n        Test that using force_insert=True with an explicit pk\n        should fail if the object already exists.\n        \"\"\"\n        # Create initial object\n        s0 = SampleUUID.objects.create(name='Initial')\n        \n        # Try to force insert with same pk - should fail\n        s1 = SampleUUID(pk=s0.pk, name='Forced Insert')\n        \n        with pytest.raises(IntegrityError):\n            s1.save(force_insert=True)\n    \n    def test_force_update_with_explicit_pk_should_work_if_exists(self):\n        \"\"\"\n        Test that using force_update=True with an explicit pk\n        should work if the object exists.\n        \"\"\"\n        # Create initial object\n        s0 = SampleUUID.objects.create(name='Initial')\n        \n        # Force update with same pk - should work\n        s1 = SampleUUID(pk=s0.pk, name='Forced Update')\n        s1.save(force_update=True)\n        \n        # Verify update worked\n        updated_object = SampleUUID.objects.get(pk=s0.pk)\n        assert updated_object.name == 'Forced Update'\n        assert SampleUUID.objects.count() == 1\n    \n    def test_autofield_behavior_unchanged(self):\n        \"\"\"\n        Test that AutoField behavior is unchanged by the fix.\n        AutoFields should continue to work as before.\n        \"\"\"\n        # Create object with AutoField\n        s1 = SampleAutoField(name='Auto Field Test')\n        s1.save()\n        \n        # Get the auto-generated pk\n        auto_pk = s1.pk\n        assert auto_pk is not None\n        \n        # Create another instance with explicit pk\n        s2 = SampleAutoField(pk=auto_pk, name='Updated Auto Field')\n        s2.save()\n        \n        # Verify update worked\n        assert SampleAutoField.objects.count() == 1\n        updated_object = SampleAutoField.objects.get(pk=auto_pk)\n        assert updated_object.name == 'Updated Auto Field'\n    \n    def test_state_adding_flag_behavior(self):\n        \"\"\"\n        Test that the _state.adding flag behaves correctly in different scenarios.\n        \"\"\"\n        # Test 1: New instance without explicit pk\n        s1 = SampleUUID(name='New without PK')\n        assert s1._state.adding is True\n        s1.save()\n        assert s1._state.adding is False\n        \n        # Test 2: New instance with explicit pk\n        test_id = uuid4()\n        s2 = SampleUUID(pk=test_id, name='New with PK')\n        assert s2._state.adding is True\n        s2.save()\n        assert s2._state.adding is False\n        \n        # Test 3: Instance loaded from database\n        s3 = SampleUUID.objects.get(pk=test_id)\n        assert s3._state.adding is False\n        s3.name = 'Modified'\n        s3.save()\n        assert s3._state.adding is False\n    \n    def test_loaddata_scenario(self):\n        \"\"\"\n        Test the scenario mentioned in the issue where loaddata\n        command behavior changes when loading fixtures multiple times.\n        This simulates what happens during fixture loading.\n        \"\"\"\n        # Simulate first fixture load\n        fixture_id = uuid4()\n        s1 = SampleUUID(pk=fixture_id, name='Fixture Data')\n        s1.save()\n        \n        # Simulate second fixture load (same data)\n        # This should update, not fail with integrity error\n        s2 = SampleUUID(pk=fixture_id, name='Fixture Data')\n        s2.save()\n        \n        # Verify only one object exists\n        assert SampleUUID.objects.filter(pk=fixture_id).count() == 1\n        assert SampleUUID.objects.count() == 1\n    \n    def test_edge_case_none_pk_with_default(self):\n        \"\"\"\n        Test edge case where pk is explicitly set to None\n        but field has a default.\n        \"\"\"\n        # Create instance with explicit None pk\n        s1 = SampleUUID(pk=None, name='None PK')\n        s1.save()\n        \n        # Should get a generated UUID\n        assert s1.pk is not None\n        assert SampleUUID.objects.filter(pk=s1.pk).exists()\n        \n        # Save again - should update the same object\n        s1.name = 'Updated None PK'\n        s1.save()\n        \n        assert SampleUUID.objects.count() == 1\n        updated_object = SampleUUID.objects.get(pk=s1.pk)\n        assert updated_object.name == 'Updated None PK'\n</patched>\n</file>\n```",
  "patch": "--- a/tests/model_save_pk_default/test_save_with_explicit_pk.py\n+++ b/tests/model_save_pk_default/test_save_with_explicit_pk.py\n+import pytest\n+from uuid import uuid4\n+from django.db import models, IntegrityError\n+from django.test import TestCase, TransactionTestCase\n+from django.db import transaction\n+\n+\n+class SampleUUID(models.Model):\n+    \"\"\"Model with UUID primary key that has a default value.\"\"\"\n+    id = models.UUIDField(primary_key=True, default=uuid4)\n+    name = models.CharField(blank=True, max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class SampleUUIDNoDefault(models.Model):\n+    \"\"\"Model with UUID primary key that has no default value.\"\"\"\n+    id = models.UUIDField(primary_key=True)\n+    name = models.CharField(blank=True, max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class SampleAutoField(models.Model):\n+    \"\"\"Model with AutoField primary key (has implicit default).\"\"\"\n+    name = models.CharField(blank=True, max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class TestSaveWithExplicitPK(TransactionTestCase):\n+    \"\"\"Test saving model instances with explicit pk values when pk field has a default.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Create tables for test models.\"\"\"\n+        from django.db import connection\n+        from django.core.management.color import no_style\n+        from django.core.management.sql import sql_create_index\n+        \n+        style = no_style()\n+        \n+        # Create tables for our test models\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(SampleUUID)\n+            schema_editor.create_model(SampleUUIDNoDefault)\n+            schema_editor.create_model(SampleAutoField)\n+    \n+    def tearDown(self):\n+        \"\"\"Drop tables for test models.\"\"\"\n+        from django.db import connection\n+        \n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.delete_model(SampleUUID)\n+            schema_editor.delete_model(SampleUUIDNoDefault)\n+            schema_editor.delete_model(SampleAutoField)\n+    \n+    def test_save_with_explicit_pk_should_update_existing_object(self):\n+        \"\"\"\n+        Test that saving a model instance with an explicit pk value\n+        should UPDATE an existing object, not INSERT a new one.\n+        This reproduces the bug described in the issue.\n+        \"\"\"\n+        # Create an initial object\n+        s0 = SampleUUID.objects.create()\n+        original_id = s0.id\n+        original_name = s0.name\n+        \n+        # Create a new instance with the same pk but different data\n+        s1 = SampleUUID(pk=s0.pk, name='Test 1')\n+        \n+        # This should UPDATE the existing object, not INSERT a new one\n+        s1.save()\n+        \n+        # Verify that only one object exists with the given pk\n+        objects = SampleUUID.objects.filter(pk=original_id)\n+        assert objects.count() == 1\n+        \n+        # Verify that the object was updated\n+        updated_object = objects.first()\n+        assert updated_object.id == original_id\n+        assert updated_object.name == 'Test 1'\n+        \n+        # Verify total count hasn't increased\n+        assert SampleUUID.objects.count() == 1\n+    \n+    def test_save_with_explicit_pk_nonexistent_object_should_insert(self):\n+        \"\"\"\n+        Test that saving a model instance with an explicit pk value\n+        that doesn't exist should INSERT a new object.\n+        \"\"\"\n+        # Generate a UUID that doesn't exist in the database\n+        new_id = uuid4()\n+        \n+        # Create an instance with explicit pk\n+        s1 = SampleUUID(pk=new_id, name='New Object')\n+        s1.save()\n+        \n+        # Verify the object was created\n+        assert SampleUUID.objects.filter(pk=new_id).exists()\n+        created_object = SampleUUID.objects.get(pk=new_id)\n+        assert created_object.name == 'New Object'\n+        assert SampleUUID.objects.count() == 1\n+    \n+    def test_save_without_explicit_pk_should_insert_with_default(self):\n+        \"\"\"\n+        Test that saving a model instance without an explicit pk value\n+        should INSERT with the default value (existing behavior should be preserved).\n+        \"\"\"\n+        # Create an instance without explicit pk\n+        s1 = SampleUUID(name='Auto PK')\n+        s1.save()\n+        \n+        # Verify the object was created with a generated UUID\n+        assert s1.pk is not None\n+        assert SampleUUID.objects.filter(pk=s1.pk).exists()\n+        created_object = SampleUUID.objects.get(pk=s1.pk)\n+        assert created_object.name == 'Auto PK'\n+        assert SampleUUID.objects.count() == 1\n+    \n+    def test_save_with_explicit_pk_no_default_field_should_work(self):\n+        \"\"\"\n+        Test that the behavior works correctly for pk fields without defaults.\n+        This should work the same way regardless of the bug fix.\n+        \"\"\"\n+        # Generate a UUID for testing\n+        test_id = uuid4()\n+        \n+        # Create an instance with explicit pk (no default on field)\n+        s1 = SampleUUIDNoDefault(pk=test_id, name='No Default')\n+        s1.save()\n+        \n+        # Create another instance with same pk but different data\n+        s2 = SampleUUIDNoDefault(pk=test_id, name='Updated')\n+        s2.save()\n+        \n+        # Verify that the object was updated, not duplicated\n+        objects = SampleUUIDNoDefault.objects.filter(pk=test_id)\n+        assert objects.count() == 1\n+        updated_object = objects.first()\n+        assert updated_object.name == 'Updated'\n+        assert SampleUUIDNoDefault.objects.count() == 1\n+    \n+    def test_multiple_saves_with_explicit_pk_should_update(self):\n+        \"\"\"\n+        Test that multiple saves with the same explicit pk should\n+        continue to update the same object.\n+        \"\"\"\n+        # Create initial object\n+        s0 = SampleUUID.objects.create(name='Initial')\n+        original_id = s0.pk\n+        \n+        # Update multiple times with explicit pk\n+        for i in range(3):\n+            s_update = SampleUUID(pk=original_id, name=f'Update {i}')\n+            s_update.save()\n+        \n+        # Verify only one object exists\n+        assert SampleUUID.objects.count() == 1\n+        final_object = SampleUUID.objects.get(pk=original_id)\n+        assert final_object.name == 'Update 2'\n+    \n+    def test_force_insert_with_explicit_pk_should_fail_if_exists(self):\n+        \"\"\"\n+        Test that using force_insert=True with an explicit pk\n+        should fail if the object already exists.\n+        \"\"\"\n+        # Create initial object\n+        s0 = SampleUUID.objects.create(name='Initial')\n+        \n+        # Try to force insert with same pk - should fail\n+        s1 = SampleUUID(pk=s0.pk, name='Forced Insert')\n+        \n+        with pytest.raises(IntegrityError):\n+            s1.save(force_insert=True)\n+    \n+    def test_force_update_with_explicit_pk_should_work_if_exists(self):\n+        \"\"\"\n+        Test that using force_update=True with an explicit pk\n+        should work if the object exists.\n+        \"\"\"\n+        # Create initial object\n+        s0 = SampleUUID.objects.create(name='Initial')\n+        \n+        # Force update with same pk - should work\n+        s1 = SampleUUID(pk=s0.pk, name='Forced Update')\n+        s1.save(force_update=True)\n+        \n+        # Verify update worked\n+        updated_object = SampleUUID.objects.get(pk=s0.pk)\n+        assert updated_object.name == 'Forced Update'\n+        assert SampleUUID.objects.count() == 1\n+    \n+    def test_autofield_behavior_unchanged(self):\n+        \"\"\"\n+        Test that AutoField behavior is unchanged by the fix.\n+        AutoFields should continue to work as before.\n+        \"\"\"\n+        # Create object with AutoField\n+        s1 = SampleAutoField(name='Auto Field Test')\n+        s1.save()\n+        \n+        # Get the auto-generated pk\n+        auto_pk = s1.pk\n+        assert auto_pk is not None\n+        \n+        # Create another instance with explicit pk\n+        s2 = SampleAutoField(pk=auto_pk, name='Updated Auto Field')\n+        s2.save()\n+        \n+        # Verify update worked\n+        assert SampleAutoField.objects.count() == 1\n+        updated_object = SampleAutoField.objects.get(pk=auto_pk)\n+        assert updated_object.name == 'Updated Auto Field'\n+    \n+    def test_state_adding_flag_behavior(self):\n+        \"\"\"\n+        Test that the _state.adding flag behaves correctly in different scenarios.\n+        \"\"\"\n+        # Test 1: New instance without explicit pk\n+        s1 = SampleUUID(name='New without PK')\n+        assert s1._state.adding is True\n+        s1.save()\n+        assert s1._state.adding is False\n+        \n+        # Test 2: New instance with explicit pk\n+        test_id = uuid4()\n+        s2 = SampleUUID(pk=test_id, name='New with PK')\n+        assert s2._state.adding is True\n+        s2.save()\n+        assert s2._state.adding is False\n+        \n+        # Test 3: Instance loaded from database\n+        s3 = SampleUUID.objects.get(pk=test_id)\n+        assert s3._state.adding is False\n+        s3.name = 'Modified'\n+        s3.save()\n+        assert s3._state.adding is False\n+    \n+    def test_loaddata_scenario(self):\n+        \"\"\"\n+        Test the scenario mentioned in the issue where loaddata\n+        command behavior changes when loading fixtures multiple times.\n+        This simulates what happens during fixture loading.\n+        \"\"\"\n+        # Simulate first fixture load\n+        fixture_id = uuid4()\n+        s1 = SampleUUID(pk=fixture_id, name='Fixture Data')\n+        s1.save()\n+        \n+        # Simulate second fixture load (same data)\n+        # This should update, not fail with integrity error\n+        s2 = SampleUUID(pk=fixture_id, name='Fixture Data')\n+        s2.save()\n+        \n+        # Verify only one object exists\n+        assert SampleUUID.objects.filter(pk=fixture_id).count() == 1\n+        assert SampleUUID.objects.count() == 1\n+    \n+    def test_edge_case_none_pk_with_default(self):\n+        \"\"\"\n+        Test edge case where pk is explicitly set to None\n+        but field has a default.\n+        \"\"\"\n+        # Create instance with explicit None pk\n+        s1 = SampleUUID(pk=None, name='None PK')\n+        s1.save()\n+        \n+        # Should get a generated UUID\n+        assert s1.pk is not None\n+        assert SampleUUID.objects.filter(pk=s1.pk).exists()\n+        \n+        # Save again - should update the same object\n+        s1.name = 'Updated None PK'\n+        s1.save()\n+        \n+        assert SampleUUID.objects.count() == 1\n+        updated_object = SampleUUID.objects.get(pk=s1.pk)\n+        assert updated_object.name == 'Updated None PK'\n"
}