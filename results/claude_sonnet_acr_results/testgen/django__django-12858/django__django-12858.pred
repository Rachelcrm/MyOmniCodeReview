{
  "instance_id": "django__django-12858",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_validation/test_ordering_validation.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.core.checks import Error\nfrom django.db import models\nfrom django.test import TestCase\n\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    parent = models.ForeignKey('self', models.CASCADE, null=True, blank=True)\n    \n    class Meta:\n        app_label = 'test_app'\n\n\nclass Supply(models.Model):\n    product = models.ForeignKey(Product, on_delete=models.CASCADE)\n    quantity = models.IntegerField()\n    \n    class Meta:\n        app_label = 'test_app'\n\n\nclass Stock(models.Model):\n    supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n    location = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n\n\nclass StockWithValidOrdering(models.Model):\n    \"\"\"Model with valid ordering that includes lookups\"\"\"\n    supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n    location = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n        ordering = ['supply__product__parent__isnull', 'location']\n\n\nclass StockWithInvalidOrdering(models.Model):\n    \"\"\"Model with invalid ordering that should fail validation\"\"\"\n    supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n    location = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n        ordering = ['supply__product__nonexistent_field']\n\n\nclass StockWithMixedOrdering(models.Model):\n    \"\"\"Model with mixed valid and invalid ordering\"\"\"\n    supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n    location = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n        ordering = ['supply__product__parent__isnull', 'supply__product__invalid_field']\n\n\nclass OrderingValidationTest(TestCase):\n    \"\"\"Test suite for ordering validation with lookups\"\"\"\n    \n    def test_ordering_with_isnull_lookup_should_pass_validation(self):\n        \"\"\"Test that ordering with __isnull lookup passes validation\"\"\"\n        # This should not raise any validation errors\n        errors = StockWithValidOrdering.check()\n        \n        # Filter for only models.E015 errors related to ordering\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'ordering' in error.msg\n        ]\n        \n        self.assertEqual(len(ordering_errors), 0, \n                        \"Ordering with __isnull lookup should not produce validation errors\")\n    \n    def test_ordering_with_invalid_field_should_fail_validation(self):\n        \"\"\"Test that ordering with truly invalid fields still fails validation\"\"\"\n        errors = StockWithInvalidOrdering.check()\n        \n        # Should have at least one models.E015 error for the invalid field\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'nonexistent_field' in error.msg\n        ]\n        \n        self.assertGreater(len(ordering_errors), 0,\n                          \"Ordering with invalid field should produce validation errors\")\n    \n    def test_ordering_with_mixed_valid_invalid_fields(self):\n        \"\"\"Test that validation correctly identifies only the invalid parts\"\"\"\n        errors = StockWithMixedOrdering.check()\n        \n        # Should have error for invalid_field but not for parent__isnull\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'ordering' in error.msg\n        ]\n        \n        # Should have exactly one error for the invalid field\n        invalid_field_errors = [\n            error for error in ordering_errors\n            if 'invalid_field' in error.msg\n        ]\n        \n        # Should not have errors for the valid isnull lookup\n        isnull_errors = [\n            error for error in ordering_errors\n            if 'isnull' in error.msg\n        ]\n        \n        self.assertGreater(len(invalid_field_errors), 0,\n                          \"Should have error for invalid field\")\n        self.assertEqual(len(isnull_errors), 0,\n                        \"Should not have error for valid __isnull lookup\")\n    \n    def test_ordering_with_other_valid_lookups(self):\n        \"\"\"Test that other valid lookups also pass validation\"\"\"\n        \n        class StockWithOtherLookups(models.Model):\n            supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n            location = models.CharField(max_length=100)\n            created_at = models.DateTimeField(auto_now_add=True)\n            \n            class Meta:\n                app_label = 'test_app'\n                ordering = [\n                    'supply__product__name__icontains',\n                    'supply__product__parent__isnull',\n                    'created_at__year'\n                ]\n        \n        errors = StockWithOtherLookups.check()\n        \n        # Filter for only models.E015 errors related to ordering\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'ordering' in error.msg\n        ]\n        \n        self.assertEqual(len(ordering_errors), 0,\n                        \"Ordering with valid lookups should not produce validation errors\")\n    \n    def test_ordering_with_transforms_still_works(self):\n        \"\"\"Test that transforms in ordering still work correctly\"\"\"\n        \n        class StockWithTransforms(models.Model):\n            supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n            location = models.CharField(max_length=100)\n            created_at = models.DateTimeField(auto_now_add=True)\n            \n            class Meta:\n                app_label = 'test_app'\n                ordering = [\n                    'created_at__year',  # This is a transform\n                    'supply__product__name__upper'  # This is also a transform\n                ]\n        \n        errors = StockWithTransforms.check()\n        \n        # Filter for only models.E015 errors related to ordering\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'ordering' in error.msg\n        ]\n        \n        self.assertEqual(len(ordering_errors), 0,\n                        \"Ordering with transforms should not produce validation errors\")\n    \n    def test_ordering_validation_preserves_existing_functionality(self):\n        \"\"\"Test that the fix doesn't break existing validation for regular fields\"\"\"\n        \n        class StockWithRegularFields(models.Model):\n            supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n            location = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n                ordering = [\n                    'supply__product__name',  # Valid field path\n                    'location',  # Valid direct field\n                    'supply__quantity'  # Valid related field\n                ]\n        \n        errors = StockWithRegularFields.check()\n        \n        # Filter for only models.E015 errors related to ordering\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'ordering' in error.msg\n        ]\n        \n        self.assertEqual(len(ordering_errors), 0,\n                        \"Ordering with regular valid fields should not produce validation errors\")\n    \n    def test_ordering_with_pk_alias_still_works(self):\n        \"\"\"Test that pk alias in ordering still works\"\"\"\n        \n        class StockWithPkOrdering(models.Model):\n            supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n            location = models.CharField(max_length=100)\n            \n            class Meta:\n                app_label = 'test_app'\n                ordering = ['pk', 'supply__pk']\n        \n        errors = StockWithPkOrdering.check()\n        \n        # Filter for only models.E015 errors related to ordering\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'ordering' in error.msg\n        ]\n        \n        self.assertEqual(len(ordering_errors), 0,\n                        \"Ordering with pk alias should not produce validation errors\")\n\n\nclass OrderingFunctionalTest(TestCase):\n    \"\"\"Test that the ordering actually works in practice\"\"\"\n    \n    @classmethod\n    def setUpTestData(cls):\n        \"\"\"Set up test data\"\"\"\n        # Create products with and without parents\n        cls.parent_product = Product.objects.create(name=\"Parent Product\")\n        cls.child_product = Product.objects.create(name=\"Child Product\", parent=cls.parent_product)\n        cls.orphan_product = Product.objects.create(name=\"Orphan Product\", parent=None)\n        \n        # Create supplies\n        cls.supply1 = Supply.objects.create(product=cls.parent_product, quantity=10)\n        cls.supply2 = Supply.objects.create(product=cls.child_product, quantity=20)\n        cls.supply3 = Supply.objects.create(product=cls.orphan_product, quantity=30)\n        \n        # Create stocks\n        cls.stock1 = Stock.objects.create(supply=cls.supply1, location=\"A\")\n        cls.stock2 = Stock.objects.create(supply=cls.supply2, location=\"B\")\n        cls.stock3 = Stock.objects.create(supply=cls.supply3, location=\"C\")\n    \n    def test_ordering_by_isnull_lookup_works_functionally(self):\n        \"\"\"Test that ordering by __isnull actually works in queries\"\"\"\n        # Test ascending order (nulls first)\n        stocks_asc = list(Stock.objects.order_by('supply__product__parent__isnull').values_list('pk', flat=True))\n        \n        # Test descending order (nulls last)\n        stocks_desc = list(Stock.objects.order_by('-supply__product__parent__isnull').values_list('pk', flat=True))\n        \n        # Both queries should execute without errors\n        self.assertIsInstance(stocks_asc, list)\n        self.assertIsInstance(stocks_desc, list)\n        self.assertGreater(len(stocks_asc), 0)\n        self.assertGreater(len(stocks_desc), 0)\n        \n        # The orders should be different (unless all values are the same)\n        # This verifies that the ordering is actually being applied\n        if len(set(stocks_asc)) > 1:  # Only test if there are different values\n            self.assertNotEqual(stocks_asc, stocks_desc)\n</patched>\n```\n\n```\n<file>tests/model_validation/test_ordering_edge_cases.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.core.checks import Error\nfrom django.db import models\nfrom django.test import TestCase\n\n\nclass BaseModel(models.Model):\n    name = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'test_app'\n        abstract = True\n\n\nclass Category(models.Model):\n    name = models.CharField(max_length=100)\n    parent = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True)\n    \n    class Meta:\n        app_label = 'test_app'\n\n\nclass Item(models.Model):\n    name = models.CharField(max_length=100)\n    category = models.ForeignKey(Category, on_delete=models.CASCADE)\n    price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)\n    \n    class Meta:\n        app_label = 'test_app'\n\n\nclass OrderingEdgeCasesTest(TestCase):\n    \"\"\"Test edge cases for ordering validation with lookups\"\"\"\n    \n    def test_ordering_with_multiple_isnull_lookups(self):\n        \"\"\"Test ordering with multiple __isnull lookups\"\"\"\n        \n        class ModelWithMultipleIsnull(models.Model):\n            item = models.ForeignKey(Item, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'test_app'\n                ordering = [\n                    'item__category__parent__isnull',\n                    'item__price__isnull'\n                ]\n        \n        errors = ModelWithMultipleIsnull.check()\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'ordering' in error.msg\n        ]\n        \n        self.assertEqual(len(ordering_errors), 0,\n                        \"Multiple __isnull lookups should not produce validation errors\")\n    \n    def test_ordering_with_deep_nested_isnull_lookup(self):\n        \"\"\"Test ordering with deeply nested __isnull lookup\"\"\"\n        \n        class ModelWithDeepNesting(models.Model):\n            item = models.ForeignKey(Item, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'test_app'\n                ordering = ['item__category__parent__parent__isnull']\n        \n        errors = ModelWithDeepNesting.check()\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'ordering' in error.msg\n        ]\n        \n        self.assertEqual(len(ordering_errors), 0,\n                        \"Deep nested __isnull lookup should not produce validation errors\")\n    \n    def test_ordering_with_mixed_lookups_and_fields(self):\n        \"\"\"Test ordering with mix of lookups, transforms, and regular fields\"\"\"\n        \n        class ModelWithMixedOrdering(models.Model):\n            item = models.ForeignKey(Item, on_delete=models.CASCADE)\n            created_at = models.DateTimeField(auto_now_add=True)\n            \n            class Meta:\n                app_label = 'test_app'\n                ordering = [\n                    'item__name',  # Regular field\n                    'item__price__isnull',  # Lookup\n                    'created_at__year',  # Transform\n                    'item__category__name__icontains'  # Another lookup\n                ]\n        \n        errors = ModelWithMixedOrdering.check()\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'ordering' in error.msg\n        ]\n        \n        self.assertEqual(len(ordering_errors), 0,\n                        \"Mixed ordering with lookups, transforms, and fields should not produce validation errors\")\n    \n    def test_ordering_with_invalid_lookup_still_fails(self):\n        \"\"\"Test that invalid lookups still produce validation errors\"\"\"\n        \n        class ModelWithInvalidLookup(models.Model):\n            item = models.ForeignKey(Item, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'test_app'\n                ordering = ['item__price__invalid_lookup']\n        \n        errors = ModelWithInvalidLookup.check()\n        ordering_errors = [\n            error for error in errors \n            if error.id == 'models.E015' and 'invalid_lookup' in error.msg\n        ]\n        \n        self.assertGreater(len(ordering_errors), 0,\n                          \"Invalid lookup should still produce validation errors\")\n    \n    def test_ordering_with_invalid_field_before_lookup_fails(self):\n        \"\"\"Test that invalid field before lookup produces validation error\"\"\"\n        \n        class ModelWithInvalidFieldBeforeLookup(models.Model):\n            item = models.ForeignKey(Item, on_delete=models.CASCADE)\n            \n            class Meta:\n                app_label = 'test_app'\n                ordering = ['item__invalid_field__isnull']\n        \n        errors = ModelWithInvalidFieldBeforeLookup.check()\n        ordering_errors = [\n            error for",
  "patch": "--- a/tests/model_validation/test_ordering_validation.py\n+++ b/tests/model_validation/test_ordering_validation.py\n-# Empty if creating new file\n+import pytest\n+from django.core.checks import Error\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class Product(models.Model):\n+    name = models.CharField(max_length=100)\n+    parent = models.ForeignKey('self', models.CASCADE, null=True, blank=True)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class Supply(models.Model):\n+    product = models.ForeignKey(Product, on_delete=models.CASCADE)\n+    quantity = models.IntegerField()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class Stock(models.Model):\n+    supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n+    location = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class StockWithValidOrdering(models.Model):\n+    \"\"\"Model with valid ordering that includes lookups\"\"\"\n+    supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n+    location = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        ordering = ['supply__product__parent__isnull', 'location']\n+\n+\n+class StockWithInvalidOrdering(models.Model):\n+    \"\"\"Model with invalid ordering that should fail validation\"\"\"\n+    supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n+    location = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        ordering = ['supply__product__nonexistent_field']\n+\n+\n+class StockWithMixedOrdering(models.Model):\n+    \"\"\"Model with mixed valid and invalid ordering\"\"\"\n+    supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n+    location = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        ordering = ['supply__product__parent__isnull', 'supply__product__invalid_field']\n+\n+\n+class OrderingValidationTest(TestCase):\n+    \"\"\"Test suite for ordering validation with lookups\"\"\"\n+    \n+    def test_ordering_with_isnull_lookup_should_pass_validation(self):\n+        \"\"\"Test that ordering with __isnull lookup passes validation\"\"\"\n+        # This should not raise any validation errors\n+        errors = StockWithValidOrdering.check()\n+        \n+        # Filter for only models.E015 errors related to ordering\n+        ordering_errors = [\n+            error for error in errors \n+            if error.id == 'models.E015' and 'ordering' in error.msg\n+        ]\n+        \n+        self.assertEqual(len(ordering_errors), 0, \n+                        \"Ordering with __isnull lookup should not produce validation errors\")\n+    \n+    def test_ordering_with_invalid_field_should_fail_validation(self):\n+        \"\"\"Test that ordering with truly invalid fields still fails validation\"\"\"\n+        errors = StockWithInvalidOrdering.check()\n+        \n+        # Should have at least one models.E015 error for the invalid field\n+        ordering_errors = [\n+            error for error in errors \n+            if error.id == 'models.E015' and 'nonexistent_field' in error.msg\n+        ]\n+        \n+        self.assertGreater(len(ordering_errors), 0,\n+                          \"Ordering with invalid field should produce validation errors\")\n+    \n+    def test_ordering_with_mixed_valid_invalid_fields(self):\n+        \"\"\"Test that validation correctly identifies only the invalid parts\"\"\"\n+        errors = StockWithMixedOrdering.check()\n+        \n+        # Should have error for invalid_field but not for parent__isnull\n+        ordering_errors = [\n+            error for error in errors \n+            if error.id == 'models.E015' and 'ordering' in error.msg\n+        ]\n+        \n+        # Should have exactly one error for the invalid field\n+        invalid_field_errors = [\n+            error for error in ordering_errors\n+            if 'invalid_field' in error.msg\n+        ]\n+        \n+        # Should not have errors for the valid isnull lookup\n+        isnull_errors = [\n+            error for error in ordering_errors\n+            if 'isnull' in error.msg\n+        ]\n+        \n+        self.assertGreater(len(invalid_field_errors), 0,\n+                          \"Should have error for invalid field\")\n+        self.assertEqual(len(isnull_errors), 0,\n+                        \"Should not have error for valid __isnull lookup\")\n+    \n+    def test_ordering_with_other_valid_lookups(self):\n+        \"\"\"Test that other valid lookups also pass validation\"\"\"\n+        \n+        class StockWithOtherLookups(models.Model):\n+            supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n+            location = models.CharField(max_length=100)\n+            created_at = models.DateTimeField(auto_now_add=True)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+                ordering = [\n+                    'supply__product__name__icontains',\n+                    'supply__product__parent__isnull',\n+                    'created_at__year'\n+                ]\n+        \n+        errors = StockWithOtherLookups.check()\n+        \n+        # Filter for only models.E015 errors related to ordering\n+        ordering_errors = [\n+            error for error in errors \n+            if error.id == 'models.E015' and 'ordering' in error.msg\n+        ]\n+        \n+        self.assertEqual(len(ordering_errors), 0,\n+                        \"Ordering with valid lookups should not produce validation errors\")\n+    \n+    def test_ordering_with_transforms_still_works(self):\n+        \"\"\"Test that transforms in ordering still work correctly\"\"\"\n+        \n+        class StockWithTransforms(models.Model):\n+            supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n+            location = models.CharField(max_length=100)\n+            created_at = models.DateTimeField(auto_now_add=True)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+                ordering = [\n+                    'created_at__year',  # This is a transform\n+                    'supply__product__name__upper'  # This is also a transform\n+                ]\n+        \n+        errors = StockWithTransforms.check()\n+        \n+        # Filter for only models.E015 errors related to ordering\n+        ordering_errors = [\n+            error for error in errors \n+            if error.id == 'models.E015' and 'ordering' in error.msg\n+        ]\n+        \n+        self.assertEqual(len(ordering_errors), 0,\n+                        \"Ordering with transforms should not produce validation errors\")\n+    \n+    def test_ordering_validation_preserves_existing_functionality(self):\n+        \"\"\"Test that the fix doesn't break existing validation for regular fields\"\"\"\n+        \n+        class StockWithRegularFields(models.Model):\n+            supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n+            location = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+                ordering = [\n+                    'supply__product__name',  # Valid field path\n+                    'location',  # Valid direct field\n+                    'supply__quantity'  # Valid related field\n+                ]\n+        \n+        errors = StockWithRegularFields.check()\n+        \n+        # Filter for only models.E015 errors related to ordering\n+        ordering_errors = [\n+            error for error in errors \n+            if error.id == 'models.E015' and 'ordering' in error.msg\n+        ]\n+        \n+        self.assertEqual(len(ordering_errors), 0,\n+                        \"Ordering with regular valid fields should not produce validation errors\")\n+    \n+    def test_ordering_with_pk_alias_still_works(self):\n+        \"\"\"Test that pk alias in ordering still works\"\"\"\n+        \n+        class StockWithPkOrdering(models.Model):\n+            supply = models.ForeignKey(Supply, on_delete=models.CASCADE)\n+            location = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+                ordering = ['pk', 'supply__pk']\n+        \n+        errors = StockWithPkOrdering.check()\n+        \n+        # Filter for only models.E015 errors related to ordering\n+        ordering_errors = [\n+            error for error in errors \n+            if error.id == 'models.E015' and 'ordering' in error.msg\n+        ]\n+        \n+        self.assertEqual(len(ordering_errors), 0,\n+                        \"Ordering with pk alias should not produce validation errors\")\n+\n+\n+class OrderingFunctionalTest(TestCase):\n+    \"\"\"Test that the ordering actually works in practice\"\"\"\n+    \n+    @classmethod\n+    def setUpTestData(cls):\n+        \"\"\"Set up test data\"\"\"\n+        # Create products with and without parents\n+        cls.parent_product = Product.objects.create(name=\"Parent Product\")\n+        cls.child_product = Product.objects.create(name=\"Child Product\", parent=cls.parent_product)\n+        cls.orphan_product = Product.objects.create(name=\"Orphan Product\", parent=None)\n+        \n+        # Create supplies\n+        cls.supply1 = Supply.objects.create(product=cls.parent_product, quantity=10)\n+        cls.supply2 = Supply.objects.create(product=cls.child_product, quantity=20)\n+        cls.supply3 = Supply.objects.create(product=cls.orphan_product, quantity=30)\n+        \n+        # Create stocks\n+        cls.stock1 = Stock.objects.create(supply=cls.supply1, location=\"A\")\n+        cls.stock2 = Stock.objects.create(supply=cls.supply2, location=\"B\")\n+        cls.stock3 = Stock.objects.create(supply=cls.supply3, location=\"C\")\n+    \n+    def test_ordering_by_isnull_lookup_works_functionally(self):\n+        \"\"\"Test that ordering by __isnull actually works in queries\"\"\"\n+        # Test ascending order (nulls first)\n+        stocks_asc = list(Stock.objects.order_by('supply__product__parent__isnull').values_list('pk', flat=True))\n+        \n+        # Test descending order (nulls last)\n+        stocks_desc = list(Stock.objects.order_by('-supply__product__parent__isnull').values_list('pk', flat=True))\n+        \n+        # Both queries should execute without errors\n+        self.assertIsInstance(stocks_asc, list)\n+        self.assertIsInstance(stocks_desc, list)\n+        self.assertGreater(len(stocks_asc), 0)\n+        self.assertGreater(len(stocks_desc), 0)\n+        \n+        # The orders should be different (unless all values are the same)\n+        # This verifies that the ordering is actually being applied\n+        if len(set(stocks_asc)) > 1:  # Only test if there are different values\n+            self.assertNotEqual(stocks_asc, stocks_desc)\n"
}