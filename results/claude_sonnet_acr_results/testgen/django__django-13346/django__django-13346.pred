{
  "instance_id": "django__django-13346",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_fields/test_jsonfield.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport json\nimport pytest\nfrom django.db import models\nfrom django.test import TestCase, skipUnlessDBFeature\nfrom django.test.utils import isolate_apps\n\n\n@isolate_apps('model_fields')\nclass JSONFieldInLookupTests(TestCase):\n    \"\"\"Test cases for __in lookup on JSONField key transforms.\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        \n        class TestModel(models.Model):\n            json_field = models.JSONField()\n            \n            class Meta:\n                app_label = 'model_fields'\n        \n        cls.TestModel = TestModel\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        # Create test objects with various JSON structures\n        self.TestModel.objects.create(json_field={'key': 0, 'other': 'value1'})\n        self.TestModel.objects.create(json_field={'key': 1, 'other': 'value2'})\n        self.TestModel.objects.create(json_field={'key': 2, 'other': 'value3'})\n        self.TestModel.objects.create(json_field={'key': 'string_value', 'other': 'value4'})\n        self.TestModel.objects.create(json_field={'key': None, 'other': 'value5'})\n        self.TestModel.objects.create(json_field={'different_key': 0, 'other': 'value6'})\n        \n        # Nested JSON structures\n        self.TestModel.objects.create(json_field={'nested': {'key': 0}, 'other': 'value7'})\n        self.TestModel.objects.create(json_field={'nested': {'key': 1}, 'other': 'value8'})\n        self.TestModel.objects.create(json_field={'nested': {'key': 2}, 'other': 'value9'})\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_key_transform_in_lookup_single_value(self):\n        \"\"\"Test __in lookup with single value should match exact lookup.\"\"\"\n        # Test with integer value\n        in_filter = {'json_field__key__in': [0]}\n        exact_filter = {'json_field__key': 0}\n        \n        in_items = list(self.TestModel.objects.filter(**in_filter))\n        exact_items = list(self.TestModel.objects.filter(**exact_filter))\n        \n        self.assertEqual(len(in_items), len(exact_items))\n        self.assertEqual(len(in_items), 1)\n        self.assertEqual(in_items[0].json_field['key'], 0)\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_key_transform_in_lookup_multiple_values(self):\n        \"\"\"Test __in lookup with multiple values.\"\"\"\n        # Test with multiple integer values\n        in_filter = {'json_field__key__in': [0, 1, 2]}\n        items = list(self.TestModel.objects.filter(**in_filter))\n        \n        self.assertEqual(len(items), 3)\n        keys = [item.json_field['key'] for item in items]\n        self.assertCountEqual(keys, [0, 1, 2])\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_key_transform_in_lookup_mixed_types(self):\n        \"\"\"Test __in lookup with mixed data types.\"\"\"\n        # Test with mixed types: integer, string, None\n        in_filter = {'json_field__key__in': [0, 'string_value', None]}\n        items = list(self.TestModel.objects.filter(**in_filter))\n        \n        self.assertEqual(len(items), 3)\n        keys = [item.json_field['key'] for item in items]\n        self.assertCountEqual(keys, [0, 'string_value', None])\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_key_transform_in_lookup_empty_list(self):\n        \"\"\"Test __in lookup with empty list should return no results.\"\"\"\n        in_filter = {'json_field__key__in': []}\n        items = list(self.TestModel.objects.filter(**in_filter))\n        \n        self.assertEqual(len(items), 0)\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_key_transform_in_lookup_nonexistent_values(self):\n        \"\"\"Test __in lookup with values that don't exist.\"\"\"\n        in_filter = {'json_field__key__in': [999, 'nonexistent']}\n        items = list(self.TestModel.objects.filter(**in_filter))\n        \n        self.assertEqual(len(items), 0)\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_nested_key_transform_in_lookup(self):\n        \"\"\"Test __in lookup on nested JSON keys.\"\"\"\n        in_filter = {'json_field__nested__key__in': [0, 1]}\n        items = list(self.TestModel.objects.filter(**in_filter))\n        \n        self.assertEqual(len(items), 2)\n        nested_keys = [item.json_field['nested']['key'] for item in items]\n        self.assertCountEqual(nested_keys, [0, 1])\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_key_transform_in_lookup_consistency_with_exact(self):\n        \"\"\"Test that __in lookup is consistent with multiple exact lookups.\"\"\"\n        # Get results using __in lookup\n        in_filter = {'json_field__key__in': [0, 1]}\n        in_items = set(self.TestModel.objects.filter(**in_filter).values_list('id', flat=True))\n        \n        # Get results using multiple exact lookups with OR\n        from django.db.models import Q\n        exact_items = set(self.TestModel.objects.filter(\n            Q(json_field__key=0) | Q(json_field__key=1)\n        ).values_list('id', flat=True))\n        \n        self.assertEqual(in_items, exact_items)\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_key_transform_in_lookup_with_none_values(self):\n        \"\"\"Test __in lookup behavior with None values.\"\"\"\n        # Test that None in the list works correctly\n        in_filter = {'json_field__key__in': [None]}\n        items = list(self.TestModel.objects.filter(**in_filter))\n        \n        self.assertEqual(len(items), 1)\n        self.assertIsNone(items[0].json_field['key'])\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_key_transform_in_lookup_case_sensitivity(self):\n        \"\"\"Test __in lookup case sensitivity for string values.\"\"\"\n        # Add test data with different cases\n        self.TestModel.objects.create(json_field={'key': 'Test', 'other': 'case_test1'})\n        self.TestModel.objects.create(json_field={'key': 'test', 'other': 'case_test2'})\n        \n        # Test case-sensitive lookup\n        in_filter = {'json_field__key__in': ['Test']}\n        items = list(self.TestModel.objects.filter(**in_filter))\n        \n        self.assertEqual(len(items), 1)\n        self.assertEqual(items[0].json_field['key'], 'Test')\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_key_transform_in_lookup_with_duplicates(self):\n        \"\"\"Test __in lookup with duplicate values in the list.\"\"\"\n        # Duplicates in the __in list should not affect results\n        in_filter = {'json_field__key__in': [0, 0, 1, 1]}\n        items = list(self.TestModel.objects.filter(**in_filter))\n        \n        self.assertEqual(len(items), 2)\n        keys = [item.json_field['key'] for item in items]\n        self.assertCountEqual(keys, [0, 1])\n\n\n@isolate_apps('model_fields')\nclass JSONFieldInLookupBugReproductionTests(TestCase):\n    \"\"\"Test cases that reproduce the specific bug described in the issue.\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        \n        class OurModel(models.Model):\n            our_field = models.JSONField()\n            \n            class Meta:\n                app_label = 'model_fields'\n        \n        cls.OurModel = OurModel\n    \n    def setUp(self):\n        \"\"\"Set up test data that reproduces the bug scenario.\"\"\"\n        # Create 312 objects with our_field.key = 0 to match the issue description\n        for i in range(312):\n            self.OurModel.objects.create(our_field={'key': 0, 'index': i})\n        \n        # Add some objects with different key values\n        for i in range(10):\n            self.OurModel.objects.create(our_field={'key': i + 1, 'index': i + 312})\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_bug_reproduction_in_vs_exact_lookup(self):\n        \"\"\"\n        Reproduce the exact bug described in the issue.\n        \n        This test should fail before the fix and pass after the fix.\n        The issue states that:\n        - first_filter = {'our_field__key__in': [0]} returns 0 items (BUG)\n        - second_filter = {'our_field__key': 0} returns 312 items (CORRECT)\n        \n        They should return the same number of items.\n        \"\"\"\n        # This is the failing case from the issue\n        first_filter = {'our_field__key__in': [0]}\n        first_items = self.OurModel.objects.filter(**first_filter)\n        first_count = len(first_items)\n        \n        # This is the working case from the issue\n        second_filter = {'our_field__key': 0}\n        second_items = self.OurModel.objects.filter(**second_filter)\n        second_count = len(second_items)\n        \n        # Before the fix, this assertion will fail because first_count is 0\n        # After the fix, this assertion should pass because both should return 312\n        self.assertEqual(first_count, second_count)\n        self.assertEqual(first_count, 312)\n        self.assertEqual(second_count, 312)\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_bug_reproduction_multiple_values_in_lookup(self):\n        \"\"\"Test that __in lookup works with multiple values after the fix.\"\"\"\n        # Test with multiple values\n        filter_dict = {'our_field__key__in': [0, 1, 2]}\n        items = self.OurModel.objects.filter(**filter_dict)\n        count = len(items)\n        \n        # Should return 312 (for key=0) + 1 (for key=1) + 1 (for key=2) = 314\n        self.assertEqual(count, 314)\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_bug_reproduction_consistency_check(self):\n        \"\"\"Verify that __in and exact lookups are consistent for all values.\"\"\"\n        for key_value in [0, 1, 2, 3]:\n            with self.subTest(key_value=key_value):\n                in_filter = {'our_field__key__in': [key_value]}\n                exact_filter = {'our_field__key': key_value}\n                \n                in_count = self.OurModel.objects.filter(**in_filter).count()\n                exact_count = self.OurModel.objects.filter(**exact_filter).count()\n                \n                self.assertEqual(in_count, exact_count, \n                    f\"__in and exact lookups should return same count for key={key_value}\")\n\n\n@isolate_apps('model_fields')  \nclass JSONFieldInLookupDatabaseSpecificTests(TestCase):\n    \"\"\"Test cases for database-specific behavior of __in lookup on JSON key transforms.\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        \n        class TestModel(models.Model):\n            json_field = models.JSONField()\n            \n            class Meta:\n                app_label = 'model_fields'\n        \n        cls.TestModel = TestModel\n    \n    def setUp(self):\n        \"\"\"Set up test data for database-specific tests.\"\"\"\n        # Test data with various numeric types\n        self.TestModel.objects.create(json_field={'num': 42})\n        self.TestModel.objects.create(json_field={'num': 42.0})\n        self.TestModel.objects.create(json_field={'num': '42'})\n        \n        # Test data with boolean values\n        self.TestModel.objects.create(json_field={'bool': True})\n        self.TestModel.objects.create(json_field={'bool': False})\n        \n        # Test data with array values\n        self.TestModel.objects.create(json_field={'arr': [1, 2, 3]})\n        self.TestModel.objects.create(json_field={'arr': [4, 5, 6]})\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_numeric_type_handling_in_lookup(self):\n        \"\"\"Test how different numeric types are handled in __in lookup.\"\"\"\n        # Test integer lookup\n        int_filter = {'json_field__num__in': [42]}\n        int_items = list(self.TestModel.objects.filter(**int_filter))\n        \n        # Should find items where num is 42 (as int or float, depending on DB)\n        self.assertGreaterEqual(len(int_items), 1)\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_boolean_handling_in_lookup(self):\n        \"\"\"Test boolean value handling in __in lookup.\"\"\"\n        true_filter = {'json_field__bool__in': [True]}\n        true_items = list(self.TestModel.objects.filter(**true_filter))\n        \n        false_filter = {'json_field__bool__in': [False]}\n        false_items = list(self.TestModel.objects.filter(**false_filter))\n        \n        self.assertEqual(len(true_items), 1)\n        self.assertEqual(len(false_items), 1)\n        self.assertTrue(true_items[0].json_field['bool'])\n        self.assertFalse(false_items[0].json_field['bool'])\n    \n    @skipUnlessDBFeature('supports_json_field')\n    def test_array_handling_in_lookup(self):\n        \"\"\"Test array value handling in __in lookup.\"\"\"\n        # Note: This tests the lookup on the array itself, not array elements\n        arr_filter = {'json_field__arr__in': [[1, 2, 3]]}\n        arr_items = list(self.TestModel.objects.filter(**arr_filter))\n        \n        self.assertEqual(len(arr_items), 1)\n        self.assertEqual(arr_items[0].json_field['arr'], [1, 2, 3])\n</patched>\n```",
  "patch": "--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n-# Empty if creating new file\n+import json\n+import pytest\n+from django.db import models\n+from django.test import TestCase, skipUnlessDBFeature\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps('model_fields')\n+class JSONFieldInLookupTests(TestCase):\n+    \"\"\"Test cases for __in lookup on JSONField key transforms.\"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        \n+        class TestModel(models.Model):\n+            json_field = models.JSONField()\n+            \n+            class Meta:\n+                app_label = 'model_fields'\n+        \n+        cls.TestModel = TestModel\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        # Create test objects with various JSON structures\n+        self.TestModel.objects.create(json_field={'key': 0, 'other': 'value1'})\n+        self.TestModel.objects.create(json_field={'key': 1, 'other': 'value2'})\n+        self.TestModel.objects.create(json_field={'key': 2, 'other': 'value3'})\n+        self.TestModel.objects.create(json_field={'key': 'string_value', 'other': 'value4'})\n+        self.TestModel.objects.create(json_field={'key': None, 'other': 'value5'})\n+        self.TestModel.objects.create(json_field={'different_key': 0, 'other': 'value6'})\n+        \n+        # Nested JSON structures\n+        self.TestModel.objects.create(json_field={'nested': {'key': 0}, 'other': 'value7'})\n+        self.TestModel.objects.create(json_field={'nested': {'key': 1}, 'other': 'value8'})\n+        self.TestModel.objects.create(json_field={'nested': {'key': 2}, 'other': 'value9'})\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_key_transform_in_lookup_single_value(self):\n+        \"\"\"Test __in lookup with single value should match exact lookup.\"\"\"\n+        # Test with integer value\n+        in_filter = {'json_field__key__in': [0]}\n+        exact_filter = {'json_field__key': 0}\n+        \n+        in_items = list(self.TestModel.objects.filter(**in_filter))\n+        exact_items = list(self.TestModel.objects.filter(**exact_filter))\n+        \n+        self.assertEqual(len(in_items), len(exact_items))\n+        self.assertEqual(len(in_items), 1)\n+        self.assertEqual(in_items[0].json_field['key'], 0)\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_key_transform_in_lookup_multiple_values(self):\n+        \"\"\"Test __in lookup with multiple values.\"\"\"\n+        # Test with multiple integer values\n+        in_filter = {'json_field__key__in': [0, 1, 2]}\n+        items = list(self.TestModel.objects.filter(**in_filter))\n+        \n+        self.assertEqual(len(items), 3)\n+        keys = [item.json_field['key'] for item in items]\n+        self.assertCountEqual(keys, [0, 1, 2])\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_key_transform_in_lookup_mixed_types(self):\n+        \"\"\"Test __in lookup with mixed data types.\"\"\"\n+        # Test with mixed types: integer, string, None\n+        in_filter = {'json_field__key__in': [0, 'string_value', None]}\n+        items = list(self.TestModel.objects.filter(**in_filter))\n+        \n+        self.assertEqual(len(items), 3)\n+        keys = [item.json_field['key'] for item in items]\n+        self.assertCountEqual(keys, [0, 'string_value', None])\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_key_transform_in_lookup_empty_list(self):\n+        \"\"\"Test __in lookup with empty list should return no results.\"\"\"\n+        in_filter = {'json_field__key__in': []}\n+        items = list(self.TestModel.objects.filter(**in_filter))\n+        \n+        self.assertEqual(len(items), 0)\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_key_transform_in_lookup_nonexistent_values(self):\n+        \"\"\"Test __in lookup with values that don't exist.\"\"\"\n+        in_filter = {'json_field__key__in': [999, 'nonexistent']}\n+        items = list(self.TestModel.objects.filter(**in_filter))\n+        \n+        self.assertEqual(len(items), 0)\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_nested_key_transform_in_lookup(self):\n+        \"\"\"Test __in lookup on nested JSON keys.\"\"\"\n+        in_filter = {'json_field__nested__key__in': [0, 1]}\n+        items = list(self.TestModel.objects.filter(**in_filter))\n+        \n+        self.assertEqual(len(items), 2)\n+        nested_keys = [item.json_field['nested']['key'] for item in items]\n+        self.assertCountEqual(nested_keys, [0, 1])\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_key_transform_in_lookup_consistency_with_exact(self):\n+        \"\"\"Test that __in lookup is consistent with multiple exact lookups.\"\"\"\n+        # Get results using __in lookup\n+        in_filter = {'json_field__key__in': [0, 1]}\n+        in_items = set(self.TestModel.objects.filter(**in_filter).values_list('id', flat=True))\n+        \n+        # Get results using multiple exact lookups with OR\n+        from django.db.models import Q\n+        exact_items = set(self.TestModel.objects.filter(\n+            Q(json_field__key=0) | Q(json_field__key=1)\n+        ).values_list('id', flat=True))\n+        \n+        self.assertEqual(in_items, exact_items)\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_key_transform_in_lookup_with_none_values(self):\n+        \"\"\"Test __in lookup behavior with None values.\"\"\"\n+        # Test that None in the list works correctly\n+        in_filter = {'json_field__key__in': [None]}\n+        items = list(self.TestModel.objects.filter(**in_filter))\n+        \n+        self.assertEqual(len(items), 1)\n+        self.assertIsNone(items[0].json_field['key'])\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_key_transform_in_lookup_case_sensitivity(self):\n+        \"\"\"Test __in lookup case sensitivity for string values.\"\"\"\n+        # Add test data with different cases\n+        self.TestModel.objects.create(json_field={'key': 'Test', 'other': 'case_test1'})\n+        self.TestModel.objects.create(json_field={'key': 'test', 'other': 'case_test2'})\n+        \n+        # Test case-sensitive lookup\n+        in_filter = {'json_field__key__in': ['Test']}\n+        items = list(self.TestModel.objects.filter(**in_filter))\n+        \n+        self.assertEqual(len(items), 1)\n+        self.assertEqual(items[0].json_field['key'], 'Test')\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_key_transform_in_lookup_with_duplicates(self):\n+        \"\"\"Test __in lookup with duplicate values in the list.\"\"\"\n+        # Duplicates in the __in list should not affect results\n+        in_filter = {'json_field__key__in': [0, 0, 1, 1]}\n+        items = list(self.TestModel.objects.filter(**in_filter))\n+        \n+        self.assertEqual(len(items), 2)\n+        keys = [item.json_field['key'] for item in items]\n+        self.assertCountEqual(keys, [0, 1])\n+\n+\n+@isolate_apps('model_fields')\n+class JSONFieldInLookupBugReproductionTests(TestCase):\n+    \"\"\"Test cases that reproduce the specific bug described in the issue.\"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        \n+        class OurModel(models.Model):\n+            our_field = models.JSONField()\n+            \n+            class Meta:\n+                app_label = 'model_fields'\n+        \n+        cls.OurModel = OurModel\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data that reproduces the bug scenario.\"\"\"\n+        # Create 312 objects with our_field.key = 0 to match the issue description\n+        for i in range(312):\n+            self.OurModel.objects.create(our_field={'key': 0, 'index': i})\n+        \n+        # Add some objects with different key values\n+        for i in range(10):\n+            self.OurModel.objects.create(our_field={'key': i + 1, 'index': i + 312})\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_bug_reproduction_in_vs_exact_lookup(self):\n+        \"\"\"\n+        Reproduce the exact bug described in the issue.\n+        \n+        This test should fail before the fix and pass after the fix.\n+        The issue states that:\n+        - first_filter = {'our_field__key__in': [0]} returns 0 items (BUG)\n+        - second_filter = {'our_field__key': 0} returns 312 items (CORRECT)\n+        \n+        They should return the same number of items.\n+        \"\"\"\n+        # This is the failing case from the issue\n+        first_filter = {'our_field__key__in': [0]}\n+        first_items = self.OurModel.objects.filter(**first_filter)\n+        first_count = len(first_items)\n+        \n+        # This is the working case from the issue\n+        second_filter = {'our_field__key': 0}\n+        second_items = self.OurModel.objects.filter(**second_filter)\n+        second_count = len(second_items)\n+        \n+        # Before the fix, this assertion will fail because first_count is 0\n+        # After the fix, this assertion should pass because both should return 312\n+        self.assertEqual(first_count, second_count)\n+        self.assertEqual(first_count, 312)\n+        self.assertEqual(second_count, 312)\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_bug_reproduction_multiple_values_in_lookup(self):\n+        \"\"\"Test that __in lookup works with multiple values after the fix.\"\"\"\n+        # Test with multiple values\n+        filter_dict = {'our_field__key__in': [0, 1, 2]}\n+        items = self.OurModel.objects.filter(**filter_dict)\n+        count = len(items)\n+        \n+        # Should return 312 (for key=0) + 1 (for key=1) + 1 (for key=2) = 314\n+        self.assertEqual(count, 314)\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_bug_reproduction_consistency_check(self):\n+        \"\"\"Verify that __in and exact lookups are consistent for all values.\"\"\"\n+        for key_value in [0, 1, 2, 3]:\n+            with self.subTest(key_value=key_value):\n+                in_filter = {'our_field__key__in': [key_value]}\n+                exact_filter = {'our_field__key': key_value}\n+                \n+                in_count = self.OurModel.objects.filter(**in_filter).count()\n+                exact_count = self.OurModel.objects.filter(**exact_filter).count()\n+                \n+                self.assertEqual(in_count, exact_count, \n+                    f\"__in and exact lookups should return same count for key={key_value}\")\n+\n+\n+@isolate_apps('model_fields')  \n+class JSONFieldInLookupDatabaseSpecificTests(TestCase):\n+    \"\"\"Test cases for database-specific behavior of __in lookup on JSON key transforms.\"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        \n+        class TestModel(models.Model):\n+            json_field = models.JSONField()\n+            \n+            class Meta:\n+                app_label = 'model_fields'\n+        \n+        cls.TestModel = TestModel\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data for database-specific tests.\"\"\"\n+        # Test data with various numeric types\n+        self.TestModel.objects.create(json_field={'num': 42})\n+        self.TestModel.objects.create(json_field={'num': 42.0})\n+        self.TestModel.objects.create(json_field={'num': '42'})\n+        \n+        # Test data with boolean values\n+        self.TestModel.objects.create(json_field={'bool': True})\n+        self.TestModel.objects.create(json_field={'bool': False})\n+        \n+        # Test data with array values\n+        self.TestModel.objects.create(json_field={'arr': [1, 2, 3]})\n+        self.TestModel.objects.create(json_field={'arr': [4, 5, 6]})\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_numeric_type_handling_in_lookup(self):\n+        \"\"\"Test how different numeric types are handled in __in lookup.\"\"\"\n+        # Test integer lookup\n+        int_filter = {'json_field__num__in': [42]}\n+        int_items = list(self.TestModel.objects.filter(**int_filter))\n+        \n+        # Should find items where num is 42 (as int or float, depending on DB)\n+        self.assertGreaterEqual(len(int_items), 1)\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_boolean_handling_in_lookup(self):\n+        \"\"\"Test boolean value handling in __in lookup.\"\"\"\n+        true_filter = {'json_field__bool__in': [True]}\n+        true_items = list(self.TestModel.objects.filter(**true_filter))\n+        \n+        false_filter = {'json_field__bool__in': [False]}\n+        false_items = list(self.TestModel.objects.filter(**false_filter))\n+        \n+        self.assertEqual(len(true_items), 1)\n+        self.assertEqual(len(false_items), 1)\n+        self.assertTrue(true_items[0].json_field['bool'])\n+        self.assertFalse(false_items[0].json_field['bool'])\n+    \n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_array_handling_in_lookup(self):\n+        \"\"\"Test array value handling in __in lookup.\"\"\"\n+        # Note: This tests the lookup on the array itself, not array elements\n+        arr_filter = {'json_field__arr__in': [[1, 2, 3]]}\n+        arr_items = list(self.TestModel.objects.filter(**arr_filter))\n+        \n+        self.assertEqual(len(arr_items), 1)\n+        self.assertEqual(arr_items[0].json_field['arr'], [1, 2, 3])\n"
}