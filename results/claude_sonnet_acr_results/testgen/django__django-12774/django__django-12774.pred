{
  "instance_id": "django__django-12774",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/queries/test_in_bulk.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models\nfrom django.test import TestCase\nfrom django.test.utils import isolate_apps\n\n\n@isolate_apps('queries')\nclass InBulkUniqueConstraintTests(TestCase):\n    \"\"\"Test QuerySet.in_bulk() with UniqueConstraint fields.\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test models with different uniqueness configurations.\"\"\"\n        \n        # Model with traditional unique=True field\n        class ArticleWithUniqueField(models.Model):\n            slug = models.CharField(max_length=255, unique=True)\n            title = models.CharField(max_length=255)\n            \n            class Meta:\n                app_label = 'queries'\n        \n        # Model with UniqueConstraint on single field\n        class ArticleWithUniqueConstraint(models.Model):\n            slug = models.CharField(max_length=255)\n            title = models.CharField(max_length=255)\n            \n            class Meta:\n                app_label = 'queries'\n                constraints = [\n                    models.UniqueConstraint(fields=['slug'], name='unique_slug')\n                ]\n        \n        # Model with UniqueConstraint on multiple fields\n        class ArticleWithMultiFieldConstraint(models.Model):\n            slug = models.CharField(max_length=255)\n            category = models.CharField(max_length=100)\n            title = models.CharField(max_length=255)\n            \n            class Meta:\n                app_label = 'queries'\n                constraints = [\n                    models.UniqueConstraint(fields=['slug', 'category'], name='unique_slug_category')\n                ]\n        \n        # Model with no uniqueness on the field\n        class ArticleWithoutUnique(models.Model):\n            slug = models.CharField(max_length=255)\n            title = models.CharField(max_length=255)\n            \n            class Meta:\n                app_label = 'queries'\n        \n        # Model with both unique=True and UniqueConstraint\n        class ArticleWithBothUnique(models.Model):\n            slug = models.CharField(max_length=255, unique=True)\n            title = models.CharField(max_length=255)\n            \n            class Meta:\n                app_label = 'queries'\n                constraints = [\n                    models.UniqueConstraint(fields=['title'], name='unique_title')\n                ]\n        \n        self.ArticleWithUniqueField = ArticleWithUniqueField\n        self.ArticleWithUniqueConstraint = ArticleWithUniqueConstraint\n        self.ArticleWithMultiFieldConstraint = ArticleWithMultiFieldConstraint\n        self.ArticleWithoutUnique = ArticleWithoutUnique\n        self.ArticleWithBothUnique = ArticleWithBothUnique\n\n    def test_in_bulk_with_unique_field_works(self):\n        \"\"\"Test that in_bulk works with traditional unique=True fields.\"\"\"\n        # This should work (existing functionality)\n        result = self.ArticleWithUniqueField.objects.in_bulk(field_name='slug')\n        self.assertEqual(result, {})\n        \n        # Test with actual data\n        article = self.ArticleWithUniqueField.objects.create(slug='test-slug', title='Test')\n        result = self.ArticleWithUniqueField.objects.in_bulk(['test-slug'], field_name='slug')\n        self.assertEqual(result, {'test-slug': article})\n\n    def test_in_bulk_with_unique_constraint_should_work(self):\n        \"\"\"Test that in_bulk should work with single-field UniqueConstraint (this is the bug).\"\"\"\n        # This currently fails but should work after the fix\n        try:\n            result = self.ArticleWithUniqueConstraint.objects.in_bulk(field_name='slug')\n            self.assertEqual(result, {})\n            \n            # Test with actual data\n            article = self.ArticleWithUniqueConstraint.objects.create(slug='test-slug', title='Test')\n            result = self.ArticleWithUniqueConstraint.objects.in_bulk(['test-slug'], field_name='slug')\n            self.assertEqual(result, {'test-slug': article})\n        except ValueError as e:\n            # This is the current bug - it should not raise this error\n            self.assertIn(\"in_bulk()'s field_name must be a unique field\", str(e))\n            pytest.fail(\"in_bulk() should work with UniqueConstraint fields but currently fails\")\n\n    def test_in_bulk_with_multi_field_constraint_should_fail(self):\n        \"\"\"Test that in_bulk fails with multi-field UniqueConstraint.\"\"\"\n        # This should still fail because the constraint is on multiple fields\n        with self.assertRaises(ValueError) as cm:\n            self.ArticleWithMultiFieldConstraint.objects.in_bulk(field_name='slug')\n        \n        self.assertIn(\"in_bulk()'s field_name must be a unique field\", str(cm.exception))\n\n    def test_in_bulk_with_non_unique_field_should_fail(self):\n        \"\"\"Test that in_bulk fails with non-unique fields.\"\"\"\n        # This should fail (existing behavior)\n        with self.assertRaises(ValueError) as cm:\n            self.ArticleWithoutUnique.objects.in_bulk(field_name='slug')\n        \n        self.assertIn(\"in_bulk()'s field_name must be a unique field\", str(cm.exception))\n\n    def test_in_bulk_with_pk_always_works(self):\n        \"\"\"Test that in_bulk always works with pk field.\"\"\"\n        # This should always work regardless of constraints\n        result = self.ArticleWithoutUnique.objects.in_bulk(field_name='pk')\n        self.assertEqual(result, {})\n        \n        result = self.ArticleWithUniqueConstraint.objects.in_bulk(field_name='pk')\n        self.assertEqual(result, {})\n\n    def test_in_bulk_with_both_unique_types(self):\n        \"\"\"Test in_bulk with model that has both unique=True and UniqueConstraint fields.\"\"\"\n        # Both should work\n        result = self.ArticleWithBothUnique.objects.in_bulk(field_name='slug')\n        self.assertEqual(result, {})\n        \n        try:\n            result = self.ArticleWithBothUnique.objects.in_bulk(field_name='title')\n            self.assertEqual(result, {})\n        except ValueError:\n            pytest.fail(\"in_bulk() should work with UniqueConstraint fields\")\n\n    def test_in_bulk_with_unique_constraint_and_data(self):\n        \"\"\"Test in_bulk with UniqueConstraint field and actual data.\"\"\"\n        # Create test data\n        article1 = self.ArticleWithUniqueConstraint.objects.create(slug='slug1', title='Title 1')\n        article2 = self.ArticleWithUniqueConstraint.objects.create(slug='slug2', title='Title 2')\n        \n        try:\n            # Test with specific slugs\n            result = self.ArticleWithUniqueConstraint.objects.in_bulk(['slug1', 'slug2'], field_name='slug')\n            expected = {'slug1': article1, 'slug2': article2}\n            self.assertEqual(result, expected)\n            \n            # Test with all objects\n            result = self.ArticleWithUniqueConstraint.objects.in_bulk(field_name='slug')\n            self.assertEqual(result, expected)\n            \n            # Test with non-existent slug\n            result = self.ArticleWithUniqueConstraint.objects.in_bulk(['nonexistent'], field_name='slug')\n            self.assertEqual(result, {})\n            \n        except ValueError:\n            pytest.fail(\"in_bulk() should work with UniqueConstraint fields\")\n\n    def test_in_bulk_edge_cases_with_unique_constraint(self):\n        \"\"\"Test edge cases for in_bulk with UniqueConstraint.\"\"\"\n        try:\n            # Empty id_list\n            result = self.ArticleWithUniqueConstraint.objects.in_bulk([], field_name='slug')\n            self.assertEqual(result, {})\n            \n            # None id_list (should return all objects)\n            result = self.ArticleWithUniqueConstraint.objects.in_bulk(None, field_name='slug')\n            self.assertEqual(result, {})\n            \n        except ValueError:\n            pytest.fail(\"in_bulk() should work with UniqueConstraint fields\")\n\n    def test_in_bulk_error_message_unchanged(self):\n        \"\"\"Test that error messages remain the same for non-unique fields.\"\"\"\n        with self.assertRaises(ValueError) as cm:\n            self.ArticleWithoutUnique.objects.in_bulk(field_name='slug')\n        \n        # Error message should be unchanged\n        self.assertEqual(\n            str(cm.exception),\n            \"in_bulk()'s field_name must be a unique field but 'slug' isn't.\"\n        )\n</patched>\n```",
  "patch": "--- a/tests/queries/test_in_bulk.py\n+++ b/tests/queries/test_in_bulk.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models\n+from django.test import TestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps('queries')\n+class InBulkUniqueConstraintTests(TestCase):\n+    \"\"\"Test QuerySet.in_bulk() with UniqueConstraint fields.\"\"\"\n+\n+    def setUp(self):\n+        \"\"\"Set up test models with different uniqueness configurations.\"\"\"\n+        \n+        # Model with traditional unique=True field\n+        class ArticleWithUniqueField(models.Model):\n+            slug = models.CharField(max_length=255, unique=True)\n+            title = models.CharField(max_length=255)\n+            \n+            class Meta:\n+                app_label = 'queries'\n+        \n+        # Model with UniqueConstraint on single field\n+        class ArticleWithUniqueConstraint(models.Model):\n+            slug = models.CharField(max_length=255)\n+            title = models.CharField(max_length=255)\n+            \n+            class Meta:\n+                app_label = 'queries'\n+                constraints = [\n+                    models.UniqueConstraint(fields=['slug'], name='unique_slug')\n+                ]\n+        \n+        # Model with UniqueConstraint on multiple fields\n+        class ArticleWithMultiFieldConstraint(models.Model):\n+            slug = models.CharField(max_length=255)\n+            category = models.CharField(max_length=100)\n+            title = models.CharField(max_length=255)\n+            \n+            class Meta:\n+                app_label = 'queries'\n+                constraints = [\n+                    models.UniqueConstraint(fields=['slug', 'category'], name='unique_slug_category')\n+                ]\n+        \n+        # Model with no uniqueness on the field\n+        class ArticleWithoutUnique(models.Model):\n+            slug = models.CharField(max_length=255)\n+            title = models.CharField(max_length=255)\n+            \n+            class Meta:\n+                app_label = 'queries'\n+        \n+        # Model with both unique=True and UniqueConstraint\n+        class ArticleWithBothUnique(models.Model):\n+            slug = models.CharField(max_length=255, unique=True)\n+            title = models.CharField(max_length=255)\n+            \n+            class Meta:\n+                app_label = 'queries'\n+                constraints = [\n+                    models.UniqueConstraint(fields=['title'], name='unique_title')\n+                ]\n+        \n+        self.ArticleWithUniqueField = ArticleWithUniqueField\n+        self.ArticleWithUniqueConstraint = ArticleWithUniqueConstraint\n+        self.ArticleWithMultiFieldConstraint = ArticleWithMultiFieldConstraint\n+        self.ArticleWithoutUnique = ArticleWithoutUnique\n+        self.ArticleWithBothUnique = ArticleWithBothUnique\n+\n+    def test_in_bulk_with_unique_field_works(self):\n+        \"\"\"Test that in_bulk works with traditional unique=True fields.\"\"\"\n+        # This should work (existing functionality)\n+        result = self.ArticleWithUniqueField.objects.in_bulk(field_name='slug')\n+        self.assertEqual(result, {})\n+        \n+        # Test with actual data\n+        article = self.ArticleWithUniqueField.objects.create(slug='test-slug', title='Test')\n+        result = self.ArticleWithUniqueField.objects.in_bulk(['test-slug'], field_name='slug')\n+        self.assertEqual(result, {'test-slug': article})\n+\n+    def test_in_bulk_with_unique_constraint_should_work(self):\n+        \"\"\"Test that in_bulk should work with single-field UniqueConstraint (this is the bug).\"\"\"\n+        # This currently fails but should work after the fix\n+        try:\n+            result = self.ArticleWithUniqueConstraint.objects.in_bulk(field_name='slug')\n+            self.assertEqual(result, {})\n+            \n+            # Test with actual data\n+            article = self.ArticleWithUniqueConstraint.objects.create(slug='test-slug', title='Test')\n+            result = self.ArticleWithUniqueConstraint.objects.in_bulk(['test-slug'], field_name='slug')\n+            self.assertEqual(result, {'test-slug': article})\n+        except ValueError as e:\n+            # This is the current bug - it should not raise this error\n+            self.assertIn(\"in_bulk()'s field_name must be a unique field\", str(e))\n+            pytest.fail(\"in_bulk() should work with UniqueConstraint fields but currently fails\")\n+\n+    def test_in_bulk_with_multi_field_constraint_should_fail(self):\n+        \"\"\"Test that in_bulk fails with multi-field UniqueConstraint.\"\"\"\n+        # This should still fail because the constraint is on multiple fields\n+        with self.assertRaises(ValueError) as cm:\n+            self.ArticleWithMultiFieldConstraint.objects.in_bulk(field_name='slug')\n+        \n+        self.assertIn(\"in_bulk()'s field_name must be a unique field\", str(cm.exception))\n+\n+    def test_in_bulk_with_non_unique_field_should_fail(self):\n+        \"\"\"Test that in_bulk fails with non-unique fields.\"\"\"\n+        # This should fail (existing behavior)\n+        with self.assertRaises(ValueError) as cm:\n+            self.ArticleWithoutUnique.objects.in_bulk(field_name='slug')\n+        \n+        self.assertIn(\"in_bulk()'s field_name must be a unique field\", str(cm.exception))\n+\n+    def test_in_bulk_with_pk_always_works(self):\n+        \"\"\"Test that in_bulk always works with pk field.\"\"\"\n+        # This should always work regardless of constraints\n+        result = self.ArticleWithoutUnique.objects.in_bulk(field_name='pk')\n+        self.assertEqual(result, {})\n+        \n+        result = self.ArticleWithUniqueConstraint.objects.in_bulk(field_name='pk')\n+        self.assertEqual(result, {})\n+\n+    def test_in_bulk_with_both_unique_types(self):\n+        \"\"\"Test in_bulk with model that has both unique=True and UniqueConstraint fields.\"\"\"\n+        # Both should work\n+        result = self.ArticleWithBothUnique.objects.in_bulk(field_name='slug')\n+        self.assertEqual(result, {})\n+        \n+        try:\n+            result = self.ArticleWithBothUnique.objects.in_bulk(field_name='title')\n+            self.assertEqual(result, {})\n+        except ValueError:\n+            pytest.fail(\"in_bulk() should work with UniqueConstraint fields\")\n+\n+    def test_in_bulk_with_unique_constraint_and_data(self):\n+        \"\"\"Test in_bulk with UniqueConstraint field and actual data.\"\"\"\n+        # Create test data\n+        article1 = self.ArticleWithUniqueConstraint.objects.create(slug='slug1', title='Title 1')\n+        article2 = self.ArticleWithUniqueConstraint.objects.create(slug='slug2', title='Title 2')\n+        \n+        try:\n+            # Test with specific slugs\n+            result = self.ArticleWithUniqueConstraint.objects.in_bulk(['slug1', 'slug2'], field_name='slug')\n+            expected = {'slug1': article1, 'slug2': article2}\n+            self.assertEqual(result, expected)\n+            \n+            # Test with all objects\n+            result = self.ArticleWithUniqueConstraint.objects.in_bulk(field_name='slug')\n+            self.assertEqual(result, expected)\n+            \n+            # Test with non-existent slug\n+            result = self.ArticleWithUniqueConstraint.objects.in_bulk(['nonexistent'], field_name='slug')\n+            self.assertEqual(result, {})\n+            \n+        except ValueError:\n+            pytest.fail(\"in_bulk() should work with UniqueConstraint fields\")\n+\n+    def test_in_bulk_edge_cases_with_unique_constraint(self):\n+        \"\"\"Test edge cases for in_bulk with UniqueConstraint.\"\"\"\n+        try:\n+            # Empty id_list\n+            result = self.ArticleWithUniqueConstraint.objects.in_bulk([], field_name='slug')\n+            self.assertEqual(result, {})\n+            \n+            # None id_list (should return all objects)\n+            result = self.ArticleWithUniqueConstraint.objects.in_bulk(None, field_name='slug')\n+            self.assertEqual(result, {})\n+            \n+        except ValueError:\n+            pytest.fail(\"in_bulk() should work with UniqueConstraint fields\")\n+\n+    def test_in_bulk_error_message_unchanged(self):\n+        \"\"\"Test that error messages remain the same for non-unique fields.\"\"\"\n+        with self.assertRaises(ValueError) as cm:\n+            self.ArticleWithoutUnique.objects.in_bulk(field_name='slug')\n+        \n+        # Error message should be unchanged\n+        self.assertEqual(\n+            str(cm.exception),\n+            \"in_bulk()'s field_name must be a unique field but 'slug' isn't.\"\n+        )\n"
}