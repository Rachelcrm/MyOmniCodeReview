{
  "instance_id": "django__django-15037",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/inspectdb/test_foreign_key_to_field.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom io import StringIO\nfrom django.core.management import call_command\nfrom django.db import connection\nfrom django.test import TestCase, TransactionTestCase\nfrom django.test.utils import override_settings\n\n\nclass InspectDBForeignKeyToFieldTests(TransactionTestCase):\n    \"\"\"\n    Test that inspectdb correctly handles foreign keys that reference\n    specific fields (not primary keys) in other tables.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test tables with foreign key to specific field.\"\"\"\n        with connection.cursor() as cursor:\n            # Create foo table with primary key and unique other_id field\n            cursor.execute(\"\"\"\n                CREATE TABLE test_foo (\n                    id SERIAL PRIMARY KEY,\n                    other_id INTEGER UNIQUE\n                )\n            \"\"\")\n            \n            # Create bar table with foreign key to foo.other_id (not foo.id)\n            cursor.execute(\"\"\"\n                CREATE TABLE test_bar (\n                    id SERIAL PRIMARY KEY,\n                    other_id INTEGER,\n                    CONSTRAINT test_fk_constraint \n                    FOREIGN KEY(other_id) REFERENCES test_foo(other_id)\n                )\n            \"\"\")\n            \n            # Create baz table with foreign key to foo.id (primary key) for comparison\n            cursor.execute(\"\"\"\n                CREATE TABLE test_baz (\n                    id SERIAL PRIMARY KEY,\n                    foo_id INTEGER,\n                    CONSTRAINT test_fk_constraint_pk\n                    FOREIGN KEY(foo_id) REFERENCES test_foo(id)\n                )\n            \"\"\")\n\n    def tearDown(self):\n        \"\"\"Clean up test tables.\"\"\"\n        with connection.cursor() as cursor:\n            cursor.execute(\"DROP TABLE IF EXISTS test_bar CASCADE\")\n            cursor.execute(\"DROP TABLE IF EXISTS test_baz CASCADE\")\n            cursor.execute(\"DROP TABLE IF EXISTS test_foo CASCADE\")\n\n    def test_foreign_key_to_specific_field_includes_to_field_parameter(self):\n        \"\"\"\n        Test that inspectdb generates ForeignKey with to_field parameter\n        when foreign key references a specific non-primary key field.\n        \"\"\"\n        out = StringIO()\n        call_command('inspectdb', 'test_bar', stdout=out)\n        output = out.getvalue()\n        \n        # Should contain to_field parameter for the foreign key to other_id\n        self.assertIn(\"to_field='other_id'\", output)\n        self.assertIn(\"ForeignKey('TestFoo'\", output)\n        \n    def test_foreign_key_to_primary_key_no_to_field_parameter(self):\n        \"\"\"\n        Test that inspectdb does NOT generate to_field parameter\n        when foreign key references the primary key (existing behavior).\n        \"\"\"\n        out = StringIO()\n        call_command('inspectdb', 'test_baz', stdout=out)\n        output = out.getvalue()\n        \n        # Should NOT contain to_field parameter for foreign key to primary key\n        self.assertNotIn(\"to_field=\", output)\n        self.assertIn(\"ForeignKey('TestFoo'\", output)\n\n    def test_foreign_key_to_field_with_self_reference(self):\n        \"\"\"\n        Test that inspectdb handles self-referencing foreign keys to specific fields.\n        \"\"\"\n        with connection.cursor() as cursor:\n            # Create self-referencing table\n            cursor.execute(\"\"\"\n                CREATE TABLE test_self_ref (\n                    id SERIAL PRIMARY KEY,\n                    code VARCHAR(10) UNIQUE,\n                    parent_code VARCHAR(10),\n                    CONSTRAINT test_self_fk\n                    FOREIGN KEY(parent_code) REFERENCES test_self_ref(code)\n                )\n            \"\"\")\n        \n        try:\n            out = StringIO()\n            call_command('inspectdb', 'test_self_ref', stdout=out)\n            output = out.getvalue()\n            \n            # Should contain to_field parameter for self-reference to code field\n            self.assertIn(\"to_field='code'\", output)\n            self.assertIn(\"ForeignKey('self'\", output)\n            \n        finally:\n            with connection.cursor() as cursor:\n                cursor.execute(\"DROP TABLE IF EXISTS test_self_ref CASCADE\")\n\n    def test_multiple_foreign_keys_mixed_references(self):\n        \"\"\"\n        Test that inspectdb correctly handles multiple foreign keys,\n        some to primary keys and some to specific fields.\n        \"\"\"\n        with connection.cursor() as cursor:\n            # Create table with multiple foreign keys\n            cursor.execute(\"\"\"\n                CREATE TABLE test_multi_fk (\n                    id SERIAL PRIMARY KEY,\n                    foo_id INTEGER,\n                    foo_other_id INTEGER,\n                    CONSTRAINT test_multi_fk_pk\n                    FOREIGN KEY(foo_id) REFERENCES test_foo(id),\n                    CONSTRAINT test_multi_fk_other\n                    FOREIGN KEY(foo_other_id) REFERENCES test_foo(other_id)\n                )\n            \"\"\")\n        \n        try:\n            out = StringIO()\n            call_command('inspectdb', 'test_multi_fk', stdout=out)\n            output = out.getvalue()\n            \n            # Should have one FK with to_field and one without\n            self.assertIn(\"to_field='other_id'\", output)\n            # Count occurrences of ForeignKey - should be 2\n            fk_count = output.count(\"ForeignKey('TestFoo'\")\n            self.assertEqual(fk_count, 2)\n            \n        finally:\n            with connection.cursor() as cursor:\n                cursor.execute(\"DROP TABLE IF EXISTS test_multi_fk CASCADE\")\n\n    def test_foreign_key_to_field_with_unique_constraint(self):\n        \"\"\"\n        Test that inspectdb generates OneToOneField with to_field parameter\n        when foreign key to specific field has unique constraint.\n        \"\"\"\n        with connection.cursor() as cursor:\n            # Create table with unique foreign key to specific field\n            cursor.execute(\"\"\"\n                CREATE TABLE test_unique_fk (\n                    id SERIAL PRIMARY KEY,\n                    unique_other_id INTEGER UNIQUE,\n                    CONSTRAINT test_unique_fk_constraint\n                    FOREIGN KEY(unique_other_id) REFERENCES test_foo(other_id)\n                )\n            \"\"\")\n        \n        try:\n            out = StringIO()\n            call_command('inspectdb', 'test_unique_fk', stdout=out)\n            output = out.getvalue()\n            \n            # Should contain OneToOneField with to_field parameter\n            self.assertIn(\"to_field='other_id'\", output)\n            self.assertIn(\"OneToOneField('TestFoo'\", output)\n            \n        finally:\n            with connection.cursor() as cursor:\n                cursor.execute(\"DROP TABLE IF EXISTS test_unique_fk CASCADE\")\n\n    def test_inspectdb_output_format_with_to_field(self):\n        \"\"\"\n        Test that the generated model code is properly formatted\n        when to_field parameter is included.\n        \"\"\"\n        out = StringIO()\n        call_command('inspectdb', 'test_bar', stdout=out)\n        output = out.getvalue()\n        \n        # Check that the field definition is properly formatted\n        lines = output.split('\\n')\n        fk_line = None\n        for line in lines:\n            if 'ForeignKey' in line and 'to_field' in line:\n                fk_line = line.strip()\n                break\n        \n        self.assertIsNotNone(fk_line)\n        # Should have proper syntax: ForeignKey('TestFoo', models.DO_NOTHING, to_field='other_id')\n        self.assertIn(\"models.DO_NOTHING\", fk_line)\n        self.assertIn(\"to_field='other_id'\", fk_line)\n        self.assertTrue(fk_line.endswith(')'))\n\n    def test_foreign_key_to_field_preserves_existing_functionality(self):\n        \"\"\"\n        Test that the fix doesn't break existing functionality for\n        foreign keys that reference primary keys.\n        \"\"\"\n        out = StringIO()\n        call_command('inspectdb', stdout=out)\n        output = out.getvalue()\n        \n        # Should contain models for all test tables\n        self.assertIn(\"class TestFoo(models.Model):\", output)\n        self.assertIn(\"class TestBar(models.Model):\", output)\n        self.assertIn(\"class TestBaz(models.Model):\", output)\n        \n        # TestBaz should have FK without to_field (references primary key)\n        baz_section = self._extract_model_section(output, \"TestBaz\")\n        self.assertIn(\"ForeignKey('TestFoo'\", baz_section)\n        self.assertNotIn(\"to_field=\", baz_section)\n        \n        # TestBar should have FK with to_field (references specific field)\n        bar_section = self._extract_model_section(output, \"TestBar\")\n        self.assertIn(\"ForeignKey('TestFoo'\", bar_section)\n        self.assertIn(\"to_field='other_id'\", bar_section)\n\n    def _extract_model_section(self, output, model_name):\n        \"\"\"Helper method to extract a specific model's section from inspectdb output.\"\"\"\n        lines = output.split('\\n')\n        start_idx = None\n        end_idx = None\n        \n        for i, line in enumerate(lines):\n            if f\"class {model_name}(models.Model):\" in line:\n                start_idx = i\n            elif start_idx is not None and line.startswith('class ') and 'models.Model' in line:\n                end_idx = i\n                break\n        \n        if start_idx is not None:\n            if end_idx is None:\n                end_idx = len(lines)\n            return '\\n'.join(lines[start_idx:end_idx])\n        return \"\"\n\n\nclass InspectDBForeignKeyToFieldFailureTests(TransactionTestCase):\n    \"\"\"\n    Tests that demonstrate the bug before the fix is applied.\n    These tests should fail with the current implementation.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test tables with foreign key to specific field.\"\"\"\n        with connection.cursor() as cursor:\n            # Create foo table with primary key and unique other_id field\n            cursor.execute(\"\"\"\n                CREATE TABLE bug_test_foo (\n                    id SERIAL PRIMARY KEY,\n                    other_id INTEGER UNIQUE\n                )\n            \"\"\")\n            \n            # Create bar table with foreign key to foo.other_id (not foo.id)\n            cursor.execute(\"\"\"\n                CREATE TABLE bug_test_bar (\n                    id SERIAL PRIMARY KEY,\n                    other_id INTEGER,\n                    CONSTRAINT bug_test_fk_constraint \n                    FOREIGN KEY(other_id) REFERENCES bug_test_foo(other_id)\n                )\n            \"\"\")\n\n    def tearDown(self):\n        \"\"\"Clean up test tables.\"\"\"\n        with connection.cursor() as cursor:\n            cursor.execute(\"DROP TABLE IF EXISTS bug_test_bar CASCADE\")\n            cursor.execute(\"DROP TABLE IF EXISTS bug_test_foo CASCADE\")\n\n    def test_bug_foreign_key_to_specific_field_missing_to_field(self):\n        \"\"\"\n        This test demonstrates the bug: inspectdb should generate\n        to_field parameter but currently doesn't.\n        \n        This test should FAIL before the fix is applied.\n        \"\"\"\n        out = StringIO()\n        call_command('inspectdb', 'bug_test_bar', stdout=out)\n        output = out.getvalue()\n        \n        # This assertion should fail with current implementation\n        # because inspectdb doesn't generate to_field parameter\n        try:\n            self.assertIn(\"to_field='other_id'\", output)\n            # If this passes, the bug is fixed\n        except AssertionError:\n            # This is expected with the current buggy implementation\n            # The test documents the bug\n            self.assertNotIn(\"to_field='other_id'\", output)\n            self.assertIn(\"ForeignKey('BugTestFoo'\", output)\n            # Re-raise to show this test fails (demonstrating the bug)\n            raise AssertionError(\n                \"Bug confirmed: inspectdb does not generate to_field parameter \"\n                \"for foreign keys that reference specific non-primary key fields\"\n            )\n</patched>\n</file>\n```",
  "patch": "--- a/tests/inspectdb/test_foreign_key_to_field.py\n+++ b/tests/inspectdb/test_foreign_key_to_field.py\n-# Empty if creating new file\n+import pytest\n+from io import StringIO\n+from django.core.management import call_command\n+from django.db import connection\n+from django.test import TestCase, TransactionTestCase\n+from django.test.utils import override_settings\n+\n+\n+class InspectDBForeignKeyToFieldTests(TransactionTestCase):\n+    \"\"\"\n+    Test that inspectdb correctly handles foreign keys that reference\n+    specific fields (not primary keys) in other tables.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test tables with foreign key to specific field.\"\"\"\n+        with connection.cursor() as cursor:\n+            # Create foo table with primary key and unique other_id field\n+            cursor.execute(\"\"\"\n+                CREATE TABLE test_foo (\n+                    id SERIAL PRIMARY KEY,\n+                    other_id INTEGER UNIQUE\n+                )\n+            \"\"\")\n+            \n+            # Create bar table with foreign key to foo.other_id (not foo.id)\n+            cursor.execute(\"\"\"\n+                CREATE TABLE test_bar (\n+                    id SERIAL PRIMARY KEY,\n+                    other_id INTEGER,\n+                    CONSTRAINT test_fk_constraint \n+                    FOREIGN KEY(other_id) REFERENCES test_foo(other_id)\n+                )\n+            \"\"\")\n+            \n+            # Create baz table with foreign key to foo.id (primary key) for comparison\n+            cursor.execute(\"\"\"\n+                CREATE TABLE test_baz (\n+                    id SERIAL PRIMARY KEY,\n+                    foo_id INTEGER,\n+                    CONSTRAINT test_fk_constraint_pk\n+                    FOREIGN KEY(foo_id) REFERENCES test_foo(id)\n+                )\n+            \"\"\")\n+\n+    def tearDown(self):\n+        \"\"\"Clean up test tables.\"\"\"\n+        with connection.cursor() as cursor:\n+            cursor.execute(\"DROP TABLE IF EXISTS test_bar CASCADE\")\n+            cursor.execute(\"DROP TABLE IF EXISTS test_baz CASCADE\")\n+            cursor.execute(\"DROP TABLE IF EXISTS test_foo CASCADE\")\n+\n+    def test_foreign_key_to_specific_field_includes_to_field_parameter(self):\n+        \"\"\"\n+        Test that inspectdb generates ForeignKey with to_field parameter\n+        when foreign key references a specific non-primary key field.\n+        \"\"\"\n+        out = StringIO()\n+        call_command('inspectdb', 'test_bar', stdout=out)\n+        output = out.getvalue()\n+        \n+        # Should contain to_field parameter for the foreign key to other_id\n+        self.assertIn(\"to_field='other_id'\", output)\n+        self.assertIn(\"ForeignKey('TestFoo'\", output)\n+        \n+    def test_foreign_key_to_primary_key_no_to_field_parameter(self):\n+        \"\"\"\n+        Test that inspectdb does NOT generate to_field parameter\n+        when foreign key references the primary key (existing behavior).\n+        \"\"\"\n+        out = StringIO()\n+        call_command('inspectdb', 'test_baz', stdout=out)\n+        output = out.getvalue()\n+        \n+        # Should NOT contain to_field parameter for foreign key to primary key\n+        self.assertNotIn(\"to_field=\", output)\n+        self.assertIn(\"ForeignKey('TestFoo'\", output)\n+\n+    def test_foreign_key_to_field_with_self_reference(self):\n+        \"\"\"\n+        Test that inspectdb handles self-referencing foreign keys to specific fields.\n+        \"\"\"\n+        with connection.cursor() as cursor:\n+            # Create self-referencing table\n+            cursor.execute(\"\"\"\n+                CREATE TABLE test_self_ref (\n+                    id SERIAL PRIMARY KEY,\n+                    code VARCHAR(10) UNIQUE,\n+                    parent_code VARCHAR(10),\n+                    CONSTRAINT test_self_fk\n+                    FOREIGN KEY(parent_code) REFERENCES test_self_ref(code)\n+                )\n+            \"\"\")\n+        \n+        try:\n+            out = StringIO()\n+            call_command('inspectdb', 'test_self_ref', stdout=out)\n+            output = out.getvalue()\n+            \n+            # Should contain to_field parameter for self-reference to code field\n+            self.assertIn(\"to_field='code'\", output)\n+            self.assertIn(\"ForeignKey('self'\", output)\n+            \n+        finally:\n+            with connection.cursor() as cursor:\n+                cursor.execute(\"DROP TABLE IF EXISTS test_self_ref CASCADE\")\n+\n+    def test_multiple_foreign_keys_mixed_references(self):\n+        \"\"\"\n+        Test that inspectdb correctly handles multiple foreign keys,\n+        some to primary keys and some to specific fields.\n+        \"\"\"\n+        with connection.cursor() as cursor:\n+            # Create table with multiple foreign keys\n+            cursor.execute(\"\"\"\n+                CREATE TABLE test_multi_fk (\n+                    id SERIAL PRIMARY KEY,\n+                    foo_id INTEGER,\n+                    foo_other_id INTEGER,\n+                    CONSTRAINT test_multi_fk_pk\n+                    FOREIGN KEY(foo_id) REFERENCES test_foo(id),\n+                    CONSTRAINT test_multi_fk_other\n+                    FOREIGN KEY(foo_other_id) REFERENCES test_foo(other_id)\n+                )\n+            \"\"\")\n+        \n+        try:\n+            out = StringIO()\n+            call_command('inspectdb', 'test_multi_fk', stdout=out)\n+            output = out.getvalue()\n+            \n+            # Should have one FK with to_field and one without\n+            self.assertIn(\"to_field='other_id'\", output)\n+            # Count occurrences of ForeignKey - should be 2\n+            fk_count = output.count(\"ForeignKey('TestFoo'\")\n+            self.assertEqual(fk_count, 2)\n+            \n+        finally:\n+            with connection.cursor() as cursor:\n+                cursor.execute(\"DROP TABLE IF EXISTS test_multi_fk CASCADE\")\n+\n+    def test_foreign_key_to_field_with_unique_constraint(self):\n+        \"\"\"\n+        Test that inspectdb generates OneToOneField with to_field parameter\n+        when foreign key to specific field has unique constraint.\n+        \"\"\"\n+        with connection.cursor() as cursor:\n+            # Create table with unique foreign key to specific field\n+            cursor.execute(\"\"\"\n+                CREATE TABLE test_unique_fk (\n+                    id SERIAL PRIMARY KEY,\n+                    unique_other_id INTEGER UNIQUE,\n+                    CONSTRAINT test_unique_fk_constraint\n+                    FOREIGN KEY(unique_other_id) REFERENCES test_foo(other_id)\n+                )\n+            \"\"\")\n+        \n+        try:\n+            out = StringIO()\n+            call_command('inspectdb', 'test_unique_fk', stdout=out)\n+            output = out.getvalue()\n+            \n+            # Should contain OneToOneField with to_field parameter\n+            self.assertIn(\"to_field='other_id'\", output)\n+            self.assertIn(\"OneToOneField('TestFoo'\", output)\n+            \n+        finally:\n+            with connection.cursor() as cursor:\n+                cursor.execute(\"DROP TABLE IF EXISTS test_unique_fk CASCADE\")\n+\n+    def test_inspectdb_output_format_with_to_field(self):\n+        \"\"\"\n+        Test that the generated model code is properly formatted\n+        when to_field parameter is included.\n+        \"\"\"\n+        out = StringIO()\n+        call_command('inspectdb', 'test_bar', stdout=out)\n+        output = out.getvalue()\n+        \n+        # Check that the field definition is properly formatted\n+        lines = output.split('\\n')\n+        fk_line = None\n+        for line in lines:\n+            if 'ForeignKey' in line and 'to_field' in line:\n+                fk_line = line.strip()\n+                break\n+        \n+        self.assertIsNotNone(fk_line)\n+        # Should have proper syntax: ForeignKey('TestFoo', models.DO_NOTHING, to_field='other_id')\n+        self.assertIn(\"models.DO_NOTHING\", fk_line)\n+        self.assertIn(\"to_field='other_id'\", fk_line)\n+        self.assertTrue(fk_line.endswith(')'))\n+\n+    def test_foreign_key_to_field_preserves_existing_functionality(self):\n+        \"\"\"\n+        Test that the fix doesn't break existing functionality for\n+        foreign keys that reference primary keys.\n+        \"\"\"\n+        out = StringIO()\n+        call_command('inspectdb', stdout=out)\n+        output = out.getvalue()\n+        \n+        # Should contain models for all test tables\n+        self.assertIn(\"class TestFoo(models.Model):\", output)\n+        self.assertIn(\"class TestBar(models.Model):\", output)\n+        self.assertIn(\"class TestBaz(models.Model):\", output)\n+        \n+        # TestBaz should have FK without to_field (references primary key)\n+        baz_section = self._extract_model_section(output, \"TestBaz\")\n+        self.assertIn(\"ForeignKey('TestFoo'\", baz_section)\n+        self.assertNotIn(\"to_field=\", baz_section)\n+        \n+        # TestBar should have FK with to_field (references specific field)\n+        bar_section = self._extract_model_section(output, \"TestBar\")\n+        self.assertIn(\"ForeignKey('TestFoo'\", bar_section)\n+        self.assertIn(\"to_field='other_id'\", bar_section)\n+\n+    def _extract_model_section(self, output, model_name):\n+        \"\"\"Helper method to extract a specific model's section from inspectdb output.\"\"\"\n+        lines = output.split('\\n')\n+        start_idx = None\n+        end_idx = None\n+        \n+        for i, line in enumerate(lines):\n+            if f\"class {model_name}(models.Model):\" in line:\n+                start_idx = i\n+            elif start_idx is not None and line.startswith('class ') and 'models.Model' in line:\n+                end_idx = i\n+                break\n+        \n+        if start_idx is not None:\n+            if end_idx is None:\n+                end_idx = len(lines)\n+            return '\\n'.join(lines[start_idx:end_idx])\n+        return \"\"\n+\n+\n+class InspectDBForeignKeyToFieldFailureTests(TransactionTestCase):\n+    \"\"\"\n+    Tests that demonstrate the bug before the fix is applied.\n+    These tests should fail with the current implementation.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test tables with foreign key to specific field.\"\"\"\n+        with connection.cursor() as cursor:\n+            # Create foo table with primary key and unique other_id field\n+            cursor.execute(\"\"\"\n+                CREATE TABLE bug_test_foo (\n+                    id SERIAL PRIMARY KEY,\n+                    other_id INTEGER UNIQUE\n+                )\n+            \"\"\")\n+            \n+            # Create bar table with foreign key to foo.other_id (not foo.id)\n+            cursor.execute(\"\"\"\n+                CREATE TABLE bug_test_bar (\n+                    id SERIAL PRIMARY KEY,\n+                    other_id INTEGER,\n+                    CONSTRAINT bug_test_fk_constraint \n+                    FOREIGN KEY(other_id) REFERENCES bug_test_foo(other_id)\n+                )\n+            \"\"\")\n+\n+    def tearDown(self):\n+        \"\"\"Clean up test tables.\"\"\"\n+        with connection.cursor() as cursor:\n+            cursor.execute(\"DROP TABLE IF EXISTS bug_test_bar CASCADE\")\n+            cursor.execute(\"DROP TABLE IF EXISTS bug_test_foo CASCADE\")\n+\n+    def test_bug_foreign_key_to_specific_field_missing_to_field(self):\n+        \"\"\"\n+        This test demonstrates the bug: inspectdb should generate\n+        to_field parameter but currently doesn't.\n+        \n+        This test should FAIL before the fix is applied.\n+        \"\"\"\n+        out = StringIO()\n+        call_command('inspectdb', 'bug_test_bar', stdout=out)\n+        output = out.getvalue()\n+        \n+        # This assertion should fail with current implementation\n+        # because inspectdb doesn't generate to_field parameter\n+        try:\n+            self.assertIn(\"to_field='other_id'\", output)\n+            # If this passes, the bug is fixed\n+        except AssertionError:\n+            # This is expected with the current buggy implementation\n+            # The test documents the bug\n+            self.assertNotIn(\"to_field='other_id'\", output)\n+            self.assertIn(\"ForeignKey('BugTestFoo'\", output)\n+            # Re-raise to show this test fails (demonstrating the bug)\n+            raise AssertionError(\n+                \"Bug confirmed: inspectdb does not generate to_field parameter \"\n+                \"for foreign keys that reference specific non-primary key fields\"\n+            )\n"
}