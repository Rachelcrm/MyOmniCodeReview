{
  "instance_id": "django__django-15252",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/migrations/test_recorder.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom django.db import DatabaseError, connections\nfrom django.db.migrations.recorder import MigrationRecorder\nfrom django.test import TestCase, override_settings\n\n\nclass TestRouter:\n    \"\"\"Test router that only allows migrations on 'default' database.\"\"\"\n    \n    def allow_migrate(self, db, app_label, model_name=None, **hints):\n        if db == 'default':\n            return True\n        return False\n\n\nclass RestrictiveRouter:\n    \"\"\"Test router that doesn't allow migrations on any database.\"\"\"\n    \n    def allow_migrate(self, db, app_label, model_name=None, **hints):\n        return False\n\n\nclass MigrationRecorderRouterTests(TestCase):\n    \"\"\"Test that MigrationRecorder respects database router allow_migrate rules.\"\"\"\n    \n    def setUp(self):\n        self.connection = connections['default']\n        self.recorder = MigrationRecorder(self.connection)\n    \n    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n    def test_ensure_schema_respects_router_allow_migrate_default_db(self):\n        \"\"\"Test that ensure_schema works on default database when router allows it.\"\"\"\n        # Mock has_table to return False so ensure_schema tries to create table\n        with patch.object(self.recorder, 'has_table', return_value=False):\n            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                # This should work since router allows migrations on 'default'\n                self.recorder.ensure_schema()\n                \n                # Verify that create_model was called\n                mock_schema_editor.create_model.assert_called_once_with(self.recorder.Migration)\n    \n    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n    def test_ensure_schema_respects_router_allow_migrate_non_default_db(self):\n        \"\"\"Test that ensure_schema doesn't create table when router disallows it.\"\"\"\n        # Create a mock connection for non-default database\n        mock_connection = Mock()\n        mock_connection.alias = 'other_db'\n        recorder = MigrationRecorder(mock_connection)\n        \n        # Mock has_table to return False so ensure_schema would try to create table\n        with patch.object(recorder, 'has_table', return_value=False):\n            with patch.object(recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                # This should not create the table since router disallows migrations on 'other_db'\n                recorder.ensure_schema()\n                \n                # Verify that create_model was NOT called\n                mock_schema_editor.create_model.assert_not_called()\n    \n    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.RestrictiveRouter'])\n    def test_ensure_schema_respects_router_disallow_all(self):\n        \"\"\"Test that ensure_schema doesn't create table when router disallows all migrations.\"\"\"\n        # Mock has_table to return False so ensure_schema would try to create table\n        with patch.object(self.recorder, 'has_table', return_value=False):\n            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                # This should not create the table since router disallows all migrations\n                self.recorder.ensure_schema()\n                \n                # Verify that create_model was NOT called\n                mock_schema_editor.create_model.assert_not_called()\n    \n    def test_ensure_schema_skips_when_table_exists(self):\n        \"\"\"Test that ensure_schema skips creation when table already exists.\"\"\"\n        # Mock has_table to return True\n        with patch.object(self.recorder, 'has_table', return_value=True):\n            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                # This should not try to create the table since it already exists\n                self.recorder.ensure_schema()\n                \n                # Verify that create_model was NOT called\n                mock_schema_editor.create_model.assert_not_called()\n    \n    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n    def test_record_applied_respects_router_allow_migrate(self):\n        \"\"\"Test that record_applied respects router rules through ensure_schema.\"\"\"\n        # Mock has_table to return False so ensure_schema is called\n        with patch.object(self.recorder, 'has_table', return_value=False):\n            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                with patch.object(self.recorder.migration_qs, 'create') as mock_create:\n                    # This should work on default database\n                    self.recorder.record_applied('test_app', 'test_migration')\n                    \n                    # Verify that create_model was called (table creation allowed)\n                    mock_schema_editor.create_model.assert_called_once_with(self.recorder.Migration)\n                    # Verify that migration record was created\n                    mock_create.assert_called_once_with(app='test_app', name='test_migration')\n    \n    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n    def test_record_applied_blocked_on_non_default_db(self):\n        \"\"\"Test that record_applied is blocked on non-default database.\"\"\"\n        # Create a mock connection for non-default database\n        mock_connection = Mock()\n        mock_connection.alias = 'other_db'\n        recorder = MigrationRecorder(mock_connection)\n        \n        # Mock has_table to return False so ensure_schema is called\n        with patch.object(recorder, 'has_table', return_value=False):\n            with patch.object(recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                with patch.object(recorder, 'migration_qs') as mock_qs:\n                    # This should not create the table on non-default database\n                    recorder.record_applied('test_app', 'test_migration')\n                    \n                    # Verify that create_model was NOT called (table creation blocked)\n                    mock_schema_editor.create_model.assert_not_called()\n                    # Migration record creation should still be attempted\n                    # (this would fail in practice, but we're testing the ensure_schema part)\n                    mock_qs.create.assert_called_once_with(app='test_app', name='test_migration')\n    \n    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n    def test_record_unapplied_respects_router_allow_migrate(self):\n        \"\"\"Test that record_unapplied respects router rules through ensure_schema.\"\"\"\n        # Mock has_table to return False so ensure_schema is called\n        with patch.object(self.recorder, 'has_table', return_value=False):\n            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                with patch.object(self.recorder.migration_qs, 'filter') as mock_filter:\n                    mock_queryset = Mock()\n                    mock_filter.return_value = mock_queryset\n                    \n                    # This should work on default database\n                    self.recorder.record_unapplied('test_app', 'test_migration')\n                    \n                    # Verify that create_model was called (table creation allowed)\n                    mock_schema_editor.create_model.assert_called_once_with(self.recorder.Migration)\n                    # Verify that migration record was deleted\n                    mock_filter.assert_called_once_with(app='test_app', name='test_migration')\n                    mock_queryset.delete.assert_called_once()\n    \n    def test_ensure_schema_handles_database_error(self):\n        \"\"\"Test that ensure_schema properly handles DatabaseError during table creation.\"\"\"\n        # Mock has_table to return False so ensure_schema tries to create table\n        with patch.object(self.recorder, 'has_table', return_value=False):\n            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                # Make create_model raise DatabaseError\n                mock_schema_editor.create_model.side_effect = DatabaseError(\"Test error\")\n                \n                # This should raise MigrationSchemaMissing\n                from django.db.migrations.exceptions import MigrationSchemaMissing\n                with pytest.raises(MigrationSchemaMissing):\n                    self.recorder.ensure_schema()\n    \n    @override_settings(DATABASE_ROUTERS=[])\n    def test_ensure_schema_works_without_router(self):\n        \"\"\"Test that ensure_schema works normally when no router is configured.\"\"\"\n        # Mock has_table to return False so ensure_schema tries to create table\n        with patch.object(self.recorder, 'has_table', return_value=False):\n            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                # This should work when no router is configured\n                self.recorder.ensure_schema()\n                \n                # Verify that create_model was called\n                mock_schema_editor.create_model.assert_called_once_with(self.recorder.Migration)\n\n\nclass MigrationRecorderBugReproductionTests(TestCase):\n    \"\"\"Tests that reproduce the original bug before the fix is applied.\"\"\"\n    \n    def setUp(self):\n        self.connection = connections['default']\n        self.recorder = MigrationRecorder(self.connection)\n    \n    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n    def test_bug_ensure_schema_ignores_router_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: ensure_schema creates table even when \n        router disallows migrations on non-default database.\n        \n        This test should FAIL before the fix is applied, demonstrating the bug.\n        \"\"\"\n        # Create a mock connection for non-default database\n        mock_connection = Mock()\n        mock_connection.alias = 'other_db'\n        recorder = MigrationRecorder(mock_connection)\n        \n        # Mock has_table to return False so ensure_schema tries to create table\n        with patch.object(recorder, 'has_table', return_value=False):\n            with patch.object(recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                # Before the fix, this would create the table even though router disallows it\n                recorder.ensure_schema()\n                \n                # This assertion should FAIL before the fix (demonstrating the bug)\n                # After the fix, this should PASS\n                mock_schema_editor.create_model.assert_not_called()\n    \n    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.RestrictiveRouter'])\n    def test_bug_record_applied_ignores_router_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: record_applied creates migration table\n        even when router disallows all migrations.\n        \n        This test should FAIL before the fix is applied.\n        \"\"\"\n        # Mock has_table to return False so ensure_schema is called\n        with patch.object(self.recorder, 'has_table', return_value=False):\n            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n                mock_schema_editor = Mock()\n                mock_schema_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n                mock_editor.return_value.__exit__ = Mock(return_value=None)\n                \n                with patch.object(self.recorder.migration_qs, 'create'):\n                    # Before the fix, this would create the table even though router disallows it\n                    self.recorder.record_applied('test_app', 'test_migration')\n                    \n                    # This assertion should FAIL before the fix (demonstrating the bug)\n                    # After the fix, this should PASS\n                    mock_schema_editor.create_model.assert_not_called()\n</patched>\n```",
  "patch": "--- a/tests/migrations/test_recorder.py\n+++ b/tests/migrations/test_recorder.py\n-# Empty if creating new file\n+import pytest\n+from unittest.mock import Mock, patch\n+from django.db import DatabaseError, connections\n+from django.db.migrations.recorder import MigrationRecorder\n+from django.test import TestCase, override_settings\n+\n+\n+class TestRouter:\n+    \"\"\"Test router that only allows migrations on 'default' database.\"\"\"\n+    \n+    def allow_migrate(self, db, app_label, model_name=None, **hints):\n+        if db == 'default':\n+            return True\n+        return False\n+\n+\n+class RestrictiveRouter:\n+    \"\"\"Test router that doesn't allow migrations on any database.\"\"\"\n+    \n+    def allow_migrate(self, db, app_label, model_name=None, **hints):\n+        return False\n+\n+\n+class MigrationRecorderRouterTests(TestCase):\n+    \"\"\"Test that MigrationRecorder respects database router allow_migrate rules.\"\"\"\n+    \n+    def setUp(self):\n+        self.connection = connections['default']\n+        self.recorder = MigrationRecorder(self.connection)\n+    \n+    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n+    def test_ensure_schema_respects_router_allow_migrate_default_db(self):\n+        \"\"\"Test that ensure_schema works on default database when router allows it.\"\"\"\n+        # Mock has_table to return False so ensure_schema tries to create table\n+        with patch.object(self.recorder, 'has_table', return_value=False):\n+            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                # This should work since router allows migrations on 'default'\n+                self.recorder.ensure_schema()\n+                \n+                # Verify that create_model was called\n+                mock_schema_editor.create_model.assert_called_once_with(self.recorder.Migration)\n+    \n+    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n+    def test_ensure_schema_respects_router_allow_migrate_non_default_db(self):\n+        \"\"\"Test that ensure_schema doesn't create table when router disallows it.\"\"\"\n+        # Create a mock connection for non-default database\n+        mock_connection = Mock()\n+        mock_connection.alias = 'other_db'\n+        recorder = MigrationRecorder(mock_connection)\n+        \n+        # Mock has_table to return False so ensure_schema would try to create table\n+        with patch.object(recorder, 'has_table', return_value=False):\n+            with patch.object(recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                # This should not create the table since router disallows migrations on 'other_db'\n+                recorder.ensure_schema()\n+                \n+                # Verify that create_model was NOT called\n+                mock_schema_editor.create_model.assert_not_called()\n+    \n+    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.RestrictiveRouter'])\n+    def test_ensure_schema_respects_router_disallow_all(self):\n+        \"\"\"Test that ensure_schema doesn't create table when router disallows all migrations.\"\"\"\n+        # Mock has_table to return False so ensure_schema would try to create table\n+        with patch.object(self.recorder, 'has_table', return_value=False):\n+            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                # This should not create the table since router disallows all migrations\n+                self.recorder.ensure_schema()\n+                \n+                # Verify that create_model was NOT called\n+                mock_schema_editor.create_model.assert_not_called()\n+    \n+    def test_ensure_schema_skips_when_table_exists(self):\n+        \"\"\"Test that ensure_schema skips creation when table already exists.\"\"\"\n+        # Mock has_table to return True\n+        with patch.object(self.recorder, 'has_table', return_value=True):\n+            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                # This should not try to create the table since it already exists\n+                self.recorder.ensure_schema()\n+                \n+                # Verify that create_model was NOT called\n+                mock_schema_editor.create_model.assert_not_called()\n+    \n+    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n+    def test_record_applied_respects_router_allow_migrate(self):\n+        \"\"\"Test that record_applied respects router rules through ensure_schema.\"\"\"\n+        # Mock has_table to return False so ensure_schema is called\n+        with patch.object(self.recorder, 'has_table', return_value=False):\n+            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                with patch.object(self.recorder.migration_qs, 'create') as mock_create:\n+                    # This should work on default database\n+                    self.recorder.record_applied('test_app', 'test_migration')\n+                    \n+                    # Verify that create_model was called (table creation allowed)\n+                    mock_schema_editor.create_model.assert_called_once_with(self.recorder.Migration)\n+                    # Verify that migration record was created\n+                    mock_create.assert_called_once_with(app='test_app', name='test_migration')\n+    \n+    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n+    def test_record_applied_blocked_on_non_default_db(self):\n+        \"\"\"Test that record_applied is blocked on non-default database.\"\"\"\n+        # Create a mock connection for non-default database\n+        mock_connection = Mock()\n+        mock_connection.alias = 'other_db'\n+        recorder = MigrationRecorder(mock_connection)\n+        \n+        # Mock has_table to return False so ensure_schema is called\n+        with patch.object(recorder, 'has_table', return_value=False):\n+            with patch.object(recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                with patch.object(recorder, 'migration_qs') as mock_qs:\n+                    # This should not create the table on non-default database\n+                    recorder.record_applied('test_app', 'test_migration')\n+                    \n+                    # Verify that create_model was NOT called (table creation blocked)\n+                    mock_schema_editor.create_model.assert_not_called()\n+                    # Migration record creation should still be attempted\n+                    # (this would fail in practice, but we're testing the ensure_schema part)\n+                    mock_qs.create.assert_called_once_with(app='test_app', name='test_migration')\n+    \n+    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n+    def test_record_unapplied_respects_router_allow_migrate(self):\n+        \"\"\"Test that record_unapplied respects router rules through ensure_schema.\"\"\"\n+        # Mock has_table to return False so ensure_schema is called\n+        with patch.object(self.recorder, 'has_table', return_value=False):\n+            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                with patch.object(self.recorder.migration_qs, 'filter') as mock_filter:\n+                    mock_queryset = Mock()\n+                    mock_filter.return_value = mock_queryset\n+                    \n+                    # This should work on default database\n+                    self.recorder.record_unapplied('test_app', 'test_migration')\n+                    \n+                    # Verify that create_model was called (table creation allowed)\n+                    mock_schema_editor.create_model.assert_called_once_with(self.recorder.Migration)\n+                    # Verify that migration record was deleted\n+                    mock_filter.assert_called_once_with(app='test_app', name='test_migration')\n+                    mock_queryset.delete.assert_called_once()\n+    \n+    def test_ensure_schema_handles_database_error(self):\n+        \"\"\"Test that ensure_schema properly handles DatabaseError during table creation.\"\"\"\n+        # Mock has_table to return False so ensure_schema tries to create table\n+        with patch.object(self.recorder, 'has_table', return_value=False):\n+            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                # Make create_model raise DatabaseError\n+                mock_schema_editor.create_model.side_effect = DatabaseError(\"Test error\")\n+                \n+                # This should raise MigrationSchemaMissing\n+                from django.db.migrations.exceptions import MigrationSchemaMissing\n+                with pytest.raises(MigrationSchemaMissing):\n+                    self.recorder.ensure_schema()\n+    \n+    @override_settings(DATABASE_ROUTERS=[])\n+    def test_ensure_schema_works_without_router(self):\n+        \"\"\"Test that ensure_schema works normally when no router is configured.\"\"\"\n+        # Mock has_table to return False so ensure_schema tries to create table\n+        with patch.object(self.recorder, 'has_table', return_value=False):\n+            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                # This should work when no router is configured\n+                self.recorder.ensure_schema()\n+                \n+                # Verify that create_model was called\n+                mock_schema_editor.create_model.assert_called_once_with(self.recorder.Migration)\n+\n+\n+class MigrationRecorderBugReproductionTests(TestCase):\n+    \"\"\"Tests that reproduce the original bug before the fix is applied.\"\"\"\n+    \n+    def setUp(self):\n+        self.connection = connections['default']\n+        self.recorder = MigrationRecorder(self.connection)\n+    \n+    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.TestRouter'])\n+    def test_bug_ensure_schema_ignores_router_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: ensure_schema creates table even when \n+        router disallows migrations on non-default database.\n+        \n+        This test should FAIL before the fix is applied, demonstrating the bug.\n+        \"\"\"\n+        # Create a mock connection for non-default database\n+        mock_connection = Mock()\n+        mock_connection.alias = 'other_db'\n+        recorder = MigrationRecorder(mock_connection)\n+        \n+        # Mock has_table to return False so ensure_schema tries to create table\n+        with patch.object(recorder, 'has_table', return_value=False):\n+            with patch.object(recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                # Before the fix, this would create the table even though router disallows it\n+                recorder.ensure_schema()\n+                \n+                # This assertion should FAIL before the fix (demonstrating the bug)\n+                # After the fix, this should PASS\n+                mock_schema_editor.create_model.assert_not_called()\n+    \n+    @override_settings(DATABASE_ROUTERS=['tests.migrations.test_recorder.RestrictiveRouter'])\n+    def test_bug_record_applied_ignores_router_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: record_applied creates migration table\n+        even when router disallows all migrations.\n+        \n+        This test should FAIL before the fix is applied.\n+        \"\"\"\n+        # Mock has_table to return False so ensure_schema is called\n+        with patch.object(self.recorder, 'has_table', return_value=False):\n+            with patch.object(self.recorder.connection, 'schema_editor') as mock_editor:\n+                mock_schema_editor = Mock()\n+                mock_schema_editor.return_value.__enter__ = Mock(return_value=mock_schema_editor)\n+                mock_editor.return_value.__exit__ = Mock(return_value=None)\n+                \n+                with patch.object(self.recorder.migration_qs, 'create'):\n+                    # Before the fix, this would create the table even though router disallows it\n+                    self.recorder.record_applied('test_app', 'test_migration')\n+                    \n+                    # This assertion should FAIL before the fix (demonstrating the bug)\n+                    # After the fix, this should PASS\n+                    mock_schema_editor.create_model.assert_not_called()\n"
}