--- a/tests/forms_tests/test_models.py
+++ b/tests/forms_tests/test_models.py
-# Empty if creating new file
+import pytest
+from django.db import models
+from django.forms.models import model_to_dict, BaseModelForm
+from django.forms import ModelForm
+from django.test import TestCase
+
+
+class TestModel(models.Model):
+    """Test model for model_to_dict tests."""
+    name = models.CharField(max_length=100)
+    email = models.EmailField()
+    age = models.IntegerField()
+    is_active = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = 'forms_tests'
+
+
+class TestModelForm(ModelForm):
+    """Test form for BaseModelForm._save_m2m tests."""
+    class Meta:
+        model = TestModel
+        fields = '__all__'
+
+
+class ModelToDictEmptyFieldsTest(TestCase):
+    """Test cases for model_to_dict with empty fields parameter."""
+    
+    def setUp(self):
+        """Set up test instance."""
+        self.instance = TestModel(
+            name='John Doe',
+            email='john@example.com',
+            age=30,
+            is_active=True
+        )
+    
+    def test_model_to_dict_with_empty_fields_list_returns_empty_dict(self):
+        """
+        Test that model_to_dict returns an empty dict when fields=[] is passed.
+        This test demonstrates the bug - it should pass after the fix.
+        """
+        result = model_to_dict(self.instance, fields=[])
+        expected = {}
+        self.assertEqual(result, expected, 
+                        "model_to_dict should return empty dict when fields=[] is passed")
+    
+    def test_model_to_dict_with_none_fields_returns_all_fields(self):
+        """
+        Test that model_to_dict returns all fields when fields=None (default behavior).
+        This test should pass both before and after the fix.
+        """
+        result = model_to_dict(self.instance, fields=None)
+        expected_keys = {'name', 'email', 'age', 'is_active'}
+        self.assertEqual(set(result.keys()), expected_keys,
+                        "model_to_dict should return all fields when fields=None")
+        self.assertEqual(result['name'], 'John Doe')
+        self.assertEqual(result['email'], 'john@example.com')
+        self.assertEqual(result['age'], 30)
+        self.assertEqual(result['is_active'], True)
+    
+    def test_model_to_dict_with_specific_fields_returns_only_those_fields(self):
+        """
+        Test that model_to_dict returns only specified fields when fields list is provided.
+        This test should pass both before and after the fix.
+        """
+        result = model_to_dict(self.instance, fields=['name', 'email'])
+        expected = {
+            'name': 'John Doe',
+            'email': 'john@example.com'
+        }
+        self.assertEqual(result, expected,
+                        "model_to_dict should return only specified fields")
+    
+    def test_model_to_dict_with_empty_fields_and_exclude(self):
+        """
+        Test that model_to_dict returns empty dict when fields=[] even with exclude parameter.
+        This test demonstrates the bug interaction with exclude parameter.
+        """
+        result = model_to_dict(self.instance, fields=[], exclude=['age'])
+        expected = {}
+        self.assertEqual(result, expected,
+                        "model_to_dict should return empty dict when fields=[] regardless of exclude")
+    
+    def test_model_to_dict_fields_parameter_edge_cases(self):
+        """
+        Test edge cases for the fields parameter to ensure proper handling.
+        """
+        # Test with empty tuple
+        result = model_to_dict(self.instance, fields=())
+        self.assertEqual(result, {}, "Empty tuple should return empty dict")
+        
+        # Test with single field in list
+        result = model_to_dict(self.instance, fields=['name'])
+        expected = {'name': 'John Doe'}
+        self.assertEqual(result, expected, "Single field should work correctly")
+        
+        # Test with non-existent field (should be ignored)
+        result = model_to_dict(self.instance, fields=['name', 'non_existent'])
+        expected = {'name': 'John Doe'}
+        self.assertEqual(result, expected, "Non-existent fields should be ignored")
+
+
+class BaseModelFormSaveM2MTest(TestCase):
+    """Test cases for BaseModelForm._save_m2m with empty fields parameter."""
+    
+    def setUp(self):
+        """Set up test instance and form."""
+        self.instance = TestModel.objects.create(
+            name='Jane Doe',
+            email='jane@example.com',
+            age=25,
+            is_active=True
+        )
+    
+    def test_save_m2m_with_empty_fields_meta(self):
+        """
+        Test that _save_m2m respects empty fields list in Meta.
+        This test verifies the fix for the same bug in BaseModelForm._save_m2m.
+        """
+        class EmptyFieldsForm(ModelForm):
+            class Meta:
+                model = TestModel
+                fields = []  # Empty fields list
+        
+        form = EmptyFieldsForm(instance=self.instance)
+        # This should not raise an error and should handle empty fields correctly
+        try:
+            form._save_m2m()
+        except Exception as e:
+            self.fail(f"_save_m2m should handle empty fields list without error: {e}")
+    
+    def test_save_m2m_with_none_fields_meta(self):
+        """
+        Test that _save_m2m works correctly when Meta.fields is None.
+        This test ensures existing behavior is preserved.
+        """
+        class AllFieldsForm(ModelForm):
+            class Meta:
+                model = TestModel
+                fields = '__all__'
+        
+        form = AllFieldsForm(instance=self.instance)
+        # This should work as before
+        try:
+            form._save_m2m()
+        except Exception as e:
+            self.fail(f"_save_m2m should work with all fields: {e}")
+
+
+class ModelToDictBugReproductionTest(TestCase):
+    """
+    Test that reproduces the exact bug described in the issue.
+    This test should FAIL before the fix and PASS after the fix.
+    """
+    
+    def setUp(self):
+        """Set up test instance."""
+        self.instance = TestModel(
+            name='Bug Test',
+            email='bug@test.com',
+            age=99,
+            is_active=False
+        )
+    
+    def test_bug_reproduction_empty_fields_returns_all_fields(self):
+        """
+        This test reproduces the bug where model_to_dict(instance, fields=[])
+        incorrectly returns all fields instead of an empty dict.
+        
+        Before fix: This test will FAIL because it returns all fields
+        After fix: This test will PASS because it returns empty dict
+        """
+        result = model_to_dict(self.instance, fields=[])
+        
+        # The bug: this assertion will fail before the fix because
+        # result will contain all fields instead of being empty
+        self.assertEqual(len(result), 0, 
+                        "BUG: model_to_dict with fields=[] should return empty dict, "
+                        f"but got {len(result)} fields: {list(result.keys())}")
+        
+        # Additional assertion to be very explicit about expected behavior
+        self.assertEqual(result, {}, 
+                        "model_to_dict(instance, fields=[]) must return empty dict")
+    
+    def test_bug_demonstration_fields_none_vs_empty_list(self):
+        """
+        Demonstrate the difference between fields=None and fields=[].
+        This test shows the intended behavior difference.
+        """
+        # fields=None should return all fields (existing behavior)
+        result_none = model_to_dict(self.instance, fields=None)
+        self.assertGreater(len(result_none), 0, "fields=None should return all fields")
+        
+        # fields=[] should return empty dict (bug fix)
+        result_empty = model_to_dict(self.instance, fields=[])
+        self.assertEqual(len(result_empty), 0, "fields=[] should return empty dict")
+        
+        # They should be different
+        self.assertNotEqual(result_none, result_empty, 
+                           "fields=None and fields=[] should produce different results")
