{
  "instance_id": "django__django-13023",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_fields/test_decimalfield.py</file>\n<original>\n</original>\n<patched>\nimport pytest\nfrom decimal import Decimal\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.test import TestCase\n\n\nclass DecimalFieldTopythonTests(TestCase):\n    \"\"\"Test DecimalField.to_python() method behavior with various input types.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up a DecimalField instance for testing.\"\"\"\n        self.field = models.DecimalField(max_digits=10, decimal_places=2)\n    \n    def test_to_python_with_valid_decimal(self):\n        \"\"\"Test that valid decimal values are handled correctly.\"\"\"\n        # Test with Decimal instance\n        value = Decimal('10.50')\n        result = self.field.to_python(value)\n        self.assertEqual(result, value)\n        \n        # Test with string representation\n        result = self.field.to_python('10.50')\n        self.assertEqual(result, Decimal('10.50'))\n        \n        # Test with integer\n        result = self.field.to_python(10)\n        self.assertEqual(result, Decimal('10'))\n    \n    def test_to_python_with_none(self):\n        \"\"\"Test that None values are handled correctly.\"\"\"\n        result = self.field.to_python(None)\n        self.assertIsNone(result)\n    \n    def test_to_python_with_float(self):\n        \"\"\"Test that float values are converted using context.\"\"\"\n        result = self.field.to_python(10.5)\n        self.assertIsInstance(result, Decimal)\n        # Float conversion should use the field's context\n        self.assertEqual(str(result), '10.5')\n    \n    def test_to_python_with_dict_raises_validation_error(self):\n        \"\"\"Test that dictionary values raise ValidationError, not TypeError.\"\"\"\n        test_dict = {'invalid': 'value'}\n        \n        # This should raise ValidationError, not TypeError\n        with self.assertRaises(ValidationError) as cm:\n            self.field.to_python(test_dict)\n        \n        # Verify it's a ValidationError with the correct code\n        self.assertEqual(cm.exception.code, 'invalid')\n        self.assertIn('value', cm.exception.message_dict or {})\n    \n    def test_to_python_with_list_raises_validation_error(self):\n        \"\"\"Test that list values raise ValidationError, not TypeError.\"\"\"\n        test_list = [1, 2, 3]\n        \n        # This should raise ValidationError, not TypeError\n        with self.assertRaises(ValidationError) as cm:\n            self.field.to_python(test_list)\n        \n        # Verify it's a ValidationError with the correct code\n        self.assertEqual(cm.exception.code, 'invalid')\n    \n    def test_to_python_with_complex_object_raises_validation_error(self):\n        \"\"\"Test that complex objects raise ValidationError, not TypeError.\"\"\"\n        class CustomObject:\n            def __str__(self):\n                return \"custom\"\n        \n        test_obj = CustomObject()\n        \n        # This should raise ValidationError, not TypeError\n        with self.assertRaises(ValidationError) as cm:\n            self.field.to_python(test_obj)\n        \n        # Verify it's a ValidationError with the correct code\n        self.assertEqual(cm.exception.code, 'invalid')\n    \n    def test_to_python_with_invalid_string_raises_validation_error(self):\n        \"\"\"Test that invalid string values raise ValidationError.\"\"\"\n        invalid_strings = ['not_a_number', 'abc', '10.5.5', '']\n        \n        for invalid_string in invalid_strings:\n            with self.subTest(value=invalid_string):\n                with self.assertRaises(ValidationError) as cm:\n                    self.field.to_python(invalid_string)\n                \n                # Verify it's a ValidationError with the correct code\n                self.assertEqual(cm.exception.code, 'invalid')\n    \n    def test_to_python_error_message_contains_value(self):\n        \"\"\"Test that ValidationError message contains the invalid value.\"\"\"\n        test_dict = {'key': 'value'}\n        \n        with self.assertRaises(ValidationError) as cm:\n            self.field.to_python(test_dict)\n        \n        # The error should contain information about the invalid value\n        error = cm.exception\n        self.assertEqual(error.code, 'invalid')\n        # Check that the error params contain the value\n        if hasattr(error, 'params') and error.params:\n            self.assertIn('value', error.params)\n            self.assertEqual(error.params['value'], test_dict)\n\n\nclass DecimalFieldModelIntegrationTests(TestCase):\n    \"\"\"Integration tests for DecimalField in model context.\"\"\"\n    \n    def test_model_save_with_dict_in_decimal_field(self):\n        \"\"\"Test that saving a model with dict in DecimalField raises ValidationError.\"\"\"\n        # Create a simple model for testing\n        class TestModel(models.Model):\n            decimal_field = models.DecimalField(max_digits=10, decimal_places=2)\n            \n            class Meta:\n                app_label = 'test'\n        \n        # Create instance with invalid data\n        instance = TestModel()\n        instance.decimal_field = {'invalid': 'dict'}\n        \n        # This should raise ValidationError during field validation\n        with self.assertRaises(ValidationError):\n            instance.full_clean()\n    \n    def test_model_field_validation_with_various_invalid_types(self):\n        \"\"\"Test field validation with various invalid types.\"\"\"\n        class TestModel(models.Model):\n            decimal_field = models.DecimalField(max_digits=10, decimal_places=2)\n            \n            class Meta:\n                app_label = 'test'\n        \n        invalid_values = [\n            {'dict': 'value'},\n            [1, 2, 3],\n            set([1, 2, 3]),\n            object(),\n        ]\n        \n        for invalid_value in invalid_values:\n            with self.subTest(value=type(invalid_value).__name__):\n                instance = TestModel()\n                instance.decimal_field = invalid_value\n                \n                # Should raise ValidationError, not TypeError\n                with self.assertRaises(ValidationError):\n                    instance.full_clean()\n\n\n# Test to demonstrate the bug before the fix\nclass DecimalFieldBugReproductionTest(TestCase):\n    \"\"\"Test that reproduces the original bug behavior.\"\"\"\n    \n    def test_decimal_field_dict_value_bug_reproduction(self):\n        \"\"\"\n        This test reproduces the original bug where DecimalField.to_python()\n        raises TypeError instead of ValidationError when given a dict.\n        \n        Before the fix: This would raise TypeError\n        After the fix: This should raise ValidationError\n        \"\"\"\n        field = models.DecimalField(max_digits=10, decimal_places=2)\n        test_dict = {'invalid': 'value'}\n        \n        # The bug was that this raised TypeError instead of ValidationError\n        # After the fix, it should raise ValidationError\n        with self.assertRaises(ValidationError) as cm:\n            field.to_python(test_dict)\n        \n        # Verify the error details\n        error = cm.exception\n        self.assertEqual(error.code, 'invalid')\n        \n        # Ensure it's not a TypeError being raised\n        # (This assertion would fail before the fix)\n        self.assertIsInstance(error, ValidationError)\n        self.assertNotIsInstance(error, TypeError)\n</patched>\n</file>\n```",
  "patch": "--- a/tests/model_fields/test_decimalfield.py\n+++ b/tests/model_fields/test_decimalfield.py\n+import pytest\n+from decimal import Decimal\n+from django.core.exceptions import ValidationError\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class DecimalFieldTopythonTests(TestCase):\n+    \"\"\"Test DecimalField.to_python() method behavior with various input types.\"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up a DecimalField instance for testing.\"\"\"\n+        self.field = models.DecimalField(max_digits=10, decimal_places=2)\n+    \n+    def test_to_python_with_valid_decimal(self):\n+        \"\"\"Test that valid decimal values are handled correctly.\"\"\"\n+        # Test with Decimal instance\n+        value = Decimal('10.50')\n+        result = self.field.to_python(value)\n+        self.assertEqual(result, value)\n+        \n+        # Test with string representation\n+        result = self.field.to_python('10.50')\n+        self.assertEqual(result, Decimal('10.50'))\n+        \n+        # Test with integer\n+        result = self.field.to_python(10)\n+        self.assertEqual(result, Decimal('10'))\n+    \n+    def test_to_python_with_none(self):\n+        \"\"\"Test that None values are handled correctly.\"\"\"\n+        result = self.field.to_python(None)\n+        self.assertIsNone(result)\n+    \n+    def test_to_python_with_float(self):\n+        \"\"\"Test that float values are converted using context.\"\"\"\n+        result = self.field.to_python(10.5)\n+        self.assertIsInstance(result, Decimal)\n+        # Float conversion should use the field's context\n+        self.assertEqual(str(result), '10.5')\n+    \n+    def test_to_python_with_dict_raises_validation_error(self):\n+        \"\"\"Test that dictionary values raise ValidationError, not TypeError.\"\"\"\n+        test_dict = {'invalid': 'value'}\n+        \n+        # This should raise ValidationError, not TypeError\n+        with self.assertRaises(ValidationError) as cm:\n+            self.field.to_python(test_dict)\n+        \n+        # Verify it's a ValidationError with the correct code\n+        self.assertEqual(cm.exception.code, 'invalid')\n+        self.assertIn('value', cm.exception.message_dict or {})\n+    \n+    def test_to_python_with_list_raises_validation_error(self):\n+        \"\"\"Test that list values raise ValidationError, not TypeError.\"\"\"\n+        test_list = [1, 2, 3]\n+        \n+        # This should raise ValidationError, not TypeError\n+        with self.assertRaises(ValidationError) as cm:\n+            self.field.to_python(test_list)\n+        \n+        # Verify it's a ValidationError with the correct code\n+        self.assertEqual(cm.exception.code, 'invalid')\n+    \n+    def test_to_python_with_complex_object_raises_validation_error(self):\n+        \"\"\"Test that complex objects raise ValidationError, not TypeError.\"\"\"\n+        class CustomObject:\n+            def __str__(self):\n+                return \"custom\"\n+        \n+        test_obj = CustomObject()\n+        \n+        # This should raise ValidationError, not TypeError\n+        with self.assertRaises(ValidationError) as cm:\n+            self.field.to_python(test_obj)\n+        \n+        # Verify it's a ValidationError with the correct code\n+        self.assertEqual(cm.exception.code, 'invalid')\n+    \n+    def test_to_python_with_invalid_string_raises_validation_error(self):\n+        \"\"\"Test that invalid string values raise ValidationError.\"\"\"\n+        invalid_strings = ['not_a_number', 'abc', '10.5.5', '']\n+        \n+        for invalid_string in invalid_strings:\n+            with self.subTest(value=invalid_string):\n+                with self.assertRaises(ValidationError) as cm:\n+                    self.field.to_python(invalid_string)\n+                \n+                # Verify it's a ValidationError with the correct code\n+                self.assertEqual(cm.exception.code, 'invalid')\n+    \n+    def test_to_python_error_message_contains_value(self):\n+        \"\"\"Test that ValidationError message contains the invalid value.\"\"\"\n+        test_dict = {'key': 'value'}\n+        \n+        with self.assertRaises(ValidationError) as cm:\n+            self.field.to_python(test_dict)\n+        \n+        # The error should contain information about the invalid value\n+        error = cm.exception\n+        self.assertEqual(error.code, 'invalid')\n+        # Check that the error params contain the value\n+        if hasattr(error, 'params') and error.params:\n+            self.assertIn('value', error.params)\n+            self.assertEqual(error.params['value'], test_dict)\n+\n+\n+class DecimalFieldModelIntegrationTests(TestCase):\n+    \"\"\"Integration tests for DecimalField in model context.\"\"\"\n+    \n+    def test_model_save_with_dict_in_decimal_field(self):\n+        \"\"\"Test that saving a model with dict in DecimalField raises ValidationError.\"\"\"\n+        # Create a simple model for testing\n+        class TestModel(models.Model):\n+            decimal_field = models.DecimalField(max_digits=10, decimal_places=2)\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        # Create instance with invalid data\n+        instance = TestModel()\n+        instance.decimal_field = {'invalid': 'dict'}\n+        \n+        # This should raise ValidationError during field validation\n+        with self.assertRaises(ValidationError):\n+            instance.full_clean()\n+    \n+    def test_model_field_validation_with_various_invalid_types(self):\n+        \"\"\"Test field validation with various invalid types.\"\"\"\n+        class TestModel(models.Model):\n+            decimal_field = models.DecimalField(max_digits=10, decimal_places=2)\n+            \n+            class Meta:\n+                app_label = 'test'\n+        \n+        invalid_values = [\n+            {'dict': 'value'},\n+            [1, 2, 3],\n+            set([1, 2, 3]),\n+            object(),\n+        ]\n+        \n+        for invalid_value in invalid_values:\n+            with self.subTest(value=type(invalid_value).__name__):\n+                instance = TestModel()\n+                instance.decimal_field = invalid_value\n+                \n+                # Should raise ValidationError, not TypeError\n+                with self.assertRaises(ValidationError):\n+                    instance.full_clean()\n+\n+\n+# Test to demonstrate the bug before the fix\n+class DecimalFieldBugReproductionTest(TestCase):\n+    \"\"\"Test that reproduces the original bug behavior.\"\"\"\n+    \n+    def test_decimal_field_dict_value_bug_reproduction(self):\n+        \"\"\"\n+        This test reproduces the original bug where DecimalField.to_python()\n+        raises TypeError instead of ValidationError when given a dict.\n+        \n+        Before the fix: This would raise TypeError\n+        After the fix: This should raise ValidationError\n+        \"\"\"\n+        field = models.DecimalField(max_digits=10, decimal_places=2)\n+        test_dict = {'invalid': 'value'}\n+        \n+        # The bug was that this raised TypeError instead of ValidationError\n+        # After the fix, it should raise ValidationError\n+        with self.assertRaises(ValidationError) as cm:\n+            field.to_python(test_dict)\n+        \n+        # Verify the error details\n+        error = cm.exception\n+        self.assertEqual(error.code, 'invalid')\n+        \n+        # Ensure it's not a TypeError being raised\n+        # (This assertion would fail before the fix)\n+        self.assertIsInstance(error, ValidationError)\n+        self.assertNotIsInstance(error, TypeError)\n"
}