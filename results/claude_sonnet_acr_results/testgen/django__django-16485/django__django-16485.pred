{
  "instance_id": "django__django-16485",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/template_tests/filter_tests/test_floatformat.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom decimal import Decimal\nfrom django.template.defaultfilters import floatformat\nfrom django.test import SimpleTestCase\n\n\nclass FloatformatTests(SimpleTestCase):\n    \"\"\"Test cases for the floatformat template filter.\"\"\"\n\n    def test_floatformat_zero_string_with_zero_precision_bug_reproduction(self):\n        \"\"\"\n        Test that reproduces the bug where floatformat('0.00', 0) crashes.\n        This test should fail before the fix is applied.\n        \"\"\"\n        # This should not raise ValueError: valid range for prec is [1, MAX_PREC]\n        result = floatformat('0.00', 0)\n        self.assertEqual(result, '0')\n\n    def test_floatformat_zero_decimal_with_zero_precision_bug_reproduction(self):\n        \"\"\"\n        Test that reproduces the bug where floatformat(Decimal('0.00'), 0) crashes.\n        This test should fail before the fix is applied.\n        \"\"\"\n        # This should not raise ValueError: valid range for prec is [1, MAX_PREC]\n        result = floatformat(Decimal('0.00'), 0)\n        self.assertEqual(result, '0')\n\n    def test_floatformat_zero_variations_with_zero_precision(self):\n        \"\"\"\n        Test various zero representations with precision 0 to ensure they all work.\n        \"\"\"\n        test_cases = [\n            ('0.00', '0'),\n            ('0.000', '0'),\n            ('0.0000', '0'),\n            (Decimal('0.00'), '0'),\n            (Decimal('0.000'), '0'),\n            (Decimal('0.0000'), '0'),\n            ('0', '0'),\n            (0, '0'),\n            (0.0, '0'),\n            (0.00, '0'),\n        ]\n        \n        for input_val, expected in test_cases:\n            with self.subTest(input_val=input_val):\n                result = floatformat(input_val, 0)\n                self.assertEqual(result, expected)\n\n    def test_floatformat_small_decimals_with_zero_precision(self):\n        \"\"\"\n        Test small decimal values with zero precision to ensure proper rounding.\n        \"\"\"\n        test_cases = [\n            ('0.1', '0'),\n            ('0.4', '0'),\n            ('0.5', '1'),  # Should round up\n            ('0.6', '1'),\n            ('0.9', '1'),\n            (Decimal('0.1'), '0'),\n            (Decimal('0.4'), '0'),\n            (Decimal('0.5'), '1'),\n            (Decimal('0.6'), '1'),\n            (Decimal('0.9'), '1'),\n        ]\n        \n        for input_val, expected in test_cases:\n            with self.subTest(input_val=input_val):\n                result = floatformat(input_val, 0)\n                self.assertEqual(result, expected)\n\n    def test_floatformat_negative_zero_with_zero_precision(self):\n        \"\"\"\n        Test negative zero values with precision 0.\n        \"\"\"\n        test_cases = [\n            ('-0.00', '0'),\n            ('-0.000', '0'),\n            (Decimal('-0.00'), '0'),\n            (Decimal('-0.000'), '0'),\n        ]\n        \n        for input_val, expected in test_cases:\n            with self.subTest(input_val=input_val):\n                result = floatformat(input_val, 0)\n                self.assertEqual(result, expected)\n\n    def test_floatformat_edge_cases_with_zero_precision(self):\n        \"\"\"\n        Test edge cases that might trigger the precision calculation bug.\n        \"\"\"\n        test_cases = [\n            # Very small numbers that round to zero\n            ('0.0001', '0'),\n            ('0.00001', '0'),\n            (Decimal('0.0001'), '0'),\n            (Decimal('0.00001'), '0'),\n            # Numbers that round to 1\n            ('0.5000', '1'),\n            ('0.50000', '1'),\n            (Decimal('0.5000'), '1'),\n            (Decimal('0.50000'), '1'),\n        ]\n        \n        for input_val, expected in test_cases:\n            with self.subTest(input_val=input_val):\n                result = floatformat(input_val, 0)\n                self.assertEqual(result, expected)\n\n    def test_floatformat_preserves_existing_functionality(self):\n        \"\"\"\n        Test that the fix doesn't break existing functionality for other precision values.\n        \"\"\"\n        # Test with positive precision\n        self.assertEqual(floatformat('0.00', 1), '0.0')\n        self.assertEqual(floatformat('0.00', 2), '0.00')\n        self.assertEqual(floatformat(Decimal('0.00'), 1), '0.0')\n        self.assertEqual(floatformat(Decimal('0.00'), 2), '0.00')\n        \n        # Test with negative precision\n        self.assertEqual(floatformat('0.00', -1), '0')\n        self.assertEqual(floatformat('0.00', -2), '0')\n        self.assertEqual(floatformat(Decimal('0.00'), -1), '0')\n        self.assertEqual(floatformat(Decimal('0.00'), -2), '0')\n        \n        # Test with non-zero values\n        self.assertEqual(floatformat('1.234', 0), '1')\n        self.assertEqual(floatformat('1.234', 1), '1.2')\n        self.assertEqual(floatformat('1.234', 2), '1.23')\n        self.assertEqual(floatformat(Decimal('1.234'), 0), '1')\n        self.assertEqual(floatformat(Decimal('1.234'), 1), '1.2')\n        self.assertEqual(floatformat(Decimal('1.234'), 2), '1.23')\n\n    def test_floatformat_zero_precision_with_various_exponents(self):\n        \"\"\"\n        Test zero precision with decimals having various exponents to ensure\n        the precision calculation handles all cases correctly.\n        \"\"\"\n        test_cases = [\n            # Different exponents that could cause precision calculation issues\n            (Decimal('0.0'), '0'),      # exponent = -1\n            (Decimal('0.00'), '0'),     # exponent = -2\n            (Decimal('0.000'), '0'),    # exponent = -3\n            (Decimal('0.0000'), '0'),   # exponent = -4\n            (Decimal('0.00000'), '0'),  # exponent = -5\n            # String representations\n            ('0.0', '0'),\n            ('0.00', '0'),\n            ('0.000', '0'),\n            ('0.0000', '0'),\n            ('0.00000', '0'),\n        ]\n        \n        for input_val, expected in test_cases:\n            with self.subTest(input_val=input_val):\n                result = floatformat(input_val, 0)\n                self.assertEqual(result, expected)\n\n    def test_floatformat_bug_specific_conditions(self):\n        \"\"\"\n        Test the specific conditions that trigger the original bug:\n        - Decimal value with fractional part that equals zero when converted to int\n        - Zero precision\n        - Negative exponent in decimal representation\n        \"\"\"\n        # These are the exact cases from the bug report\n        result1 = floatformat('0.00', 0)\n        self.assertEqual(result1, '0')\n        \n        result2 = floatformat(Decimal('0.00'), 0)\n        self.assertEqual(result2, '0')\n        \n        # Additional cases that follow the same pattern\n        result3 = floatformat('0.000', 0)\n        self.assertEqual(result3, '0')\n        \n        result4 = floatformat(Decimal('0.000'), 0)\n        self.assertEqual(result4, '0')\n</patched>\n```",
  "patch": "--- a/tests/template_tests/filter_tests/test_floatformat.py\n+++ b/tests/template_tests/filter_tests/test_floatformat.py\n-# Empty if creating new file\n+import pytest\n+from decimal import Decimal\n+from django.template.defaultfilters import floatformat\n+from django.test import SimpleTestCase\n+\n+\n+class FloatformatTests(SimpleTestCase):\n+    \"\"\"Test cases for the floatformat template filter.\"\"\"\n+\n+    def test_floatformat_zero_string_with_zero_precision_bug_reproduction(self):\n+        \"\"\"\n+        Test that reproduces the bug where floatformat('0.00', 0) crashes.\n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        # This should not raise ValueError: valid range for prec is [1, MAX_PREC]\n+        result = floatformat('0.00', 0)\n+        self.assertEqual(result, '0')\n+\n+    def test_floatformat_zero_decimal_with_zero_precision_bug_reproduction(self):\n+        \"\"\"\n+        Test that reproduces the bug where floatformat(Decimal('0.00'), 0) crashes.\n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        # This should not raise ValueError: valid range for prec is [1, MAX_PREC]\n+        result = floatformat(Decimal('0.00'), 0)\n+        self.assertEqual(result, '0')\n+\n+    def test_floatformat_zero_variations_with_zero_precision(self):\n+        \"\"\"\n+        Test various zero representations with precision 0 to ensure they all work.\n+        \"\"\"\n+        test_cases = [\n+            ('0.00', '0'),\n+            ('0.000', '0'),\n+            ('0.0000', '0'),\n+            (Decimal('0.00'), '0'),\n+            (Decimal('0.000'), '0'),\n+            (Decimal('0.0000'), '0'),\n+            ('0', '0'),\n+            (0, '0'),\n+            (0.0, '0'),\n+            (0.00, '0'),\n+        ]\n+        \n+        for input_val, expected in test_cases:\n+            with self.subTest(input_val=input_val):\n+                result = floatformat(input_val, 0)\n+                self.assertEqual(result, expected)\n+\n+    def test_floatformat_small_decimals_with_zero_precision(self):\n+        \"\"\"\n+        Test small decimal values with zero precision to ensure proper rounding.\n+        \"\"\"\n+        test_cases = [\n+            ('0.1', '0'),\n+            ('0.4', '0'),\n+            ('0.5', '1'),  # Should round up\n+            ('0.6', '1'),\n+            ('0.9', '1'),\n+            (Decimal('0.1'), '0'),\n+            (Decimal('0.4'), '0'),\n+            (Decimal('0.5'), '1'),\n+            (Decimal('0.6'), '1'),\n+            (Decimal('0.9'), '1'),\n+        ]\n+        \n+        for input_val, expected in test_cases:\n+            with self.subTest(input_val=input_val):\n+                result = floatformat(input_val, 0)\n+                self.assertEqual(result, expected)\n+\n+    def test_floatformat_negative_zero_with_zero_precision(self):\n+        \"\"\"\n+        Test negative zero values with precision 0.\n+        \"\"\"\n+        test_cases = [\n+            ('-0.00', '0'),\n+            ('-0.000', '0'),\n+            (Decimal('-0.00'), '0'),\n+            (Decimal('-0.000'), '0'),\n+        ]\n+        \n+        for input_val, expected in test_cases:\n+            with self.subTest(input_val=input_val):\n+                result = floatformat(input_val, 0)\n+                self.assertEqual(result, expected)\n+\n+    def test_floatformat_edge_cases_with_zero_precision(self):\n+        \"\"\"\n+        Test edge cases that might trigger the precision calculation bug.\n+        \"\"\"\n+        test_cases = [\n+            # Very small numbers that round to zero\n+            ('0.0001', '0'),\n+            ('0.00001', '0'),\n+            (Decimal('0.0001'), '0'),\n+            (Decimal('0.00001'), '0'),\n+            # Numbers that round to 1\n+            ('0.5000', '1'),\n+            ('0.50000', '1'),\n+            (Decimal('0.5000'), '1'),\n+            (Decimal('0.50000'), '1'),\n+        ]\n+        \n+        for input_val, expected in test_cases:\n+            with self.subTest(input_val=input_val):\n+                result = floatformat(input_val, 0)\n+                self.assertEqual(result, expected)\n+\n+    def test_floatformat_preserves_existing_functionality(self):\n+        \"\"\"\n+        Test that the fix doesn't break existing functionality for other precision values.\n+        \"\"\"\n+        # Test with positive precision\n+        self.assertEqual(floatformat('0.00', 1), '0.0')\n+        self.assertEqual(floatformat('0.00', 2), '0.00')\n+        self.assertEqual(floatformat(Decimal('0.00'), 1), '0.0')\n+        self.assertEqual(floatformat(Decimal('0.00'), 2), '0.00')\n+        \n+        # Test with negative precision\n+        self.assertEqual(floatformat('0.00', -1), '0')\n+        self.assertEqual(floatformat('0.00', -2), '0')\n+        self.assertEqual(floatformat(Decimal('0.00'), -1), '0')\n+        self.assertEqual(floatformat(Decimal('0.00'), -2), '0')\n+        \n+        # Test with non-zero values\n+        self.assertEqual(floatformat('1.234', 0), '1')\n+        self.assertEqual(floatformat('1.234', 1), '1.2')\n+        self.assertEqual(floatformat('1.234', 2), '1.23')\n+        self.assertEqual(floatformat(Decimal('1.234'), 0), '1')\n+        self.assertEqual(floatformat(Decimal('1.234'), 1), '1.2')\n+        self.assertEqual(floatformat(Decimal('1.234'), 2), '1.23')\n+\n+    def test_floatformat_zero_precision_with_various_exponents(self):\n+        \"\"\"\n+        Test zero precision with decimals having various exponents to ensure\n+        the precision calculation handles all cases correctly.\n+        \"\"\"\n+        test_cases = [\n+            # Different exponents that could cause precision calculation issues\n+            (Decimal('0.0'), '0'),      # exponent = -1\n+            (Decimal('0.00'), '0'),     # exponent = -2\n+            (Decimal('0.000'), '0'),    # exponent = -3\n+            (Decimal('0.0000'), '0'),   # exponent = -4\n+            (Decimal('0.00000'), '0'),  # exponent = -5\n+            # String representations\n+            ('0.0', '0'),\n+            ('0.00', '0'),\n+            ('0.000', '0'),\n+            ('0.0000', '0'),\n+            ('0.00000', '0'),\n+        ]\n+        \n+        for input_val, expected in test_cases:\n+            with self.subTest(input_val=input_val):\n+                result = floatformat(input_val, 0)\n+                self.assertEqual(result, expected)\n+\n+    def test_floatformat_bug_specific_conditions(self):\n+        \"\"\"\n+        Test the specific conditions that trigger the original bug:\n+        - Decimal value with fractional part that equals zero when converted to int\n+        - Zero precision\n+        - Negative exponent in decimal representation\n+        \"\"\"\n+        # These are the exact cases from the bug report\n+        result1 = floatformat('0.00', 0)\n+        self.assertEqual(result1, '0')\n+        \n+        result2 = floatformat(Decimal('0.00'), 0)\n+        self.assertEqual(result2, '0')\n+        \n+        # Additional cases that follow the same pattern\n+        result3 = floatformat('0.000', 0)\n+        self.assertEqual(result3, '0')\n+        \n+        result4 = floatformat(Decimal('0.000'), 0)\n+        self.assertEqual(result4, '0')\n"
}