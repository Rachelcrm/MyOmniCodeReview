{
  "instance_id": "django__django-13964",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/model_fields/test_foreign_key_non_numeric_pk.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models, transaction\nfrom django.test import TestCase, TransactionTestCase\nfrom django.db.utils import IntegrityError\n\n\nclass Product(models.Model):\n    \"\"\"Model with CharField primary key to test the bug.\"\"\"\n    sku = models.CharField(primary_key=True, max_length=50)\n    name = models.CharField(max_length=100, default=\"Test Product\")\n\n    class Meta:\n        app_label = 'model_fields'\n\n\nclass Order(models.Model):\n    \"\"\"Model with foreign key to Product.\"\"\"\n    product = models.ForeignKey(Product, on_delete=models.CASCADE)\n    quantity = models.IntegerField(default=1)\n\n    class Meta:\n        app_label = 'model_fields'\n\n\nclass ProductWithIntPK(models.Model):\n    \"\"\"Model with integer primary key for comparison.\"\"\"\n    id = models.AutoField(primary_key=True)\n    name = models.CharField(max_length=100, default=\"Test Product\")\n\n    class Meta:\n        app_label = 'model_fields'\n\n\nclass OrderWithIntPK(models.Model):\n    \"\"\"Model with foreign key to ProductWithIntPK.\"\"\"\n    product = models.ForeignKey(ProductWithIntPK, on_delete=models.CASCADE)\n    quantity = models.IntegerField(default=1)\n\n    class Meta:\n        app_label = 'model_fields'\n\n\nclass ForeignKeyNonNumericPKTestCase(TransactionTestCase):\n    \"\"\"Test case for foreign key assignments with non-numeric primary keys.\"\"\"\n\n    def test_foreign_key_assignment_after_pk_set_fails_before_fix(self):\n        \"\"\"\n        Test that demonstrates the bug: when a related object's primary key\n        is set after assignment, the foreign key field doesn't get updated.\n        This test should fail before the fix is applied.\n        \"\"\"\n        with transaction.atomic():\n            order = Order()\n            order.product = Product()  # Product with no SKU set yet\n            order.product.sku = \"foo\"  # Set SKU after assignment\n            order.product.save()\n            order.save()\n            \n            # This assertion should fail before the fix - demonstrates the bug\n            # The foreign key field contains empty string instead of \"foo\"\n            with self.assertRaises(AssertionError):\n                assert Order.objects.filter(product=order.product).exists()\n            \n            # This assertion succeeds but shouldn't - shows data loss\n            assert Order.objects.filter(product_id=\"\").exists()\n\n    def test_foreign_key_assignment_with_pk_set_before_assignment_works(self):\n        \"\"\"\n        Test that when the primary key is set before assignment,\n        everything works correctly (this should pass both before and after fix).\n        \"\"\"\n        with transaction.atomic():\n            order = Order()\n            order.product = Product(sku=\"bar\")  # SKU set before assignment\n            order.product.save()\n            order.save()\n            \n            # This should work correctly\n            assert Order.objects.filter(product=order.product).exists()\n            assert not Order.objects.filter(product_id=\"\").exists()\n\n    def test_foreign_key_assignment_after_pk_set_works_after_fix(self):\n        \"\"\"\n        Test that after the fix, setting the primary key after assignment\n        works correctly. This test should pass after the fix is applied.\n        \"\"\"\n        with transaction.atomic():\n            order = Order()\n            order.product = Product()  # Product with no SKU set yet\n            order.product.sku = \"baz\"  # Set SKU after assignment\n            order.product.save()\n            order.save()\n            \n            # After the fix, this should work correctly\n            assert Order.objects.filter(product=order.product).exists()\n            assert not Order.objects.filter(product_id=\"\").exists()\n            \n            # Verify the foreign key field was updated correctly\n            order.refresh_from_db()\n            assert order.product_id == \"baz\"\n\n    def test_foreign_key_assignment_with_none_pk_still_raises_error(self):\n        \"\"\"\n        Test that the existing behavior for None primary keys is preserved.\n        This should raise a ValueError both before and after the fix.\n        \"\"\"\n        with self.assertRaises(ValueError) as cm:\n            with transaction.atomic():\n                order = Order()\n                order.product = Product()  # Product with no SKU set\n                # Don't set the SKU - leave it as None/empty\n                order.product.save()  # This will fail because SKU is required\n                order.save()\n        \n        # The error should mention unsaved related object\n        self.assertIn(\"prohibited to prevent data loss\", str(cm.exception))\n\n    def test_foreign_key_assignment_with_integer_pk_works(self):\n        \"\"\"\n        Test that integer primary keys work correctly (baseline test).\n        This should work both before and after the fix.\n        \"\"\"\n        with transaction.atomic():\n            order = OrderWithIntPK()\n            order.product = ProductWithIntPK()  # Auto PK will be None initially\n            order.product.save()  # This sets the auto PK\n            order.save()\n            \n            # This should work correctly with integer PKs\n            assert OrderWithIntPK.objects.filter(product=order.product).exists()\n            assert not OrderWithIntPK.objects.filter(product_id__isnull=True).exists()\n\n    def test_foreign_key_assignment_multiple_updates(self):\n        \"\"\"\n        Test that multiple updates to the primary key are handled correctly.\n        \"\"\"\n        with transaction.atomic():\n            order = Order()\n            order.product = Product()\n            \n            # Set SKU multiple times\n            order.product.sku = \"first\"\n            order.product.sku = \"second\"\n            order.product.sku = \"final\"\n            \n            order.product.save()\n            order.save()\n            \n            # Should use the final value\n            assert Order.objects.filter(product=order.product).exists()\n            assert Order.objects.filter(product_id=\"final\").exists()\n            order.refresh_from_db()\n            assert order.product_id == \"final\"\n\n    def test_foreign_key_assignment_pk_change_after_save(self):\n        \"\"\"\n        Test that changing the primary key after both objects are saved\n        updates the foreign key correctly on subsequent saves.\n        \"\"\"\n        with transaction.atomic():\n            # Initial setup\n            order = Order()\n            order.product = Product(sku=\"initial\")\n            order.product.save()\n            order.save()\n            \n            # Verify initial state\n            assert order.product_id == \"initial\"\n            \n            # Change the primary key\n            order.product.sku = \"changed\"\n            order.product.save()\n            order.save()  # This should update the foreign key\n            \n            # Verify the foreign key was updated\n            order.refresh_from_db()\n            assert order.product_id == \"changed\"\n            assert Order.objects.filter(product_id=\"changed\").exists()\n            assert not Order.objects.filter(product_id=\"initial\").exists()\n\n    def test_foreign_key_assignment_empty_string_vs_none(self):\n        \"\"\"\n        Test the difference between None and empty string primary keys.\n        \"\"\"\n        # Test with None (should raise error)\n        with self.assertRaises(ValueError):\n            with transaction.atomic():\n                order = Order()\n                product = Product()\n                # Don't set SKU, it will be None/empty\n                order.product = product\n                order.product.save()  # This should fail\n                order.save()\n\n    def test_foreign_key_assignment_cached_relationship(self):\n        \"\"\"\n        Test that cached relationships are handled correctly.\n        \"\"\"\n        with transaction.atomic():\n            order = Order()\n            product = Product()\n            order.product = product\n            \n            # Access the relationship to cache it\n            _ = order.product\n            \n            # Now set the primary key\n            product.sku = \"cached_test\"\n            product.save()\n            order.save()\n            \n            # Verify it works with cached relationships\n            assert order.product_id == \"cached_test\"\n            assert Order.objects.filter(product=product).exists()\n\n    def test_foreign_key_assignment_transaction_rollback(self):\n        \"\"\"\n        Test that transaction rollback works correctly with the fix.\n        \"\"\"\n        try:\n            with transaction.atomic():\n                order = Order()\n                order.product = Product()\n                order.product.sku = \"rollback_test\"\n                order.product.save()\n                order.save()\n                \n                # Force a rollback\n                raise Exception(\"Force rollback\")\n        except Exception:\n            pass\n        \n        # Verify nothing was saved\n        assert not Order.objects.filter(product_id=\"rollback_test\").exists()\n        assert not Product.objects.filter(sku=\"rollback_test\").exists()\n\n    def test_foreign_key_assignment_edge_case_empty_string_pk(self):\n        \"\"\"\n        Test edge case where primary key is explicitly set to empty string.\n        \"\"\"\n        with self.assertRaises(IntegrityError):\n            with transaction.atomic():\n                order = Order()\n                order.product = Product()\n                order.product.sku = \"\"  # Explicitly set to empty string\n                order.product.save()  # This should fail due to empty PK\n                order.save()\n</patched>\n</file>\n```",
  "patch": "--- a/tests/model_fields/test_foreign_key_non_numeric_pk.py\n+++ b/tests/model_fields/test_foreign_key_non_numeric_pk.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models, transaction\n+from django.test import TestCase, TransactionTestCase\n+from django.db.utils import IntegrityError\n+\n+\n+class Product(models.Model):\n+    \"\"\"Model with CharField primary key to test the bug.\"\"\"\n+    sku = models.CharField(primary_key=True, max_length=50)\n+    name = models.CharField(max_length=100, default=\"Test Product\")\n+\n+    class Meta:\n+        app_label = 'model_fields'\n+\n+\n+class Order(models.Model):\n+    \"\"\"Model with foreign key to Product.\"\"\"\n+    product = models.ForeignKey(Product, on_delete=models.CASCADE)\n+    quantity = models.IntegerField(default=1)\n+\n+    class Meta:\n+        app_label = 'model_fields'\n+\n+\n+class ProductWithIntPK(models.Model):\n+    \"\"\"Model with integer primary key for comparison.\"\"\"\n+    id = models.AutoField(primary_key=True)\n+    name = models.CharField(max_length=100, default=\"Test Product\")\n+\n+    class Meta:\n+        app_label = 'model_fields'\n+\n+\n+class OrderWithIntPK(models.Model):\n+    \"\"\"Model with foreign key to ProductWithIntPK.\"\"\"\n+    product = models.ForeignKey(ProductWithIntPK, on_delete=models.CASCADE)\n+    quantity = models.IntegerField(default=1)\n+\n+    class Meta:\n+        app_label = 'model_fields'\n+\n+\n+class ForeignKeyNonNumericPKTestCase(TransactionTestCase):\n+    \"\"\"Test case for foreign key assignments with non-numeric primary keys.\"\"\"\n+\n+    def test_foreign_key_assignment_after_pk_set_fails_before_fix(self):\n+        \"\"\"\n+        Test that demonstrates the bug: when a related object's primary key\n+        is set after assignment, the foreign key field doesn't get updated.\n+        This test should fail before the fix is applied.\n+        \"\"\"\n+        with transaction.atomic():\n+            order = Order()\n+            order.product = Product()  # Product with no SKU set yet\n+            order.product.sku = \"foo\"  # Set SKU after assignment\n+            order.product.save()\n+            order.save()\n+            \n+            # This assertion should fail before the fix - demonstrates the bug\n+            # The foreign key field contains empty string instead of \"foo\"\n+            with self.assertRaises(AssertionError):\n+                assert Order.objects.filter(product=order.product).exists()\n+            \n+            # This assertion succeeds but shouldn't - shows data loss\n+            assert Order.objects.filter(product_id=\"\").exists()\n+\n+    def test_foreign_key_assignment_with_pk_set_before_assignment_works(self):\n+        \"\"\"\n+        Test that when the primary key is set before assignment,\n+        everything works correctly (this should pass both before and after fix).\n+        \"\"\"\n+        with transaction.atomic():\n+            order = Order()\n+            order.product = Product(sku=\"bar\")  # SKU set before assignment\n+            order.product.save()\n+            order.save()\n+            \n+            # This should work correctly\n+            assert Order.objects.filter(product=order.product).exists()\n+            assert not Order.objects.filter(product_id=\"\").exists()\n+\n+    def test_foreign_key_assignment_after_pk_set_works_after_fix(self):\n+        \"\"\"\n+        Test that after the fix, setting the primary key after assignment\n+        works correctly. This test should pass after the fix is applied.\n+        \"\"\"\n+        with transaction.atomic():\n+            order = Order()\n+            order.product = Product()  # Product with no SKU set yet\n+            order.product.sku = \"baz\"  # Set SKU after assignment\n+            order.product.save()\n+            order.save()\n+            \n+            # After the fix, this should work correctly\n+            assert Order.objects.filter(product=order.product).exists()\n+            assert not Order.objects.filter(product_id=\"\").exists()\n+            \n+            # Verify the foreign key field was updated correctly\n+            order.refresh_from_db()\n+            assert order.product_id == \"baz\"\n+\n+    def test_foreign_key_assignment_with_none_pk_still_raises_error(self):\n+        \"\"\"\n+        Test that the existing behavior for None primary keys is preserved.\n+        This should raise a ValueError both before and after the fix.\n+        \"\"\"\n+        with self.assertRaises(ValueError) as cm:\n+            with transaction.atomic():\n+                order = Order()\n+                order.product = Product()  # Product with no SKU set\n+                # Don't set the SKU - leave it as None/empty\n+                order.product.save()  # This will fail because SKU is required\n+                order.save()\n+        \n+        # The error should mention unsaved related object\n+        self.assertIn(\"prohibited to prevent data loss\", str(cm.exception))\n+\n+    def test_foreign_key_assignment_with_integer_pk_works(self):\n+        \"\"\"\n+        Test that integer primary keys work correctly (baseline test).\n+        This should work both before and after the fix.\n+        \"\"\"\n+        with transaction.atomic():\n+            order = OrderWithIntPK()\n+            order.product = ProductWithIntPK()  # Auto PK will be None initially\n+            order.product.save()  # This sets the auto PK\n+            order.save()\n+            \n+            # This should work correctly with integer PKs\n+            assert OrderWithIntPK.objects.filter(product=order.product).exists()\n+            assert not OrderWithIntPK.objects.filter(product_id__isnull=True).exists()\n+\n+    def test_foreign_key_assignment_multiple_updates(self):\n+        \"\"\"\n+        Test that multiple updates to the primary key are handled correctly.\n+        \"\"\"\n+        with transaction.atomic():\n+            order = Order()\n+            order.product = Product()\n+            \n+            # Set SKU multiple times\n+            order.product.sku = \"first\"\n+            order.product.sku = \"second\"\n+            order.product.sku = \"final\"\n+            \n+            order.product.save()\n+            order.save()\n+            \n+            # Should use the final value\n+            assert Order.objects.filter(product=order.product).exists()\n+            assert Order.objects.filter(product_id=\"final\").exists()\n+            order.refresh_from_db()\n+            assert order.product_id == \"final\"\n+\n+    def test_foreign_key_assignment_pk_change_after_save(self):\n+        \"\"\"\n+        Test that changing the primary key after both objects are saved\n+        updates the foreign key correctly on subsequent saves.\n+        \"\"\"\n+        with transaction.atomic():\n+            # Initial setup\n+            order = Order()\n+            order.product = Product(sku=\"initial\")\n+            order.product.save()\n+            order.save()\n+            \n+            # Verify initial state\n+            assert order.product_id == \"initial\"\n+            \n+            # Change the primary key\n+            order.product.sku = \"changed\"\n+            order.product.save()\n+            order.save()  # This should update the foreign key\n+            \n+            # Verify the foreign key was updated\n+            order.refresh_from_db()\n+            assert order.product_id == \"changed\"\n+            assert Order.objects.filter(product_id=\"changed\").exists()\n+            assert not Order.objects.filter(product_id=\"initial\").exists()\n+\n+    def test_foreign_key_assignment_empty_string_vs_none(self):\n+        \"\"\"\n+        Test the difference between None and empty string primary keys.\n+        \"\"\"\n+        # Test with None (should raise error)\n+        with self.assertRaises(ValueError):\n+            with transaction.atomic():\n+                order = Order()\n+                product = Product()\n+                # Don't set SKU, it will be None/empty\n+                order.product = product\n+                order.product.save()  # This should fail\n+                order.save()\n+\n+    def test_foreign_key_assignment_cached_relationship(self):\n+        \"\"\"\n+        Test that cached relationships are handled correctly.\n+        \"\"\"\n+        with transaction.atomic():\n+            order = Order()\n+            product = Product()\n+            order.product = product\n+            \n+            # Access the relationship to cache it\n+            _ = order.product\n+            \n+            # Now set the primary key\n+            product.sku = \"cached_test\"\n+            product.save()\n+            order.save()\n+            \n+            # Verify it works with cached relationships\n+            assert order.product_id == \"cached_test\"\n+            assert Order.objects.filter(product=product).exists()\n+\n+    def test_foreign_key_assignment_transaction_rollback(self):\n+        \"\"\"\n+        Test that transaction rollback works correctly with the fix.\n+        \"\"\"\n+        try:\n+            with transaction.atomic():\n+                order = Order()\n+                order.product = Product()\n+                order.product.sku = \"rollback_test\"\n+                order.product.save()\n+                order.save()\n+                \n+                # Force a rollback\n+                raise Exception(\"Force rollback\")\n+        except Exception:\n+            pass\n+        \n+        # Verify nothing was saved\n+        assert not Order.objects.filter(product_id=\"rollback_test\").exists()\n+        assert not Product.objects.filter(sku=\"rollback_test\").exists()\n+\n+    def test_foreign_key_assignment_edge_case_empty_string_pk(self):\n+        \"\"\"\n+        Test edge case where primary key is explicitly set to empty string.\n+        \"\"\"\n+        with self.assertRaises(IntegrityError):\n+            with transaction.atomic():\n+                order = Order()\n+                order.product = Product()\n+                order.product.sku = \"\"  # Explicitly set to empty string\n+                order.product.save()  # This should fail due to empty PK\n+                order.save()\n"
}