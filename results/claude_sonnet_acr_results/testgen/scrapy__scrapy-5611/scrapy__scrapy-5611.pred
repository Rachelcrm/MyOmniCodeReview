{
  "instance_id": "scrapy__scrapy-5611",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_response_encoding_bom.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport codecs\nimport pytest\nfrom scrapy.http import HtmlResponse\n\n\nclass TestBOMEncodingPrecedence:\n    \"\"\"Test that BOM takes precedence over Content-Type header when detecting encoding.\"\"\"\n\n    def test_utf8_bom_overrides_content_type_header(self):\n        \"\"\"Test that UTF-8 BOM takes precedence over Content-Type charset declaration.\"\"\"\n        # This test reproduces the bug described in the issue\n        # Content-Type says cp1251 but BOM indicates UTF-8\n        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n        body = codecs.BOM_UTF8 + \"<!DOCTYPE html>\u041f\u0440\u0438\u0432\u0435\u0442!\".encode('utf-8')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        # Before fix: this would fail because encoding would be 'cp1251'\n        # After fix: encoding should be 'utf-8' due to BOM precedence\n        assert response.encoding == 'utf-8'\n        assert response.text == \"<!DOCTYPE html>\u041f\u0440\u0438\u0432\u0435\u0442!\"\n\n    def test_utf16_le_bom_overrides_content_type_header(self):\n        \"\"\"Test that UTF-16 LE BOM takes precedence over Content-Type charset.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=iso-8859-1'}\n        body = codecs.BOM_UTF16_LE + \"<!DOCTYPE html>Hello\".encode('utf-16le')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        assert response.encoding == 'utf-16'\n        assert \"Hello\" in response.text\n\n    def test_utf16_be_bom_overrides_content_type_header(self):\n        \"\"\"Test that UTF-16 BE BOM takes precedence over Content-Type charset.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=ascii'}\n        body = codecs.BOM_UTF16_BE + \"<!DOCTYPE html>Test\".encode('utf-16be')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        assert response.encoding == 'utf-16'\n        assert \"Test\" in response.text\n\n    def test_utf32_le_bom_overrides_content_type_header(self):\n        \"\"\"Test that UTF-32 LE BOM takes precedence over Content-Type charset.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=cp1252'}\n        body = codecs.BOM_UTF32_LE + \"<!DOCTYPE html>Content\".encode('utf-32le')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        assert response.encoding == 'utf-32'\n        assert \"Content\" in response.text\n\n    def test_utf32_be_bom_overrides_content_type_header(self):\n        \"\"\"Test that UTF-32 BE BOM takes precedence over Content-Type charset.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=windows-1251'}\n        body = codecs.BOM_UTF32_BE + \"<!DOCTYPE html>Data\".encode('utf-32be')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        assert response.encoding == 'utf-32'\n        assert \"Data\" in response.text\n\n    def test_no_bom_uses_content_type_header(self):\n        \"\"\"Test that Content-Type header is used when no BOM is present.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n        body = \"<!DOCTYPE html>No BOM here\".encode('utf-8')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        assert response.encoding == 'utf-8'\n        assert response.text == \"<!DOCTYPE html>No BOM here\"\n\n    def test_explicit_encoding_overrides_bom(self):\n        \"\"\"Test that explicitly set encoding takes precedence over BOM.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n        body = codecs.BOM_UTF8 + \"<!DOCTYPE html>Test\".encode('utf-8')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body,\n            encoding='iso-8859-1'  # Explicitly set encoding\n        )\n        \n        # Explicit encoding should take precedence over BOM\n        assert response.encoding == 'iso-8859-1'\n\n    def test_bom_overrides_meta_charset(self):\n        \"\"\"Test that BOM takes precedence over meta charset declaration in HTML.\"\"\"\n        headers = {}  # No Content-Type header\n        html_content = '<!DOCTYPE html><html><head><meta charset=\"cp1251\"></head><body>\u0422\u0435\u0441\u0442</body></html>'\n        body = codecs.BOM_UTF8 + html_content.encode('utf-8')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        assert response.encoding == 'utf-8'\n        assert \"\u0422\u0435\u0441\u0442\" in response.text\n\n    def test_empty_body_no_bom(self):\n        \"\"\"Test that empty body doesn't cause issues with BOM detection.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n        body = b''\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        assert response.encoding == 'utf-8'\n        assert response.text == \"\"\n\n    def test_short_body_no_bom(self):\n        \"\"\"Test that very short body without BOM works correctly.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n        body = b'<'  # Single character, shorter than any BOM\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        assert response.encoding == 'utf-8'\n        assert response.text == \"<\"\n\n    def test_partial_bom_not_detected(self):\n        \"\"\"Test that partial BOM sequences are not incorrectly detected.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n        # Only first byte of UTF-8 BOM\n        body = b'\\xef' + \"<!DOCTYPE html>Test\".encode('utf-8')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        # Should use Content-Type header since BOM is incomplete\n        assert response.encoding == 'utf-8'\n\n    def test_bom_caching_consistency(self):\n        \"\"\"Test that BOM detection is cached and consistent across multiple calls.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n        body = codecs.BOM_UTF8 + \"<!DOCTYPE html>Cached\".encode('utf-8')\n        \n        response = HtmlResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        # Multiple calls should return the same encoding\n        encoding1 = response.encoding\n        encoding2 = response.encoding\n        encoding3 = response.encoding\n        \n        assert encoding1 == encoding2 == encoding3 == 'utf-8'\n\n    def test_issue_reproduction_server_example(self):\n        \"\"\"Test that reproduces the exact issue from the bug report.\"\"\"\n        # This simulates the server example from the issue description\n        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n        body = (codecs.BOM_UTF8 + \n                \"<!DOCTYPE html>\".encode('utf-8') + \n                \"\u041f\u0440\u0438\u0432\u0435\u0442!\".encode('utf-8'))\n        \n        response = HtmlResponse(\n            url='http://0.0.0.0:8000',\n            headers=headers,\n            body=body\n        )\n        \n        # Before fix: encoding would be 'cp1251' and text would be garbled\n        # After fix: encoding should be 'utf-8' and text should be correct\n        assert response.encoding == 'utf-8'\n        assert response.text == \"<!DOCTYPE html>\u041f\u0440\u0438\u0432\u0435\u0442!\"\n        # Text should NOT contain the garbled characters from the issue\n        assert \"\u043f\u00bb\u0457\" not in response.text\n        assert \"\u0420\u045f\u0421\u0402\u0420\u0451\u0420\u0406\u0420\u00b5\u0421\u201a\" not in response.text\n</patched>\n</file>\n```\n\n```\n<file>tests/test_response_text_bom_methods.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport codecs\nimport pytest\nfrom scrapy.http.response.text import TextResponse\n\n\nclass TestTextResponseBOMDetection:\n    \"\"\"Test the internal BOM detection methods of TextResponse.\"\"\"\n\n    def test_body_bom_encoding_method_utf8(self):\n        \"\"\"Test _body_bom_encoding method detects UTF-8 BOM correctly.\"\"\"\n        body = codecs.BOM_UTF8 + b\"test content\"\n        response = TextResponse(url='http://example.com', body=body)\n        \n        # Test the internal BOM detection method\n        bom_encoding = response._body_bom_encoding()\n        assert bom_encoding == 'utf-8'\n\n    def test_body_bom_encoding_method_utf16_le(self):\n        \"\"\"Test _body_bom_encoding method detects UTF-16 LE BOM correctly.\"\"\"\n        body = codecs.BOM_UTF16_LE + b\"test content\"\n        response = TextResponse(url='http://example.com', body=body)\n        \n        bom_encoding = response._body_bom_encoding()\n        assert bom_encoding == 'utf-16'\n\n    def test_body_bom_encoding_method_utf16_be(self):\n        \"\"\"Test _body_bom_encoding method detects UTF-16 BE BOM correctly.\"\"\"\n        body = codecs.BOM_UTF16_BE + b\"test content\"\n        response = TextResponse(url='http://example.com', body=body)\n        \n        bom_encoding = response._body_bom_encoding()\n        assert bom_encoding == 'utf-16'\n\n    def test_body_bom_encoding_method_utf32_le(self):\n        \"\"\"Test _body_bom_encoding method detects UTF-32 LE BOM correctly.\"\"\"\n        body = codecs.BOM_UTF32_LE + b\"test content\"\n        response = TextResponse(url='http://example.com', body=body)\n        \n        bom_encoding = response._body_bom_encoding()\n        assert bom_encoding == 'utf-32'\n\n    def test_body_bom_encoding_method_utf32_be(self):\n        \"\"\"Test _body_bom_encoding method detects UTF-32 BE BOM correctly.\"\"\"\n        body = codecs.BOM_UTF32_BE + b\"test content\"\n        response = TextResponse(url='http://example.com', body=body)\n        \n        bom_encoding = response._body_bom_encoding()\n        assert bom_encoding == 'utf-32'\n\n    def test_body_bom_encoding_method_no_bom(self):\n        \"\"\"Test _body_bom_encoding method returns None when no BOM present.\"\"\"\n        body = b\"test content without BOM\"\n        response = TextResponse(url='http://example.com', body=body)\n        \n        bom_encoding = response._body_bom_encoding()\n        assert bom_encoding is None\n\n    def test_body_bom_encoding_method_empty_body(self):\n        \"\"\"Test _body_bom_encoding method handles empty body gracefully.\"\"\"\n        body = b\"\"\n        response = TextResponse(url='http://example.com', body=body)\n        \n        bom_encoding = response._body_bom_encoding()\n        assert bom_encoding is None\n\n    def test_body_bom_encoding_method_short_body(self):\n        \"\"\"Test _body_bom_encoding method handles body shorter than BOM.\"\"\"\n        body = b\"x\"  # Single byte, shorter than any BOM\n        response = TextResponse(url='http://example.com', body=body)\n        \n        bom_encoding = response._body_bom_encoding()\n        assert bom_encoding is None\n\n    def test_body_bom_encoding_method_caching(self):\n        \"\"\"Test that _body_bom_encoding method results are cached.\"\"\"\n        body = codecs.BOM_UTF8 + b\"test content\"\n        response = TextResponse(url='http://example.com', body=body)\n        \n        # Call multiple times to test caching\n        result1 = response._body_bom_encoding()\n        result2 = response._body_bom_encoding()\n        result3 = response._body_bom_encoding()\n        \n        assert result1 == result2 == result3 == 'utf-8'\n\n    def test_declared_encoding_priority_order(self):\n        \"\"\"Test that _declared_encoding follows correct priority order with BOM.\"\"\"\n        # Test with BOM and Content-Type header\n        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n        body = codecs.BOM_UTF8 + b\"<meta charset='iso-8859-1'>test\"\n        \n        response = TextResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        # BOM should take precedence over both header and meta charset\n        declared_encoding = response._declared_encoding()\n        assert declared_encoding == 'utf-8'\n\n    def test_declared_encoding_explicit_encoding_priority(self):\n        \"\"\"Test that explicit encoding takes precedence over BOM.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n        body = codecs.BOM_UTF8 + b\"test content\"\n        \n        response = TextResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body,\n            encoding='ascii'  # Explicit encoding\n        )\n        \n        # Explicit encoding should override BOM\n        declared_encoding = response._declared_encoding()\n        assert declared_encoding == 'ascii'\n\n    def test_declared_encoding_fallback_to_headers(self):\n        \"\"\"Test that headers encoding is used when no BOM present.\"\"\"\n        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n        body = b\"test content without BOM\"\n        \n        response = TextResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        declared_encoding = response._declared_encoding()\n        assert declared_encoding == 'utf-8'\n\n    def test_declared_encoding_fallback_to_body_declared(self):\n        \"\"\"Test fallback to body declared encoding when no BOM or headers.\"\"\"\n        headers = {}  # No Content-Type header\n        body = b'<meta charset=\"iso-8859-1\">test content'\n        \n        response = TextResponse(\n            url='http://example.com',\n            headers=headers,\n            body=body\n        )\n        \n        declared_encoding = response._declared_encoding()\n        assert declared_encoding == 'iso-8859-1'\n</patched>\n</file>\n```",
  "patch": "--- a/tests/test_response_encoding_bom.py\n+++ b/tests/test_response_encoding_bom.py\n-# Empty if creating new file\n+import codecs\n+import pytest\n+from scrapy.http import HtmlResponse\n+\n+\n+class TestBOMEncodingPrecedence:\n+    \"\"\"Test that BOM takes precedence over Content-Type header when detecting encoding.\"\"\"\n+\n+    def test_utf8_bom_overrides_content_type_header(self):\n+        \"\"\"Test that UTF-8 BOM takes precedence over Content-Type charset declaration.\"\"\"\n+        # This test reproduces the bug described in the issue\n+        # Content-Type says cp1251 but BOM indicates UTF-8\n+        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n+        body = codecs.BOM_UTF8 + \"<!DOCTYPE html>\u041f\u0440\u0438\u0432\u0435\u0442!\".encode('utf-8')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        # Before fix: this would fail because encoding would be 'cp1251'\n+        # After fix: encoding should be 'utf-8' due to BOM precedence\n+        assert response.encoding == 'utf-8'\n+        assert response.text == \"<!DOCTYPE html>\u041f\u0440\u0438\u0432\u0435\u0442!\"\n+\n+    def test_utf16_le_bom_overrides_content_type_header(self):\n+        \"\"\"Test that UTF-16 LE BOM takes precedence over Content-Type charset.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=iso-8859-1'}\n+        body = codecs.BOM_UTF16_LE + \"<!DOCTYPE html>Hello\".encode('utf-16le')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        assert response.encoding == 'utf-16'\n+        assert \"Hello\" in response.text\n+\n+    def test_utf16_be_bom_overrides_content_type_header(self):\n+        \"\"\"Test that UTF-16 BE BOM takes precedence over Content-Type charset.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=ascii'}\n+        body = codecs.BOM_UTF16_BE + \"<!DOCTYPE html>Test\".encode('utf-16be')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        assert response.encoding == 'utf-16'\n+        assert \"Test\" in response.text\n+\n+    def test_utf32_le_bom_overrides_content_type_header(self):\n+        \"\"\"Test that UTF-32 LE BOM takes precedence over Content-Type charset.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=cp1252'}\n+        body = codecs.BOM_UTF32_LE + \"<!DOCTYPE html>Content\".encode('utf-32le')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        assert response.encoding == 'utf-32'\n+        assert \"Content\" in response.text\n+\n+    def test_utf32_be_bom_overrides_content_type_header(self):\n+        \"\"\"Test that UTF-32 BE BOM takes precedence over Content-Type charset.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=windows-1251'}\n+        body = codecs.BOM_UTF32_BE + \"<!DOCTYPE html>Data\".encode('utf-32be')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        assert response.encoding == 'utf-32'\n+        assert \"Data\" in response.text\n+\n+    def test_no_bom_uses_content_type_header(self):\n+        \"\"\"Test that Content-Type header is used when no BOM is present.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n+        body = \"<!DOCTYPE html>No BOM here\".encode('utf-8')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        assert response.encoding == 'utf-8'\n+        assert response.text == \"<!DOCTYPE html>No BOM here\"\n+\n+    def test_explicit_encoding_overrides_bom(self):\n+        \"\"\"Test that explicitly set encoding takes precedence over BOM.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n+        body = codecs.BOM_UTF8 + \"<!DOCTYPE html>Test\".encode('utf-8')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body,\n+            encoding='iso-8859-1'  # Explicitly set encoding\n+        )\n+        \n+        # Explicit encoding should take precedence over BOM\n+        assert response.encoding == 'iso-8859-1'\n+\n+    def test_bom_overrides_meta_charset(self):\n+        \"\"\"Test that BOM takes precedence over meta charset declaration in HTML.\"\"\"\n+        headers = {}  # No Content-Type header\n+        html_content = '<!DOCTYPE html><html><head><meta charset=\"cp1251\"></head><body>\u0422\u0435\u0441\u0442</body></html>'\n+        body = codecs.BOM_UTF8 + html_content.encode('utf-8')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        assert response.encoding == 'utf-8'\n+        assert \"\u0422\u0435\u0441\u0442\" in response.text\n+\n+    def test_empty_body_no_bom(self):\n+        \"\"\"Test that empty body doesn't cause issues with BOM detection.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n+        body = b''\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        assert response.encoding == 'utf-8'\n+        assert response.text == \"\"\n+\n+    def test_short_body_no_bom(self):\n+        \"\"\"Test that very short body without BOM works correctly.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n+        body = b'<'  # Single character, shorter than any BOM\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        assert response.encoding == 'utf-8'\n+        assert response.text == \"<\"\n+\n+    def test_partial_bom_not_detected(self):\n+        \"\"\"Test that partial BOM sequences are not incorrectly detected.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n+        # Only first byte of UTF-8 BOM\n+        body = b'\\xef' + \"<!DOCTYPE html>Test\".encode('utf-8')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        # Should use Content-Type header since BOM is incomplete\n+        assert response.encoding == 'utf-8'\n+\n+    def test_bom_caching_consistency(self):\n+        \"\"\"Test that BOM detection is cached and consistent across multiple calls.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n+        body = codecs.BOM_UTF8 + \"<!DOCTYPE html>Cached\".encode('utf-8')\n+        \n+        response = HtmlResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        # Multiple calls should return the same encoding\n+        encoding1 = response.encoding\n+        encoding2 = response.encoding\n+        encoding3 = response.encoding\n+        \n+        assert encoding1 == encoding2 == encoding3 == 'utf-8'\n+\n+    def test_issue_reproduction_server_example(self):\n+        \"\"\"Test that reproduces the exact issue from the bug report.\"\"\"\n+        # This simulates the server example from the issue description\n+        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n+        body = (codecs.BOM_UTF8 + \n+                \"<!DOCTYPE html>\".encode('utf-8') + \n+                \"\u041f\u0440\u0438\u0432\u0435\u0442!\".encode('utf-8'))\n+        \n+        response = HtmlResponse(\n+            url='http://0.0.0.0:8000',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        # Before fix: encoding would be 'cp1251' and text would be garbled\n+        # After fix: encoding should be 'utf-8' and text should be correct\n+        assert response.encoding == 'utf-8'\n+        assert response.text == \"<!DOCTYPE html>\u041f\u0440\u0438\u0432\u0435\u0442!\"\n+        # Text should NOT contain the garbled characters from the issue\n+        assert \"\u043f\u00bb\u0457\" not in response.text\n+        assert \"\u0420\u045f\u0421\u0402\u0420\u0451\u0420\u0406\u0420\u00b5\u0421\u201a\" not in response.text\n\n--- a/tests/test_response_text_bom_methods.py\n+++ b/tests/test_response_text_bom_methods.py\n-# Empty if creating new file\n+import codecs\n+import pytest\n+from scrapy.http.response.text import TextResponse\n+\n+\n+class TestTextResponseBOMDetection:\n+    \"\"\"Test the internal BOM detection methods of TextResponse.\"\"\"\n+\n+    def test_body_bom_encoding_method_utf8(self):\n+        \"\"\"Test _body_bom_encoding method detects UTF-8 BOM correctly.\"\"\"\n+        body = codecs.BOM_UTF8 + b\"test content\"\n+        response = TextResponse(url='http://example.com', body=body)\n+        \n+        # Test the internal BOM detection method\n+        bom_encoding = response._body_bom_encoding()\n+        assert bom_encoding == 'utf-8'\n+\n+    def test_body_bom_encoding_method_utf16_le(self):\n+        \"\"\"Test _body_bom_encoding method detects UTF-16 LE BOM correctly.\"\"\"\n+        body = codecs.BOM_UTF16_LE + b\"test content\"\n+        response = TextResponse(url='http://example.com', body=body)\n+        \n+        bom_encoding = response._body_bom_encoding()\n+        assert bom_encoding == 'utf-16'\n+\n+    def test_body_bom_encoding_method_utf16_be(self):\n+        \"\"\"Test _body_bom_encoding method detects UTF-16 BE BOM correctly.\"\"\"\n+        body = codecs.BOM_UTF16_BE + b\"test content\"\n+        response = TextResponse(url='http://example.com', body=body)\n+        \n+        bom_encoding = response._body_bom_encoding()\n+        assert bom_encoding == 'utf-16'\n+\n+    def test_body_bom_encoding_method_utf32_le(self):\n+        \"\"\"Test _body_bom_encoding method detects UTF-32 LE BOM correctly.\"\"\"\n+        body = codecs.BOM_UTF32_LE + b\"test content\"\n+        response = TextResponse(url='http://example.com', body=body)\n+        \n+        bom_encoding = response._body_bom_encoding()\n+        assert bom_encoding == 'utf-32'\n+\n+    def test_body_bom_encoding_method_utf32_be(self):\n+        \"\"\"Test _body_bom_encoding method detects UTF-32 BE BOM correctly.\"\"\"\n+        body = codecs.BOM_UTF32_BE + b\"test content\"\n+        response = TextResponse(url='http://example.com', body=body)\n+        \n+        bom_encoding = response._body_bom_encoding()\n+        assert bom_encoding == 'utf-32'\n+\n+    def test_body_bom_encoding_method_no_bom(self):\n+        \"\"\"Test _body_bom_encoding method returns None when no BOM present.\"\"\"\n+        body = b\"test content without BOM\"\n+        response = TextResponse(url='http://example.com', body=body)\n+        \n+        bom_encoding = response._body_bom_encoding()\n+        assert bom_encoding is None\n+\n+    def test_body_bom_encoding_method_empty_body(self):\n+        \"\"\"Test _body_bom_encoding method handles empty body gracefully.\"\"\"\n+        body = b\"\"\n+        response = TextResponse(url='http://example.com', body=body)\n+        \n+        bom_encoding = response._body_bom_encoding()\n+        assert bom_encoding is None\n+\n+    def test_body_bom_encoding_method_short_body(self):\n+        \"\"\"Test _body_bom_encoding method handles body shorter than BOM.\"\"\"\n+        body = b\"x\"  # Single byte, shorter than any BOM\n+        response = TextResponse(url='http://example.com', body=body)\n+        \n+        bom_encoding = response._body_bom_encoding()\n+        assert bom_encoding is None\n+\n+    def test_body_bom_encoding_method_caching(self):\n+        \"\"\"Test that _body_bom_encoding method results are cached.\"\"\"\n+        body = codecs.BOM_UTF8 + b\"test content\"\n+        response = TextResponse(url='http://example.com', body=body)\n+        \n+        # Call multiple times to test caching\n+        result1 = response._body_bom_encoding()\n+        result2 = response._body_bom_encoding()\n+        result3 = response._body_bom_encoding()\n+        \n+        assert result1 == result2 == result3 == 'utf-8'\n+\n+    def test_declared_encoding_priority_order(self):\n+        \"\"\"Test that _declared_encoding follows correct priority order with BOM.\"\"\"\n+        # Test with BOM and Content-Type header\n+        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n+        body = codecs.BOM_UTF8 + b\"<meta charset='iso-8859-1'>test\"\n+        \n+        response = TextResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        # BOM should take precedence over both header and meta charset\n+        declared_encoding = response._declared_encoding()\n+        assert declared_encoding == 'utf-8'\n+\n+    def test_declared_encoding_explicit_encoding_priority(self):\n+        \"\"\"Test that explicit encoding takes precedence over BOM.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=cp1251'}\n+        body = codecs.BOM_UTF8 + b\"test content\"\n+        \n+        response = TextResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body,\n+            encoding='ascii'  # Explicit encoding\n+        )\n+        \n+        # Explicit encoding should override BOM\n+        declared_encoding = response._declared_encoding()\n+        assert declared_encoding == 'ascii'\n+\n+    def test_declared_encoding_fallback_to_headers(self):\n+        \"\"\"Test that headers encoding is used when no BOM present.\"\"\"\n+        headers = {b'Content-Type': b'text/html; charset=utf-8'}\n+        body = b\"test content without BOM\"\n+        \n+        response = TextResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        declared_encoding = response._declared_encoding()\n+        assert declared_encoding == 'utf-8'\n+\n+    def test_declared_encoding_fallback_to_body_declared(self):\n+        \"\"\"Test fallback to body declared encoding when no BOM or headers.\"\"\"\n+        headers = {}  # No Content-Type header\n+        body = b'<meta charset=\"iso-8859-1\">test content'\n+        \n+        response = TextResponse(\n+            url='http://example.com',\n+            headers=headers,\n+            body=body\n+        )\n+        \n+        declared_encoding = response._declared_encoding()\n+        assert declared_encoding == 'iso-8859-1'\n"
}