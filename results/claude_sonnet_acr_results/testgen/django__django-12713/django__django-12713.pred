{
  "instance_id": "django__django-12713",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/admin_widgets/test_formfield_for_manytomany.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib import admin\nfrom django.contrib.admin.options import BaseModelAdmin\nfrom django.contrib.admin.sites import AdminSite\nfrom django.db import models\nfrom django.forms import widgets\nfrom django.test import TestCase, RequestFactory\n\n\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n    \n    class Meta:\n        app_label = 'admin_widgets'\n\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    authors = models.ManyToManyField(Author)\n    \n    class Meta:\n        app_label = 'admin_widgets'\n\n\nclass CustomSelectMultiple(widgets.SelectMultiple):\n    \"\"\"Custom widget for testing widget override functionality.\"\"\"\n    pass\n\n\nclass BookAdmin(BaseModelAdmin):\n    model = Book\n\n\nclass TestFormfieldForManyToManyWidgetOverride(TestCase):\n    \"\"\"Test suite for formfield_for_manytomany widget override functionality.\"\"\"\n    \n    def setUp(self):\n        self.site = AdminSite()\n        self.admin = BookAdmin(Book, self.site)\n        self.factory = RequestFactory()\n        self.request = self.factory.get('/')\n        self.authors_field = Book._meta.get_field('authors')\n    \n    def test_formfield_for_manytomany_respects_widget_parameter(self):\n        \"\"\"Test that formfield_for_manytomany respects explicitly passed widget parameter.\"\"\"\n        custom_widget = CustomSelectMultiple()\n        \n        # Call formfield_for_manytomany with custom widget\n        formfield = self.admin.formfield_for_manytomany(\n            self.authors_field, \n            self.request, \n            widget=custom_widget\n        )\n        \n        # The custom widget should be preserved, not overridden\n        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n        self.assertEqual(formfield.widget, custom_widget)\n    \n    def test_formfield_for_manytomany_default_widget_when_none_provided(self):\n        \"\"\"Test that formfield_for_manytomany uses default widget when none is provided.\"\"\"\n        # Call formfield_for_manytomany without widget parameter\n        formfield = self.admin.formfield_for_manytomany(\n            self.authors_field, \n            self.request\n        )\n        \n        # Should use default SelectMultiple widget\n        self.assertIsInstance(formfield.widget, widgets.SelectMultiple)\n        self.assertNotIsInstance(formfield.widget, CustomSelectMultiple)\n    \n    def test_formfield_for_manytomany_autocomplete_widget_override(self):\n        \"\"\"Test widget override works even when field is in autocomplete_fields.\"\"\"\n        # Create admin with autocomplete fields\n        class BookAdminWithAutocomplete(BaseModelAdmin):\n            model = Book\n            \n            def get_autocomplete_fields(self, request):\n                return ['authors']\n        \n        admin_with_autocomplete = BookAdminWithAutocomplete(Book, self.site)\n        custom_widget = CustomSelectMultiple()\n        \n        # Call with custom widget - should override autocomplete widget\n        formfield = admin_with_autocomplete.formfield_for_manytomany(\n            self.authors_field,\n            self.request,\n            widget=custom_widget\n        )\n        \n        # Custom widget should be preserved, not AutocompleteSelectMultiple\n        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n        self.assertEqual(formfield.widget, custom_widget)\n    \n    def test_formfield_for_manytomany_raw_id_widget_override(self):\n        \"\"\"Test widget override works even when field is in raw_id_fields.\"\"\"\n        # Create admin with raw_id_fields\n        class BookAdminWithRawId(BaseModelAdmin):\n            model = Book\n            raw_id_fields = ['authors']\n        \n        admin_with_raw_id = BookAdminWithRawId(Book, self.site)\n        custom_widget = CustomSelectMultiple()\n        \n        # Call with custom widget - should override raw_id widget\n        formfield = admin_with_raw_id.formfield_for_manytomany(\n            self.authors_field,\n            self.request,\n            widget=custom_widget\n        )\n        \n        # Custom widget should be preserved, not ManyToManyRawIdWidget\n        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n        self.assertEqual(formfield.widget, custom_widget)\n    \n    def test_formfield_for_manytomany_filter_horizontal_widget_override(self):\n        \"\"\"Test widget override works even when field is in filter_horizontal.\"\"\"\n        # Create admin with filter_horizontal\n        class BookAdminWithFilterHorizontal(BaseModelAdmin):\n            model = Book\n            filter_horizontal = ['authors']\n        \n        admin_with_filter = BookAdminWithFilterHorizontal(Book, self.site)\n        custom_widget = CustomSelectMultiple()\n        \n        # Call with custom widget - should override FilteredSelectMultiple widget\n        formfield = admin_with_filter.formfield_for_manytomany(\n            self.authors_field,\n            self.request,\n            widget=custom_widget\n        )\n        \n        # Custom widget should be preserved, not FilteredSelectMultiple\n        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n        self.assertEqual(formfield.widget, custom_widget)\n    \n    def test_formfield_for_manytomany_filter_vertical_widget_override(self):\n        \"\"\"Test widget override works even when field is in filter_vertical.\"\"\"\n        # Create admin with filter_vertical\n        class BookAdminWithFilterVertical(BaseModelAdmin):\n            model = Book\n            filter_vertical = ['authors']\n        \n        admin_with_filter = BookAdminWithFilterVertical(Book, self.site)\n        custom_widget = CustomSelectMultiple()\n        \n        # Call with custom widget - should override FilteredSelectMultiple widget\n        formfield = admin_with_filter.formfield_for_manytomany(\n            self.authors_field,\n            self.request,\n            widget=custom_widget\n        )\n        \n        # Custom widget should be preserved, not FilteredSelectMultiple\n        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n        self.assertEqual(formfield.widget, custom_widget)\n    \n    def test_formfield_for_manytomany_preserves_other_kwargs(self):\n        \"\"\"Test that other kwargs are preserved when widget is overridden.\"\"\"\n        custom_widget = CustomSelectMultiple()\n        custom_queryset = Author.objects.none()\n        \n        # Call with custom widget and other parameters\n        formfield = self.admin.formfield_for_manytomany(\n            self.authors_field,\n            self.request,\n            widget=custom_widget,\n            queryset=custom_queryset,\n            help_text=\"Custom help text\"\n        )\n        \n        # Widget should be custom\n        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n        # Other parameters should be preserved\n        self.assertEqual(formfield.queryset, custom_queryset)\n        self.assertEqual(formfield.help_text, \"Custom help text\")\n    \n    def test_formfield_for_manytomany_widget_none_uses_default(self):\n        \"\"\"Test that passing widget=None still allows default widget logic.\"\"\"\n        # Call with widget=None\n        formfield = self.admin.formfield_for_manytomany(\n            self.authors_field,\n            self.request,\n            widget=None\n        )\n        \n        # Should still get a widget (the default one)\n        self.assertIsNotNone(formfield.widget)\n        self.assertIsInstance(formfield.widget, widgets.SelectMultiple)\n\n\nclass TestFormfieldForManyToManyBugReproduction(TestCase):\n    \"\"\"Test that reproduces the original bug before the fix.\"\"\"\n    \n    def setUp(self):\n        self.site = AdminSite()\n        self.admin = BookAdmin(Book, self.site)\n        self.factory = RequestFactory()\n        self.request = self.factory.get('/')\n        self.authors_field = Book._meta.get_field('authors')\n    \n    def test_bug_reproduction_widget_override_ignored(self):\n        \"\"\"\n        This test reproduces the original bug where widget parameter was ignored.\n        This test should FAIL before the fix is applied and PASS after the fix.\n        \"\"\"\n        custom_widget = CustomSelectMultiple()\n        \n        # Before the fix, this would ignore the custom widget\n        formfield = self.admin.formfield_for_manytomany(\n            self.authors_field,\n            self.request,\n            widget=custom_widget\n        )\n        \n        # This assertion should fail before the fix (widget gets overridden)\n        # and pass after the fix (widget is preserved)\n        self.assertIsInstance(formfield.widget, CustomSelectMultiple,\n                            \"Custom widget should be preserved, not overridden by admin defaults\")\n        self.assertEqual(formfield.widget, custom_widget,\n                       \"The exact widget instance should be preserved\")\n\n\nclass TestFormfieldForForeignKeyComparison(TestCase):\n    \"\"\"Test to verify formfield_for_foreignkey behavior for comparison.\"\"\"\n    \n    def setUp(self):\n        self.site = AdminSite()\n        self.admin = BookAdmin(Book, self.site)\n        self.factory = RequestFactory()\n        self.request = self.factory.get('/')\n        \n        # Create a ForeignKey field for comparison\n        class Publisher(models.Model):\n            name = models.CharField(max_length=100)\n            class Meta:\n                app_label = 'admin_widgets'\n        \n        class BookWithPublisher(models.Model):\n            title = models.CharField(max_length=100)\n            publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)\n            class Meta:\n                app_label = 'admin_widgets'\n        \n        self.publisher_field = BookWithPublisher._meta.get_field('publisher')\n    \n    def test_formfield_for_foreignkey_respects_widget_parameter(self):\n        \"\"\"Test that formfield_for_foreignkey respects widget parameter (existing behavior).\"\"\"\n        custom_widget = widgets.Select()\n        \n        # Call formfield_for_foreignkey with custom widget\n        formfield = self.admin.formfield_for_foreignkey(\n            self.publisher_field,\n            self.request,\n            widget=custom_widget\n        )\n        \n        # The custom widget should be preserved\n        self.assertEqual(formfield.widget, custom_widget)\n        self.assertIsInstance(formfield.widget, widgets.Select)\n</patched>\n```",
  "patch": "--- a/tests/admin_widgets/test_formfield_for_manytomany.py\n+++ b/tests/admin_widgets/test_formfield_for_manytomany.py\n-# Empty if creating new file\n+import pytest\n+from django.contrib import admin\n+from django.contrib.admin.options import BaseModelAdmin\n+from django.contrib.admin.sites import AdminSite\n+from django.db import models\n+from django.forms import widgets\n+from django.test import TestCase, RequestFactory\n+\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'admin_widgets'\n+\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    authors = models.ManyToManyField(Author)\n+    \n+    class Meta:\n+        app_label = 'admin_widgets'\n+\n+\n+class CustomSelectMultiple(widgets.SelectMultiple):\n+    \"\"\"Custom widget for testing widget override functionality.\"\"\"\n+    pass\n+\n+\n+class BookAdmin(BaseModelAdmin):\n+    model = Book\n+\n+\n+class TestFormfieldForManyToManyWidgetOverride(TestCase):\n+    \"\"\"Test suite for formfield_for_manytomany widget override functionality.\"\"\"\n+    \n+    def setUp(self):\n+        self.site = AdminSite()\n+        self.admin = BookAdmin(Book, self.site)\n+        self.factory = RequestFactory()\n+        self.request = self.factory.get('/')\n+        self.authors_field = Book._meta.get_field('authors')\n+    \n+    def test_formfield_for_manytomany_respects_widget_parameter(self):\n+        \"\"\"Test that formfield_for_manytomany respects explicitly passed widget parameter.\"\"\"\n+        custom_widget = CustomSelectMultiple()\n+        \n+        # Call formfield_for_manytomany with custom widget\n+        formfield = self.admin.formfield_for_manytomany(\n+            self.authors_field, \n+            self.request, \n+            widget=custom_widget\n+        )\n+        \n+        # The custom widget should be preserved, not overridden\n+        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n+        self.assertEqual(formfield.widget, custom_widget)\n+    \n+    def test_formfield_for_manytomany_default_widget_when_none_provided(self):\n+        \"\"\"Test that formfield_for_manytomany uses default widget when none is provided.\"\"\"\n+        # Call formfield_for_manytomany without widget parameter\n+        formfield = self.admin.formfield_for_manytomany(\n+            self.authors_field, \n+            self.request\n+        )\n+        \n+        # Should use default SelectMultiple widget\n+        self.assertIsInstance(formfield.widget, widgets.SelectMultiple)\n+        self.assertNotIsInstance(formfield.widget, CustomSelectMultiple)\n+    \n+    def test_formfield_for_manytomany_autocomplete_widget_override(self):\n+        \"\"\"Test widget override works even when field is in autocomplete_fields.\"\"\"\n+        # Create admin with autocomplete fields\n+        class BookAdminWithAutocomplete(BaseModelAdmin):\n+            model = Book\n+            \n+            def get_autocomplete_fields(self, request):\n+                return ['authors']\n+        \n+        admin_with_autocomplete = BookAdminWithAutocomplete(Book, self.site)\n+        custom_widget = CustomSelectMultiple()\n+        \n+        # Call with custom widget - should override autocomplete widget\n+        formfield = admin_with_autocomplete.formfield_for_manytomany(\n+            self.authors_field,\n+            self.request,\n+            widget=custom_widget\n+        )\n+        \n+        # Custom widget should be preserved, not AutocompleteSelectMultiple\n+        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n+        self.assertEqual(formfield.widget, custom_widget)\n+    \n+    def test_formfield_for_manytomany_raw_id_widget_override(self):\n+        \"\"\"Test widget override works even when field is in raw_id_fields.\"\"\"\n+        # Create admin with raw_id_fields\n+        class BookAdminWithRawId(BaseModelAdmin):\n+            model = Book\n+            raw_id_fields = ['authors']\n+        \n+        admin_with_raw_id = BookAdminWithRawId(Book, self.site)\n+        custom_widget = CustomSelectMultiple()\n+        \n+        # Call with custom widget - should override raw_id widget\n+        formfield = admin_with_raw_id.formfield_for_manytomany(\n+            self.authors_field,\n+            self.request,\n+            widget=custom_widget\n+        )\n+        \n+        # Custom widget should be preserved, not ManyToManyRawIdWidget\n+        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n+        self.assertEqual(formfield.widget, custom_widget)\n+    \n+    def test_formfield_for_manytomany_filter_horizontal_widget_override(self):\n+        \"\"\"Test widget override works even when field is in filter_horizontal.\"\"\"\n+        # Create admin with filter_horizontal\n+        class BookAdminWithFilterHorizontal(BaseModelAdmin):\n+            model = Book\n+            filter_horizontal = ['authors']\n+        \n+        admin_with_filter = BookAdminWithFilterHorizontal(Book, self.site)\n+        custom_widget = CustomSelectMultiple()\n+        \n+        # Call with custom widget - should override FilteredSelectMultiple widget\n+        formfield = admin_with_filter.formfield_for_manytomany(\n+            self.authors_field,\n+            self.request,\n+            widget=custom_widget\n+        )\n+        \n+        # Custom widget should be preserved, not FilteredSelectMultiple\n+        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n+        self.assertEqual(formfield.widget, custom_widget)\n+    \n+    def test_formfield_for_manytomany_filter_vertical_widget_override(self):\n+        \"\"\"Test widget override works even when field is in filter_vertical.\"\"\"\n+        # Create admin with filter_vertical\n+        class BookAdminWithFilterVertical(BaseModelAdmin):\n+            model = Book\n+            filter_vertical = ['authors']\n+        \n+        admin_with_filter = BookAdminWithFilterVertical(Book, self.site)\n+        custom_widget = CustomSelectMultiple()\n+        \n+        # Call with custom widget - should override FilteredSelectMultiple widget\n+        formfield = admin_with_filter.formfield_for_manytomany(\n+            self.authors_field,\n+            self.request,\n+            widget=custom_widget\n+        )\n+        \n+        # Custom widget should be preserved, not FilteredSelectMultiple\n+        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n+        self.assertEqual(formfield.widget, custom_widget)\n+    \n+    def test_formfield_for_manytomany_preserves_other_kwargs(self):\n+        \"\"\"Test that other kwargs are preserved when widget is overridden.\"\"\"\n+        custom_widget = CustomSelectMultiple()\n+        custom_queryset = Author.objects.none()\n+        \n+        # Call with custom widget and other parameters\n+        formfield = self.admin.formfield_for_manytomany(\n+            self.authors_field,\n+            self.request,\n+            widget=custom_widget,\n+            queryset=custom_queryset,\n+            help_text=\"Custom help text\"\n+        )\n+        \n+        # Widget should be custom\n+        self.assertIsInstance(formfield.widget, CustomSelectMultiple)\n+        # Other parameters should be preserved\n+        self.assertEqual(formfield.queryset, custom_queryset)\n+        self.assertEqual(formfield.help_text, \"Custom help text\")\n+    \n+    def test_formfield_for_manytomany_widget_none_uses_default(self):\n+        \"\"\"Test that passing widget=None still allows default widget logic.\"\"\"\n+        # Call with widget=None\n+        formfield = self.admin.formfield_for_manytomany(\n+            self.authors_field,\n+            self.request,\n+            widget=None\n+        )\n+        \n+        # Should still get a widget (the default one)\n+        self.assertIsNotNone(formfield.widget)\n+        self.assertIsInstance(formfield.widget, widgets.SelectMultiple)\n+\n+\n+class TestFormfieldForManyToManyBugReproduction(TestCase):\n+    \"\"\"Test that reproduces the original bug before the fix.\"\"\"\n+    \n+    def setUp(self):\n+        self.site = AdminSite()\n+        self.admin = BookAdmin(Book, self.site)\n+        self.factory = RequestFactory()\n+        self.request = self.factory.get('/')\n+        self.authors_field = Book._meta.get_field('authors')\n+    \n+    def test_bug_reproduction_widget_override_ignored(self):\n+        \"\"\"\n+        This test reproduces the original bug where widget parameter was ignored.\n+        This test should FAIL before the fix is applied and PASS after the fix.\n+        \"\"\"\n+        custom_widget = CustomSelectMultiple()\n+        \n+        # Before the fix, this would ignore the custom widget\n+        formfield = self.admin.formfield_for_manytomany(\n+            self.authors_field,\n+            self.request,\n+            widget=custom_widget\n+        )\n+        \n+        # This assertion should fail before the fix (widget gets overridden)\n+        # and pass after the fix (widget is preserved)\n+        self.assertIsInstance(formfield.widget, CustomSelectMultiple,\n+                            \"Custom widget should be preserved, not overridden by admin defaults\")\n+        self.assertEqual(formfield.widget, custom_widget,\n+                       \"The exact widget instance should be preserved\")\n+\n+\n+class TestFormfieldForForeignKeyComparison(TestCase):\n+    \"\"\"Test to verify formfield_for_foreignkey behavior for comparison.\"\"\"\n+    \n+    def setUp(self):\n+        self.site = AdminSite()\n+        self.admin = BookAdmin(Book, self.site)\n+        self.factory = RequestFactory()\n+        self.request = self.factory.get('/')\n+        \n+        # Create a ForeignKey field for comparison\n+        class Publisher(models.Model):\n+            name = models.CharField(max_length=100)\n+            class Meta:\n+                app_label = 'admin_widgets'\n+        \n+        class BookWithPublisher(models.Model):\n+            title = models.CharField(max_length=100)\n+            publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)\n+            class Meta:\n+                app_label = 'admin_widgets'\n+        \n+        self.publisher_field = BookWithPublisher._meta.get_field('publisher')\n+    \n+    def test_formfield_for_foreignkey_respects_widget_parameter(self):\n+        \"\"\"Test that formfield_for_foreignkey respects widget parameter (existing behavior).\"\"\"\n+        custom_widget = widgets.Select()\n+        \n+        # Call formfield_for_foreignkey with custom widget\n+        formfield = self.admin.formfield_for_foreignkey(\n+            self.publisher_field,\n+            self.request,\n+            widget=custom_widget\n+        )\n+        \n+        # The custom widget should be preserved\n+        self.assertEqual(formfield.widget, custom_widget)\n+        self.assertIsInstance(formfield.widget, widgets.Select)\n"
}