{
  "instance_id": "django__django-13012",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/expressions/test_expression_wrapper.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models\nfrom django.db.models import ExpressionWrapper, Value, Sum, IntegerField\nfrom django.test import TestCase, override_settings\nfrom django.test.utils import isolate_apps\n\n\n@isolate_apps('expressions')\nclass ExpressionWrapperGroupByTests(TestCase):\n    \"\"\"\n    Test cases for ExpressionWrapper GROUP BY behavior with constant expressions.\n    \n    This tests the bug where constant expressions wrapped in ExpressionWrapper\n    are incorrectly included in GROUP BY clauses, causing PostgreSQL errors.\n    \"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        \n        # Create a test model for our queries\n        class TestModel(models.Model):\n            column_a = models.CharField(max_length=100)\n            column_b = models.IntegerField()\n            \n            class Meta:\n                app_label = 'expressions'\n        \n        cls.TestModel = TestModel\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        # Create test table\n        with self.connection.schema_editor() as schema_editor:\n            schema_editor.create_model(self.TestModel)\n        \n        # Insert test data\n        self.TestModel.objects.create(column_a='group1', column_b=10)\n        self.TestModel.objects.create(column_a='group1', column_b=20)\n        self.TestModel.objects.create(column_a='group2', column_b=30)\n    \n    def tearDown(self):\n        \"\"\"Clean up test data.\"\"\"\n        with self.connection.schema_editor() as schema_editor:\n            schema_editor.delete_model(self.TestModel)\n    \n    def test_expression_wrapper_constant_not_in_group_by(self):\n        \"\"\"\n        Test that constant expressions wrapped in ExpressionWrapper\n        are not included in GROUP BY clause.\n        \n        This is the main test case that reproduces the bug described in the issue.\n        Before the fix, this would fail with a PostgreSQL error about\n        aggregate functions not being allowed in GROUP BY.\n        \"\"\"\n        # Create a constant expression wrapped in ExpressionWrapper\n        constant_expr = ExpressionWrapper(Value(3), output_field=IntegerField())\n        \n        # This query should work without including the constant in GROUP BY\n        queryset = (\n            self.TestModel.objects\n            .annotate(expr_res=constant_expr)\n            .values('expr_res', 'column_a')\n            .annotate(sum=Sum('column_b'))\n        )\n        \n        # Execute the query - this should not raise an exception\n        results = list(queryset)\n        \n        # Verify the results are correct\n        expected_results = [\n            {'expr_res': 3, 'column_a': 'group1', 'sum': 30},\n            {'expr_res': 3, 'column_a': 'group2', 'sum': 30},\n        ]\n        \n        # Sort results for consistent comparison\n        results.sort(key=lambda x: x['column_a'])\n        expected_results.sort(key=lambda x: x['column_a'])\n        \n        self.assertEqual(results, expected_results)\n    \n    def test_expression_wrapper_constant_sql_generation(self):\n        \"\"\"\n        Test that the SQL generated for ExpressionWrapper with constants\n        does not include the constant in the GROUP BY clause.\n        \"\"\"\n        constant_expr = ExpressionWrapper(Value(42), output_field=IntegerField())\n        \n        queryset = (\n            self.TestModel.objects\n            .annotate(expr_res=constant_expr)\n            .values('expr_res', 'column_a')\n            .annotate(sum=Sum('column_b'))\n        )\n        \n        # Get the SQL query\n        sql, params = queryset.query.sql_with_params()\n        \n        # The SQL should not contain the constant (42) in the GROUP BY clause\n        # It should only group by column_a\n        self.assertIn('GROUP BY', sql.upper())\n        \n        # Split the SQL to find the GROUP BY clause\n        sql_upper = sql.upper()\n        group_by_start = sql_upper.find('GROUP BY')\n        self.assertNotEqual(group_by_start, -1, \"GROUP BY clause should be present\")\n        \n        # Extract the GROUP BY clause (everything after GROUP BY until ORDER BY or end)\n        group_by_clause = sql[group_by_start:]\n        order_by_pos = group_by_clause.upper().find('ORDER BY')\n        if order_by_pos != -1:\n            group_by_clause = group_by_clause[:order_by_pos]\n        \n        # The GROUP BY should contain column_a but not the constant value 42\n        self.assertIn('column_a', group_by_clause)\n        self.assertNotIn('42', group_by_clause)\n    \n    def test_unwrapped_constant_comparison(self):\n        \"\"\"\n        Test that unwrapped constant expressions work correctly\n        (this should pass both before and after the fix).\n        \n        This serves as a control test to ensure our fix doesn't break\n        the existing correct behavior.\n        \"\"\"\n        # Use Value directly without ExpressionWrapper\n        queryset = (\n            self.TestModel.objects\n            .annotate(expr_res=Value(5, output_field=IntegerField()))\n            .values('expr_res', 'column_a')\n            .annotate(sum=Sum('column_b'))\n        )\n        \n        # This should work fine\n        results = list(queryset)\n        \n        # Verify the results\n        expected_results = [\n            {'expr_res': 5, 'column_a': 'group1', 'sum': 30},\n            {'expr_res': 5, 'column_a': 'group2', 'sum': 30},\n        ]\n        \n        results.sort(key=lambda x: x['column_a'])\n        expected_results.sort(key=lambda x: x['column_a'])\n        \n        self.assertEqual(results, expected_results)\n    \n    def test_expression_wrapper_non_constant_expression(self):\n        \"\"\"\n        Test that ExpressionWrapper with non-constant expressions\n        still works correctly (should be included in GROUP BY when appropriate).\n        \"\"\"\n        from django.db.models import F\n        \n        # Use a field reference wrapped in ExpressionWrapper\n        field_expr = ExpressionWrapper(F('column_b'), output_field=IntegerField())\n        \n        queryset = (\n            self.TestModel.objects\n            .annotate(expr_res=field_expr)\n            .values('expr_res', 'column_a')\n            .annotate(count=models.Count('id'))\n        )\n        \n        # This should work and include the field expression in GROUP BY\n        results = list(queryset)\n        \n        # Should have one result per unique combination of column_a and column_b\n        self.assertEqual(len(results), 3)  # 3 unique combinations in our test data\n    \n    def test_expression_wrapper_get_group_by_cols_method(self):\n        \"\"\"\n        Test that ExpressionWrapper.get_group_by_cols() delegates correctly\n        to the wrapped expression.\n        \"\"\"\n        # Test with a constant expression (should return empty list)\n        constant_expr = ExpressionWrapper(Value(10), output_field=IntegerField())\n        group_by_cols = constant_expr.get_group_by_cols()\n        self.assertEqual(group_by_cols, [])\n        \n        # Test with a field expression (should return the field)\n        from django.db.models import F\n        field_expr = ExpressionWrapper(F('column_a'), output_field=models.CharField())\n        group_by_cols = field_expr.get_group_by_cols()\n        # Should delegate to F('column_a').get_group_by_cols()\n        self.assertNotEqual(group_by_cols, [])\n    \n    def test_multiple_expression_wrappers_with_constants(self):\n        \"\"\"\n        Test multiple ExpressionWrapper instances with constants in the same query.\n        \"\"\"\n        expr1 = ExpressionWrapper(Value(1), output_field=IntegerField())\n        expr2 = ExpressionWrapper(Value(2), output_field=IntegerField())\n        \n        queryset = (\n            self.TestModel.objects\n            .annotate(expr1=expr1, expr2=expr2)\n            .values('expr1', 'expr2', 'column_a')\n            .annotate(sum=Sum('column_b'))\n        )\n        \n        # Should execute without errors\n        results = list(queryset)\n        \n        # Verify all results have the expected constant values\n        for result in results:\n            self.assertEqual(result['expr1'], 1)\n            self.assertEqual(result['expr2'], 2)\n    \n    def test_nested_expression_wrapper_with_constant(self):\n        \"\"\"\n        Test ExpressionWrapper containing another ExpressionWrapper with a constant.\n        \"\"\"\n        inner_expr = ExpressionWrapper(Value(100), output_field=IntegerField())\n        outer_expr = ExpressionWrapper(inner_expr, output_field=IntegerField())\n        \n        queryset = (\n            self.TestModel.objects\n            .annotate(expr_res=outer_expr)\n            .values('expr_res', 'column_a')\n            .annotate(sum=Sum('column_b'))\n        )\n        \n        # Should execute without errors\n        results = list(queryset)\n        \n        # Verify the nested constant is handled correctly\n        for result in results:\n            self.assertEqual(result['expr_res'], 100)\n\n\n@pytest.mark.django_db\nclass TestExpressionWrapperGroupByPytest:\n    \"\"\"\n    Pytest-style tests for ExpressionWrapper GROUP BY behavior.\n    \n    These tests use pytest fixtures and assertions to provide\n    an alternative testing approach for the same functionality.\n    \"\"\"\n    \n    @pytest.fixture\n    def test_model(self, db):\n        \"\"\"Create a test model and data for testing.\"\"\"\n        from django.db import models\n        \n        class TestModel(models.Model):\n            column_a = models.CharField(max_length=100)\n            column_b = models.IntegerField()\n            \n            class Meta:\n                app_label = 'expressions'\n        \n        # Create the table\n        from django.db import connection\n        with connection.schema_editor() as schema_editor:\n            schema_editor.create_model(TestModel)\n        \n        # Insert test data\n        TestModel.objects.create(column_a='group1', column_b=10)\n        TestModel.objects.create(column_a='group1', column_b=20)\n        TestModel.objects.create(column_a='group2', column_b=30)\n        \n        yield TestModel\n        \n        # Cleanup\n        with connection.schema_editor() as schema_editor:\n            schema_editor.delete_model(TestModel)\n    \n    def test_constant_expression_wrapper_group_by_exclusion(self, test_model):\n        \"\"\"\n        Pytest version: Test that constant expressions in ExpressionWrapper\n        are excluded from GROUP BY clauses.\n        \"\"\"\n        constant_expr = ExpressionWrapper(Value(99), output_field=IntegerField())\n        \n        queryset = (\n            test_model.objects\n            .annotate(expr_res=constant_expr)\n            .values('expr_res', 'column_a')\n            .annotate(sum=Sum('column_b'))\n        )\n        \n        # Should execute without PostgreSQL GROUP BY errors\n        results = list(queryset)\n        \n        assert len(results) == 2  # Two groups\n        assert all(result['expr_res'] == 99 for result in results)\n    \n    def test_expression_wrapper_delegates_group_by_cols(self):\n        \"\"\"\n        Pytest version: Test that ExpressionWrapper.get_group_by_cols()\n        properly delegates to the wrapped expression.\n        \"\"\"\n        # Test with Value (constant) - should return empty list\n        value_wrapper = ExpressionWrapper(Value(42), output_field=IntegerField())\n        assert value_wrapper.get_group_by_cols() == []\n        \n        # Test with F expression - should return non-empty list\n        from django.db.models import F\n        field_wrapper = ExpressionWrapper(F('some_field'), output_field=IntegerField())\n        group_by_cols = field_wrapper.get_group_by_cols()\n        assert len(group_by_cols) > 0\n    \n    @pytest.mark.parametrize(\"constant_value\", [0, 1, -1, 999, None])\n    def test_various_constant_values_in_expression_wrapper(self, test_model, constant_value):\n        \"\"\"\n        Pytest version: Test ExpressionWrapper with various constant values.\n        \"\"\"\n        if constant_value is None:\n            # Handle NULL values specially\n            constant_expr = ExpressionWrapper(Value(None), output_field=IntegerField())\n        else:\n            constant_expr = ExpressionWrapper(Value(constant_value), output_field=IntegerField())\n        \n        queryset = (\n            test_model.objects\n            .annotate(expr_res=constant_expr)\n            .values('expr_res', 'column_a')\n            .annotate(sum=Sum('column_b'))\n        )\n        \n        # Should execute without errors regardless of constant value\n        results = list(queryset)\n        assert len(results) == 2  # Two groups in test data\n        \n        # All results should have the expected constant value\n        for result in results:\n            assert result['expr_res'] == constant_value\n</patched>\n```",
  "patch": "--- a/tests/expressions/test_expression_wrapper.py\n+++ b/tests/expressions/test_expression_wrapper.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models\n+from django.db.models import ExpressionWrapper, Value, Sum, IntegerField\n+from django.test import TestCase, override_settings\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps('expressions')\n+class ExpressionWrapperGroupByTests(TestCase):\n+    \"\"\"\n+    Test cases for ExpressionWrapper GROUP BY behavior with constant expressions.\n+    \n+    This tests the bug where constant expressions wrapped in ExpressionWrapper\n+    are incorrectly included in GROUP BY clauses, causing PostgreSQL errors.\n+    \"\"\"\n+    \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        \n+        # Create a test model for our queries\n+        class TestModel(models.Model):\n+            column_a = models.CharField(max_length=100)\n+            column_b = models.IntegerField()\n+            \n+            class Meta:\n+                app_label = 'expressions'\n+        \n+        cls.TestModel = TestModel\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        # Create test table\n+        with self.connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(self.TestModel)\n+        \n+        # Insert test data\n+        self.TestModel.objects.create(column_a='group1', column_b=10)\n+        self.TestModel.objects.create(column_a='group1', column_b=20)\n+        self.TestModel.objects.create(column_a='group2', column_b=30)\n+    \n+    def tearDown(self):\n+        \"\"\"Clean up test data.\"\"\"\n+        with self.connection.schema_editor() as schema_editor:\n+            schema_editor.delete_model(self.TestModel)\n+    \n+    def test_expression_wrapper_constant_not_in_group_by(self):\n+        \"\"\"\n+        Test that constant expressions wrapped in ExpressionWrapper\n+        are not included in GROUP BY clause.\n+        \n+        This is the main test case that reproduces the bug described in the issue.\n+        Before the fix, this would fail with a PostgreSQL error about\n+        aggregate functions not being allowed in GROUP BY.\n+        \"\"\"\n+        # Create a constant expression wrapped in ExpressionWrapper\n+        constant_expr = ExpressionWrapper(Value(3), output_field=IntegerField())\n+        \n+        # This query should work without including the constant in GROUP BY\n+        queryset = (\n+            self.TestModel.objects\n+            .annotate(expr_res=constant_expr)\n+            .values('expr_res', 'column_a')\n+            .annotate(sum=Sum('column_b'))\n+        )\n+        \n+        # Execute the query - this should not raise an exception\n+        results = list(queryset)\n+        \n+        # Verify the results are correct\n+        expected_results = [\n+            {'expr_res': 3, 'column_a': 'group1', 'sum': 30},\n+            {'expr_res': 3, 'column_a': 'group2', 'sum': 30},\n+        ]\n+        \n+        # Sort results for consistent comparison\n+        results.sort(key=lambda x: x['column_a'])\n+        expected_results.sort(key=lambda x: x['column_a'])\n+        \n+        self.assertEqual(results, expected_results)\n+    \n+    def test_expression_wrapper_constant_sql_generation(self):\n+        \"\"\"\n+        Test that the SQL generated for ExpressionWrapper with constants\n+        does not include the constant in the GROUP BY clause.\n+        \"\"\"\n+        constant_expr = ExpressionWrapper(Value(42), output_field=IntegerField())\n+        \n+        queryset = (\n+            self.TestModel.objects\n+            .annotate(expr_res=constant_expr)\n+            .values('expr_res', 'column_a')\n+            .annotate(sum=Sum('column_b'))\n+        )\n+        \n+        # Get the SQL query\n+        sql, params = queryset.query.sql_with_params()\n+        \n+        # The SQL should not contain the constant (42) in the GROUP BY clause\n+        # It should only group by column_a\n+        self.assertIn('GROUP BY', sql.upper())\n+        \n+        # Split the SQL to find the GROUP BY clause\n+        sql_upper = sql.upper()\n+        group_by_start = sql_upper.find('GROUP BY')\n+        self.assertNotEqual(group_by_start, -1, \"GROUP BY clause should be present\")\n+        \n+        # Extract the GROUP BY clause (everything after GROUP BY until ORDER BY or end)\n+        group_by_clause = sql[group_by_start:]\n+        order_by_pos = group_by_clause.upper().find('ORDER BY')\n+        if order_by_pos != -1:\n+            group_by_clause = group_by_clause[:order_by_pos]\n+        \n+        # The GROUP BY should contain column_a but not the constant value 42\n+        self.assertIn('column_a', group_by_clause)\n+        self.assertNotIn('42', group_by_clause)\n+    \n+    def test_unwrapped_constant_comparison(self):\n+        \"\"\"\n+        Test that unwrapped constant expressions work correctly\n+        (this should pass both before and after the fix).\n+        \n+        This serves as a control test to ensure our fix doesn't break\n+        the existing correct behavior.\n+        \"\"\"\n+        # Use Value directly without ExpressionWrapper\n+        queryset = (\n+            self.TestModel.objects\n+            .annotate(expr_res=Value(5, output_field=IntegerField()))\n+            .values('expr_res', 'column_a')\n+            .annotate(sum=Sum('column_b'))\n+        )\n+        \n+        # This should work fine\n+        results = list(queryset)\n+        \n+        # Verify the results\n+        expected_results = [\n+            {'expr_res': 5, 'column_a': 'group1', 'sum': 30},\n+            {'expr_res': 5, 'column_a': 'group2', 'sum': 30},\n+        ]\n+        \n+        results.sort(key=lambda x: x['column_a'])\n+        expected_results.sort(key=lambda x: x['column_a'])\n+        \n+        self.assertEqual(results, expected_results)\n+    \n+    def test_expression_wrapper_non_constant_expression(self):\n+        \"\"\"\n+        Test that ExpressionWrapper with non-constant expressions\n+        still works correctly (should be included in GROUP BY when appropriate).\n+        \"\"\"\n+        from django.db.models import F\n+        \n+        # Use a field reference wrapped in ExpressionWrapper\n+        field_expr = ExpressionWrapper(F('column_b'), output_field=IntegerField())\n+        \n+        queryset = (\n+            self.TestModel.objects\n+            .annotate(expr_res=field_expr)\n+            .values('expr_res', 'column_a')\n+            .annotate(count=models.Count('id'))\n+        )\n+        \n+        # This should work and include the field expression in GROUP BY\n+        results = list(queryset)\n+        \n+        # Should have one result per unique combination of column_a and column_b\n+        self.assertEqual(len(results), 3)  # 3 unique combinations in our test data\n+    \n+    def test_expression_wrapper_get_group_by_cols_method(self):\n+        \"\"\"\n+        Test that ExpressionWrapper.get_group_by_cols() delegates correctly\n+        to the wrapped expression.\n+        \"\"\"\n+        # Test with a constant expression (should return empty list)\n+        constant_expr = ExpressionWrapper(Value(10), output_field=IntegerField())\n+        group_by_cols = constant_expr.get_group_by_cols()\n+        self.assertEqual(group_by_cols, [])\n+        \n+        # Test with a field expression (should return the field)\n+        from django.db.models import F\n+        field_expr = ExpressionWrapper(F('column_a'), output_field=models.CharField())\n+        group_by_cols = field_expr.get_group_by_cols()\n+        # Should delegate to F('column_a').get_group_by_cols()\n+        self.assertNotEqual(group_by_cols, [])\n+    \n+    def test_multiple_expression_wrappers_with_constants(self):\n+        \"\"\"\n+        Test multiple ExpressionWrapper instances with constants in the same query.\n+        \"\"\"\n+        expr1 = ExpressionWrapper(Value(1), output_field=IntegerField())\n+        expr2 = ExpressionWrapper(Value(2), output_field=IntegerField())\n+        \n+        queryset = (\n+            self.TestModel.objects\n+            .annotate(expr1=expr1, expr2=expr2)\n+            .values('expr1', 'expr2', 'column_a')\n+            .annotate(sum=Sum('column_b'))\n+        )\n+        \n+        # Should execute without errors\n+        results = list(queryset)\n+        \n+        # Verify all results have the expected constant values\n+        for result in results:\n+            self.assertEqual(result['expr1'], 1)\n+            self.assertEqual(result['expr2'], 2)\n+    \n+    def test_nested_expression_wrapper_with_constant(self):\n+        \"\"\"\n+        Test ExpressionWrapper containing another ExpressionWrapper with a constant.\n+        \"\"\"\n+        inner_expr = ExpressionWrapper(Value(100), output_field=IntegerField())\n+        outer_expr = ExpressionWrapper(inner_expr, output_field=IntegerField())\n+        \n+        queryset = (\n+            self.TestModel.objects\n+            .annotate(expr_res=outer_expr)\n+            .values('expr_res', 'column_a')\n+            .annotate(sum=Sum('column_b'))\n+        )\n+        \n+        # Should execute without errors\n+        results = list(queryset)\n+        \n+        # Verify the nested constant is handled correctly\n+        for result in results:\n+            self.assertEqual(result['expr_res'], 100)\n+\n+\n+@pytest.mark.django_db\n+class TestExpressionWrapperGroupByPytest:\n+    \"\"\"\n+    Pytest-style tests for ExpressionWrapper GROUP BY behavior.\n+    \n+    These tests use pytest fixtures and assertions to provide\n+    an alternative testing approach for the same functionality.\n+    \"\"\"\n+    \n+    @pytest.fixture\n+    def test_model(self, db):\n+        \"\"\"Create a test model and data for testing.\"\"\"\n+        from django.db import models\n+        \n+        class TestModel(models.Model):\n+            column_a = models.CharField(max_length=100)\n+            column_b = models.IntegerField()\n+            \n+            class Meta:\n+                app_label = 'expressions'\n+        \n+        # Create the table\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(TestModel)\n+        \n+        # Insert test data\n+        TestModel.objects.create(column_a='group1', column_b=10)\n+        TestModel.objects.create(column_a='group1', column_b=20)\n+        TestModel.objects.create(column_a='group2', column_b=30)\n+        \n+        yield TestModel\n+        \n+        # Cleanup\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.delete_model(TestModel)\n+    \n+    def test_constant_expression_wrapper_group_by_exclusion(self, test_model):\n+        \"\"\"\n+        Pytest version: Test that constant expressions in ExpressionWrapper\n+        are excluded from GROUP BY clauses.\n+        \"\"\"\n+        constant_expr = ExpressionWrapper(Value(99), output_field=IntegerField())\n+        \n+        queryset = (\n+            test_model.objects\n+            .annotate(expr_res=constant_expr)\n+            .values('expr_res', 'column_a')\n+            .annotate(sum=Sum('column_b'))\n+        )\n+        \n+        # Should execute without PostgreSQL GROUP BY errors\n+        results = list(queryset)\n+        \n+        assert len(results) == 2  # Two groups\n+        assert all(result['expr_res'] == 99 for result in results)\n+    \n+    def test_expression_wrapper_delegates_group_by_cols(self):\n+        \"\"\"\n+        Pytest version: Test that ExpressionWrapper.get_group_by_cols()\n+        properly delegates to the wrapped expression.\n+        \"\"\"\n+        # Test with Value (constant) - should return empty list\n+        value_wrapper = ExpressionWrapper(Value(42), output_field=IntegerField())\n+        assert value_wrapper.get_group_by_cols() == []\n+        \n+        # Test with F expression - should return non-empty list\n+        from django.db.models import F\n+        field_wrapper = ExpressionWrapper(F('some_field'), output_field=IntegerField())\n+        group_by_cols = field_wrapper.get_group_by_cols()\n+        assert len(group_by_cols) > 0\n+    \n+    @pytest.mark.parametrize(\"constant_value\", [0, 1, -1, 999, None])\n+    def test_various_constant_values_in_expression_wrapper(self, test_model, constant_value):\n+        \"\"\"\n+        Pytest version: Test ExpressionWrapper with various constant values.\n+        \"\"\"\n+        if constant_value is None:\n+            # Handle NULL values specially\n+            constant_expr = ExpressionWrapper(Value(None), output_field=IntegerField())\n+        else:\n+            constant_expr = ExpressionWrapper(Value(constant_value), output_field=IntegerField())\n+        \n+        queryset = (\n+            test_model.objects\n+            .annotate(expr_res=constant_expr)\n+            .values('expr_res', 'column_a')\n+            .annotate(sum=Sum('column_b'))\n+        )\n+        \n+        # Should execute without errors regardless of constant value\n+        results = list(queryset)\n+        assert len(results) == 2  # Two groups in test data\n+        \n+        # All results should have the expected constant value\n+        for result in results:\n+            assert result['expr_res'] == constant_value\n"
}