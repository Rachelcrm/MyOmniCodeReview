{
  "instance_id": "django__django-13410",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/files/test_locks.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport fcntl\nimport os\nimport tempfile\nimport pytest\nfrom unittest import mock\n\nfrom django.core.files import locks\n\n\nclass TestFileLocks:\n    \"\"\"Test file locking functionality.\"\"\"\n\n    def test_lock_returns_false_with_current_buggy_implementation(self):\n        \"\"\"\n        Test that demonstrates the bug: lock() always returns False\n        even when fcntl.flock() succeeds (returns None).\n        This test should fail after the fix is applied.\n        \"\"\"\n        # Skip if not on POSIX or fcntl not available\n        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n        \n        with tempfile.NamedTemporaryFile() as temp_file:\n            # Mock fcntl.flock to return None (success case)\n            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n                # With the current buggy implementation, this returns False\n                # even though fcntl.flock returned None (success)\n                result = locks.lock(temp_file, locks.LOCK_EX)\n                # This assertion demonstrates the bug - it should be True but is False\n                assert result is False  # This shows the current buggy behavior\n\n    def test_unlock_returns_false_with_current_buggy_implementation(self):\n        \"\"\"\n        Test that demonstrates the bug: unlock() always returns False\n        even when fcntl.flock() succeeds (returns None).\n        This test should fail after the fix is applied.\n        \"\"\"\n        # Skip if not on POSIX or fcntl not available\n        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n        \n        with tempfile.NamedTemporaryFile() as temp_file:\n            # Mock fcntl.flock to return None (success case)\n            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n                # With the current buggy implementation, this returns False\n                # even though fcntl.flock returned None (success)\n                result = locks.unlock(temp_file)\n                # This assertion demonstrates the bug - it should be True but is False\n                assert result is False  # This shows the current buggy behavior\n\n    def test_lock_should_return_true_on_success(self):\n        \"\"\"\n        Test that lock() returns True when fcntl.flock() succeeds.\n        This test will pass after the fix is applied.\n        \"\"\"\n        # Skip if not on POSIX or fcntl not available\n        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n        \n        with tempfile.NamedTemporaryFile() as temp_file:\n            # Mock fcntl.flock to return None (success case)\n            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n                result = locks.lock(temp_file, locks.LOCK_EX)\n                assert result is True\n\n    def test_lock_should_return_false_on_failure(self):\n        \"\"\"\n        Test that lock() returns False when fcntl.flock() raises OSError.\n        This test will pass after the fix is applied.\n        \"\"\"\n        # Skip if not on POSIX or fcntl not available\n        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n        \n        with tempfile.NamedTemporaryFile() as temp_file:\n            # Mock fcntl.flock to raise OSError (failure case)\n            with mock.patch('django.core.files.locks.fcntl.flock', side_effect=OSError(\"Lock failed\")):\n                result = locks.lock(temp_file, locks.LOCK_EX)\n                assert result is False\n\n    def test_unlock_should_return_true_on_success(self):\n        \"\"\"\n        Test that unlock() returns True when fcntl.flock() succeeds.\n        This test will pass after the fix is applied.\n        \"\"\"\n        # Skip if not on POSIX or fcntl not available\n        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n        \n        with tempfile.NamedTemporaryFile() as temp_file:\n            # Mock fcntl.flock to return None (success case)\n            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n                result = locks.unlock(temp_file)\n                assert result is True\n\n    def test_unlock_should_return_false_on_failure(self):\n        \"\"\"\n        Test that unlock() returns False when fcntl.flock() raises OSError.\n        This test will pass after the fix is applied.\n        \"\"\"\n        # Skip if not on POSIX or fcntl not available\n        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n        \n        with tempfile.NamedTemporaryFile() as temp_file:\n            # Mock fcntl.flock to raise OSError (failure case)\n            with mock.patch('django.core.files.locks.fcntl.flock', side_effect=OSError(\"Unlock failed\")):\n                result = locks.unlock(temp_file)\n                assert result is False\n\n    def test_non_blocking_lock_behavior(self):\n        \"\"\"\n        Test non-blocking lock behavior which is critical for the bug fix.\n        Non-blocking locks need accurate return values to know if lock was acquired.\n        \"\"\"\n        # Skip if not on POSIX or fcntl not available\n        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n        \n        with tempfile.NamedTemporaryFile() as temp_file:\n            # Test successful non-blocking lock\n            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n                result = locks.lock(temp_file, locks.LOCK_EX | locks.LOCK_NB)\n                assert result is True\n            \n            # Test failed non-blocking lock (would block)\n            with mock.patch('django.core.files.locks.fcntl.flock', side_effect=OSError(\"Would block\")):\n                result = locks.lock(temp_file, locks.LOCK_EX | locks.LOCK_NB)\n                assert result is False\n\n    def test_lock_with_different_flags(self):\n        \"\"\"\n        Test lock function with different flag combinations.\n        \"\"\"\n        # Skip if not on POSIX or fcntl not available\n        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n        \n        with tempfile.NamedTemporaryFile() as temp_file:\n            # Test exclusive lock\n            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None) as mock_flock:\n                result = locks.lock(temp_file, locks.LOCK_EX)\n                assert result is True\n                mock_flock.assert_called_once_with(temp_file.fileno(), locks.LOCK_EX)\n            \n            # Test shared lock\n            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None) as mock_flock:\n                result = locks.lock(temp_file, locks.LOCK_SH)\n                assert result is True\n                mock_flock.assert_called_once_with(temp_file.fileno(), locks.LOCK_SH)\n\n    def test_fd_function_with_file_object(self):\n        \"\"\"\n        Test that _fd function works correctly with file objects.\n        \"\"\"\n        with tempfile.NamedTemporaryFile() as temp_file:\n            fd = locks._fd(temp_file)\n            assert fd == temp_file.fileno()\n\n    def test_fd_function_with_file_descriptor(self):\n        \"\"\"\n        Test that _fd function works correctly with file descriptors.\n        \"\"\"\n        with tempfile.NamedTemporaryFile() as temp_file:\n            fd_number = temp_file.fileno()\n            fd = locks._fd(fd_number)\n            assert fd == fd_number\n\n    def test_lock_unlock_integration(self):\n        \"\"\"\n        Integration test for lock and unlock functions.\n        This test verifies the complete workflow works correctly.\n        \"\"\"\n        # Skip if not on POSIX or fcntl not available\n        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n        \n        with tempfile.NamedTemporaryFile() as temp_file:\n            # Mock successful operations\n            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n                # Lock the file\n                lock_result = locks.lock(temp_file, locks.LOCK_EX)\n                assert lock_result is True\n                \n                # Unlock the file\n                unlock_result = locks.unlock(temp_file)\n                assert unlock_result is True\n\n    def test_constants_are_available(self):\n        \"\"\"\n        Test that lock constants are properly defined.\n        \"\"\"\n        # These should be available regardless of platform\n        assert hasattr(locks, 'LOCK_EX')\n        assert hasattr(locks, 'LOCK_SH') \n        assert hasattr(locks, 'LOCK_NB')\n        \n        # On POSIX with fcntl, they should have proper values\n        if os.name != 'nt' and hasattr(locks, 'fcntl'):\n            assert locks.LOCK_EX == fcntl.LOCK_EX\n            assert locks.LOCK_SH == fcntl.LOCK_SH\n            assert locks.LOCK_NB == fcntl.LOCK_NB\n</patched>\n</file>\n```",
  "patch": "--- a/tests/files/test_locks.py\n+++ b/tests/files/test_locks.py\n-# Empty if creating new file\n+import fcntl\n+import os\n+import tempfile\n+import pytest\n+from unittest import mock\n+\n+from django.core.files import locks\n+\n+\n+class TestFileLocks:\n+    \"\"\"Test file locking functionality.\"\"\"\n+\n+    def test_lock_returns_false_with_current_buggy_implementation(self):\n+        \"\"\"\n+        Test that demonstrates the bug: lock() always returns False\n+        even when fcntl.flock() succeeds (returns None).\n+        This test should fail after the fix is applied.\n+        \"\"\"\n+        # Skip if not on POSIX or fcntl not available\n+        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n+            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n+        \n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            # Mock fcntl.flock to return None (success case)\n+            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n+                # With the current buggy implementation, this returns False\n+                # even though fcntl.flock returned None (success)\n+                result = locks.lock(temp_file, locks.LOCK_EX)\n+                # This assertion demonstrates the bug - it should be True but is False\n+                assert result is False  # This shows the current buggy behavior\n+\n+    def test_unlock_returns_false_with_current_buggy_implementation(self):\n+        \"\"\"\n+        Test that demonstrates the bug: unlock() always returns False\n+        even when fcntl.flock() succeeds (returns None).\n+        This test should fail after the fix is applied.\n+        \"\"\"\n+        # Skip if not on POSIX or fcntl not available\n+        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n+            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n+        \n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            # Mock fcntl.flock to return None (success case)\n+            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n+                # With the current buggy implementation, this returns False\n+                # even though fcntl.flock returned None (success)\n+                result = locks.unlock(temp_file)\n+                # This assertion demonstrates the bug - it should be True but is False\n+                assert result is False  # This shows the current buggy behavior\n+\n+    def test_lock_should_return_true_on_success(self):\n+        \"\"\"\n+        Test that lock() returns True when fcntl.flock() succeeds.\n+        This test will pass after the fix is applied.\n+        \"\"\"\n+        # Skip if not on POSIX or fcntl not available\n+        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n+            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n+        \n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            # Mock fcntl.flock to return None (success case)\n+            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n+                result = locks.lock(temp_file, locks.LOCK_EX)\n+                assert result is True\n+\n+    def test_lock_should_return_false_on_failure(self):\n+        \"\"\"\n+        Test that lock() returns False when fcntl.flock() raises OSError.\n+        This test will pass after the fix is applied.\n+        \"\"\"\n+        # Skip if not on POSIX or fcntl not available\n+        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n+            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n+        \n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            # Mock fcntl.flock to raise OSError (failure case)\n+            with mock.patch('django.core.files.locks.fcntl.flock', side_effect=OSError(\"Lock failed\")):\n+                result = locks.lock(temp_file, locks.LOCK_EX)\n+                assert result is False\n+\n+    def test_unlock_should_return_true_on_success(self):\n+        \"\"\"\n+        Test that unlock() returns True when fcntl.flock() succeeds.\n+        This test will pass after the fix is applied.\n+        \"\"\"\n+        # Skip if not on POSIX or fcntl not available\n+        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n+            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n+        \n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            # Mock fcntl.flock to return None (success case)\n+            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n+                result = locks.unlock(temp_file)\n+                assert result is True\n+\n+    def test_unlock_should_return_false_on_failure(self):\n+        \"\"\"\n+        Test that unlock() returns False when fcntl.flock() raises OSError.\n+        This test will pass after the fix is applied.\n+        \"\"\"\n+        # Skip if not on POSIX or fcntl not available\n+        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n+            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n+        \n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            # Mock fcntl.flock to raise OSError (failure case)\n+            with mock.patch('django.core.files.locks.fcntl.flock', side_effect=OSError(\"Unlock failed\")):\n+                result = locks.unlock(temp_file)\n+                assert result is False\n+\n+    def test_non_blocking_lock_behavior(self):\n+        \"\"\"\n+        Test non-blocking lock behavior which is critical for the bug fix.\n+        Non-blocking locks need accurate return values to know if lock was acquired.\n+        \"\"\"\n+        # Skip if not on POSIX or fcntl not available\n+        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n+            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n+        \n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            # Test successful non-blocking lock\n+            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n+                result = locks.lock(temp_file, locks.LOCK_EX | locks.LOCK_NB)\n+                assert result is True\n+            \n+            # Test failed non-blocking lock (would block)\n+            with mock.patch('django.core.files.locks.fcntl.flock', side_effect=OSError(\"Would block\")):\n+                result = locks.lock(temp_file, locks.LOCK_EX | locks.LOCK_NB)\n+                assert result is False\n+\n+    def test_lock_with_different_flags(self):\n+        \"\"\"\n+        Test lock function with different flag combinations.\n+        \"\"\"\n+        # Skip if not on POSIX or fcntl not available\n+        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n+            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n+        \n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            # Test exclusive lock\n+            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None) as mock_flock:\n+                result = locks.lock(temp_file, locks.LOCK_EX)\n+                assert result is True\n+                mock_flock.assert_called_once_with(temp_file.fileno(), locks.LOCK_EX)\n+            \n+            # Test shared lock\n+            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None) as mock_flock:\n+                result = locks.lock(temp_file, locks.LOCK_SH)\n+                assert result is True\n+                mock_flock.assert_called_once_with(temp_file.fileno(), locks.LOCK_SH)\n+\n+    def test_fd_function_with_file_object(self):\n+        \"\"\"\n+        Test that _fd function works correctly with file objects.\n+        \"\"\"\n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            fd = locks._fd(temp_file)\n+            assert fd == temp_file.fileno()\n+\n+    def test_fd_function_with_file_descriptor(self):\n+        \"\"\"\n+        Test that _fd function works correctly with file descriptors.\n+        \"\"\"\n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            fd_number = temp_file.fileno()\n+            fd = locks._fd(fd_number)\n+            assert fd == fd_number\n+\n+    def test_lock_unlock_integration(self):\n+        \"\"\"\n+        Integration test for lock and unlock functions.\n+        This test verifies the complete workflow works correctly.\n+        \"\"\"\n+        # Skip if not on POSIX or fcntl not available\n+        if os.name == 'nt' or not hasattr(locks, 'fcntl'):\n+            pytest.skip(\"Test only applies to POSIX systems with fcntl\")\n+        \n+        with tempfile.NamedTemporaryFile() as temp_file:\n+            # Mock successful operations\n+            with mock.patch('django.core.files.locks.fcntl.flock', return_value=None):\n+                # Lock the file\n+                lock_result = locks.lock(temp_file, locks.LOCK_EX)\n+                assert lock_result is True\n+                \n+                # Unlock the file\n+                unlock_result = locks.unlock(temp_file)\n+                assert unlock_result is True\n+\n+    def test_constants_are_available(self):\n+        \"\"\"\n+        Test that lock constants are properly defined.\n+        \"\"\"\n+        # These should be available regardless of platform\n+        assert hasattr(locks, 'LOCK_EX')\n+        assert hasattr(locks, 'LOCK_SH') \n+        assert hasattr(locks, 'LOCK_NB')\n+        \n+        # On POSIX with fcntl, they should have proper values\n+        if os.name != 'nt' and hasattr(locks, 'fcntl'):\n+            assert locks.LOCK_EX == fcntl.LOCK_EX\n+            assert locks.LOCK_SH == fcntl.LOCK_SH\n+            assert locks.LOCK_NB == fcntl.LOCK_NB\n"
}