{
  "instance_id": "django__django-14349",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/validators/test_url_validator_bpo43882.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.core.exceptions import ValidationError\nfrom django.core.validators import URLValidator\n\n\nclass TestURLValidatorBPO43882:\n    \"\"\"\n    Test URLValidator behavior with URLs containing LF, CR, and tab characters.\n    \n    These tests verify that Django continues to reject URLs with potentially\n    dangerous whitespace characters even after Python's bpo-43882 fix which\n    strips these characters in urlsplit().\n    \"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up URLValidator instance for each test.\"\"\"\n        self.validator = URLValidator()\n    \n    def test_url_with_newline_at_end_should_fail(self):\n        \"\"\"Test that URLs with newline at the end are rejected.\"\"\"\n        url_with_newline = 'http://www.djangoproject.com/\\n'\n        \n        with pytest.raises(ValidationError) as exc_info:\n            self.validator(url_with_newline)\n        \n        # Verify the error message and code are as expected\n        assert exc_info.value.code == 'invalid'\n        assert 'Enter a valid URL.' in str(exc_info.value)\n    \n    def test_ipv6_url_with_newline_at_end_should_fail(self):\n        \"\"\"Test that IPv6 URLs with newline at the end are rejected.\"\"\"\n        ipv6_url_with_newline = 'http://[::ffff:192.9.5.5]\\n'\n        \n        with pytest.raises(ValidationError) as exc_info:\n            self.validator(ipv6_url_with_newline)\n        \n        assert exc_info.value.code == 'invalid'\n        assert 'Enter a valid URL.' in str(exc_info.value)\n    \n    def test_url_with_carriage_return_should_fail(self):\n        \"\"\"Test that URLs with carriage return are rejected.\"\"\"\n        url_with_cr = 'http://www.example.com/\\r'\n        \n        with pytest.raises(ValidationError):\n            self.validator(url_with_cr)\n    \n    def test_url_with_tab_should_fail(self):\n        \"\"\"Test that URLs with tab character are rejected.\"\"\"\n        url_with_tab = 'http://www.example.com/\\t'\n        \n        with pytest.raises(ValidationError):\n            self.validator(url_with_tab)\n    \n    def test_url_with_newline_in_middle_should_fail(self):\n        \"\"\"Test that URLs with newline in the middle are rejected.\"\"\"\n        url_with_newline_middle = 'http://www.example\\n.com/'\n        \n        with pytest.raises(ValidationError):\n            self.validator(url_with_newline_middle)\n    \n    def test_url_with_multiple_whitespace_chars_should_fail(self):\n        \"\"\"Test that URLs with multiple whitespace characters are rejected.\"\"\"\n        url_with_multiple = 'http://www.example.com/\\n\\r\\t'\n        \n        with pytest.raises(ValidationError):\n            self.validator(url_with_multiple)\n    \n    def test_url_with_cr_lf_combination_should_fail(self):\n        \"\"\"Test that URLs with CRLF combination are rejected.\"\"\"\n        url_with_crlf = 'http://www.example.com/\\r\\n'\n        \n        with pytest.raises(ValidationError):\n            self.validator(url_with_crlf)\n    \n    def test_valid_url_without_whitespace_should_pass(self):\n        \"\"\"Test that valid URLs without problematic whitespace pass validation.\"\"\"\n        valid_urls = [\n            'http://www.djangoproject.com/',\n            'https://example.com/path',\n            'http://[::ffff:192.9.5.5]',\n            'ftp://files.example.com/file.txt',\n            'https://subdomain.example.com:8080/path?query=value#fragment'\n        ]\n        \n        for url in valid_urls:\n            # Should not raise ValidationError\n            self.validator(url)\n    \n    def test_url_with_encoded_whitespace_should_pass(self):\n        \"\"\"Test that URLs with properly encoded whitespace characters pass.\"\"\"\n        # These should be valid as the whitespace is properly URL-encoded\n        valid_encoded_urls = [\n            'http://www.example.com/path%20with%20spaces',\n            'http://www.example.com/path%0A',  # encoded newline\n            'http://www.example.com/path%0D',  # encoded carriage return\n            'http://www.example.com/path%09',  # encoded tab\n        ]\n        \n        for url in valid_encoded_urls:\n            # Should not raise ValidationError\n            self.validator(url)\n    \n    def test_edge_cases_with_whitespace_in_different_url_parts(self):\n        \"\"\"Test whitespace characters in different parts of the URL.\"\"\"\n        # Test cases where whitespace appears in different URL components\n        invalid_urls = [\n            'http\\n://www.example.com/',  # in scheme\n            'http://www.exam\\nple.com/',  # in hostname\n            'http://www.example.com:80\\n80/',  # in port\n            'http://www.example.com/pa\\nth/',  # in path\n            'http://www.example.com/?que\\nry=value',  # in query\n            'http://www.example.com/#frag\\nment',  # in fragment\n        ]\n        \n        for url in invalid_urls:\n            with pytest.raises(ValidationError):\n                self.validator(url)\n    \n    def test_custom_schemes_with_whitespace_should_fail(self):\n        \"\"\"Test that custom schemes also reject whitespace characters.\"\"\"\n        custom_validator = URLValidator(schemes=['custom', 'http', 'https'])\n        \n        invalid_urls = [\n            'custom://example.com/\\n',\n            'custom://example.com/\\r',\n            'custom://example.com/\\t',\n        ]\n        \n        for url in invalid_urls:\n            with pytest.raises(ValidationError):\n                custom_validator(url)\n    \n    def test_regression_original_failing_cases(self):\n        \"\"\"\n        Regression test for the specific cases mentioned in the bug report.\n        \n        These are the exact URLs that were failing in the original issue:\n        - 'http://www.djangoproject.com/\\n'\n        - 'http://[::ffff:192.9.5.5]\\n'\n        \"\"\"\n        # These should fail validation (reproduce the bug)\n        failing_urls = [\n            'http://www.djangoproject.com/\\n',\n            'http://[::ffff:192.9.5.5]\\n'\n        ]\n        \n        for url in failing_urls:\n            with pytest.raises(ValidationError) as exc_info:\n                self.validator(url)\n            \n            # Ensure we get the expected error\n            assert exc_info.value.code == 'invalid'\n            assert 'Enter a valid URL.' in str(exc_info.value)\n</patched>\n```",
  "patch": "--- a/tests/validators/test_url_validator_bpo43882.py\n+++ b/tests/validators/test_url_validator_bpo43882.py\n-# Empty if creating new file\n+import pytest\n+from django.core.exceptions import ValidationError\n+from django.core.validators import URLValidator\n+\n+\n+class TestURLValidatorBPO43882:\n+    \"\"\"\n+    Test URLValidator behavior with URLs containing LF, CR, and tab characters.\n+    \n+    These tests verify that Django continues to reject URLs with potentially\n+    dangerous whitespace characters even after Python's bpo-43882 fix which\n+    strips these characters in urlsplit().\n+    \"\"\"\n+    \n+    def setup_method(self):\n+        \"\"\"Set up URLValidator instance for each test.\"\"\"\n+        self.validator = URLValidator()\n+    \n+    def test_url_with_newline_at_end_should_fail(self):\n+        \"\"\"Test that URLs with newline at the end are rejected.\"\"\"\n+        url_with_newline = 'http://www.djangoproject.com/\\n'\n+        \n+        with pytest.raises(ValidationError) as exc_info:\n+            self.validator(url_with_newline)\n+        \n+        # Verify the error message and code are as expected\n+        assert exc_info.value.code == 'invalid'\n+        assert 'Enter a valid URL.' in str(exc_info.value)\n+    \n+    def test_ipv6_url_with_newline_at_end_should_fail(self):\n+        \"\"\"Test that IPv6 URLs with newline at the end are rejected.\"\"\"\n+        ipv6_url_with_newline = 'http://[::ffff:192.9.5.5]\\n'\n+        \n+        with pytest.raises(ValidationError) as exc_info:\n+            self.validator(ipv6_url_with_newline)\n+        \n+        assert exc_info.value.code == 'invalid'\n+        assert 'Enter a valid URL.' in str(exc_info.value)\n+    \n+    def test_url_with_carriage_return_should_fail(self):\n+        \"\"\"Test that URLs with carriage return are rejected.\"\"\"\n+        url_with_cr = 'http://www.example.com/\\r'\n+        \n+        with pytest.raises(ValidationError):\n+            self.validator(url_with_cr)\n+    \n+    def test_url_with_tab_should_fail(self):\n+        \"\"\"Test that URLs with tab character are rejected.\"\"\"\n+        url_with_tab = 'http://www.example.com/\\t'\n+        \n+        with pytest.raises(ValidationError):\n+            self.validator(url_with_tab)\n+    \n+    def test_url_with_newline_in_middle_should_fail(self):\n+        \"\"\"Test that URLs with newline in the middle are rejected.\"\"\"\n+        url_with_newline_middle = 'http://www.example\\n.com/'\n+        \n+        with pytest.raises(ValidationError):\n+            self.validator(url_with_newline_middle)\n+    \n+    def test_url_with_multiple_whitespace_chars_should_fail(self):\n+        \"\"\"Test that URLs with multiple whitespace characters are rejected.\"\"\"\n+        url_with_multiple = 'http://www.example.com/\\n\\r\\t'\n+        \n+        with pytest.raises(ValidationError):\n+            self.validator(url_with_multiple)\n+    \n+    def test_url_with_cr_lf_combination_should_fail(self):\n+        \"\"\"Test that URLs with CRLF combination are rejected.\"\"\"\n+        url_with_crlf = 'http://www.example.com/\\r\\n'\n+        \n+        with pytest.raises(ValidationError):\n+            self.validator(url_with_crlf)\n+    \n+    def test_valid_url_without_whitespace_should_pass(self):\n+        \"\"\"Test that valid URLs without problematic whitespace pass validation.\"\"\"\n+        valid_urls = [\n+            'http://www.djangoproject.com/',\n+            'https://example.com/path',\n+            'http://[::ffff:192.9.5.5]',\n+            'ftp://files.example.com/file.txt',\n+            'https://subdomain.example.com:8080/path?query=value#fragment'\n+        ]\n+        \n+        for url in valid_urls:\n+            # Should not raise ValidationError\n+            self.validator(url)\n+    \n+    def test_url_with_encoded_whitespace_should_pass(self):\n+        \"\"\"Test that URLs with properly encoded whitespace characters pass.\"\"\"\n+        # These should be valid as the whitespace is properly URL-encoded\n+        valid_encoded_urls = [\n+            'http://www.example.com/path%20with%20spaces',\n+            'http://www.example.com/path%0A',  # encoded newline\n+            'http://www.example.com/path%0D',  # encoded carriage return\n+            'http://www.example.com/path%09',  # encoded tab\n+        ]\n+        \n+        for url in valid_encoded_urls:\n+            # Should not raise ValidationError\n+            self.validator(url)\n+    \n+    def test_edge_cases_with_whitespace_in_different_url_parts(self):\n+        \"\"\"Test whitespace characters in different parts of the URL.\"\"\"\n+        # Test cases where whitespace appears in different URL components\n+        invalid_urls = [\n+            'http\\n://www.example.com/',  # in scheme\n+            'http://www.exam\\nple.com/',  # in hostname\n+            'http://www.example.com:80\\n80/',  # in port\n+            'http://www.example.com/pa\\nth/',  # in path\n+            'http://www.example.com/?que\\nry=value',  # in query\n+            'http://www.example.com/#frag\\nment',  # in fragment\n+        ]\n+        \n+        for url in invalid_urls:\n+            with pytest.raises(ValidationError):\n+                self.validator(url)\n+    \n+    def test_custom_schemes_with_whitespace_should_fail(self):\n+        \"\"\"Test that custom schemes also reject whitespace characters.\"\"\"\n+        custom_validator = URLValidator(schemes=['custom', 'http', 'https'])\n+        \n+        invalid_urls = [\n+            'custom://example.com/\\n',\n+            'custom://example.com/\\r',\n+            'custom://example.com/\\t',\n+        ]\n+        \n+        for url in invalid_urls:\n+            with pytest.raises(ValidationError):\n+                custom_validator(url)\n+    \n+    def test_regression_original_failing_cases(self):\n+        \"\"\"\n+        Regression test for the specific cases mentioned in the bug report.\n+        \n+        These are the exact URLs that were failing in the original issue:\n+        - 'http://www.djangoproject.com/\\n'\n+        - 'http://[::ffff:192.9.5.5]\\n'\n+        \"\"\"\n+        # These should fail validation (reproduce the bug)\n+        failing_urls = [\n+            'http://www.djangoproject.com/\\n',\n+            'http://[::ffff:192.9.5.5]\\n'\n+        ]\n+        \n+        for url in failing_urls:\n+            with pytest.raises(ValidationError) as exc_info:\n+                self.validator(url)\n+            \n+            # Ensure we get the expected error\n+            assert exc_info.value.code == 'invalid'\n+            assert 'Enter a valid URL.' in str(exc_info.value)\n"
}