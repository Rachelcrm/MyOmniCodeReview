{
  "instance_id": "sympy__sympy-20916",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>sympy/printing/pretty/tests/test_pretty_symbology.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom sympy.printing.pretty.pretty_symbology import pretty_symbol, pretty_use_unicode\nfrom sympy import symbols\n\n\nclass TestPrettySymbolSubscripts:\n    \"\"\"Test that pretty_symbol correctly formats subscripts for all symbol types.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Enable unicode for testing.\"\"\"\n        self.original_unicode_setting = pretty_use_unicode()\n        pretty_use_unicode(True)\n    \n    def teardown_method(self):\n        \"\"\"Restore original unicode setting.\"\"\"\n        pretty_use_unicode(self.original_unicode_setting)\n    \n    def test_greek_letter_subscripts_basic(self):\n        \"\"\"Test that Greek letters with numeric subscripts are formatted correctly.\"\"\"\n        # Test omega with subscripts\n        result = pretty_symbol('omega0')\n        expected = '\u03c9\u2080'  # omega with subscript 0\n        assert result == expected, f\"Expected '\u03c9\u2080', got '{result}'\"\n        \n        result = pretty_symbol('omega1')\n        expected = '\u03c9\u2081'  # omega with subscript 1\n        assert result == expected, f\"Expected '\u03c9\u2081', got '{result}'\"\n        \n        result = pretty_symbol('omega2')\n        expected = '\u03c9\u2082'  # omega with subscript 2\n        assert result == expected, f\"Expected '\u03c9\u2082', got '{result}'\"\n    \n    def test_greek_letter_subscripts_all_digits(self):\n        \"\"\"Test all digits 0-9 as subscripts on Greek letters.\"\"\"\n        for i in range(10):\n            result = pretty_symbol(f'alpha{i}')\n            # Expected subscript unicode characters\n            subscript_chars = ['\u2080', '\u2081', '\u2082', '\u2083', '\u2084', '\u2085', '\u2086', '\u2087', '\u2088', '\u2089']\n            expected = f'\u03b1{subscript_chars[i]}'\n            assert result == expected, f\"Expected '\u03b1{subscript_chars[i]}', got '{result}'\"\n    \n    def test_multiple_greek_letters_with_subscripts(self):\n        \"\"\"Test various Greek letters with subscripts.\"\"\"\n        test_cases = [\n            ('alpha0', '\u03b1\u2080'),\n            ('beta1', '\u03b2\u2081'),\n            ('gamma2', '\u03b3\u2082'),\n            ('delta3', '\u03b4\u2083'),\n            ('epsilon4', '\u03b5\u2084'),\n            ('zeta5', '\u03b6\u2085'),\n            ('eta6', '\u03b7\u2086'),\n            ('theta7', '\u03b8\u2087'),\n            ('iota8', '\u03b9\u2088'),\n            ('kappa9', '\u03ba\u2089'),\n            ('lambda0', '\u03bb\u2080'),\n            ('mu1', '\u03bc\u2081'),\n            ('nu2', '\u03bd\u2082'),\n            ('xi3', '\u03be\u2083'),\n            ('omicron4', '\u03bf\u2084'),\n            ('pi5', '\u03c0\u2085'),\n            ('rho6', '\u03c1\u2086'),\n            ('sigma7', '\u03c3\u2087'),\n            ('tau8', '\u03c4\u2088'),\n            ('upsilon9', '\u03c5\u2089'),\n            ('phi0', '\u03c6\u2080'),\n            ('chi1', '\u03c7\u2081'),\n            ('psi2', '\u03c8\u2082'),\n            ('omega3', '\u03c9\u2083'),\n        ]\n        \n        for input_symbol, expected in test_cases:\n            result = pretty_symbol(input_symbol)\n            assert result == expected, f\"For '{input_symbol}': expected '{expected}', got '{result}'\"\n    \n    def test_non_greek_symbols_still_work(self):\n        \"\"\"Test that non-Greek symbols with subscripts still work correctly.\"\"\"\n        # These should already work, but let's verify they're not broken\n        test_cases = [\n            ('t0', 't\u2080'),\n            ('w0', 'w\u2080'),\n            ('x1', 'x\u2081'),\n            ('y2', 'y\u2082'),\n            ('z3', 'z\u2083'),\n        ]\n        \n        for input_symbol, expected in test_cases:\n            result = pretty_symbol(input_symbol)\n            assert result == expected, f\"For '{input_symbol}': expected '{expected}', got '{result}'\"\n    \n    def test_greek_letters_without_subscripts(self):\n        \"\"\"Test that Greek letters without subscripts are still formatted correctly.\"\"\"\n        test_cases = [\n            ('alpha', '\u03b1'),\n            ('beta', '\u03b2'),\n            ('gamma', '\u03b3'),\n            ('omega', '\u03c9'),\n        ]\n        \n        for input_symbol, expected in test_cases:\n            result = pretty_symbol(input_symbol)\n            assert result == expected, f\"For '{input_symbol}': expected '{expected}', got '{result}'\"\n    \n    def test_capital_greek_letters_with_subscripts(self):\n        \"\"\"Test that capital Greek letters with subscripts work correctly.\"\"\"\n        test_cases = [\n            ('Alpha0', '\u0391\u2080'),\n            ('Beta1', '\u0392\u2081'),\n            ('Gamma2', '\u0393\u2082'),\n            ('Omega3', '\u03a9\u2083'),\n        ]\n        \n        for input_symbol, expected in test_cases:\n            result = pretty_symbol(input_symbol)\n            assert result == expected, f\"For '{input_symbol}': expected '{expected}', got '{result}'\"\n    \n    def test_multiple_subscripts(self):\n        \"\"\"Test Greek letters with multiple digit subscripts.\"\"\"\n        # Note: This tests the current behavior - multiple digits might be handled differently\n        result = pretty_symbol('omega12')\n        # This should convert both digits to subscripts\n        expected = '\u03c9\u2081\u2082'\n        assert result == expected, f\"Expected '\u03c9\u2081\u2082', got '{result}'\"\n    \n    def test_greek_letters_with_superscripts(self):\n        \"\"\"Test that Greek letters with superscripts work correctly.\"\"\"\n        # Test basic superscript functionality\n        result = pretty_symbol('alpha__1')  # Using __ for superscript based on split_super_sub\n        # This should produce alpha with superscript 1\n        # The exact format depends on how split_super_sub handles superscripts\n        assert '\u03b1' in result, f\"Expected alpha character in result, got '{result}'\"\n    \n    def test_unicode_disabled(self):\n        \"\"\"Test that when unicode is disabled, subscripts are not converted.\"\"\"\n        pretty_use_unicode(False)\n        \n        result = pretty_symbol('omega0')\n        # When unicode is disabled, should return the original string\n        expected = 'omega0'\n        assert result == expected, f\"Expected 'omega0', got '{result}'\"\n        \n        # Re-enable unicode for other tests\n        pretty_use_unicode(True)\n    \n    def test_consistency_with_matrix_example(self):\n        \"\"\"Test the specific case mentioned in the issue description.\"\"\"\n        # The issue shows that t\u2080\u22c5w\u2080 works but \u03c90 doesn't\n        # Let's test the individual components\n        \n        t_result = pretty_symbol('t0')\n        w_result = pretty_symbol('w0')\n        omega_result = pretty_symbol('omega0')\n        \n        # All should have proper subscripts\n        assert t_result == 't\u2080', f\"Expected 't\u2080', got '{t_result}'\"\n        assert w_result == 'w\u2080', f\"Expected 'w\u2080', got '{w_result}'\"\n        assert omega_result == '\u03c9\u2080', f\"Expected '\u03c9\u2080', got '{omega_result}'\"\n        \n        # The omega case is the one that was failing\n        assert '\u2080' in omega_result, \"Omega should have subscript 0, not regular 0\"\n        assert '0' not in omega_result, \"Omega should not have regular digit 0\"\n\n\nclass TestPrettySymbolEdgeCases:\n    \"\"\"Test edge cases for pretty_symbol subscript formatting.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Enable unicode for testing.\"\"\"\n        self.original_unicode_setting = pretty_use_unicode()\n        pretty_use_unicode(True)\n    \n    def teardown_method(self):\n        \"\"\"Restore original unicode setting.\"\"\"\n        pretty_use_unicode(self.original_unicode_setting)\n    \n    def test_empty_string(self):\n        \"\"\"Test that empty string is handled gracefully.\"\"\"\n        result = pretty_symbol('')\n        assert result == '', f\"Expected empty string, got '{result}'\"\n    \n    def test_invalid_greek_name(self):\n        \"\"\"Test that invalid Greek letter names fall back gracefully.\"\"\"\n        result = pretty_symbol('notgreek0')\n        # Should not be converted to Greek, but subscript should still work\n        expected = 'notgreek\u2080'\n        assert result == expected, f\"Expected 'notgreek\u2080', got '{result}'\"\n    \n    def test_mixed_subscripts(self):\n        \"\"\"Test Greek letters with mixed character subscripts.\"\"\"\n        # Test with letter subscripts (if supported)\n        result = pretty_symbol('omegai')\n        # This should convert omega to unicode but leave 'i' as is or convert to subscript\n        assert '\u03c9' in result, f\"Expected omega character in result, got '{result}'\"\n</patched>\n</file>\n```\n\n```\n<file>sympy/printing/tests/test_pretty.py</file>\n<original>\n# This will add tests to existing test file - we need to find the right location\n</original>\n<patched>\n# Add these tests to the existing test_pretty.py file\n\ndef test_greek_subscripts_unicode_issue():\n    \"\"\"\n    Test for the specific issue: pprint unicode does not format subscripts on Greek letters.\n    \n    This test reproduces the issue described where Greek letters like omega\n    should display subscripts as Unicode subscript characters (\u03c9\u2080) rather \n    than regular digits (\u03c90).\n    \"\"\"\n    from sympy import symbols, Matrix, pretty\n    from sympy.printing.pretty.pretty_symbology import pretty_use_unicode\n    \n    # Save original unicode setting\n    original_unicode = pretty_use_unicode()\n    pretty_use_unicode(True)\n    \n    try:\n        # Test individual symbols\n        t0, t1, t2 = symbols('t0 t1 t2')\n        w0, w1, w2 = symbols('w0 w1 w2') \n        omega0, omega1, omega2 = symbols('omega0 omega1 omega2')\n        \n        # Test that regular symbols work (these should already work)\n        t0_pretty = pretty(t0)\n        w0_pretty = pretty(w0)\n        \n        # Test that Greek symbols also work (this was the bug)\n        omega0_pretty = pretty(omega0)\n        omega1_pretty = pretty(omega1)\n        omega2_pretty = pretty(omega2)\n        \n        # All should have Unicode subscripts, not regular digits\n        assert '\u2080' in t0_pretty, f\"t0 should have subscript, got: {repr(t0_pretty)}\"\n        assert '\u2080' in w0_pretty, f\"w0 should have subscript, got: {repr(w0_pretty)}\"\n        assert '\u2080' in omega0_pretty, f\"omega0 should have subscript, got: {repr(omega0_pretty)}\"\n        assert '\u2081' in omega1_pretty, f\"omega1 should have subscript, got: {repr(omega1_pretty)}\"\n        assert '\u2082' in omega2_pretty, f\"omega2 should have subscript, got: {repr(omega2_pretty)}\"\n        \n        # Ensure no regular digits appear in subscript positions\n        assert '0' not in omega0_pretty.replace('\u2080', ''), f\"omega0 should not have regular 0, got: {repr(omega0_pretty)}\"\n        assert '1' not in omega1_pretty.replace('\u2081', ''), f\"omega1 should not have regular 1, got: {repr(omega1_pretty)}\"\n        assert '2' not in omega2_pretty.replace('\u2082', ''), f\"omega2 should not have regular 2, got: {repr(omega2_pretty)}\"\n        \n        # Test the matrix case from the issue description\n        # Good case: [ -t\u2080\u22c5w\u2080   -t\u2081\u22c5w\u2080   -t\u2082\u22c5w\u2080]\n        # Bad case:  [ -t\u2080\u22c5\u03c90   -t\u2081\u22c5\u03c90   -t\u2082\u22c5\u03c90]\n        matrix_expr = Matrix([[-t0*w0, -t1*w0, -t2*w0]])\n        matrix_pretty = pretty(matrix_expr)\n        \n        # Should contain proper subscripts\n        assert '\u2080' in matrix_pretty, f\"Matrix should contain subscripts, got: {repr(matrix_pretty)}\"\n        \n        # Test with omega symbols\n        matrix_omega = Matrix([[-t0*omega0, -t1*omega0, -t2*omega0]])\n        matrix_omega_pretty = pretty(matrix_omega)\n        \n        # Should contain both regular subscripts and Greek letter subscripts\n        assert '\u2080' in matrix_omega_pretty, f\"Matrix with omega should contain subscripts, got: {repr(matrix_omega_pretty)}\"\n        assert '\u03c9' in matrix_omega_pretty, f\"Matrix should contain omega character, got: {repr(matrix_omega_pretty)}\"\n        \n        # The key test: omega should have subscript, not regular digit\n        # Look for the pattern \u03c9\u2080 (omega with subscript) rather than \u03c90 (omega with regular digit)\n        assert '\u03c9\u2080' in matrix_omega_pretty, f\"Should contain '\u03c9\u2080', got: {repr(matrix_omega_pretty)}\"\n        assert '\u03c90' not in matrix_omega_pretty, f\"Should not contain '\u03c90', got: {repr(matrix_omega_pretty)}\"\n        \n    finally:\n        # Restore original unicode setting\n        pretty_use_unicode(original_unicode)\n\n\ndef test_greek_letters_subscript_consistency():\n    \"\"\"\n    Test that all Greek letters handle subscripts consistently.\n    \"\"\"\n    from sympy import symbols, pretty\n    from sympy.printing.pretty.pretty_symbology import pretty_use_unicode\n    \n    # Save original unicode setting\n    original_unicode = pretty_use_unicode()\n    pretty_use_unicode(True)\n    \n    try:\n        # Test various Greek letters with subscripts\n        greek_letters = ['alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', \n                        'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', \n                        'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', \n                        'phi', 'chi', 'psi', 'omega']\n        \n        for greek_name in greek_letters:\n            for digit in range(3):  # Test digits 0, 1, 2\n                symbol_name = f\"{greek_name}{digit}\"\n                sym = symbols(symbol_name)\n                pretty_result = pretty(sym)\n                \n                # Should contain the appropriate subscript digit\n                subscript_digits = ['\u2080', '\u2081', '\u2082']\n                expected_subscript = subscript_digits[digit]\n                \n                assert expected_subscript in pretty_result, \\\n                    f\"Symbol {symbol_name} should contain subscript {expected_subscript}, got: {repr(pretty_result)}\"\n                \n                # Should not contain the regular digit in subscript position\n                assert str(digit) not in pretty_result.replace(expected_subscript, ''), \\\n                    f\"Symbol {symbol_name} should not contain regular digit {digit}, got: {repr(pretty_result)}\"\n    \n    finally:\n        # Restore original unicode setting\n        pretty_use_unicode(original_unicode)\n\n\ndef test_subscript_formatting_unicode_vs_ascii():\n    \"\"\"\n    Test that subscript formatting behaves correctly in both Unicode and ASCII modes.\n    \"\"\"\n    from sympy import symbols",
  "patch": "--- a/sympy/printing/pretty/tests/test_pretty_symbology.py\n+++ b/sympy/printing/pretty/tests/test_pretty_symbology.py\n-# Empty if creating new file\n+import pytest\n+from sympy.printing.pretty.pretty_symbology import pretty_symbol, pretty_use_unicode\n+from sympy import symbols\n+\n+\n+class TestPrettySymbolSubscripts:\n+    \"\"\"Test that pretty_symbol correctly formats subscripts for all symbol types.\"\"\"\n+    \n+    def setup_method(self):\n+        \"\"\"Enable unicode for testing.\"\"\"\n+        self.original_unicode_setting = pretty_use_unicode()\n+        pretty_use_unicode(True)\n+    \n+    def teardown_method(self):\n+        \"\"\"Restore original unicode setting.\"\"\"\n+        pretty_use_unicode(self.original_unicode_setting)\n+    \n+    def test_greek_letter_subscripts_basic(self):\n+        \"\"\"Test that Greek letters with numeric subscripts are formatted correctly.\"\"\"\n+        # Test omega with subscripts\n+        result = pretty_symbol('omega0')\n+        expected = '\u03c9\u2080'  # omega with subscript 0\n+        assert result == expected, f\"Expected '\u03c9\u2080', got '{result}'\"\n+        \n+        result = pretty_symbol('omega1')\n+        expected = '\u03c9\u2081'  # omega with subscript 1\n+        assert result == expected, f\"Expected '\u03c9\u2081', got '{result}'\"\n+        \n+        result = pretty_symbol('omega2')\n+        expected = '\u03c9\u2082'  # omega with subscript 2\n+        assert result == expected, f\"Expected '\u03c9\u2082', got '{result}'\"\n+    \n+    def test_greek_letter_subscripts_all_digits(self):\n+        \"\"\"Test all digits 0-9 as subscripts on Greek letters.\"\"\"\n+        for i in range(10):\n+            result = pretty_symbol(f'alpha{i}')\n+            # Expected subscript unicode characters\n+            subscript_chars = ['\u2080', '\u2081', '\u2082', '\u2083', '\u2084', '\u2085', '\u2086', '\u2087', '\u2088', '\u2089']\n+            expected = f'\u03b1{subscript_chars[i]}'\n+            assert result == expected, f\"Expected '\u03b1{subscript_chars[i]}', got '{result}'\"\n+    \n+    def test_multiple_greek_letters_with_subscripts(self):\n+        \"\"\"Test various Greek letters with subscripts.\"\"\"\n+        test_cases = [\n+            ('alpha0', '\u03b1\u2080'),\n+            ('beta1', '\u03b2\u2081'),\n+            ('gamma2', '\u03b3\u2082'),\n+            ('delta3', '\u03b4\u2083'),\n+            ('epsilon4', '\u03b5\u2084'),\n+            ('zeta5', '\u03b6\u2085'),\n+            ('eta6', '\u03b7\u2086'),\n+            ('theta7', '\u03b8\u2087'),\n+            ('iota8', '\u03b9\u2088'),\n+            ('kappa9', '\u03ba\u2089'),\n+            ('lambda0', '\u03bb\u2080'),\n+            ('mu1', '\u03bc\u2081'),\n+            ('nu2', '\u03bd\u2082'),\n+            ('xi3', '\u03be\u2083'),\n+            ('omicron4', '\u03bf\u2084'),\n+            ('pi5', '\u03c0\u2085'),\n+            ('rho6', '\u03c1\u2086'),\n+            ('sigma7', '\u03c3\u2087'),\n+            ('tau8', '\u03c4\u2088'),\n+            ('upsilon9', '\u03c5\u2089'),\n+            ('phi0', '\u03c6\u2080'),\n+            ('chi1', '\u03c7\u2081'),\n+            ('psi2', '\u03c8\u2082'),\n+            ('omega3', '\u03c9\u2083'),\n+        ]\n+        \n+        for input_symbol, expected in test_cases:\n+            result = pretty_symbol(input_symbol)\n+            assert result == expected, f\"For '{input_symbol}': expected '{expected}', got '{result}'\"\n+    \n+    def test_non_greek_symbols_still_work(self):\n+        \"\"\"Test that non-Greek symbols with subscripts still work correctly.\"\"\"\n+        # These should already work, but let's verify they're not broken\n+        test_cases = [\n+            ('t0', 't\u2080'),\n+            ('w0', 'w\u2080'),\n+            ('x1', 'x\u2081'),\n+            ('y2', 'y\u2082'),\n+            ('z3', 'z\u2083'),\n+        ]\n+        \n+        for input_symbol, expected in test_cases:\n+            result = pretty_symbol(input_symbol)\n+            assert result == expected, f\"For '{input_symbol}': expected '{expected}', got '{result}'\"\n+    \n+    def test_greek_letters_without_subscripts(self):\n+        \"\"\"Test that Greek letters without subscripts are still formatted correctly.\"\"\"\n+        test_cases = [\n+            ('alpha', '\u03b1'),\n+            ('beta', '\u03b2'),\n+            ('gamma', '\u03b3'),\n+            ('omega', '\u03c9'),\n+        ]\n+        \n+        for input_symbol, expected in test_cases:\n+            result = pretty_symbol(input_symbol)\n+            assert result == expected, f\"For '{input_symbol}': expected '{expected}', got '{result}'\"\n+    \n+    def test_capital_greek_letters_with_subscripts(self):\n+        \"\"\"Test that capital Greek letters with subscripts work correctly.\"\"\"\n+        test_cases = [\n+            ('Alpha0', '\u0391\u2080'),\n+            ('Beta1', '\u0392\u2081'),\n+            ('Gamma2', '\u0393\u2082'),\n+            ('Omega3', '\u03a9\u2083'),\n+        ]\n+        \n+        for input_symbol, expected in test_cases:\n+            result = pretty_symbol(input_symbol)\n+            assert result == expected, f\"For '{input_symbol}': expected '{expected}', got '{result}'\"\n+    \n+    def test_multiple_subscripts(self):\n+        \"\"\"Test Greek letters with multiple digit subscripts.\"\"\"\n+        # Note: This tests the current behavior - multiple digits might be handled differently\n+        result = pretty_symbol('omega12')\n+        # This should convert both digits to subscripts\n+        expected = '\u03c9\u2081\u2082'\n+        assert result == expected, f\"Expected '\u03c9\u2081\u2082', got '{result}'\"\n+    \n+    def test_greek_letters_with_superscripts(self):\n+        \"\"\"Test that Greek letters with superscripts work correctly.\"\"\"\n+        # Test basic superscript functionality\n+        result = pretty_symbol('alpha__1')  # Using __ for superscript based on split_super_sub\n+        # This should produce alpha with superscript 1\n+        # The exact format depends on how split_super_sub handles superscripts\n+        assert '\u03b1' in result, f\"Expected alpha character in result, got '{result}'\"\n+    \n+    def test_unicode_disabled(self):\n+        \"\"\"Test that when unicode is disabled, subscripts are not converted.\"\"\"\n+        pretty_use_unicode(False)\n+        \n+        result = pretty_symbol('omega0')\n+        # When unicode is disabled, should return the original string\n+        expected = 'omega0'\n+        assert result == expected, f\"Expected 'omega0', got '{result}'\"\n+        \n+        # Re-enable unicode for other tests\n+        pretty_use_unicode(True)\n+    \n+    def test_consistency_with_matrix_example(self):\n+        \"\"\"Test the specific case mentioned in the issue description.\"\"\"\n+        # The issue shows that t\u2080\u22c5w\u2080 works but \u03c90 doesn't\n+        # Let's test the individual components\n+        \n+        t_result = pretty_symbol('t0')\n+        w_result = pretty_symbol('w0')\n+        omega_result = pretty_symbol('omega0')\n+        \n+        # All should have proper subscripts\n+        assert t_result == 't\u2080', f\"Expected 't\u2080', got '{t_result}'\"\n+        assert w_result == 'w\u2080', f\"Expected 'w\u2080', got '{w_result}'\"\n+        assert omega_result == '\u03c9\u2080', f\"Expected '\u03c9\u2080', got '{omega_result}'\"\n+        \n+        # The omega case is the one that was failing\n+        assert '\u2080' in omega_result, \"Omega should have subscript 0, not regular 0\"\n+        assert '0' not in omega_result, \"Omega should not have regular digit 0\"\n+\n+\n+class TestPrettySymbolEdgeCases:\n+    \"\"\"Test edge cases for pretty_symbol subscript formatting.\"\"\"\n+    \n+    def setup_method(self):\n+        \"\"\"Enable unicode for testing.\"\"\"\n+        self.original_unicode_setting = pretty_use_unicode()\n+        pretty_use_unicode(True)\n+    \n+    def teardown_method(self):\n+        \"\"\"Restore original unicode setting.\"\"\"\n+        pretty_use_unicode(self.original_unicode_setting)\n+    \n+    def test_empty_string(self):\n+        \"\"\"Test that empty string is handled gracefully.\"\"\"\n+        result = pretty_symbol('')\n+        assert result == '', f\"Expected empty string, got '{result}'\"\n+    \n+    def test_invalid_greek_name(self):\n+        \"\"\"Test that invalid Greek letter names fall back gracefully.\"\"\"\n+        result = pretty_symbol('notgreek0')\n+        # Should not be converted to Greek, but subscript should still work\n+        expected = 'notgreek\u2080'\n+        assert result == expected, f\"Expected 'notgreek\u2080', got '{result}'\"\n+    \n+    def test_mixed_subscripts(self):\n+        \"\"\"Test Greek letters with mixed character subscripts.\"\"\"\n+        # Test with letter subscripts (if supported)\n+        result = pretty_symbol('omegai')\n+        # This should convert omega to unicode but leave 'i' as is or convert to subscript\n+        assert '\u03c9' in result, f\"Expected omega character in result, got '{result}'\"\n"
}