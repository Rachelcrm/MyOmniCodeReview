{
  "instance_id": "django__django-15280",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/prefetch_related/test_deferred_fields_bug.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import models\nfrom django.test import TestCase\nfrom django.db.models import Prefetch\nfrom django.test.utils import override_settings\n\n\nclass User(models.Model):\n    email = models.EmailField()\n    kind = models.CharField(\n        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n    )\n    \n    class Meta:\n        app_label = 'prefetch_related'\n\n\nclass Profile(models.Model):\n    full_name = models.CharField(max_length=255)\n    user = models.OneToOneField(User, on_delete=models.CASCADE)\n    \n    class Meta:\n        app_label = 'prefetch_related'\n\n\nclass Company(models.Model):\n    name = models.CharField(max_length=255)\n    \n    class Meta:\n        app_label = 'prefetch_related'\n\n\nclass Employee(models.Model):\n    name = models.CharField(max_length=255)\n    company = models.ForeignKey(Company, on_delete=models.CASCADE, related_name='employees')\n    \n    class Meta:\n        app_label = 'prefetch_related'\n\n\n@override_settings(USE_TZ=False)\nclass DeferredFieldsPrefetchTestCase(TestCase):\n    \"\"\"\n    Test case for the bug where deferred fields are incorrect when following \n    prefetches back to the \"parent\" object.\n    \n    The issue occurs when using nested Prefetch objects with .only() - the inner\n    queryset correctly selects only the specified fields, but the resulting instances\n    incorrectly inherit deferred field information from the outer queryset.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        self.user = User.objects.create(\n            email=\"test@example.com\",\n            kind=\"ADMIN\",\n        )\n        self.profile = Profile.objects.create(\n            user=self.user, \n            full_name=\"Test Tester\"\n        )\n        \n        self.company = Company.objects.create(name=\"Test Company\")\n        self.employee = Employee.objects.create(\n            name=\"John Doe\",\n            company=self.company\n        )\n\n    def test_onetoone_prefetch_deferred_fields_bug_reproduction(self):\n        \"\"\"\n        Test that reproduces the original bug with OneToOneField.\n        \n        This test should FAIL before the fix is applied, demonstrating the bug\n        where accessing user.profile.user.kind triggers an unnecessary database query\n        even though 'kind' was explicitly selected in the inner queryset.\n        \"\"\"\n        queryset = User.objects.only(\"email\").prefetch_related(\n            Prefetch(\n                \"profile\",\n                queryset=Profile.objects.prefetch_related(\n                    Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n                ),\n            )\n        )\n        \n        # First, execute the main queryset - should be 3 queries\n        with self.assertNumQueries(3):\n            user = queryset.first()\n        \n        # Verify the deferred fields are incorrectly set\n        # This demonstrates the bug - kind should NOT be in deferred fields\n        # since it was explicitly selected in the inner queryset\n        deferred_fields = user.profile.user.get_deferred_fields()\n        self.assertIn('kind', deferred_fields, \n                     \"Bug reproduction: 'kind' should not be deferred but is marked as deferred\")\n        \n        # This should NOT trigger additional queries since 'kind' was prefetched\n        # But due to the bug, it will trigger 1 additional query\n        with self.assertNumQueries(1):  # This demonstrates the bug - should be 0\n            kind_value = user.profile.user.kind\n            \n        self.assertEqual(kind_value, \"ADMIN\")\n\n    def test_onetoone_prefetch_deferred_fields_expected_behavior(self):\n        \"\"\"\n        Test the expected behavior after the fix is applied.\n        \n        This test should PASS after the fix, showing that deferred fields\n        are correctly handled when following prefetches back to parent objects.\n        \"\"\"\n        queryset = User.objects.only(\"email\").prefetch_related(\n            Prefetch(\n                \"profile\",\n                queryset=Profile.objects.prefetch_related(\n                    Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n                ),\n            )\n        )\n        \n        # Execute the main queryset - should be 3 queries\n        with self.assertNumQueries(3):\n            user = queryset.first()\n        \n        # After the fix, accessing the prefetched field should not trigger additional queries\n        with self.assertNumQueries(0):\n            kind_value = user.profile.user.kind\n            \n        self.assertEqual(kind_value, \"ADMIN\")\n        \n        # Verify that the correct fields are marked as deferred\n        # The inner user should only have 'kind' loaded, so 'email' should be deferred\n        inner_user_deferred = user.profile.user.get_deferred_fields()\n        self.assertNotIn('kind', inner_user_deferred, \n                        \"'kind' should not be deferred as it was explicitly selected\")\n        self.assertIn('email', inner_user_deferred,\n                     \"'email' should be deferred as it was not selected in inner queryset\")\n\n    def test_foreignkey_prefetch_deferred_fields_bug_reproduction(self):\n        \"\"\"\n        Test that reproduces the bug with ForeignKey relationships.\n        \n        Similar to the OneToOne case, but using ForeignKey to show the bug\n        also affects this type of relationship.\n        \"\"\"\n        queryset = Company.objects.only(\"name\").prefetch_related(\n            Prefetch(\n                \"employees\",\n                queryset=Employee.objects.prefetch_related(\n                    Prefetch(\"company\", queryset=Company.objects.only(\"name\"))\n                ),\n            )\n        )\n        \n        # Execute the main queryset\n        with self.assertNumQueries(3):\n            company = queryset.first()\n        \n        # Access the prefetched field - this should not trigger additional queries\n        # but due to the bug, it will\n        with self.assertNumQueries(1):  # This demonstrates the bug - should be 0\n            employee = company.employees.all()[0]\n            company_name = employee.company.name\n            \n        self.assertEqual(company_name, \"Test Company\")\n\n    def test_foreignkey_prefetch_deferred_fields_expected_behavior(self):\n        \"\"\"\n        Test the expected behavior for ForeignKey after the fix.\n        \"\"\"\n        queryset = Company.objects.only(\"name\").prefetch_related(\n            Prefetch(\n                \"employees\",\n                queryset=Employee.objects.prefetch_related(\n                    Prefetch(\"company\", queryset=Company.objects.only(\"name\"))\n                ),\n            )\n        )\n        \n        # Execute the main queryset\n        with self.assertNumQueries(3):\n            company = queryset.first()\n        \n        # After the fix, this should not trigger additional queries\n        with self.assertNumQueries(0):\n            employee = company.employees.all()[0]\n            company_name = employee.company.name\n            \n        self.assertEqual(company_name, \"Test Company\")\n\n    def test_multiple_nested_prefetch_levels(self):\n        \"\"\"\n        Test more complex nested prefetch scenarios to ensure the fix works\n        for deeper nesting levels.\n        \"\"\"\n        # Create additional test data for deeper nesting\n        user2 = User.objects.create(email=\"user2@example.com\", kind=\"REGULAR\")\n        profile2 = Profile.objects.create(user=user2, full_name=\"User Two\")\n        \n        queryset = User.objects.only(\"email\").prefetch_related(\n            Prefetch(\n                \"profile\",\n                queryset=Profile.objects.only(\"full_name\").prefetch_related(\n                    Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n                ),\n            )\n        )\n        \n        # Execute the main queryset\n        with self.assertNumQueries(3):\n            users = list(queryset.all())\n        \n        # After the fix, accessing nested prefetched fields should not trigger queries\n        with self.assertNumQueries(0):\n            for user in users:\n                profile_name = user.profile.full_name\n                user_kind = user.profile.user.kind\n                \n                # Verify we can access the data\n                self.assertIsNotNone(profile_name)\n                self.assertIn(user_kind, [\"ADMIN\", \"REGULAR\"])\n\n    def test_deferred_fields_state_preservation(self):\n        \"\"\"\n        Test that the deferred fields state is correctly preserved for each\n        instance based on its originating queryset.\n        \"\"\"\n        queryset = User.objects.only(\"email\").prefetch_related(\n            Prefetch(\n                \"profile\",\n                queryset=Profile.objects.prefetch_related(\n                    Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n                ),\n            )\n        )\n        \n        with self.assertNumQueries(3):\n            user = queryset.first()\n        \n        # The outer user should have 'kind' deferred but 'email' loaded\n        outer_user_deferred = user.get_deferred_fields()\n        self.assertNotIn('email', outer_user_deferred, \n                        \"Outer user should have 'email' loaded\")\n        self.assertIn('kind', outer_user_deferred,\n                     \"Outer user should have 'kind' deferred\")\n        \n        # The inner user (accessed via profile.user) should have 'email' deferred but 'kind' loaded\n        inner_user_deferred = user.profile.user.get_deferred_fields()\n        self.assertNotIn('kind', inner_user_deferred,\n                        \"Inner user should have 'kind' loaded\")\n        self.assertIn('email', inner_user_deferred,\n                     \"Inner user should have 'email' deferred\")\n\n    def test_edge_case_empty_only_queryset(self):\n        \"\"\"\n        Test edge case where the inner queryset uses only() with no fields.\n        \"\"\"\n        queryset = User.objects.only(\"email\").prefetch_related(\n            Prefetch(\n                \"profile\",\n                queryset=Profile.objects.prefetch_related(\n                    Prefetch(\"user\", queryset=User.objects.only())\n                ),\n            )\n        )\n        \n        with self.assertNumQueries(3):\n            user = queryset.first()\n        \n        # When only() is called with no arguments, only the primary key should be loaded\n        inner_user_deferred = user.profile.user.get_deferred_fields()\n        self.assertIn('email', inner_user_deferred)\n        self.assertIn('kind', inner_user_deferred)\n\n    def test_multiple_fields_in_only(self):\n        \"\"\"\n        Test that the fix works when multiple fields are specified in only().\n        \"\"\"\n        queryset = User.objects.only(\"id\").prefetch_related(\n            Prefetch(\n                \"profile\",\n                queryset=Profile.objects.prefetch_related(\n                    Prefetch(\"user\", queryset=User.objects.only(\"email\", \"kind\"))\n                ),\n            )\n        )\n        \n        with self.assertNumQueries(3):\n            user = queryset.first()\n        \n        # After the fix, accessing both prefetched fields should not trigger queries\n        with self.assertNumQueries(0):\n            email = user.profile.user.email\n            kind = user.profile.user.kind\n            \n        self.assertEqual(email, \"test@example.com\")\n        self.assertEqual(kind, \"ADMIN\")\n        \n        # Verify deferred fields state\n        inner_user_deferred = user.profile.user.get_deferred_fields()\n        self.assertNotIn('email', inner_user_deferred)\n        self.assertNotIn('kind', inner_user_deferred)\n</patched>\n</file>\n```",
  "patch": "--- a/tests/prefetch_related/test_deferred_fields_bug.py\n+++ b/tests/prefetch_related/test_deferred_fields_bug.py\n-# Empty if creating new file\n+import pytest\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import Prefetch\n+from django.test.utils import override_settings\n+\n+\n+class User(models.Model):\n+    email = models.EmailField()\n+    kind = models.CharField(\n+        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n+    )\n+    \n+    class Meta:\n+        app_label = 'prefetch_related'\n+\n+\n+class Profile(models.Model):\n+    full_name = models.CharField(max_length=255)\n+    user = models.OneToOneField(User, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'prefetch_related'\n+\n+\n+class Company(models.Model):\n+    name = models.CharField(max_length=255)\n+    \n+    class Meta:\n+        app_label = 'prefetch_related'\n+\n+\n+class Employee(models.Model):\n+    name = models.CharField(max_length=255)\n+    company = models.ForeignKey(Company, on_delete=models.CASCADE, related_name='employees')\n+    \n+    class Meta:\n+        app_label = 'prefetch_related'\n+\n+\n+@override_settings(USE_TZ=False)\n+class DeferredFieldsPrefetchTestCase(TestCase):\n+    \"\"\"\n+    Test case for the bug where deferred fields are incorrect when following \n+    prefetches back to the \"parent\" object.\n+    \n+    The issue occurs when using nested Prefetch objects with .only() - the inner\n+    queryset correctly selects only the specified fields, but the resulting instances\n+    incorrectly inherit deferred field information from the outer queryset.\n+    \"\"\"\n+    \n+    def setUp(self):\n+        \"\"\"Set up test data.\"\"\"\n+        self.user = User.objects.create(\n+            email=\"test@example.com\",\n+            kind=\"ADMIN\",\n+        )\n+        self.profile = Profile.objects.create(\n+            user=self.user, \n+            full_name=\"Test Tester\"\n+        )\n+        \n+        self.company = Company.objects.create(name=\"Test Company\")\n+        self.employee = Employee.objects.create(\n+            name=\"John Doe\",\n+            company=self.company\n+        )\n+\n+    def test_onetoone_prefetch_deferred_fields_bug_reproduction(self):\n+        \"\"\"\n+        Test that reproduces the original bug with OneToOneField.\n+        \n+        This test should FAIL before the fix is applied, demonstrating the bug\n+        where accessing user.profile.user.kind triggers an unnecessary database query\n+        even though 'kind' was explicitly selected in the inner queryset.\n+        \"\"\"\n+        queryset = User.objects.only(\"email\").prefetch_related(\n+            Prefetch(\n+                \"profile\",\n+                queryset=Profile.objects.prefetch_related(\n+                    Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+                ),\n+            )\n+        )\n+        \n+        # First, execute the main queryset - should be 3 queries\n+        with self.assertNumQueries(3):\n+            user = queryset.first()\n+        \n+        # Verify the deferred fields are incorrectly set\n+        # This demonstrates the bug - kind should NOT be in deferred fields\n+        # since it was explicitly selected in the inner queryset\n+        deferred_fields = user.profile.user.get_deferred_fields()\n+        self.assertIn('kind', deferred_fields, \n+                     \"Bug reproduction: 'kind' should not be deferred but is marked as deferred\")\n+        \n+        # This should NOT trigger additional queries since 'kind' was prefetched\n+        # But due to the bug, it will trigger 1 additional query\n+        with self.assertNumQueries(1):  # This demonstrates the bug - should be 0\n+            kind_value = user.profile.user.kind\n+            \n+        self.assertEqual(kind_value, \"ADMIN\")\n+\n+    def test_onetoone_prefetch_deferred_fields_expected_behavior(self):\n+        \"\"\"\n+        Test the expected behavior after the fix is applied.\n+        \n+        This test should PASS after the fix, showing that deferred fields\n+        are correctly handled when following prefetches back to parent objects.\n+        \"\"\"\n+        queryset = User.objects.only(\"email\").prefetch_related(\n+            Prefetch(\n+                \"profile\",\n+                queryset=Profile.objects.prefetch_related(\n+                    Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+                ),\n+            )\n+        )\n+        \n+        # Execute the main queryset - should be 3 queries\n+        with self.assertNumQueries(3):\n+            user = queryset.first()\n+        \n+        # After the fix, accessing the prefetched field should not trigger additional queries\n+        with self.assertNumQueries(0):\n+            kind_value = user.profile.user.kind\n+            \n+        self.assertEqual(kind_value, \"ADMIN\")\n+        \n+        # Verify that the correct fields are marked as deferred\n+        # The inner user should only have 'kind' loaded, so 'email' should be deferred\n+        inner_user_deferred = user.profile.user.get_deferred_fields()\n+        self.assertNotIn('kind', inner_user_deferred, \n+                        \"'kind' should not be deferred as it was explicitly selected\")\n+        self.assertIn('email', inner_user_deferred,\n+                     \"'email' should be deferred as it was not selected in inner queryset\")\n+\n+    def test_foreignkey_prefetch_deferred_fields_bug_reproduction(self):\n+        \"\"\"\n+        Test that reproduces the bug with ForeignKey relationships.\n+        \n+        Similar to the OneToOne case, but using ForeignKey to show the bug\n+        also affects this type of relationship.\n+        \"\"\"\n+        queryset = Company.objects.only(\"name\").prefetch_related(\n+            Prefetch(\n+                \"employees\",\n+                queryset=Employee.objects.prefetch_related(\n+                    Prefetch(\"company\", queryset=Company.objects.only(\"name\"))\n+                ),\n+            )\n+        )\n+        \n+        # Execute the main queryset\n+        with self.assertNumQueries(3):\n+            company = queryset.first()\n+        \n+        # Access the prefetched field - this should not trigger additional queries\n+        # but due to the bug, it will\n+        with self.assertNumQueries(1):  # This demonstrates the bug - should be 0\n+            employee = company.employees.all()[0]\n+            company_name = employee.company.name\n+            \n+        self.assertEqual(company_name, \"Test Company\")\n+\n+    def test_foreignkey_prefetch_deferred_fields_expected_behavior(self):\n+        \"\"\"\n+        Test the expected behavior for ForeignKey after the fix.\n+        \"\"\"\n+        queryset = Company.objects.only(\"name\").prefetch_related(\n+            Prefetch(\n+                \"employees\",\n+                queryset=Employee.objects.prefetch_related(\n+                    Prefetch(\"company\", queryset=Company.objects.only(\"name\"))\n+                ),\n+            )\n+        )\n+        \n+        # Execute the main queryset\n+        with self.assertNumQueries(3):\n+            company = queryset.first()\n+        \n+        # After the fix, this should not trigger additional queries\n+        with self.assertNumQueries(0):\n+            employee = company.employees.all()[0]\n+            company_name = employee.company.name\n+            \n+        self.assertEqual(company_name, \"Test Company\")\n+\n+    def test_multiple_nested_prefetch_levels(self):\n+        \"\"\"\n+        Test more complex nested prefetch scenarios to ensure the fix works\n+        for deeper nesting levels.\n+        \"\"\"\n+        # Create additional test data for deeper nesting\n+        user2 = User.objects.create(email=\"user2@example.com\", kind=\"REGULAR\")\n+        profile2 = Profile.objects.create(user=user2, full_name=\"User Two\")\n+        \n+        queryset = User.objects.only(\"email\").prefetch_related(\n+            Prefetch(\n+                \"profile\",\n+                queryset=Profile.objects.only(\"full_name\").prefetch_related(\n+                    Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+                ),\n+            )\n+        )\n+        \n+        # Execute the main queryset\n+        with self.assertNumQueries(3):\n+            users = list(queryset.all())\n+        \n+        # After the fix, accessing nested prefetched fields should not trigger queries\n+        with self.assertNumQueries(0):\n+            for user in users:\n+                profile_name = user.profile.full_name\n+                user_kind = user.profile.user.kind\n+                \n+                # Verify we can access the data\n+                self.assertIsNotNone(profile_name)\n+                self.assertIn(user_kind, [\"ADMIN\", \"REGULAR\"])\n+\n+    def test_deferred_fields_state_preservation(self):\n+        \"\"\"\n+        Test that the deferred fields state is correctly preserved for each\n+        instance based on its originating queryset.\n+        \"\"\"\n+        queryset = User.objects.only(\"email\").prefetch_related(\n+            Prefetch(\n+                \"profile\",\n+                queryset=Profile.objects.prefetch_related(\n+                    Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+                ),\n+            )\n+        )\n+        \n+        with self.assertNumQueries(3):\n+            user = queryset.first()\n+        \n+        # The outer user should have 'kind' deferred but 'email' loaded\n+        outer_user_deferred = user.get_deferred_fields()\n+        self.assertNotIn('email', outer_user_deferred, \n+                        \"Outer user should have 'email' loaded\")\n+        self.assertIn('kind', outer_user_deferred,\n+                     \"Outer user should have 'kind' deferred\")\n+        \n+        # The inner user (accessed via profile.user) should have 'email' deferred but 'kind' loaded\n+        inner_user_deferred = user.profile.user.get_deferred_fields()\n+        self.assertNotIn('kind', inner_user_deferred,\n+                        \"Inner user should have 'kind' loaded\")\n+        self.assertIn('email', inner_user_deferred,\n+                     \"Inner user should have 'email' deferred\")\n+\n+    def test_edge_case_empty_only_queryset(self):\n+        \"\"\"\n+        Test edge case where the inner queryset uses only() with no fields.\n+        \"\"\"\n+        queryset = User.objects.only(\"email\").prefetch_related(\n+            Prefetch(\n+                \"profile\",\n+                queryset=Profile.objects.prefetch_related(\n+                    Prefetch(\"user\", queryset=User.objects.only())\n+                ),\n+            )\n+        )\n+        \n+        with self.assertNumQueries(3):\n+            user = queryset.first()\n+        \n+        # When only() is called with no arguments, only the primary key should be loaded\n+        inner_user_deferred = user.profile.user.get_deferred_fields()\n+        self.assertIn('email', inner_user_deferred)\n+        self.assertIn('kind', inner_user_deferred)\n+\n+    def test_multiple_fields_in_only(self):\n+        \"\"\"\n+        Test that the fix works when multiple fields are specified in only().\n+        \"\"\"\n+        queryset = User.objects.only(\"id\").prefetch_related(\n+            Prefetch(\n+                \"profile\",\n+                queryset=Profile.objects.prefetch_related(\n+                    Prefetch(\"user\", queryset=User.objects.only(\"email\", \"kind\"))\n+                ),\n+            )\n+        )\n+        \n+        with self.assertNumQueries(3):\n+            user = queryset.first()\n+        \n+        # After the fix, accessing both prefetched fields should not trigger queries\n+        with self.assertNumQueries(0):\n+            email = user.profile.user.email\n+            kind = user.profile.user.kind\n+            \n+        self.assertEqual(email, \"test@example.com\")\n+        self.assertEqual(kind, \"ADMIN\")\n+        \n+        # Verify deferred fields state\n+        inner_user_deferred = user.profile.user.get_deferred_fields()\n+        self.assertNotIn('email', inner_user_deferred)\n+        self.assertNotIn('kind', inner_user_deferred)\n"
}