{
  "instance_id": "django__django-14155",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/urls_tests/test_resolvers.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport functools\nimport pytest\nfrom django.urls.resolvers import ResolverMatch\n\n\ndef dummy_view(request, arg1, arg2=None):\n    \"\"\"A dummy view function for testing.\"\"\"\n    return \"dummy response\"\n\n\ndef another_view(request, x, y, z=10):\n    \"\"\"Another dummy view function for testing.\"\"\"\n    return \"another response\"\n\n\nclass DummyClass:\n    \"\"\"A dummy class-based view for testing.\"\"\"\n    def __call__(self, request):\n        return \"class response\"\n\n\nclass TestResolverMatchPartialHandling:\n    \"\"\"Test ResolverMatch handling of functools.partial objects.\"\"\"\n\n    def test_resolver_match_with_regular_function(self):\n        \"\"\"Test that regular functions work as before.\"\"\"\n        match = ResolverMatch(dummy_view, (), {})\n        \n        # Should show the actual function path\n        assert \"dummy_view\" in match._func_path\n        assert \"test_resolvers\" in match._func_path\n        \n        # __repr__ should show the function path\n        repr_str = repr(match)\n        assert \"dummy_view\" in repr_str\n        assert \"test_resolvers\" in repr_str\n\n    def test_resolver_match_with_class_based_view(self):\n        \"\"\"Test that class-based views work as before.\"\"\"\n        view_instance = DummyClass()\n        match = ResolverMatch(view_instance, (), {})\n        \n        # Should show the class path\n        assert \"DummyClass\" in match._func_path\n        assert \"test_resolvers\" in match._func_path\n        \n        # __repr__ should show the class path\n        repr_str = repr(match)\n        assert \"DummyClass\" in repr_str\n\n    def test_resolver_match_with_partial_function_no_args(self):\n        \"\"\"Test ResolverMatch with functools.partial without pre-filled args.\"\"\"\n        partial_view = functools.partial(dummy_view)\n        match = ResolverMatch(partial_view, (), {})\n        \n        # Before fix: this would show functools.partial\n        # After fix: should show the underlying function\n        assert \"dummy_view\" in match._func_path\n        assert \"test_resolvers\" in match._func_path\n        assert \"functools.partial\" not in match._func_path\n        \n        # __repr__ should show the underlying function, not functools.partial\n        repr_str = repr(match)\n        assert \"dummy_view\" in repr_str\n        assert \"functools.partial\" not in repr_str\n\n    def test_resolver_match_with_partial_function_with_args(self):\n        \"\"\"Test ResolverMatch with functools.partial with pre-filled args.\"\"\"\n        partial_view = functools.partial(another_view, \"fixed_arg\")\n        match = ResolverMatch(partial_view, (), {})\n        \n        # Should show the underlying function, not functools.partial\n        assert \"another_view\" in match._func_path\n        assert \"test_resolvers\" in match._func_path\n        assert \"functools.partial\" not in match._func_path\n        \n        # __repr__ should show the underlying function\n        repr_str = repr(match)\n        assert \"another_view\" in repr_str\n        assert \"functools.partial\" not in repr_str\n\n    def test_resolver_match_with_partial_function_with_kwargs(self):\n        \"\"\"Test ResolverMatch with functools.partial with pre-filled kwargs.\"\"\"\n        partial_view = functools.partial(another_view, z=99)\n        match = ResolverMatch(partial_view, (), {})\n        \n        # Should show the underlying function, not functools.partial\n        assert \"another_view\" in match._func_path\n        assert \"test_resolvers\" in match._func_path\n        assert \"functools.partial\" not in match._func_path\n        \n        # __repr__ should show the underlying function\n        repr_str = repr(match)\n        assert \"another_view\" in repr_str\n        assert \"functools.partial\" not in repr_str\n\n    def test_resolver_match_with_partial_function_mixed_args(self):\n        \"\"\"Test ResolverMatch with functools.partial with both args and kwargs.\"\"\"\n        partial_view = functools.partial(another_view, \"fixed_arg\", z=99)\n        match = ResolverMatch(partial_view, (), {})\n        \n        # Should show the underlying function, not functools.partial\n        assert \"another_view\" in match._func_path\n        assert \"test_resolvers\" in match._func_path\n        assert \"functools.partial\" not in match._func_path\n        \n        # __repr__ should show the underlying function\n        repr_str = repr(match)\n        assert \"another_view\" in repr_str\n        assert \"functools.partial\" not in repr_str\n\n    def test_resolver_match_partial_preserves_original_func_reference(self):\n        \"\"\"Test that the original func is preserved when using partial.\"\"\"\n        partial_view = functools.partial(dummy_view, \"arg\")\n        match = ResolverMatch(partial_view, (), {})\n        \n        # The func attribute should still be the partial for backward compatibility\n        assert match.func is partial_view\n        assert isinstance(match.func, functools.partial)\n\n    def test_resolver_match_nested_partial(self):\n        \"\"\"Test ResolverMatch with nested functools.partial objects.\"\"\"\n        # Create a partial of a partial\n        first_partial = functools.partial(another_view, \"first_arg\")\n        nested_partial = functools.partial(first_partial, y=\"second_arg\")\n        match = ResolverMatch(nested_partial, (), {})\n        \n        # Should unwrap to the original function\n        assert \"another_view\" in match._func_path\n        assert \"test_resolvers\" in match._func_path\n        assert \"functools.partial\" not in match._func_path\n        \n        # __repr__ should show the underlying function\n        repr_str = repr(match)\n        assert \"another_view\" in repr_str\n        assert \"functools.partial\" not in repr_str\n\n    def test_resolver_match_partial_with_lambda(self):\n        \"\"\"Test ResolverMatch with functools.partial wrapping a lambda.\"\"\"\n        lambda_func = lambda request: \"lambda response\"\n        partial_view = functools.partial(lambda_func)\n        match = ResolverMatch(partial_view, (), {})\n        \n        # Lambda functions have __name__ as '<lambda>'\n        assert \"<lambda>\" in match._func_path\n        assert \"functools.partial\" not in match._func_path\n        \n        # __repr__ should show the lambda, not functools.partial\n        repr_str = repr(match)\n        assert \"<lambda>\" in repr_str\n        assert \"functools.partial\" not in repr_str\n\n    def test_resolver_match_partial_without_name_attribute(self):\n        \"\"\"Test ResolverMatch with partial of object without __name__.\"\"\"\n        class CallableClass:\n            def __call__(self, request):\n                return \"callable response\"\n        \n        callable_obj = CallableClass()\n        partial_view = functools.partial(callable_obj)\n        match = ResolverMatch(partial_view, (), {})\n        \n        # Should show the class name of the underlying callable\n        assert \"CallableClass\" in match._func_path\n        assert \"test_resolvers\" in match._func_path\n        assert \"functools.partial\" not in match._func_path\n        \n        # __repr__ should show the class, not functools.partial\n        repr_str = repr(match)\n        assert \"CallableClass\" in repr_str\n        assert \"functools.partial\" not in repr_str\n\n    def test_resolver_match_repr_bug_demonstration(self):\n        \"\"\"\n        This test demonstrates the bug before the fix is applied.\n        It should fail before the fix and pass after the fix.\n        \"\"\"\n        partial_view = functools.partial(dummy_view, \"test_arg\")\n        match = ResolverMatch(partial_view, (), {})\n        \n        # This is the main bug: __repr__ should not show functools.partial\n        repr_str = repr(match)\n        \n        # The bug: this assertion should fail before the fix\n        # because repr_str would contain \"functools.partial\" instead of \"dummy_view\"\n        assert \"functools.partial\" not in repr_str, (\n            f\"ResolverMatch.__repr__() shows 'functools.partial' instead of \"\n            f\"the underlying function. Got: {repr_str}\"\n        )\n        \n        # After the fix, it should show the actual function\n        assert \"dummy_view\" in repr_str, (\n            f\"ResolverMatch.__repr__() should show the underlying function name. \"\n            f\"Got: {repr_str}\"\n        )\n\n    def test_resolver_match_all_attributes_preserved(self):\n        \"\"\"Test that all ResolverMatch attributes work correctly with partial.\"\"\"\n        partial_view = functools.partial(dummy_view, \"test_arg\")\n        args = (\"url_arg\",)\n        kwargs = {\"url_kwarg\": \"value\"}\n        url_name = \"test_url\"\n        app_names = [\"test_app\"]\n        namespaces = [\"test_ns\"]\n        route = \"test/route/\"\n        \n        match = ResolverMatch(\n            partial_view, args, kwargs, url_name=url_name,\n            app_names=app_names, namespaces=namespaces, route=route\n        )\n        \n        # All attributes should be preserved\n        assert match.func is partial_view\n        assert match.args == args\n        assert match.kwargs == kwargs\n        assert match.url_name == url_name\n        assert match.app_names == app_names\n        assert match.namespaces == namespaces\n        assert match.route == route\n        \n        # The view_name should be constructed correctly\n        assert \"dummy_view\" in match.view_name\n        \n        # __getitem__ should still work\n        assert match[0] is partial_view\n        assert match[1] == args\n        assert match[2] == kwargs\n</patched>\n</file>\n```",
  "patch": "--- a/tests/urls_tests/test_resolvers.py\n+++ b/tests/urls_tests/test_resolvers.py\n-# Empty if creating new file\n+import functools\n+import pytest\n+from django.urls.resolvers import ResolverMatch\n+\n+\n+def dummy_view(request, arg1, arg2=None):\n+    \"\"\"A dummy view function for testing.\"\"\"\n+    return \"dummy response\"\n+\n+\n+def another_view(request, x, y, z=10):\n+    \"\"\"Another dummy view function for testing.\"\"\"\n+    return \"another response\"\n+\n+\n+class DummyClass:\n+    \"\"\"A dummy class-based view for testing.\"\"\"\n+    def __call__(self, request):\n+        return \"class response\"\n+\n+\n+class TestResolverMatchPartialHandling:\n+    \"\"\"Test ResolverMatch handling of functools.partial objects.\"\"\"\n+\n+    def test_resolver_match_with_regular_function(self):\n+        \"\"\"Test that regular functions work as before.\"\"\"\n+        match = ResolverMatch(dummy_view, (), {})\n+        \n+        # Should show the actual function path\n+        assert \"dummy_view\" in match._func_path\n+        assert \"test_resolvers\" in match._func_path\n+        \n+        # __repr__ should show the function path\n+        repr_str = repr(match)\n+        assert \"dummy_view\" in repr_str\n+        assert \"test_resolvers\" in repr_str\n+\n+    def test_resolver_match_with_class_based_view(self):\n+        \"\"\"Test that class-based views work as before.\"\"\"\n+        view_instance = DummyClass()\n+        match = ResolverMatch(view_instance, (), {})\n+        \n+        # Should show the class path\n+        assert \"DummyClass\" in match._func_path\n+        assert \"test_resolvers\" in match._func_path\n+        \n+        # __repr__ should show the class path\n+        repr_str = repr(match)\n+        assert \"DummyClass\" in repr_str\n+\n+    def test_resolver_match_with_partial_function_no_args(self):\n+        \"\"\"Test ResolverMatch with functools.partial without pre-filled args.\"\"\"\n+        partial_view = functools.partial(dummy_view)\n+        match = ResolverMatch(partial_view, (), {})\n+        \n+        # Before fix: this would show functools.partial\n+        # After fix: should show the underlying function\n+        assert \"dummy_view\" in match._func_path\n+        assert \"test_resolvers\" in match._func_path\n+        assert \"functools.partial\" not in match._func_path\n+        \n+        # __repr__ should show the underlying function, not functools.partial\n+        repr_str = repr(match)\n+        assert \"dummy_view\" in repr_str\n+        assert \"functools.partial\" not in repr_str\n+\n+    def test_resolver_match_with_partial_function_with_args(self):\n+        \"\"\"Test ResolverMatch with functools.partial with pre-filled args.\"\"\"\n+        partial_view = functools.partial(another_view, \"fixed_arg\")\n+        match = ResolverMatch(partial_view, (), {})\n+        \n+        # Should show the underlying function, not functools.partial\n+        assert \"another_view\" in match._func_path\n+        assert \"test_resolvers\" in match._func_path\n+        assert \"functools.partial\" not in match._func_path\n+        \n+        # __repr__ should show the underlying function\n+        repr_str = repr(match)\n+        assert \"another_view\" in repr_str\n+        assert \"functools.partial\" not in repr_str\n+\n+    def test_resolver_match_with_partial_function_with_kwargs(self):\n+        \"\"\"Test ResolverMatch with functools.partial with pre-filled kwargs.\"\"\"\n+        partial_view = functools.partial(another_view, z=99)\n+        match = ResolverMatch(partial_view, (), {})\n+        \n+        # Should show the underlying function, not functools.partial\n+        assert \"another_view\" in match._func_path\n+        assert \"test_resolvers\" in match._func_path\n+        assert \"functools.partial\" not in match._func_path\n+        \n+        # __repr__ should show the underlying function\n+        repr_str = repr(match)\n+        assert \"another_view\" in repr_str\n+        assert \"functools.partial\" not in repr_str\n+\n+    def test_resolver_match_with_partial_function_mixed_args(self):\n+        \"\"\"Test ResolverMatch with functools.partial with both args and kwargs.\"\"\"\n+        partial_view = functools.partial(another_view, \"fixed_arg\", z=99)\n+        match = ResolverMatch(partial_view, (), {})\n+        \n+        # Should show the underlying function, not functools.partial\n+        assert \"another_view\" in match._func_path\n+        assert \"test_resolvers\" in match._func_path\n+        assert \"functools.partial\" not in match._func_path\n+        \n+        # __repr__ should show the underlying function\n+        repr_str = repr(match)\n+        assert \"another_view\" in repr_str\n+        assert \"functools.partial\" not in repr_str\n+\n+    def test_resolver_match_partial_preserves_original_func_reference(self):\n+        \"\"\"Test that the original func is preserved when using partial.\"\"\"\n+        partial_view = functools.partial(dummy_view, \"arg\")\n+        match = ResolverMatch(partial_view, (), {})\n+        \n+        # The func attribute should still be the partial for backward compatibility\n+        assert match.func is partial_view\n+        assert isinstance(match.func, functools.partial)\n+\n+    def test_resolver_match_nested_partial(self):\n+        \"\"\"Test ResolverMatch with nested functools.partial objects.\"\"\"\n+        # Create a partial of a partial\n+        first_partial = functools.partial(another_view, \"first_arg\")\n+        nested_partial = functools.partial(first_partial, y=\"second_arg\")\n+        match = ResolverMatch(nested_partial, (), {})\n+        \n+        # Should unwrap to the original function\n+        assert \"another_view\" in match._func_path\n+        assert \"test_resolvers\" in match._func_path\n+        assert \"functools.partial\" not in match._func_path\n+        \n+        # __repr__ should show the underlying function\n+        repr_str = repr(match)\n+        assert \"another_view\" in repr_str\n+        assert \"functools.partial\" not in repr_str\n+\n+    def test_resolver_match_partial_with_lambda(self):\n+        \"\"\"Test ResolverMatch with functools.partial wrapping a lambda.\"\"\"\n+        lambda_func = lambda request: \"lambda response\"\n+        partial_view = functools.partial(lambda_func)\n+        match = ResolverMatch(partial_view, (), {})\n+        \n+        # Lambda functions have __name__ as '<lambda>'\n+        assert \"<lambda>\" in match._func_path\n+        assert \"functools.partial\" not in match._func_path\n+        \n+        # __repr__ should show the lambda, not functools.partial\n+        repr_str = repr(match)\n+        assert \"<lambda>\" in repr_str\n+        assert \"functools.partial\" not in repr_str\n+\n+    def test_resolver_match_partial_without_name_attribute(self):\n+        \"\"\"Test ResolverMatch with partial of object without __name__.\"\"\"\n+        class CallableClass:\n+            def __call__(self, request):\n+                return \"callable response\"\n+        \n+        callable_obj = CallableClass()\n+        partial_view = functools.partial(callable_obj)\n+        match = ResolverMatch(partial_view, (), {})\n+        \n+        # Should show the class name of the underlying callable\n+        assert \"CallableClass\" in match._func_path\n+        assert \"test_resolvers\" in match._func_path\n+        assert \"functools.partial\" not in match._func_path\n+        \n+        # __repr__ should show the class, not functools.partial\n+        repr_str = repr(match)\n+        assert \"CallableClass\" in repr_str\n+        assert \"functools.partial\" not in repr_str\n+\n+    def test_resolver_match_repr_bug_demonstration(self):\n+        \"\"\"\n+        This test demonstrates the bug before the fix is applied.\n+        It should fail before the fix and pass after the fix.\n+        \"\"\"\n+        partial_view = functools.partial(dummy_view, \"test_arg\")\n+        match = ResolverMatch(partial_view, (), {})\n+        \n+        # This is the main bug: __repr__ should not show functools.partial\n+        repr_str = repr(match)\n+        \n+        # The bug: this assertion should fail before the fix\n+        # because repr_str would contain \"functools.partial\" instead of \"dummy_view\"\n+        assert \"functools.partial\" not in repr_str, (\n+            f\"ResolverMatch.__repr__() shows 'functools.partial' instead of \"\n+            f\"the underlying function. Got: {repr_str}\"\n+        )\n+        \n+        # After the fix, it should show the actual function\n+        assert \"dummy_view\" in repr_str, (\n+            f\"ResolverMatch.__repr__() should show the underlying function name. \"\n+            f\"Got: {repr_str}\"\n+        )\n+\n+    def test_resolver_match_all_attributes_preserved(self):\n+        \"\"\"Test that all ResolverMatch attributes work correctly with partial.\"\"\"\n+        partial_view = functools.partial(dummy_view, \"test_arg\")\n+        args = (\"url_arg\",)\n+        kwargs = {\"url_kwarg\": \"value\"}\n+        url_name = \"test_url\"\n+        app_names = [\"test_app\"]\n+        namespaces = [\"test_ns\"]\n+        route = \"test/route/\"\n+        \n+        match = ResolverMatch(\n+            partial_view, args, kwargs, url_name=url_name,\n+            app_names=app_names, namespaces=namespaces, route=route\n+        )\n+        \n+        # All attributes should be preserved\n+        assert match.func is partial_view\n+        assert match.args == args\n+        assert match.kwargs == kwargs\n+        assert match.url_name == url_name\n+        assert match.app_names == app_names\n+        assert match.namespaces == namespaces\n+        assert match.route == route\n+        \n+        # The view_name should be constructed correctly\n+        assert \"dummy_view\" in match.view_name\n+        \n+        # __getitem__ should still work\n+        assert match[0] is partial_view\n+        assert match[1] == args\n+        assert match[2] == kwargs\n"
}