{
  "instance_id": "mwaskom__seaborn-3069",
  "model": "openrouter/anthropic/claude-sonnet-4",
  "response": "```\n<file>tests/test_core/test_nominal_scale_categorical_behavior.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.testing.decorators import check_figures_equal\n\nimport seaborn as sns\nimport seaborn.objects as so\nfrom seaborn._core.scales import Nominal\nfrom seaborn._core.plot import Plot, Plotter\n\n\nclass TestNominalScaleCategoricalBehavior:\n    \"\"\"Test that Nominal scales behave like categorical scales.\"\"\"\n\n    @pytest.fixture\n    def categorical_data(self):\n        \"\"\"Sample categorical data for testing.\"\"\"\n        return pd.DataFrame({\n            'category': ['A', 'B', 'C', 'D'],\n            'value': [1, 2, 3, 4],\n            'numeric_cat': [1, 2, 3, 4]  # Will be treated as categorical\n        })\n\n    def test_nominal_scale_has_categorical_attribute(self):\n        \"\"\"Test that Nominal scale can be identified as categorical.\"\"\"\n        nominal_scale = Nominal()\n        # This test will fail before the fix is applied\n        # After fix, Nominal should have _categorical = True or similar identifier\n        assert hasattr(nominal_scale, '_categorical') or hasattr(nominal_scale, 'is_categorical')\n\n    def test_nominal_scale_axis_limits_plus_minus_half(self, categorical_data):\n        \"\"\"Test that Nominal scales set axis limits to +/- 0.5 from first/last tick.\"\"\"\n        # Create a plot with explicit Nominal scale\n        p = Plot(categorical_data, x='category', y='value').add(so.Dot()).scale(x=so.Nominal())\n        \n        # This test demonstrates the bug - before fix, limits may not be set correctly\n        plotter = Plotter(pyplot=False, theme={})\n        plotter._extract_data(p)\n        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._finalize_figure(p)\n        \n        # Check that x-axis limits are set to -0.5 and n_categories - 0.5\n        ax = plotter._subplots[0]['ax']\n        xlim = ax.get_xlim()\n        \n        # Should be approximately (-0.5, 3.5) for 4 categories (0, 1, 2, 3)\n        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n        assert xlim[1] == pytest.approx(3.5, abs=0.1)\n\n    def test_nominal_scale_no_grid_display(self, categorical_data):\n        \"\"\"Test that Nominal scales suppress grid display.\"\"\"\n        # Create a plot with explicit Nominal scale and a style that normally shows grid\n        with sns.axes_style(\"whitegrid\"):  # This style normally shows grid\n            p = Plot(categorical_data, x='category', y='value').add(so.Dot()).scale(x=so.Nominal())\n            \n            plotter = Plotter(pyplot=False, theme={})\n            plotter._extract_data(p)\n            plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n            plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n            plotter._finalize_figure(p)\n            \n            ax = plotter._subplots[0]['ax']\n            \n            # This test will fail before the fix - grid should be disabled for categorical axis\n            # Check that grid is disabled on x-axis (categorical)\n            assert not ax.xaxis.grid\n            # y-axis should still have grid (it's continuous)\n            # Note: This assertion might need adjustment based on actual implementation\n\n    def test_nominal_scale_y_axis_inversion(self, categorical_data):\n        \"\"\"Test that Nominal scales on y-axis are inverted.\"\"\"\n        # Create a plot with Nominal scale on y-axis\n        p = Plot(categorical_data, x='value', y='category').add(so.Dot()).scale(y=so.Nominal())\n        \n        plotter = Plotter(pyplot=False, theme={})\n        plotter._extract_data(p)\n        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._finalize_figure(p)\n        \n        ax = plotter._subplots[0]['ax']\n        \n        # This test will fail before the fix - y-axis should be inverted for categorical\n        ylim = ax.get_ylim()\n        # For inverted axis, ylim[0] should be greater than ylim[1]\n        assert ylim[0] > ylim[1], \"Y-axis should be inverted for Nominal scale\"\n\n    def test_inferred_nominal_scale_behavior(self, categorical_data):\n        \"\"\"Test that inferred Nominal scales also get categorical behavior.\"\"\"\n        # Create a plot without explicit scale - should infer Nominal for string data\n        p = Plot(categorical_data, x='category', y='value').add(so.Dot())\n        \n        plotter = Plotter(pyplot=False, theme={})\n        plotter._extract_data(p)\n        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._finalize_figure(p)\n        \n        ax = plotter._subplots[0]['ax']\n        xlim = ax.get_xlim()\n        \n        # Should still get categorical behavior even with inferred scale\n        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n        assert xlim[1] == pytest.approx(3.5, abs=0.1)\n\n    def test_continuous_scale_unaffected(self, categorical_data):\n        \"\"\"Test that continuous scales are not affected by categorical behavior.\"\"\"\n        # Create a plot with continuous scale\n        p = Plot(categorical_data, x='value', y='value').add(so.Dot())\n        \n        plotter = Plotter(pyplot=False, theme={})\n        plotter._extract_data(p)\n        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._finalize_figure(p)\n        \n        ax = plotter._subplots[0]['ax']\n        xlim = ax.get_xlim()\n        ylim = ax.get_ylim()\n        \n        # Continuous scales should not have the +/- 0.5 behavior\n        # Limits should be based on data range with normal matplotlib margins\n        assert xlim[0] < 1  # Should have some margin below minimum value (1)\n        assert xlim[1] > 4  # Should have some margin above maximum value (4)\n        assert ylim[0] < 1\n        assert ylim[1] > 4\n        \n        # Y-axis should not be inverted for continuous scale\n        assert ylim[0] < ylim[1], \"Y-axis should not be inverted for continuous scale\"\n\n    def test_mixed_scales_behavior(self, categorical_data):\n        \"\"\"Test behavior when one axis is Nominal and other is continuous.\"\"\"\n        # x-axis: Nominal, y-axis: continuous\n        p = Plot(categorical_data, x='category', y='value').add(so.Dot()).scale(x=so.Nominal())\n        \n        plotter = Plotter(pyplot=False, theme={})\n        plotter._extract_data(p)\n        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._finalize_figure(p)\n        \n        ax = plotter._subplots[0]['ax']\n        xlim = ax.get_xlim()\n        ylim = ax.get_ylim()\n        \n        # X-axis (Nominal) should have categorical behavior\n        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n        assert xlim[1] == pytest.approx(3.5, abs=0.1)\n        \n        # Y-axis (continuous) should have normal behavior\n        assert ylim[0] < 1\n        assert ylim[1] > 4\n        assert ylim[0] < ylim[1]  # Should not be inverted\n\n    def test_nominal_scale_with_numeric_categories(self, categorical_data):\n        \"\"\"Test that Nominal scale works with numeric categories.\"\"\"\n        # Force numeric data to be treated as categorical\n        p = Plot(categorical_data, x='numeric_cat', y='value').add(so.Dot()).scale(x=so.Nominal())\n        \n        plotter = Plotter(pyplot=False, theme={})\n        plotter._extract_data(p)\n        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._finalize_figure(p)\n        \n        ax = plotter._subplots[0]['ax']\n        xlim = ax.get_xlim()\n        \n        # Should still get categorical behavior for numeric data with Nominal scale\n        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n        assert xlim[1] == pytest.approx(3.5, abs=0.1)\n\n    @pytest.mark.parametrize(\"axis\", [\"x\", \"y\"])\n    def test_nominal_scale_both_axes(self, categorical_data, axis):\n        \"\"\"Test Nominal scale behavior on both x and y axes.\"\"\"\n        if axis == \"x\":\n            p = Plot(categorical_data, x='category', y='value').add(so.Dot()).scale(x=so.Nominal())\n        else:\n            p = Plot(categorical_data, x='value', y='category').add(so.Dot()).scale(y=so.Nominal())\n        \n        plotter = Plotter(pyplot=False, theme={})\n        plotter._extract_data(p)\n        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._finalize_figure(p)\n        \n        ax = plotter._subplots[0]['ax']\n        \n        if axis == \"x\":\n            xlim = ax.get_xlim()\n            assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n            assert xlim[1] == pytest.approx(3.5, abs=0.1)\n        else:\n            ylim = ax.get_ylim()\n            assert ylim[0] == pytest.approx(3.5, abs=0.1)  # Inverted\n            assert ylim[1] == pytest.approx(-0.5, abs=0.1)  # Inverted\n\n    def test_nominal_scale_preserves_existing_string_behavior(self):\n        \"\"\"Test that existing string-based categorical behavior is preserved.\"\"\"\n        # This test ensures we don't break existing functionality\n        data = pd.DataFrame({\n            'str_cat': ['A', 'B', 'C'],\n            'value': [1, 2, 3]\n        })\n        \n        # Test without explicit Nominal scale (should infer categorical behavior)\n        p = Plot(data, x='str_cat', y='value').add(so.Dot())\n        \n        plotter = Plotter(pyplot=False, theme={})\n        plotter._extract_data(p)\n        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n        plotter._finalize_figure(p)\n        \n        ax = plotter._subplots[0]['ax']\n        xlim = ax.get_xlim()\n        \n        # Should still work as before for string data\n        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n        assert xlim[1] == pytest.approx(2.5, abs=0.1)  # 3 categories: 0, 1, 2\n</patched>\n```\n\n```\n<file>tests/test_core/test_scales_nominal.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nimport numpy as np\nimport pandas as pd\n\nimport seaborn.objects as so\nfrom seaborn._core.scales import Nominal, Scale\nfrom seaborn._core.properties import Coordinate\n\n\nclass TestNominalScaleIdentification:\n    \"\"\"Test that Nominal scale can be properly identified as categorical.\"\"\"\n\n    def test_nominal_scale_is_categorical_attribute(self):\n        \"\"\"Test that Nominal scale has categorical identification attribute.\"\"\"\n        nominal = Nominal()\n        \n        # This test will fail before the fix is applied\n        # The fix should add a _categorical attribute or similar\n        assert hasattr(nominal, '_categorical'), \"Nominal scale should have _categorical attribute\"\n        assert getattr(nominal, '_categorical') is True, \"Nominal scale should be marked as categorical\"\n\n    def test_nominal_scale_inheritance(self):\n        \"\"\"Test that Nominal scale properly inherits from Scale.\"\"\"\n        nominal = Nominal()\n        assert isinstance(nominal, Scale), \"Nominal should inherit from Scale\"\n\n    def test_nominal_scale_setup_preserves_functionality(self):\n        \"\"\"Test that adding categorical identification doesn't break existing setup.\"\"\"\n        data = pd.Series(['A', 'B', 'C', 'A', 'B'])\n        prop = Coordinate()\n        \n        nominal = Nominal()\n        setup_scale = nominal._setup(data, prop)\n        \n        # Verify that setup still works correctly\n        assert setup_scale is not None\n        assert hasattr(setup_scale, '_pipeline')\n        assert hasattr(setup_scale, '_matplotlib_scale')\n        \n        # Verify categorical identification is preserved after setup\n        if hasattr(nominal, '_categorical'):\n            assert hasattr(setup_scale, '_categorical')\n            assert getattr(setup_scale, '_categorical') is True\n\n    def test_other_scales_not_categorical(self):\n        \"\"\"Test that other scale types are not marked as categorical.\"\"\"\n        from seaborn._core.scales import Continuous\n        \n        continuous = Continuous()\n        \n        # Continuous scales should not be marked as categorical\n        if hasattr(continuous, '_categorical'):\n            assert getattr(continuous, '_categorical') is False\n        # Or they might not have the attribute at all, which is also fine\n\n    def test_nominal_scale_categorical_identification_method(self):\n        \"\"\"Test alternative implementation using a method for categorical identification.\"\"\"\n        nominal = Nominal()\n        \n        # Alternative implementation might use a method instead of attribute\n        if hasattr(nominal, 'is_categorical'):\n            assert callable(getattr(nominal, 'is_categorical'))\n            assert nominal.is_categorical() is True\n        elif hasattr(nominal, '_categorical'):\n            # Attribute-based implementation\n            assert getattr(nominal, '_categorical') is True\n        else:\n            pytest.fail(\"Nominal scale should have either _categorical attribute or is_categorical() method\")\n</patched>\n```\n\n```\n<file>tests/test_core/test_plot_finalize_figure.py</file>\n<original>\n# Empty if creating new file\n</original>\n",
  "patch": "--- a/tests/test_core/test_nominal_scale_categorical_behavior.py\n+++ b/tests/test_core/test_nominal_scale_categorical_behavior.py\n-# Empty if creating new file\n+import pytest\n+import numpy as np\n+import pandas as pd\n+import matplotlib.pyplot as plt\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+import seaborn as sns\n+import seaborn.objects as so\n+from seaborn._core.scales import Nominal\n+from seaborn._core.plot import Plot, Plotter\n+\n+\n+class TestNominalScaleCategoricalBehavior:\n+    \"\"\"Test that Nominal scales behave like categorical scales.\"\"\"\n+\n+    @pytest.fixture\n+    def categorical_data(self):\n+        \"\"\"Sample categorical data for testing.\"\"\"\n+        return pd.DataFrame({\n+            'category': ['A', 'B', 'C', 'D'],\n+            'value': [1, 2, 3, 4],\n+            'numeric_cat': [1, 2, 3, 4]  # Will be treated as categorical\n+        })\n+\n+    def test_nominal_scale_has_categorical_attribute(self):\n+        \"\"\"Test that Nominal scale can be identified as categorical.\"\"\"\n+        nominal_scale = Nominal()\n+        # This test will fail before the fix is applied\n+        # After fix, Nominal should have _categorical = True or similar identifier\n+        assert hasattr(nominal_scale, '_categorical') or hasattr(nominal_scale, 'is_categorical')\n+\n+    def test_nominal_scale_axis_limits_plus_minus_half(self, categorical_data):\n+        \"\"\"Test that Nominal scales set axis limits to +/- 0.5 from first/last tick.\"\"\"\n+        # Create a plot with explicit Nominal scale\n+        p = Plot(categorical_data, x='category', y='value').add(so.Dot()).scale(x=so.Nominal())\n+        \n+        # This test demonstrates the bug - before fix, limits may not be set correctly\n+        plotter = Plotter(pyplot=False, theme={})\n+        plotter._extract_data(p)\n+        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._finalize_figure(p)\n+        \n+        # Check that x-axis limits are set to -0.5 and n_categories - 0.5\n+        ax = plotter._subplots[0]['ax']\n+        xlim = ax.get_xlim()\n+        \n+        # Should be approximately (-0.5, 3.5) for 4 categories (0, 1, 2, 3)\n+        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n+        assert xlim[1] == pytest.approx(3.5, abs=0.1)\n+\n+    def test_nominal_scale_no_grid_display(self, categorical_data):\n+        \"\"\"Test that Nominal scales suppress grid display.\"\"\"\n+        # Create a plot with explicit Nominal scale and a style that normally shows grid\n+        with sns.axes_style(\"whitegrid\"):  # This style normally shows grid\n+            p = Plot(categorical_data, x='category', y='value').add(so.Dot()).scale(x=so.Nominal())\n+            \n+            plotter = Plotter(pyplot=False, theme={})\n+            plotter._extract_data(p)\n+            plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+            plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+            plotter._finalize_figure(p)\n+            \n+            ax = plotter._subplots[0]['ax']\n+            \n+            # This test will fail before the fix - grid should be disabled for categorical axis\n+            # Check that grid is disabled on x-axis (categorical)\n+            assert not ax.xaxis.grid\n+            # y-axis should still have grid (it's continuous)\n+            # Note: This assertion might need adjustment based on actual implementation\n+\n+    def test_nominal_scale_y_axis_inversion(self, categorical_data):\n+        \"\"\"Test that Nominal scales on y-axis are inverted.\"\"\"\n+        # Create a plot with Nominal scale on y-axis\n+        p = Plot(categorical_data, x='value', y='category').add(so.Dot()).scale(y=so.Nominal())\n+        \n+        plotter = Plotter(pyplot=False, theme={})\n+        plotter._extract_data(p)\n+        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._finalize_figure(p)\n+        \n+        ax = plotter._subplots[0]['ax']\n+        \n+        # This test will fail before the fix - y-axis should be inverted for categorical\n+        ylim = ax.get_ylim()\n+        # For inverted axis, ylim[0] should be greater than ylim[1]\n+        assert ylim[0] > ylim[1], \"Y-axis should be inverted for Nominal scale\"\n+\n+    def test_inferred_nominal_scale_behavior(self, categorical_data):\n+        \"\"\"Test that inferred Nominal scales also get categorical behavior.\"\"\"\n+        # Create a plot without explicit scale - should infer Nominal for string data\n+        p = Plot(categorical_data, x='category', y='value').add(so.Dot())\n+        \n+        plotter = Plotter(pyplot=False, theme={})\n+        plotter._extract_data(p)\n+        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._finalize_figure(p)\n+        \n+        ax = plotter._subplots[0]['ax']\n+        xlim = ax.get_xlim()\n+        \n+        # Should still get categorical behavior even with inferred scale\n+        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n+        assert xlim[1] == pytest.approx(3.5, abs=0.1)\n+\n+    def test_continuous_scale_unaffected(self, categorical_data):\n+        \"\"\"Test that continuous scales are not affected by categorical behavior.\"\"\"\n+        # Create a plot with continuous scale\n+        p = Plot(categorical_data, x='value', y='value').add(so.Dot())\n+        \n+        plotter = Plotter(pyplot=False, theme={})\n+        plotter._extract_data(p)\n+        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._finalize_figure(p)\n+        \n+        ax = plotter._subplots[0]['ax']\n+        xlim = ax.get_xlim()\n+        ylim = ax.get_ylim()\n+        \n+        # Continuous scales should not have the +/- 0.5 behavior\n+        # Limits should be based on data range with normal matplotlib margins\n+        assert xlim[0] < 1  # Should have some margin below minimum value (1)\n+        assert xlim[1] > 4  # Should have some margin above maximum value (4)\n+        assert ylim[0] < 1\n+        assert ylim[1] > 4\n+        \n+        # Y-axis should not be inverted for continuous scale\n+        assert ylim[0] < ylim[1], \"Y-axis should not be inverted for continuous scale\"\n+\n+    def test_mixed_scales_behavior(self, categorical_data):\n+        \"\"\"Test behavior when one axis is Nominal and other is continuous.\"\"\"\n+        # x-axis: Nominal, y-axis: continuous\n+        p = Plot(categorical_data, x='category', y='value').add(so.Dot()).scale(x=so.Nominal())\n+        \n+        plotter = Plotter(pyplot=False, theme={})\n+        plotter._extract_data(p)\n+        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._finalize_figure(p)\n+        \n+        ax = plotter._subplots[0]['ax']\n+        xlim = ax.get_xlim()\n+        ylim = ax.get_ylim()\n+        \n+        # X-axis (Nominal) should have categorical behavior\n+        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n+        assert xlim[1] == pytest.approx(3.5, abs=0.1)\n+        \n+        # Y-axis (continuous) should have normal behavior\n+        assert ylim[0] < 1\n+        assert ylim[1] > 4\n+        assert ylim[0] < ylim[1]  # Should not be inverted\n+\n+    def test_nominal_scale_with_numeric_categories(self, categorical_data):\n+        \"\"\"Test that Nominal scale works with numeric categories.\"\"\"\n+        # Force numeric data to be treated as categorical\n+        p = Plot(categorical_data, x='numeric_cat', y='value').add(so.Dot()).scale(x=so.Nominal())\n+        \n+        plotter = Plotter(pyplot=False, theme={})\n+        plotter._extract_data(p)\n+        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._finalize_figure(p)\n+        \n+        ax = plotter._subplots[0]['ax']\n+        xlim = ax.get_xlim()\n+        \n+        # Should still get categorical behavior for numeric data with Nominal scale\n+        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n+        assert xlim[1] == pytest.approx(3.5, abs=0.1)\n+\n+    @pytest.mark.parametrize(\"axis\", [\"x\", \"y\"])\n+    def test_nominal_scale_both_axes(self, categorical_data, axis):\n+        \"\"\"Test Nominal scale behavior on both x and y axes.\"\"\"\n+        if axis == \"x\":\n+            p = Plot(categorical_data, x='category', y='value').add(so.Dot()).scale(x=so.Nominal())\n+        else:\n+            p = Plot(categorical_data, x='value', y='category').add(so.Dot()).scale(y=so.Nominal())\n+        \n+        plotter = Plotter(pyplot=False, theme={})\n+        plotter._extract_data(p)\n+        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._finalize_figure(p)\n+        \n+        ax = plotter._subplots[0]['ax']\n+        \n+        if axis == \"x\":\n+            xlim = ax.get_xlim()\n+            assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n+            assert xlim[1] == pytest.approx(3.5, abs=0.1)\n+        else:\n+            ylim = ax.get_ylim()\n+            assert ylim[0] == pytest.approx(3.5, abs=0.1)  # Inverted\n+            assert ylim[1] == pytest.approx(-0.5, abs=0.1)  # Inverted\n+\n+    def test_nominal_scale_preserves_existing_string_behavior(self):\n+        \"\"\"Test that existing string-based categorical behavior is preserved.\"\"\"\n+        # This test ensures we don't break existing functionality\n+        data = pd.DataFrame({\n+            'str_cat': ['A', 'B', 'C'],\n+            'value': [1, 2, 3]\n+        })\n+        \n+        # Test without explicit Nominal scale (should infer categorical behavior)\n+        p = Plot(data, x='str_cat', y='value').add(so.Dot())\n+        \n+        plotter = Plotter(pyplot=False, theme={})\n+        plotter._extract_data(p)\n+        plotter._setup_figure(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._setup_scales(p, plotter._extract_data(p)[0], plotter._extract_data(p)[1])\n+        plotter._finalize_figure(p)\n+        \n+        ax = plotter._subplots[0]['ax']\n+        xlim = ax.get_xlim()\n+        \n+        # Should still work as before for string data\n+        assert xlim[0] == pytest.approx(-0.5, abs=0.1)\n+        assert xlim[1] == pytest.approx(2.5, abs=0.1)  # 3 categories: 0, 1, 2\n\n--- a/tests/test_core/test_scales_nominal.py\n+++ b/tests/test_core/test_scales_nominal.py\n-# Empty if creating new file\n+import pytest\n+import numpy as np\n+import pandas as pd\n+\n+import seaborn.objects as so\n+from seaborn._core.scales import Nominal, Scale\n+from seaborn._core.properties import Coordinate\n+\n+\n+class TestNominalScaleIdentification:\n+    \"\"\"Test that Nominal scale can be properly identified as categorical.\"\"\"\n+\n+    def test_nominal_scale_is_categorical_attribute(self):\n+        \"\"\"Test that Nominal scale has categorical identification attribute.\"\"\"\n+        nominal = Nominal()\n+        \n+        # This test will fail before the fix is applied\n+        # The fix should add a _categorical attribute or similar\n+        assert hasattr(nominal, '_categorical'), \"Nominal scale should have _categorical attribute\"\n+        assert getattr(nominal, '_categorical') is True, \"Nominal scale should be marked as categorical\"\n+\n+    def test_nominal_scale_inheritance(self):\n+        \"\"\"Test that Nominal scale properly inherits from Scale.\"\"\"\n+        nominal = Nominal()\n+        assert isinstance(nominal, Scale), \"Nominal should inherit from Scale\"\n+\n+    def test_nominal_scale_setup_preserves_functionality(self):\n+        \"\"\"Test that adding categorical identification doesn't break existing setup.\"\"\"\n+        data = pd.Series(['A', 'B', 'C', 'A', 'B'])\n+        prop = Coordinate()\n+        \n+        nominal = Nominal()\n+        setup_scale = nominal._setup(data, prop)\n+        \n+        # Verify that setup still works correctly\n+        assert setup_scale is not None\n+        assert hasattr(setup_scale, '_pipeline')\n+        assert hasattr(setup_scale, '_matplotlib_scale')\n+        \n+        # Verify categorical identification is preserved after setup\n+        if hasattr(nominal, '_categorical'):\n+            assert hasattr(setup_scale, '_categorical')\n+            assert getattr(setup_scale, '_categorical') is True\n+\n+    def test_other_scales_not_categorical(self):\n+        \"\"\"Test that other scale types are not marked as categorical.\"\"\"\n+        from seaborn._core.scales import Continuous\n+        \n+        continuous = Continuous()\n+        \n+        # Continuous scales should not be marked as categorical\n+        if hasattr(continuous, '_categorical'):\n+            assert getattr(continuous, '_categorical') is False\n+        # Or they might not have the attribute at all, which is also fine\n+\n+    def test_nominal_scale_categorical_identification_method(self):\n+        \"\"\"Test alternative implementation using a method for categorical identification.\"\"\"\n+        nominal = Nominal()\n+        \n+        # Alternative implementation might use a method instead of attribute\n+        if hasattr(nominal, 'is_categorical'):\n+            assert callable(getattr(nominal, 'is_categorical'))\n+            assert nominal.is_categorical() is True\n+        elif hasattr(nominal, '_categorical'):\n+            # Attribute-based implementation\n+            assert getattr(nominal, '_categorical') is True\n+        else:\n+            pytest.fail(\"Nominal scale should have either _categorical attribute or is_categorical() method\")\n"
}