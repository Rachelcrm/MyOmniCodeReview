{
  "patch": "Looking at the issue, the problem is that when a field is defined in `radio_fields`, the `formfield_for_foreignkey` method unconditionally overwrites any custom `empty_label` that might have been set in the kwargs by a subclass's override of the method.\n\nThe issue is on line 272 in the `formfield_for_foreignkey` method:\n\n```python\nkwargs[\"empty_label\"] = _(\"None\") if db_field.blank else None\n```\n\nThis line always sets the `empty_label` to the default value, ignoring any custom value that might already be present in kwargs. The fix is to check if an `empty_label` is already present in kwargs and only use the default if none is provided.\n\nHere's the reasoning:\n1. The current code unconditionally sets `kwargs[\"empty_label\"]` to the default value\n2. This overwrites any custom `empty_label` that a subclass might have set in their override of `formfield_for_foreignkey`\n3. The fix should preserve any existing `empty_label` in kwargs while still providing a default when none is present\n4. The suggested fix uses `kwargs.get('empty_label') or _('None')` to check if a custom label exists first\n\n```\n<file>django/contrib/admin/options.py</file>\n<original>\n            elif db_field.name in self.radio_fields:\n                kwargs[\"widget\"] = widgets.AdminRadioSelect(\n                    attrs={\n                        \"class\": get_ul_class(self.radio_fields[db_field.name]),\n                    }\n                )\n                kwargs[\"empty_label\"] = _(\"None\") if db_field.blank else None\n</original>\n<patched>\n            elif db_field.name in self.radio_fields:\n                kwargs[\"widget\"] = widgets.AdminRadioSelect(\n                    attrs={\n                        \"class\": get_ul_class(self.radio_fields[db_field.name]),\n                    }\n                )\n                kwargs[\"empty_label\"] = (kwargs.get(\"empty_label\") or _(\"None\")) if db_field.blank else None\n</patched>\n```"
}