{
  "patch": "Looking at the issue, the problem is that SQLite's `PRAGMA foreign_key_check()` and `PRAGMA foreign_key_list()` commands fail when table names are SQL keywords (like \"order\") because the table names are not properly quoted.\n\nThe issue is specifically in the SQLite backend's `check_constraints` method. Looking at the code context provided, I can see that the MySQL backend properly quotes table names using backticks, but the SQLite backend is missing from the provided locations. However, based on the error message and the issue description, I need to find and fix the SQLite backend's `check_constraints` method.\n\nThe issue mentions that the problem is in `django/db/backends/sqlite3/base.py` at line 327 in the `check_constraints` function. The SQL statements `PRAGMA foreign_key_check(%s)` and `PRAGMA foreign_key_list(%s)` need to have their table names properly quoted.\n\nLet me write the patch to fix this issue:\n\n```\n<file>django/db/backends/sqlite3/base.py</file>\n<original>\n    def check_constraints(self, table_names=None):\n        \"\"\"\n        Check each table name in `table_names` for rows with invalid foreign\n        key references. This method is intended to be used in conjunction with\n        `disable_constraint_checking()` and `enable_constraint_checking()`, to\n        determine if rows with invalid references were entered while constraint\n        checks were off.\n        \"\"\"\n        if self.features.supports_pragma_foreign_key_check:\n            with self.cursor() as cursor:\n                if table_names is None:\n                    violations = cursor.execute('PRAGMA foreign_key_check').fetchall()\n                else:\n                    violations = chain.from_iterable(\n                        cursor.execute('PRAGMA foreign_key_check(%s)' % table_name).fetchall()\n                        for table_name in table_names\n                    )\n                # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check\n                for table_name, rowid, referenced_table_name, foreign_key_index in violations:\n                    foreign_key = cursor.execute(\n                        'PRAGMA foreign_key_list(%s)' % table_name\n                    ).fetchall()[foreign_key_index]\n                    column_name, referenced_column_name = foreign_key[3:5]\n                    primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n                    primary_key_value, bad_value = cursor.execute(\n                        'SELECT %s, %s FROM %s WHERE rowid = %%s' % (\n                            primary_key_column_name, column_name, table_name,\n                        ),\n                        (rowid,),\n                    ).fetchone()\n                    raise IntegrityError(\n                        \"The row in table '%s' with primary key '%s' has an \"\n                        \"invalid foreign key: %s.%s contains a value '%s' that \"\n                        \"does not have a corresponding value in %s.%s.\" % (\n                            table_name, primary_key_value, table_name, column_name,\n                            bad_value, referenced_table_name, referenced_column_name,\n                        )\n                    )\n</original>\n<patched>\n    def check_constraints(self, table_names=None):\n        \"\"\"\n        Check each table name in `table_names` for rows with invalid foreign\n        key references. This method is intended to be used in conjunction with\n        `disable_constraint_checking()` and `enable_constraint_checking()`, to\n        determine if rows with invalid references were entered while constraint\n        checks were off.\n        \"\"\"\n        if self.features.supports_pragma_foreign_key_check:\n            with self.cursor() as cursor:\n                if table_names is None:\n                    violations = cursor.execute('PRAGMA foreign_key_check').fetchall()\n                else:\n                    violations = chain.from_iterable(\n                        cursor.execute('PRAGMA foreign_key_check(%s)' % self.ops.quote_name(table_name)).fetchall()\n                        for table_name in table_names\n                    )\n                # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check\n                for table_name, rowid, referenced_table_name, foreign_key_index in violations:\n                    foreign_key = cursor.execute(\n                        'PRAGMA foreign_key_list(%s)' % self.ops.quote_name(table_name)\n                    ).fetchall()[foreign_key_index]\n                    column_name, referenced_column_name = foreign_key[3:5]\n                    primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n                    primary_key_value, bad_value = cursor.execute(\n                        'SELECT %s, %s FROM %s WHERE rowid = %%s' % (\n                            self.ops.quote_name(primary_key_column_name), self.ops.quote_name(column_name), self.ops.quote_name(table_name),\n                        ),\n                        (rowid,),\n                    ).fetchone()\n                    raise IntegrityError(\n                        \"The row in table '%s' with primary key '%s' has an \"\n                        \"invalid foreign key: %s.%s contains a value '%s' that \"\n                        \"does not have a corresponding value in %s.%s.\" % (\n                            table_name, primary_key_value, table_name, column_name,\n                            bad_value, referenced_table_name, referenced_column_name,\n                        )\n                    )\n</patched>\n```\n\nThe key changes I made:\n\n1. **Line with `PRAGMA foreign_key_check(%s)`**: Changed `table_name` to `self.ops.quote_name(table_name)` to properly quote the table name.\n\n2. **Line with `PRAGMA foreign_key_list(%s)`**: Changed `table_name` to `self.ops.quote_name(table_name)` to properly quote the table name.\n\n3. **SELECT statement**: Changed the column names and table name to use `self.ops.quote_name()` for proper quoting:\n   - `primary_key_column_name` → `self.ops.quote_name(primary_key_column_name)`\n   - `column_name` → `self.ops.quote_name(column_name)`\n   - `table_name` → `self.ops.quote_name(table_name)`\n\nThis fix ensures that when table names or column names are SQL keywords (like \"order\"), they will be properly quoted with double quotes in SQLite, preventing the syntax errors that were occurring during `loaddata` operations."
}