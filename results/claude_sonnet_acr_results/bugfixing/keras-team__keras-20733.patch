{
  "patch": "diff --git a/keras/api/ops/__init__.py b/keras/api/ops/__init__.py\nindex 56a071bde..aeff94813 100644\n--- a/keras/api/ops/__init__.py\n+++ b/keras/api/ops/__init__.py\n@@ -220,6 +220,7 @@ from keras.src.ops.numpy import prod\n from keras.src.ops.numpy import quantile\n from keras.src.ops.numpy import ravel\n from keras.src.ops.numpy import real\n+from keras.src.ops.numpy import rearrange\n from keras.src.ops.numpy import reciprocal\n from keras.src.ops.numpy import repeat\n from keras.src.ops.numpy import reshape\ndiff --git a/keras/api/ops/numpy/__init__.py b/keras/api/ops/numpy/__init__.py\nindex 0eb882811..36f82434d 100644\n--- a/keras/api/ops/numpy/__init__.py\n+++ b/keras/api/ops/numpy/__init__.py\n@@ -120,6 +120,7 @@ from keras.src.ops.numpy import prod\n from keras.src.ops.numpy import quantile\n from keras.src.ops.numpy import ravel\n from keras.src.ops.numpy import real\n+from keras.src.ops.numpy import rearrange\n from keras.src.ops.numpy import reciprocal\n from keras.src.ops.numpy import repeat\n from keras.src.ops.numpy import reshape\ndiff --git a/keras/src/ops/numpy.py b/keras/src/ops/numpy.py\nindex cfdcfa7fa..0638ad53c 100644\n--- a/keras/src/ops/numpy.py\n+++ b/keras/src/ops/numpy.py\n@@ -5866,6 +5866,179 @@ def vectorize(pyfunc, *, excluded=None, signature=None):\n     )\n \n \n+class Rearrange(Operation):\n+    def __init__(self, pattern):\n+        super().__init__()\n+        self.pattern = pattern\n+        self._parse_pattern()\n+\n+    def _parse_pattern(self):\n+        \"\"\"Parse einops-style pattern string.\"\"\"\n+        if \"->\" not in self.pattern:\n+            raise ValueError(\n+                f\"Pattern must contain '->' to separate input and output. \"\n+                f\"Received: {self.pattern}\"\n+            )\n+        \n+        input_pattern, output_pattern = self.pattern.split(\"->\")\n+        self.input_pattern = input_pattern.strip()\n+        self.output_pattern = output_pattern.strip()\n+        \n+        # Extract dimension names from patterns\n+        self.input_dims = self._extract_dims(self.input_pattern)\n+        self.output_dims = self._extract_dims(self.output_pattern)\n+\n+    def _extract_dims(self, pattern):\n+        \"\"\"Extract dimension names from a pattern, handling parentheses for grouping.\"\"\"\n+        dims = []\n+        i = 0\n+        while i < len(pattern):\n+            if pattern[i] == '(':\n+                # Find matching closing parenthesis\n+                paren_count = 1\n+                j = i + 1\n+                group = \"\"\n+                while j < len(pattern) and paren_count > 0:\n+                    if pattern[j] == '(':\n+                        paren_count += 1\n+                    elif pattern[j] == ')':\n+                        paren_count -= 1\n+                    if paren_count > 0:\n+                        group += pattern[j]\n+                    j += 1\n+                dims.append(f\"({group})\")\n+                i = j\n+            elif pattern[i].isalnum() or pattern[i] == '_':\n+                # Single dimension name\n+                j = i\n+                while j < len(pattern) and (pattern[j].isalnum() or pattern[j] == '_'):\n+                    j += 1\n+                dims.append(pattern[i:j])\n+                i = j\n+            else:\n+                i += 1\n+        return dims\n+\n+    def _compute_transpose_axes(self, input_shape):\n+        \"\"\"Compute transpose axes to rearrange dimensions.\"\"\"\n+        # Create mapping from dimension names to their positions and sizes\n+        dim_to_pos = {}\n+        dim_to_size = {}\n+        \n+        for i, dim_name in enumerate(self.input_dims):\n+            if dim_name.startswith('(') and dim_name.endswith(')'):\n+                # This is a grouped dimension, skip for now\n+                continue\n+            dim_to_pos[dim_name] = i\n+            dim_to_size[dim_name] = input_shape[i]\n+        \n+        # Compute axes for transpose\n+        transpose_axes = []\n+        for dim_name in self.output_dims:\n+            if dim_name.startswith('(') and dim_name.endswith(')'):\n+                # Handle grouped dimensions\n+                group_dims = dim_name[1:-1].split()\n+                for group_dim in group_dims:\n+                    if group_dim in dim_to_pos:\n+                        transpose_axes.append(dim_to_pos[group_dim])\n+            elif dim_name in dim_to_pos:\n+                transpose_axes.append(dim_to_pos[dim_name])\n+        \n+        return transpose_axes\n+\n+    def _compute_output_shape(self, input_shape):\n+        \"\"\"Compute the output shape after rearrangement.\"\"\"\n+        # Create mapping from dimension names to their sizes\n+        dim_to_size = {}\n+        for i, dim_name in enumerate(self.input_dims):\n+            if not (dim_name.startswith('(') and dim_name.endswith(')')):\n+                dim_to_size[dim_name] = input_shape[i]\n+        \n+        output_shape = []\n+        for dim_name in self.output_dims:\n+            if dim_name.startswith('(') and dim_name.endswith(')'):\n+                # Handle grouped dimensions - multiply sizes\n+                group_dims = dim_name[1:-1].split()\n+                group_size = 1\n+                for group_dim in group_dims:\n+                    if group_dim in dim_to_size:\n+                        group_size *= dim_to_size[group_dim]\n+                output_shape.append(group_size)\n+            elif dim_name in dim_to_size:\n+                output_shape.append(dim_to_size[dim_name])\n+        \n+        return output_shape\n+\n+    def call(self, x):\n+        input_shape = x.shape\n+        \n+        # Handle simple transpose case\n+        if len(self.input_dims) == len(self.output_dims):\n+            # Check if it's just a reordering\n+            if set(self.input_dims) == set(self.output_dims):\n+                transpose_axes = []\n+                dim_to_pos = {dim: i for i, dim in enumerate(self.input_dims)}\n+                for dim in self.output_dims:\n+                    transpose_axes.append(dim_to_pos[dim])\n+                return transpose(x, axes=transpose_axes)\n+        \n+        # Handle reshape cases (dimension merging/splitting)\n+        output_shape = self._compute_output_shape(input_shape)\n+        \n+        # First transpose if needed to get dimensions in the right order\n+        if len(self.input_dims) == len(self.output_dims):\n+            transpose_axes = self._compute_transpose_axes(input_shape)\n+            if transpose_axes != list(range(len(transpose_axes))):\n+                x = transpose(x, axes=transpose_axes)\n+        \n+        # Then reshape to final shape\n+        return reshape(x, output_shape)\n+\n+    def compute_output_spec(self, x):\n+        input_shape = x.shape\n+        output_shape = self._compute_output_shape(input_shape)\n+        return KerasTensor(output_shape, dtype=x.dtype)\n+\n+\n+@keras_export([\"keras.ops.rearrange\", \"keras.ops.numpy.rearrange\"])\n+def rearrange(x, pattern):\n+    \"\"\"Rearrange tensor dimensions using einops-style patterns.\n+\n+    This function provides einops-style tensor rearrangement functionality,\n+    allowing you to reshape and transpose tensors using intuitive string patterns.\n+\n+    Args:\n+        x: Input tensor.\n+        pattern: String pattern describing the rearrangement.\n+            Format: \"input_pattern -> output_pattern\"\n+            Examples:\n+            - \"b h w c -> b (h w) c\" - flatten spatial dimensions\n+            - \"b (h w) c -> b h w c\" - unflatten (requires known h, w)\n+            - \"b h w c -> b c h w\" - transpose dimensions\n+            - \"h w -> w h\" - simple transpose\n+\n+    Returns:\n+        Rearranged tensor.\n+\n+    Examples:\n+    >>> x = keras.ops.ones((2, 4, 4, 3))\n+    >>> y = keras.ops.rearrange(x, \"b h w c -> b (h w) c\")\n+    >>> y.shape\n+    (2, 16, 3)\n+\n+    >>> x = keras.ops.ones((2, 3, 4, 4))\n+    >>> y = keras.ops.rearrange(x, \"b c h w -> b h w c\")\n+    >>> y.shape\n+    (2, 4, 4, 3)\n+    \"\"\"\n+    if any_symbolic_tensors((x,)):\n+        return Rearrange(pattern).symbolic_call(x)\n+    \n+    # For non-symbolic tensors, we can use the operation directly\n+    op = Rearrange(pattern)\n+    return op.call(x)\n+\n+\n class Vstack(Operation):\n     def call(self, xs):\n         return backend.numpy.vstack(xs)\n"
}