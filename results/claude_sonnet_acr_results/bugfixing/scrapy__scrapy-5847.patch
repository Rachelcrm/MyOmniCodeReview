{
  "patch": "diff --git a/scrapy/extensions/feedexport.py b/scrapy/extensions/feedexport.py\nindex bcf0b779a..3d95ef65a 100644\n--- a/scrapy/extensions/feedexport.py\n+++ b/scrapy/extensions/feedexport.py\n@@ -99,6 +99,10 @@ class IFeedStorage(Interface):\n     def store(file):\n         \"\"\"Store the given file stream\"\"\"\n \n+    def cleanup():\n+        \"\"\"Clean up resources when the feed should be removed (e.g., when no items\n+        are exported and store_empty is False)\"\"\"\n+\n \n @implementer(IFeedStorage)\n class BlockingFeedStorage:\n@@ -115,6 +119,9 @@ class BlockingFeedStorage:\n     def _store_in_thread(self, file):\n         raise NotImplementedError\n \n+    def cleanup(self):\n+        pass\n+\n \n @implementer(IFeedStorage)\n class StdoutFeedStorage:\n@@ -136,6 +143,9 @@ class StdoutFeedStorage:\n     def store(self, file):\n         pass\n \n+    def cleanup(self):\n+        pass\n+\n \n @implementer(IFeedStorage)\n class FileFeedStorage:\n@@ -153,6 +163,13 @@ class FileFeedStorage:\n     def store(self, file):\n         file.close()\n \n+    def cleanup(self):\n+        try:\n+            if Path(self.path).exists():\n+                Path(self.path).unlink()\n+        except OSError:\n+            pass\n+\n \n class S3FeedStorage(BlockingFeedStorage):\n     def __init__(\n@@ -410,7 +427,10 @@ class FeedExporter:\n         if not slot.itemcount and not slot.store_empty:\n             # We need to call slot.storage.store nonetheless to get the file\n             # properly closed.\n-            return defer.maybeDeferred(slot.storage.store, get_file(slot))\n+            d = defer.maybeDeferred(slot.storage.store, get_file(slot))\n+            # Clean up empty file after storing\n+            d.addCallback(lambda _: defer.maybeDeferred(slot.storage.cleanup))\n+            return d\n \n         logmsg = f\"{slot.format} feed ({slot.itemcount} items) in: {slot.uri}\"\n         d = defer.maybeDeferred(slot.storage.store, get_file(slot))\n"
}