{
  "patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex aaf35ee37c..f7294931af 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -596,6 +596,8 @@ class Query(BaseExpression):\n         joinpromoter.add_votes(\n             j for j in self.alias_map if self.alias_map[j].join_type == INNER)\n         rhs_votes = set()\n+        # Collect all existing aliases from rhs to avoid conflicts when generating new aliases\n+        rhs_aliases = set(rhs.alias_map.keys())\n         # Now, add the joins from rhs query into the new query (skipping base\n         # table).\n         rhs_tables = list(rhs.alias_map)[1:]\n@@ -604,7 +606,7 @@ class Query(BaseExpression):\n             # If the left side of the join was already relabeled, use the\n             # updated alias.\n             join = join.relabeled_clone(change_map)\n-            new_alias = self.join(join, reuse=reuse)\n+            new_alias = self.join(join, reuse=reuse, avoid_aliases=rhs_aliases)\n             if join.join_type == INNER:\n                 rhs_votes.add(new_alias)\n             # We can't reuse the same join again in the query. If we have two\n@@ -745,13 +747,16 @@ class Query(BaseExpression):\n             for model, values in seen.items():\n                 callback(target, model, values)\n \n-    def table_alias(self, table_name, create=False, filtered_relation=None):\n+    def table_alias(self, table_name, create=False, filtered_relation=None, avoid_aliases=None):\n         \"\"\"\n         Return a table alias for the given table_name and whether this is a\n         new alias or not.\n \n         If 'create' is true, a new alias is always created. Otherwise, the\n         most recently created alias for the table (if one exists) is reused.\n+        \n+        The 'avoid_aliases' parameter is a set of aliases that should not be\n+        used when generating new aliases.\n         \"\"\"\n         alias_list = self.table_map.get(table_name)\n         if not create and alias_list:\n@@ -761,7 +766,13 @@ class Query(BaseExpression):\n \n         # Create a new alias for this table.\n         if alias_list:\n-            alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n+            # Generate a new alias, avoiding conflicts with existing aliases\n+            avoid_aliases = avoid_aliases or set()\n+            counter = len(self.alias_map) + 1\n+            alias = '%s%d' % (self.alias_prefix, counter)\n+            while alias in self.alias_map or alias in avoid_aliases:\n+                counter += 1\n+                alias = '%s%d' % (self.alias_prefix, counter)\n             alias_list.append(alias)\n         else:\n             # The first occurrence of a table uses the table name directly.\n@@ -948,7 +959,7 @@ class Query(BaseExpression):\n         \"\"\"\n         return len([1 for count in self.alias_refcount.values() if count])\n \n-    def join(self, join, reuse=None):\n+    def join(self, join, reuse=None, avoid_aliases=None):\n         \"\"\"\n         Return an alias for the 'join', either reusing an existing alias for\n         that join or creating a new one. 'join' is either a base_table_class or\n@@ -956,6 +967,9 @@ class Query(BaseExpression):\n \n         The 'reuse' parameter can be either None which means all joins are\n         reusable, or it can be a set containing the aliases that can be reused.\n+        \n+        The 'avoid_aliases' parameter is a set of aliases that should not be\n+        used when generating new aliases.\n \n         A join is always created as LOUTER if the lhs alias is LOUTER to make\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n@@ -976,7 +990,7 @@ class Query(BaseExpression):\n             return reuse_alias\n \n         # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)\n+        alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation, avoid_aliases=avoid_aliases)\n         if join.join_type:\n             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n                 join_type = LOUTER\n"
}