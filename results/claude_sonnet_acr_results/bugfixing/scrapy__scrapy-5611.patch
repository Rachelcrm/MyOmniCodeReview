{
  "patch": "diff --git a/scrapy/http/response/text.py b/scrapy/http/response/text.py\nindex 89516b9b6..f375feded 100644\n--- a/scrapy/http/response/text.py\n+++ b/scrapy/http/response/text.py\n@@ -97,12 +97,23 @@ class TextResponse(Response):\n \n     def _body_inferred_encoding(self):\n         if self._cached_benc is None:\n-            content_type = to_unicode(self.headers.get(b'Content-Type', b''))\n-            benc, ubody = html_to_unicode(content_type, self.body,\n-                                          auto_detect_fun=self._auto_detect_fun,\n-                                          default_encoding=self._DEFAULT_ENCODING)\n-            self._cached_benc = benc\n-            self._cached_ubody = ubody\n+            # Check for BOM first, as it should take precedence over Content-Type header\n+            bom_encoding = self._detect_bom_encoding()\n+            if bom_encoding:\n+                self._cached_benc = bom_encoding\n+                # Remove BOM from body for text processing\n+                bom_length = self._get_bom_length(bom_encoding)\n+                body_without_bom = self.body[bom_length:]\n+                charset = f'charset={bom_encoding}'\n+                self._cached_ubody = html_to_unicode(charset, body_without_bom)[1]\n+            else:\n+                # Fall back to current behavior if no BOM detected\n+                content_type = to_unicode(self.headers.get(b'Content-Type', b''))\n+                benc, ubody = html_to_unicode(content_type, self.body,\n+                                              auto_detect_fun=self._auto_detect_fun,\n+                                              default_encoding=self._DEFAULT_ENCODING)\n+                self._cached_benc = benc\n+                self._cached_ubody = ubody\n         return self._cached_benc\n \n     def _auto_detect_fun(self, text):\n@@ -113,6 +124,36 @@ class TextResponse(Response):\n                 continue\n             return resolve_encoding(enc)\n \n+    def _detect_bom_encoding(self):\n+        \"\"\"Detect encoding from BOM (Byte Order Mark) at the beginning of the body.\"\"\"\n+        if not self.body:\n+            return None\n+        \n+        # Check for various BOM patterns\n+        if self.body.startswith(b'\\xef\\xbb\\xbf'):\n+            return 'utf-8'\n+        elif self.body.startswith(b'\\xff\\xfe\\x00\\x00'):\n+            return 'utf-32-le'\n+        elif self.body.startswith(b'\\x00\\x00\\xfe\\xff'):\n+            return 'utf-32-be'\n+        elif self.body.startswith(b'\\xff\\xfe'):\n+            return 'utf-16-le'\n+        elif self.body.startswith(b'\\xfe\\xff'):\n+            return 'utf-16-be'\n+        \n+        return None\n+    \n+    def _get_bom_length(self, encoding):\n+        \"\"\"Get the length of BOM for the given encoding.\"\"\"\n+        bom_lengths = {\n+            'utf-8': 3,\n+            'utf-16-le': 2,\n+            'utf-16-be': 2,\n+            'utf-32-le': 4,\n+            'utf-32-be': 4,\n+        }\n+        return bom_lengths.get(encoding, 0)\n+\n     @memoizemethod_noargs\n     def _body_declared_encoding(self):\n         return html_body_declared_encoding(self.body)\n"
}