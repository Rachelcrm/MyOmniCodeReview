{
  "patch": "Looking at the issue, the problem is in the `resolve_lookup_value` method in `django/db/models/sql/query.py`. When it encounters a named tuple, it tries to reconstruct it by passing a generator expression to the constructor. However, named tuples expect individual arguments, not an iterable.\n\nThe issue is on line 1080-1083 where the code does:\n\n```python\nreturn type(value)(\n    self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n    for sub_value in value\n)\n```\n\nFor named tuples, this passes a generator object to the constructor, but named tuples expect the values as separate positional arguments. The fix is to expand the generator using the `*` operator.\n\n```\n<file>django/db/models/sql/query.py</file>\n<original>\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            return type(value)(\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n        return value\n</original>\n<patched>\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            return type(value)(*(\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            ))\n        return value\n</patched>\n```\n\nThe key change is adding the `*` operator before the generator expression to unpack it into individual arguments. This ensures that both regular tuples and named tuples are handled correctly:\n\n- For regular tuples: `tuple(*(generator))` works the same as `tuple(generator)`\n- For named tuples: `NamedTuple(*(generator))` properly passes the resolved values as individual positional arguments to the named tuple constructor\n\nThis fix preserves the existing functionality for regular tuples and lists while properly handling named tuples that require individual arguments rather than an iterable."
}