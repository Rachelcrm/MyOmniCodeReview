{
  "patch": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 5089737034..f5b45c52c3 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -75,10 +75,10 @@ class Lookup:\n             return self.lhs.output_field.get_prep_value(self.rhs)\n         return self.rhs\n \n-    def get_db_prep_lookup(self, value, connection):\n+    def get_db_prep_lookup(self, value, _connection):\n         return ('%s', [value])\n \n-    def process_lhs(self, compiler, connection, lhs=None):\n+    def process_lhs(self, compiler, _connection, lhs=None):\n         lhs = lhs or self.lhs\n         if hasattr(lhs, 'resolve_expression'):\n             lhs = lhs.resolve_expression(compiler.query)\n@@ -114,7 +114,7 @@ class Lookup:\n             new.rhs = new.rhs.relabeled_clone(relabels)\n         return new\n \n-    def get_group_by_cols(self, alias=None):\n+    def get_group_by_cols(self, _alias=None):\n         cols = self.lhs.get_group_by_cols()\n         if hasattr(self.rhs, 'get_group_by_cols'):\n             cols.extend(self.rhs.get_group_by_cols())\n@@ -133,7 +133,7 @@ class Lookup:\n                 expr = Case(When(expr, then=True), default=False)\n                 wrapped = True\n             exprs.append(expr)\n-        lookup = type(self)(*exprs) if wrapped else self\n+        lookup = type(self)(exprs[0], exprs[1]) if wrapped else self\n         return lookup.as_sql(compiler, connection)\n \n     @cached_property\n@@ -182,6 +182,12 @@ class Transform(RegisterLookupMixin, Func):\n             bilateral_transforms.append(self.__class__)\n         return bilateral_transforms\n \n+    def __rand__(self, other):\n+        raise NotImplementedError\n+\n+    def __ror__(self, other):\n+        raise NotImplementedError\n+\n \n class BuiltinLookup(Lookup):\n     def process_lhs(self, compiler, connection, lhs=None):\n@@ -253,7 +259,7 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n-    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+    def resolve_expression_parameter(self, compiler, _connection, sql, param):\n         params = [param]\n         if hasattr(param, 'resolve_expression'):\n             param = param.resolve_expression(compiler.query)\n@@ -285,6 +291,9 @@ class PostgresOperatorLookup(FieldGetDbPrepValueMixin, Lookup):\n         params = tuple(lhs_params) + tuple(rhs_params)\n         return '%s %s %s' % (lhs, self.postgres_operator, rhs), params\n \n+    def as_sql(self, compiler, connection):\n+        return self.as_postgresql(compiler, connection)\n+\n \n @Field.register_lookup\n class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n@@ -324,8 +333,8 @@ class IExact(BuiltinLookup):\n     lookup_name = 'iexact'\n     prepare_rhs = False\n \n-    def process_rhs(self, qn, connection):\n-        rhs, params = super().process_rhs(qn, connection)\n+    def process_rhs(self, compiler, connection):\n+        rhs, params = super().process_rhs(compiler, connection)\n         if params:\n             params[0] = connection.ops.prep_for_iexact_query(params[0])\n         return rhs, params\n@@ -357,8 +366,9 @@ class IntegerFieldFloatRounding:\n     decimal portion of the float would always be discarded.\n     \"\"\"\n     def get_prep_lookup(self):\n-        if isinstance(self.rhs, float):\n-            self.rhs = math.ceil(self.rhs)\n+        rhs = self.rhs\n+        if isinstance(rhs, float):\n+            self.rhs = math.ceil(rhs)\n         return super().get_prep_lookup()\n \n \n@@ -458,8 +468,8 @@ class PatternLookup(BuiltinLookup):\n         else:\n             return super().get_rhs_op(connection, rhs)\n \n-    def process_rhs(self, qn, connection):\n-        rhs, params = super().process_rhs(qn, connection)\n+    def process_rhs(self, compiler, connection):\n+        rhs, params = super().process_rhs(compiler, connection)\n         if self.rhs_is_direct_value() and params and not self.bilateral_transforms:\n             params[0] = self.param_pattern % connection.ops.prep_for_like_query(params[0])\n         return rhs, params\n"
}