{
  "patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 97977d72ef..6dcb006954 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -93,7 +93,7 @@ class MigrationAutodetector:\n         the related fields change during renames).\n         \"\"\"\n         fields_def = []\n-        for name, field in sorted(fields.items()):\n+        for _, field in sorted(fields.items()):\n             deconstruction = self.deep_deconstruct(field)\n             if field.remote_field and field.remote_field.model:\n                 del deconstruction[2]['to']\n@@ -119,6 +119,7 @@ class MigrationAutodetector:\n         # and gathering them into a big per-app list.\n         # Then go through that list, order it, and split into migrations to\n         # resolve dependencies caused by M2Ms and FKs.\n+        # pylint: disable=attribute-defined-outside-init\n         self.generated_operations = {}\n         self.altered_indexes = {}\n         self.altered_constraints = {}\n@@ -206,6 +207,7 @@ class MigrationAutodetector:\n         in the old state so dependencies can be made from the through model\n         deletion to the field that uses it.\n         \"\"\"\n+        # pylint: disable=attribute-defined-outside-init\n         self.kept_model_keys = self.old_model_keys & self.new_model_keys\n         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n@@ -272,7 +274,7 @@ class MigrationAutodetector:\n                 for operation in list(self.generated_operations[app_label]):\n                     deps_satisfied = True\n                     operation_dependencies = set()\n-                    for dep in operation._auto_deps:\n+                    for dep in operation._auto_deps:  # pylint: disable=protected-access\n                         # Temporarily resolve the swappable dependency to\n                         # prevent circular references. While keeping the\n                         # dependency checks on the resolved model, add the\n@@ -341,7 +343,7 @@ class MigrationAutodetector:\n             # construct a dependency graph for intra-app dependencies\n             dependency_graph = {op: set() for op in ops}\n             for op in ops:\n-                for dep in op._auto_deps:\n+                for dep in op._auto_deps:  # pylint: disable=protected-access\n                     # Resolve intra-app dependencies to handle circular\n                     # references involving a swappable model.\n                     dep = self._resolve_dependency(dep)[0]\n@@ -434,7 +436,7 @@ class MigrationAutodetector:\n \n     def add_operation(self, app_label, operation, dependencies=None, beginning=False):\n         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)\n-        operation._auto_deps = dependencies or []\n+        operation._auto_deps = dependencies or []  # pylint: disable=protected-access\n         if beginning:\n             self.generated_operations.setdefault(app_label, []).insert(0, operation)\n         else:\n@@ -1367,7 +1369,7 @@ class MigrationAutodetector:\n         app_dependencies = {}\n         for app_label, migrations in changes.items():\n             for migration in migrations:\n-                for dep_app_label, name in migration.dependencies:\n+                for dep_app_label, _ in migration.dependencies:\n                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)\n         required_apps = set(app_labels)\n         # Keep resolving till there's no change\n"
}