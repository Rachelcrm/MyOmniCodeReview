{
  "patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex a44adfc760..89914a4675 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -36,6 +36,9 @@ class SQLCompiler:\n         # Multiline ordering SQL clause may appear from RawSQL.\n         self.ordering_parts = re.compile(r'^(.*)\\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)\n         self._meta_ordering = None\n+        self.col_count = None\n+        self.where = None\n+        self.having = None\n \n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n@@ -272,9 +275,9 @@ class SQLCompiler:\n         else:\n             ordering = []\n         if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n+            asc, _ = ORDER_DIR['ASC']\n         else:\n-            asc, desc = ORDER_DIR['DESC']\n+            asc, _ = ORDER_DIR['DESC']\n \n         order_by = []\n         for field in ordering:\n@@ -407,7 +410,7 @@ class SQLCompiler:\n             return node.output_field.select_format(self, sql, params)\n         return sql, params\n \n-    def get_combinator_sql(self, combinator, all):\n+    def get_combinator_sql(self, combinator, all_):\n         features = self.connection.features\n         compilers = [\n             query.get_compiler(self.using, self.connection)\n@@ -451,7 +454,7 @@ class SQLCompiler:\n         if not parts:\n             raise EmptyResultSet\n         combinator_sql = self.connection.ops.set_operators[combinator]\n-        if all and combinator == 'union':\n+        if all_ and combinator == 'union':\n             combinator_sql += ' ALL'\n         braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n@@ -811,11 +814,11 @@ class SQLCompiler:\n             fields_found.add(f.name)\n \n             if restricted:\n-                next = requested.get(f.name, {})\n+                next_ = requested.get(f.name, {})\n                 if not f.is_relation:\n                     # If a non-related field is used like a relation,\n                     # or if a single non-relational field is given.\n-                    if next or f.name in requested:\n+                    if next_ or f.name in requested:\n                         raise FieldError(\n                             \"Non-relational field given in select_related: '%s'. \"\n                             \"Choices are: %s\" % (\n@@ -824,7 +827,7 @@ class SQLCompiler:\n                             )\n                         )\n             else:\n-                next = False\n+                next_ = False\n \n             if not select_related_descend(f, restricted, requested,\n                                           only_load.get(field_model)):\n@@ -848,7 +851,7 @@ class SQLCompiler:\n                 select.append((col, None))\n             klass_info['select_fields'] = select_fields\n             next_klass_infos = self.get_related_selections(\n-                select, f.remote_field.model._meta, alias, cur_depth + 1, next, restricted)\n+                select, f.remote_field.model._meta, alias, cur_depth + 1, next_, restricted)\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n         if restricted:\n@@ -884,10 +887,10 @@ class SQLCompiler:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n                 klass_info['select_fields'] = select_fields\n-                next = requested.get(f.related_query_name(), {})\n+                next_ = requested.get(f.related_query_name(), {})\n                 next_klass_infos = self.get_related_selections(\n                     select, model._meta, alias, cur_depth + 1,\n-                    next, restricted)\n+                    next_, restricted)\n                 get_related_klass_infos(klass_info, next_klass_infos)\n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -905,7 +908,7 @@ class SQLCompiler:\n                         if from_obj:\n                             f.remote_field.set_cached_value(from_obj, obj)\n \n-                    def remote_setter(obj, from_obj):\n+                    def remote_setter(obj, from_obj, name=name):\n                         setattr(from_obj, name, obj)\n                     klass_info = {\n                         'model': model,\n"
}