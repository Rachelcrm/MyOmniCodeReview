{
  "patch": "diff --git a/sympy/matrices/sparse.py b/sympy/matrices/sparse.py\nindex e6f36cdf35..541d83c3ca 100644\n--- a/sympy/matrices/sparse.py\n+++ b/sympy/matrices/sparse.py\n@@ -5,7 +5,7 @@\n \n from sympy.core.containers import Dict\n from sympy.core.expr import Expr\n-from sympy.core.compatibility import is_sequence, as_int, range\n+from sympy.core.compatibility import is_sequence, as_int, range as xrange\n from sympy.core.logic import fuzzy_and\n from sympy.core.singleton import S\n from sympy.functions import Abs\n@@ -39,7 +39,7 @@ class SparseMatrix(MatrixBase):\n     sympy.matrices.dense.Matrix\n     \"\"\"\n \n-    def __new__(cls, *args, **kwargs):\n+    def __new__(cls, *args, **_kwargs):\n         self = object.__new__(cls)\n         if len(args) == 1 and isinstance(args[0], SparseMatrix):\n             self.rows = args[0].rows\n@@ -55,8 +55,8 @@ def __new__(cls, *args, **kwargs):\n \n             if isinstance(args[2], collections.Callable):\n                 op = args[2]\n-                for i in range(self.rows):\n-                    for j in range(self.cols):\n+                for i in xrange(self.rows):\n+                    for j in xrange(self.cols):\n                         value = self._sympify(\n                             op(self._sympify(i), self._sympify(j)))\n                         if value:\n@@ -73,8 +73,8 @@ def __new__(cls, *args, **kwargs):\n                         'List length (%s) != rows*columns (%s)' %\n                         (len(args[2]), self.rows*self.cols))\n                 flat_list = args[2]\n-                for i in range(self.rows):\n-                    for j in range(self.cols):\n+                for i in xrange(self.rows):\n+                    for j in xrange(self.cols):\n                         value = self._sympify(flat_list[i*self.cols + j])\n                         if value:\n                             self._smat[(i, j)] = value\n@@ -83,8 +83,8 @@ def __new__(cls, *args, **kwargs):\n             r, c, _list = Matrix._handle_creation_inputs(*args)\n             self.rows = r\n             self.cols = c\n-            for i in range(self.rows):\n-                for j in range(self.cols):\n+            for i in xrange(self.rows):\n+                for j in xrange(self.cols):\n                     value = _list[self.cols*i + j]\n                     if value:\n                         self._smat[(i, j)] = value\n@@ -108,10 +108,10 @@ def __getitem__(self, key):\n             try:\n                 i, j = self.key2ij(key)\n                 return self._smat.get((i, j), S.Zero)\n-            except (TypeError, IndexError):\n+            except (TypeError, IndexError) as exc:\n                 if isinstance(i, slice):\n                     # XXX remove list() when PY2 support is dropped\n-                    i = list(range(self.rows))[i]\n+                    i = list(xrange(self.rows))[i]\n                 elif is_sequence(i):\n                     pass\n                 elif isinstance(i, Expr) and not i.is_number:\n@@ -119,11 +119,11 @@ def __getitem__(self, key):\n                     return MatrixElement(self, i, j)\n                 else:\n                     if i >= self.rows:\n-                        raise IndexError('Row index out of bounds')\n+                        raise IndexError('Row index out of bounds') from exc\n                     i = [i]\n                 if isinstance(j, slice):\n                     # XXX remove list() when PY2 support is dropped\n-                    j = list(range(self.cols))[j]\n+                    j = list(xrange(self.cols))[j]\n                 elif is_sequence(j):\n                     pass\n                 elif isinstance(j, Expr) and not j.is_number:\n@@ -131,7 +131,7 @@ def __getitem__(self, key):\n                     return MatrixElement(self, i, j)\n                 else:\n                     if j >= self.cols:\n-                        raise IndexError('Col index out of bounds')\n+                        raise IndexError('Col index out of bounds') from exc\n                     j = [j]\n                 return self.extract(i, j)\n \n@@ -139,7 +139,7 @@ def __getitem__(self, key):\n         if isinstance(key, slice):\n             lo, hi = key.indices(len(self))[:2]\n             L = []\n-            for i in range(lo, hi):\n+            for i in xrange(lo, hi):\n                 m, n = divmod(i, self.cols)\n                 L.append(self._smat.get((m, n), S.Zero))\n             return L\n@@ -165,7 +165,7 @@ def _cholesky_sparse(self):\n         \"\"\"Algorithm for numeric Cholesky factorization of a sparse matrix.\"\"\"\n         Crowstruc = self.row_structure_symbolic_cholesky()\n         C = self.zeros(self.rows)\n-        for i in range(len(Crowstruc)):\n+        for i in xrange(len(Crowstruc)):\n             for j in Crowstruc[i]:\n                 if i != j:\n                     C[i, j] = self[i, j]\n@@ -245,14 +245,14 @@ def _eval_inverse(self, **kwargs):\n         else:\n             raise NotImplementedError(\n                 'Method may be \"CH\" or \"LDL\", not %s.' % method)\n-        rv = M.hstack(*[solve(I[:, i]) for i in range(I.cols)])\n+        rv = M.hstack(*[solve(I[:, i]) for i in xrange(I.cols)])\n         if not sym:\n             scale = (r1*rv[:, 0])[0, 0]\n             rv /= scale\n         return self._new(rv)\n \n     def _eval_Abs(self):\n-        return self.applyfunc(lambda x: Abs(x))\n+        return self.applyfunc(Abs)\n \n     def _eval_add(self, other):\n         \"\"\"If `other` is a SparseMatrix, add efficiently. Otherwise,\n@@ -263,25 +263,25 @@ def _eval_add(self, other):\n         smat = {}\n         zero = self._sympify(0)\n         for key in set().union(self._smat.keys(), other._smat.keys()):\n-            sum = self._smat.get(key, zero) + other._smat.get(key, zero)\n-            if sum != 0:\n-                smat[key] = sum\n+            total = self._smat.get(key, zero) + other._smat.get(key, zero)\n+            if total != 0:\n+                smat[key] = total\n         return self._new(self.rows, self.cols, smat)\n \n-    def _eval_col_insert(self, icol, other):\n+    def _eval_col_insert(self, pos, other):\n         if not isinstance(other, SparseMatrix):\n             other = SparseMatrix(other)\n         new_smat = {}\n         # make room for the new rows\n         for key, val in self._smat.items():\n             row, col = key\n-            if col >= icol:\n+            if col >= pos:\n                 col += other.cols\n             new_smat[(row, col)] = val\n         # add other's keys\n         for key, val in other._smat.items():\n             row, col = key\n-            new_smat[(row, col + icol)] = val\n+            new_smat[(row, col + pos)] = val\n         return self._new(self.rows, self.cols + other.cols, new_smat)\n \n     def _eval_conjugate(self):\n@@ -321,7 +321,7 @@ def _eval_extract(self, rowsList, colsList):\n \n     @classmethod\n     def _eval_eye(cls, rows, cols):\n-        entries = {(i,i): S.One for i in range(min(rows, cols))}\n+        entries = {(i,i): S.One for i in xrange(min(rows, cols))}\n         return cls._new(rows, cols, entries)\n \n     def _eval_has(self, *patterns):\n@@ -334,7 +334,7 @@ def _eval_has(self, *patterns):\n         return any(self[key].has(*patterns) for key in self._smat) or zhas\n \n     def _eval_is_Identity(self):\n-        if not all(self[i, i] == 1 for i in range(self.rows)):\n+        if not all(self[i, i] == 1 for i in xrange(self.rows)):\n             return False\n         return len(self._smat) == self.rows\n \n@@ -367,20 +367,20 @@ def _eval_matrix_mul(self, other):\n                     smat[(row, col)] = val\n         return self._new(self.rows, other.cols, smat)\n \n-    def _eval_row_insert(self, irow, other):\n+    def _eval_row_insert(self, pos, other):\n         if not isinstance(other, SparseMatrix):\n             other = SparseMatrix(other)\n         new_smat = {}\n         # make room for the new rows\n         for key, val in self._smat.items():\n             row, col = key\n-            if row >= irow:\n+            if row >= pos:\n                 row += other.rows\n             new_smat[(row, col)] = val\n         # add other's keys\n         for key, val in other._smat.items():\n             row, col = key\n-            new_smat[(row + irow, col)] = val\n+            new_smat[(row + pos, col)] = val\n         return self._new(self.rows + other.rows, self.cols, new_smat)\n \n     def _eval_scalar_mul(self, other):\n@@ -434,7 +434,7 @@ def _LDL_sparse(self):\n         L = self.eye(self.rows)\n         D = self.zeros(self.rows, self.cols)\n \n-        for i in range(len(Lrowstruc)):\n+        for i in xrange(len(Lrowstruc)):\n             for j in Lrowstruc[i]:\n                 if i != j:\n                     L[i, j] = self[i, j]\n@@ -467,12 +467,12 @@ def _lower_triangular_solve(self, rhs):\n         \"\"\"Fast algorithm for solving a lower-triangular system,\n         exploiting the sparsity of the given matrix.\n         \"\"\"\n-        rows = [[] for i in range(self.rows)]\n+        rows = [[] for i in xrange(self.rows)]\n         for i, j, v in self.row_list():\n             if i > j:\n                 rows[i].append((j, v))\n         X = rhs.copy()\n-        for i in range(self.rows):\n+        for i in xrange(self.rows):\n             for j, v in rows[i]:\n                 X[i, 0] -= v*X[j, 0]\n             X[i, 0] /= self[i, i]\n@@ -488,12 +488,12 @@ def _upper_triangular_solve(self, rhs):\n         \"\"\"Fast algorithm for solving an upper-triangular system,\n         exploiting the sparsity of the given matrix.\n         \"\"\"\n-        rows = [[] for i in range(self.rows)]\n+        rows = [[] for i in xrange(self.rows)]\n         for i, j, v in self.row_list():\n             if i < j:\n                 rows[i].append((j, v))\n         X = rhs.copy()\n-        for i in range(self.rows - 1, -1, -1):\n+        for i in xrange(self.rows - 1, -1, -1):\n             rows[i].reverse()\n             for j, v in rows[i]:\n                 X[i, 0] -= v*X[j, 0]\n@@ -676,7 +676,7 @@ def liupc(self):\n         # Algorithm 2.4, p 17 of reference\n \n         # get the indices of the elements that are non-zero on or below diag\n-        R = [[] for r in range(self.rows)]\n+        R = [[] for r in xrange(self.rows)]\n         for r, c, _ in self.row_list():\n             if c <= r:\n                 R[r].append(c)\n@@ -684,7 +684,7 @@ def liupc(self):\n         inf = len(R)  # nothing will be this large\n         parent = [inf]*self.rows\n         virtual = [inf]*self.rows\n-        for r in range(self.rows):\n+        for r in xrange(self.rows):\n             for c in R[r][:-1]:\n                 while virtual[c] < r:\n                     t = virtual[c]\n@@ -748,7 +748,7 @@ def row_structure_symbolic_cholesky(self):\n         R, parent = self.liupc()\n         inf = len(R)  # this acts as infinity\n         Lrow = copy.deepcopy(R)\n-        for k in range(self.rows):\n+        for k in xrange(self.rows):\n             for j in R[k]:\n                 while j != inf and j != k:\n                     Lrow[k].append(j)\n"
}