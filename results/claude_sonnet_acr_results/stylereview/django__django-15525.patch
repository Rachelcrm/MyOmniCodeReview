{
  "patch": "diff --git a/django/core/serializers/base.py b/django/core/serializers/base.py\nindex da85cb4b92..35f1477948 100644\n--- a/django/core/serializers/base.py\n+++ b/django/core/serializers/base.py\n@@ -36,14 +36,10 @@ class PickleSerializer:\n class SerializerDoesNotExist(KeyError):\n     \"\"\"The requested serializer was not found.\"\"\"\n \n-    pass\n-\n \n class SerializationError(Exception):\n     \"\"\"Something bad happened during serialization.\"\"\"\n \n-    pass\n-\n \n class DeserializationError(Exception):\n     \"\"\"Something bad happened during deserialization.\"\"\"\n@@ -119,6 +115,7 @@ class Serializer:\n         \"\"\"\n         Serialize a queryset.\n         \"\"\"\n+        # pylint: disable=attribute-defined-outside-init\n         self.options = options\n \n         self.stream = stream if stream is not None else self.stream_class()\n@@ -133,18 +130,18 @@ class Serializer:\n             self.start_object(obj)\n             # Use the concrete parent class' _meta instead of the object's _meta\n             # This is to avoid local_fields problems for proxy models. Refs #17717.\n-            concrete_model = obj._meta.concrete_model\n+            concrete_model = obj._meta.concrete_model  # pylint: disable=protected-access\n             # When using natural primary keys, retrieve the pk field of the\n             # parent for multi-table inheritance child models. That field must\n             # be serialized, otherwise deserialization isn't possible.\n             if self.use_natural_primary_keys:\n-                pk = concrete_model._meta.pk\n+                pk = concrete_model._meta.pk  # pylint: disable=protected-access\n                 pk_parent = (\n                     pk if pk.remote_field and pk.remote_field.parent_link else None\n                 )\n             else:\n                 pk_parent = None\n-            for field in concrete_model._meta.local_fields:\n+            for field in concrete_model._meta.local_fields:  # pylint: disable=protected-access\n                 if field.serialize or field is pk_parent:\n                     if field.remote_field is None:\n                         if (\n@@ -158,7 +155,7 @@ class Serializer:\n                             or field.attname[:-3] in self.selected_fields\n                         ):\n                             self.handle_fk_field(obj, field)\n-            for field in concrete_model._meta.local_many_to_many:\n+            for field in concrete_model._meta.local_many_to_many:  # pylint: disable=protected-access\n                 if field.serialize:\n                     if (\n                         self.selected_fields is None\n@@ -167,7 +164,7 @@ class Serializer:\n                         self.handle_m2m_field(obj, field)\n             self.end_object(obj)\n             progress_bar.update(count)\n-            self.first = self.first and False\n+            self.first = self.first and False  # pylint: disable=attribute-defined-outside-init\n         self.end_serialization()\n         return self.getvalue()\n \n@@ -183,7 +180,6 @@ class Serializer:\n         \"\"\"\n         Called when serializing of the queryset ends.\n         \"\"\"\n-        pass\n \n     def start_object(self, obj):\n         \"\"\"\n@@ -197,7 +193,6 @@ class Serializer:\n         \"\"\"\n         Called when serializing of an object ends.\n         \"\"\"\n-        pass\n \n     def handle_field(self, obj, field):\n         \"\"\"\n@@ -297,7 +292,7 @@ class DeserializedObject:\n     def save_deferred_fields(self, using=None):\n         self.m2m_data = {}\n         for field, field_value in self.deferred_fields.items():\n-            opts = self.object._meta\n+            opts = self.object._meta  # pylint: disable=protected-access\n             label = opts.app_label + \".\" + opts.model_name\n             if isinstance(field.remote_field, models.ManyToManyRel):\n                 try:\n@@ -329,16 +324,18 @@ def build_instance(Model, data, db):\n     If the model instance doesn't have a primary key and the model supports\n     natural keys, try to retrieve it from the database.\n     \"\"\"\n-    default_manager = Model._meta.default_manager\n-    pk = data.get(Model._meta.pk.attname)\n+    default_manager = Model._meta.default_manager  # pylint: disable=protected-access\n+    pk = data.get(Model._meta.pk.attname)  # pylint: disable=protected-access\n     if (\n         pk is None\n         and hasattr(default_manager, \"get_by_natural_key\")\n         and hasattr(Model, \"natural_key\")\n     ):\n         natural_key = Model(**data).natural_key()\n+        obj = Model(**data)\n+        obj._state.adding = False  # pylint: disable=protected-access\n         try:\n-            data[Model._meta.pk.attname] = Model._meta.pk.to_python(\n+            data[Model._meta.pk.attname] = Model._meta.pk.to_python(  # pylint: disable=protected-access\n                 default_manager.db_manager(db).get_by_natural_key(*natural_key).pk\n             )\n         except Model.DoesNotExist:\n"
}