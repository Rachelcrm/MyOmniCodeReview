{
  "patch": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex f0bdb1481..bc95c4cda 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -146,14 +146,14 @@ def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:\n             yield x\n \n \n-def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:\n+def extract_suffixes(paths: Iterable[PurePath], prefix: str) -> Iterator[str]:\n     \"\"\"Return the parts of the paths following the prefix.\n \n-    :param iter: Iterator over path names.\n+    :param paths: Iterator over path names.\n     :param prefix: Expected prefix of the path names.\n     \"\"\"\n     p_len = len(prefix)\n-    for p in iter:\n+    for p in paths:\n         yield p.name[p_len:]\n \n \n@@ -188,29 +188,28 @@ def _force_symlink(\n         pass\n     try:\n         current_symlink.symlink_to(link_to)\n-    except Exception:\n+    except OSError:\n         pass\n \n \n def make_numbered_dir(root: Path, prefix: str) -> Path:\n     \"\"\"Create a directory with an increased number as suffix for the given prefix.\"\"\"\n-    for i in range(10):\n+    for _ in range(10):\n         # try up to 10 times to create the folder\n         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n         new_number = max_existing + 1\n         new_path = root.joinpath(f\"{prefix}{new_number}\")\n         try:\n             new_path.mkdir()\n-        except Exception:\n+        except OSError:\n             pass\n         else:\n             _force_symlink(root, prefix + \"current\", new_path)\n             return new_path\n-    else:\n-        raise OSError(\n-            \"could not create numbered dir with prefix \"\n-            \"{prefix} in {root} after 10 tries\".format(prefix=prefix, root=root)\n-        )\n+    raise OSError(\n+        \"could not create numbered dir with prefix \"\n+        \"{prefix} in {root} after 10 tries\".format(prefix=prefix, root=root)\n+    )\n \n \n def create_cleanup_lock(p: Path) -> Path:\n@@ -289,7 +288,7 @@ def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) ->\n         return False\n     try:\n         lock_time = lock.stat().st_mtime\n-    except Exception:\n+    except OSError:\n         return False\n     else:\n         if lock_time < consider_lock_dead_if_created_before:\n@@ -336,12 +335,12 @@ def make_numbered_dir_with_cleanup(\n ) -> Path:\n     \"\"\"Create a numbered dir with a cleanup lock and remove old ones.\"\"\"\n     e = None\n-    for i in range(10):\n+    for _ in range(10):\n         try:\n             p = make_numbered_dir(root, prefix)\n             lock_path = create_cleanup_lock(p)\n             register_cleanup_lock_removal(lock_path)\n-        except Exception as exc:\n+        except OSError as exc:\n             e = exc\n         else:\n             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout\n@@ -358,13 +357,13 @@ def make_numbered_dir_with_cleanup(\n     raise e\n \n \n-def resolve_from_str(input: str, rootpath: Path) -> Path:\n-    input = expanduser(input)\n-    input = expandvars(input)\n-    if isabs(input):\n-        return Path(input)\n+def resolve_from_str(input_str: str, rootpath: Path) -> Path:\n+    input_str = expanduser(input_str)\n+    input_str = expandvars(input_str)\n+    if isabs(input_str):\n+        return Path(input_str)\n     else:\n-        return rootpath.joinpath(input)\n+        return rootpath.joinpath(input_str)\n \n \n def fnmatch_ex(pattern: str, path) -> bool:\n@@ -404,8 +403,8 @@ def fnmatch_ex(pattern: str, path) -> bool:\n \n \n def parts(s: str) -> Set[str]:\n-    parts = s.split(sep)\n-    return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}\n+    path_parts = s.split(sep)\n+    return {sep.join(path_parts[: i + 1]) or sep for i in range(len(path_parts))}\n \n \n def symlink_or_skip(src, dst, **kwargs):\n@@ -434,7 +433,7 @@ class ImportPathMismatchError(ImportError):\n \n \n def import_path(\n-    p: Union[str, py.path.local, Path],\n+    p: Union[str, Path],\n     *,\n     mode: Union[str, ImportMode] = ImportMode.prepend,\n ) -> ModuleType:\n"
}