{
  "patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0fd69059ee..f89e0db70d 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -133,7 +133,7 @@ class Field(RegisterLookupMixin):\n                  db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n                  serialize=True, unique_for_date=None, unique_for_month=None,\n                  unique_for_year=None, choices=None, help_text='', db_column=None,\n-                 db_tablespace=None, auto_created=False, validators=(),\n+                 db_tablespace=None, auto_created=False, field_validators=(),\n                  error_messages=None):\n         self.name = name\n         self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n@@ -166,7 +166,7 @@ class Field(RegisterLookupMixin):\n             self.creation_counter = Field.creation_counter\n             Field.creation_counter += 1\n \n-        self._validators = list(validators)  # Store for deconstruction later\n+        self._validators = list(field_validators)  # Store for deconstruction later\n \n         messages = {}\n         for c in reversed(self.__class__.__mro__):\n@@ -406,7 +406,7 @@ class Field(RegisterLookupMixin):\n         from django.db.models.expressions import Col\n         return Col(self.model._meta.db_table, self)\n \n-    def select_format(self, compiler, sql, params):\n+    def select_format(self, _compiler, sql, params):\n         \"\"\"\n         Custom format for select clauses. For example, GIS columns need to be\n         selected as AsText(table.col) on MySQL as the table.col data can't be\n@@ -510,7 +510,7 @@ class Field(RegisterLookupMixin):\n         Uses deconstruct() to clone a new copy of this Field.\n         Will not preserve any class attachments/attribute names.\n         \"\"\"\n-        name, path, args, kwargs = self.deconstruct()\n+        _, _, args, kwargs = self.deconstruct()\n         return self.__class__(*args, **kwargs)\n \n     def __eq__(self, other):\n@@ -533,9 +533,9 @@ class Field(RegisterLookupMixin):\n         # intended to be altered after initial creation.\n         obj = copy.copy(self)\n         if self.remote_field:\n-            obj.remote_field = copy.copy(self.remote_field)\n+            obj.remote_field = copy.copy(self.remote_field)  # pylint: disable=attribute-defined-outside-init\n             if hasattr(self.remote_field, 'field') and self.remote_field.field is self:\n-                obj.remote_field.field = obj\n+                obj.remote_field.field = obj  # pylint: disable=attribute-defined-outside-init\n         memodict[id(self)] = obj\n         return obj\n \n@@ -567,7 +567,7 @@ class Field(RegisterLookupMixin):\n         return _load_field, (self.model._meta.app_label, self.model._meta.object_name,\n                              self.name)\n \n-    def get_pk_value_on_save(self, instance):\n+    def get_pk_value_on_save(self, _instance):\n         \"\"\"\n         Hook to generate new PK values on save. This method is called when\n         saving instances with no primary key value set. If this method returns\n@@ -610,7 +610,7 @@ class Field(RegisterLookupMixin):\n         if errors:\n             raise exceptions.ValidationError(errors)\n \n-    def validate(self, value, model_instance):\n+    def validate(self, value, _model_instance):\n         \"\"\"\n         Validate value and raise ValidationError if necessary. Subclasses\n         should override this to provide validation logic.\n@@ -624,7 +624,7 @@ class Field(RegisterLookupMixin):\n                 if isinstance(option_value, (list, tuple)):\n                     # This is an optgroup, so look inside the group for\n                     # options.\n-                    for optgroup_key, optgroup_value in option_value:\n+                    for optgroup_key, _ in option_value:\n                         if value == optgroup_key:\n                             return\n                 elif value == option_key:\n@@ -652,22 +652,22 @@ class Field(RegisterLookupMixin):\n         self.run_validators(value)\n         return value\n \n-    def db_type_parameters(self, connection):\n-        return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')\n+    def db_type_parameters(self, db_connection):\n+        return DictWrapper(self.__dict__, db_connection.ops.quote_name, 'qn_')\n \n-    def db_check(self, connection):\n+    def db_check(self, db_connection):\n         \"\"\"\n         Return the database column check constraint for this field, for the\n         provided connection. Works the same way as db_type() for the case that\n         get_internal_type() does not map to a preexisting model field.\n         \"\"\"\n-        data = self.db_type_parameters(connection)\n+        data = self.db_type_parameters(db_connection)\n         try:\n-            return connection.data_type_check_constraints[self.get_internal_type()] % data\n+            return db_connection.data_type_check_constraints[self.get_internal_type()] % data\n         except KeyError:\n             return None\n \n-    def db_type(self, connection):\n+    def db_type(self, db_connection):\n         \"\"\"\n         Return the database column data type for this field, for the provided\n         connection.\n@@ -687,35 +687,35 @@ class Field(RegisterLookupMixin):\n         # mapped to one of the built-in Django field types. In this case, you\n         # can implement db_type() instead of get_internal_type() to specify\n         # exactly which wacky database column type you want to use.\n-        data = self.db_type_parameters(connection)\n+        data = self.db_type_parameters(db_connection)\n         try:\n-            return connection.data_types[self.get_internal_type()] % data\n+            return db_connection.data_types[self.get_internal_type()] % data\n         except KeyError:\n             return None\n \n-    def rel_db_type(self, connection):\n+    def rel_db_type(self, db_connection):\n         \"\"\"\n         Return the data type that a related field pointing to this field should\n         use. For example, this method is called by ForeignKey and OneToOneField\n         to determine its data type.\n         \"\"\"\n-        return self.db_type(connection)\n+        return self.db_type(db_connection)\n \n-    def cast_db_type(self, connection):\n+    def cast_db_type(self, db_connection):\n         \"\"\"Return the data type to use in the Cast() function.\"\"\"\n-        db_type = connection.ops.cast_data_types.get(self.get_internal_type())\n+        db_type = db_connection.ops.cast_data_types.get(self.get_internal_type())\n         if db_type:\n-            return db_type % self.db_type_parameters(connection)\n-        return self.db_type(connection)\n+            return db_type % self.db_type_parameters(db_connection)\n+        return self.db_type(db_connection)\n \n-    def db_parameters(self, connection):\n+    def db_parameters(self, db_connection):\n         \"\"\"\n         Extension of db_type(), providing a range of different return values\n         (type, checks). This will look at db_type(), allowing custom model\n         fields to override it.\n         \"\"\"\n-        type_string = self.db_type(connection)\n-        check_string = self.db_check(connection)\n+        type_string = self.db_type(db_connection)\n+        check_string = self.db_check(db_connection)\n         return {\n             \"type\": type_string,\n             \"check\": check_string,\n"
}