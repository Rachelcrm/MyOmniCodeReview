{
  "patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..a8c56411e9 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -45,8 +45,9 @@ class JSONField(CheckFieldDefaultMixin, Field):\n             if not router.allow_migrate_model(db, self.model):\n                 continue\n             connection = connections[db]\n+            required_db_features = getattr(self.model._meta, 'required_db_features', [])\n             if not (\n-                'supports_json_field' in self.model._meta.required_db_features or\n+                'supports_json_field' in required_db_features or\n                 connection.features.supports_json_field\n             ):\n                 errors.append(\n@@ -67,7 +68,7 @@ class JSONField(CheckFieldDefaultMixin, Field):\n             kwargs['decoder'] = self.decoder\n         return name, path, args, kwargs\n \n-    def from_db_value(self, value, expression, connection):\n+    def from_db_value(self, value, _expression, connection):\n         if value is None:\n             return value\n         if connection.features.has_native_json_field and self.decoder is None:\n@@ -103,17 +104,17 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         super().validate(value, model_instance)\n         try:\n             json.dumps(value, cls=self.encoder)\n-        except TypeError:\n+        except TypeError as e:\n             raise exceptions.ValidationError(\n                 self.error_messages['invalid'],\n                 code='invalid',\n                 params={'value': value},\n-            )\n+            ) from e\n \n     def value_to_string(self, obj):\n         return self.value_from_object(obj)\n \n-    def formfield(self, **kwargs):\n+    def formfield(self, form_class=None, choices_form_class=None, **kwargs):\n         return super().formfield(**{\n             'form_class': forms.JSONField,\n             'encoder': self.encoder,\n@@ -241,8 +242,8 @@ class HasAnyKeys(HasKeys):\n class JSONExact(lookups.Exact):\n     can_use_none_as_rhs = True\n \n-    def process_lhs(self, compiler, connection):\n-        lhs, lhs_params = super().process_lhs(compiler, connection)\n+    def process_lhs(self, compiler, connection, lhs_only=False):\n+        lhs, lhs_params = super().process_lhs(compiler, connection, lhs_only)\n         if connection.vendor == 'sqlite':\n             rhs, rhs_params = super().process_rhs(compiler, connection)\n             if rhs == '%s' and rhs_params == [None]:\n@@ -314,7 +315,7 @@ class KeyTransform(Transform):\n             lookup = self.key_name\n         return '(%s %s %%s)' % (lhs, self.postgres_operator), tuple(params) + (lookup,)\n \n-    def as_sqlite(self, compiler, connection):\n+    def as_sqlite(self, compiler, connection, *args, **kwargs):\n         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n         json_path = compile_json_path(key_transforms)\n         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n@@ -390,7 +391,7 @@ class KeyTransformExact(JSONExact):\n \n     def process_rhs(self, compiler, connection):\n         if isinstance(self.rhs, KeyTransform):\n-            return super(lookups.Exact, self).process_rhs(compiler, connection)\n+            return super().process_rhs(compiler, connection)\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n         if connection.vendor == 'oracle':\n             func = []\n@@ -409,7 +410,7 @@ class KeyTransformExact(JSONExact):\n         return rhs, rhs_params\n \n     def as_oracle(self, compiler, connection):\n-        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        _rhs, rhs_params = super().process_rhs(compiler, connection)\n         if rhs_params == ['null']:\n             # Field has key and it's NULL.\n             has_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)\n"
}