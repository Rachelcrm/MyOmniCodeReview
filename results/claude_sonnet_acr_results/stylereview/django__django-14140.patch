{
  "patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex ae0f886107..146e654b12 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -70,10 +70,10 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, _summarize=False, _for_save=False):\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n+        clause, joins = query._add_q(  # pylint: disable=protected-access\n             self, reuse, allow_joins=allow_joins, split_subq=False,\n             check_filterable=False,\n         )\n@@ -130,7 +130,7 @@ class DeferredAttribute:\n         loaded in the instance. This can be done if the to-be fetched\n         field is a primary key field.\n         \"\"\"\n-        opts = instance._meta\n+        opts = instance._meta  # pylint: disable=protected-access\n         link_field = opts.get_ancestor_link(self.field.model)\n         if self.field.primary_key and self.field != link_field:\n             return getattr(instance, link_field.attname)\n@@ -236,7 +236,7 @@ def select_related_descend(field, restricted, requested, load_fields, reverse=Fa\n                 msg = (\n                     'Field %s.%s cannot be both deferred and traversed using '\n                     'select_related at the same time.'\n-                ) % (field.model._meta.object_name, field.name)\n+                ) % (field.model._meta.object_name, field.name)  # pylint: disable=protected-access\n                 raise FieldError(msg)\n     return True\n \n@@ -263,8 +263,8 @@ def check_rel_lookup_compatibility(model, target_opts, field):\n     \"\"\"\n     def check(opts):\n         return (\n-            model._meta.concrete_model == opts.concrete_model or\n-            opts.concrete_model in model._meta.get_parent_list() or\n+            model._meta.concrete_model == opts.concrete_model or  # pylint: disable=protected-access\n+            opts.concrete_model in model._meta.get_parent_list() or  # pylint: disable=protected-access\n             model in opts.get_parent_list()\n         )\n     # If the field is a primary key, then doing a query against the field's\n@@ -278,7 +278,7 @@ def check_rel_lookup_compatibility(model, target_opts, field):\n     # we are going to turn this into __in=qs.values('pk') later on.\n     return (\n         check(target_opts) or\n-        (getattr(field, 'primary_key', False) and check(field.model._meta))\n+        (getattr(field, 'primary_key', False) and check(field.model._meta))  # pylint: disable=protected-access\n     )\n \n \n@@ -317,7 +317,7 @@ class FilteredRelation:\n         \"\"\"\n         raise NotImplementedError('FilteredRelation.resolve_expression() is unused.')\n \n-    def as_sql(self, compiler, connection):\n+    def as_sql(self, compiler, _connection):\n         # Resolve the condition in Join.filtered_relation.\n         query = compiler.query\n         where = query.build_filtered_relation_q(self.condition, reuse=set(self.path))\n"
}