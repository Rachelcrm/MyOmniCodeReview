{
  "patch": "diff --git a/youtube_dl/YoutubeDL.py b/youtube_dl/YoutubeDL.py\nindex fe30758ef..161aafb19 100755\n--- a/youtube_dl/YoutubeDL.py\n+++ b/youtube_dl/YoutubeDL.py\n@@ -771,7 +771,7 @@ class YoutubeDL(object):\n         for key, value in extra_info.items():\n             info_dict.setdefault(key, value)\n \n-    def extract_info(self, url, download=True, ie_key=None, extra_info={},\n+    def extract_info(self, url, download=True, ie_key=None, extra_info=None,\n                      process=True, force_generic_extractor=False):\n         \"\"\"\n         Return a list with a dictionary for each video extracted.\n@@ -787,6 +787,8 @@ class YoutubeDL(object):\n             must be True for download to work.\n         force_generic_extractor -- force using the generic extractor\n         \"\"\"\n+        \n+        extra_info = extra_info or {}\n \n         if not ie_key and force_generic_extractor:\n             ie_key = 'Generic'\n@@ -806,9 +808,10 @@ class YoutubeDL(object):\n                                     'and will probably not work.')\n \n             return self.__extract_info(url, ie, download, extra_info, process)\n-        else:\n-            self.report_error('no suitable InfoExtractor for URL %s' % url)\n+        \n+        self.report_error('no suitable InfoExtractor for URL %s' % url)\n \n+    @staticmethod\n     def __handle_extraction_exceptions(func):\n         def wrapper(self, *args, **kwargs):\n             try:\n@@ -856,7 +859,7 @@ class YoutubeDL(object):\n             'extractor_key': ie.ie_key(),\n         })\n \n-    def process_ie_result(self, ie_result, download=True, extra_info={}):\n+    def process_ie_result(self, ie_result, download=True, extra_info=None):\n         \"\"\"\n         Take the result of the ie(may be modified) and resolve all unresolved\n         references (URLs, playlist items).\n@@ -864,6 +867,8 @@ class YoutubeDL(object):\n         It will also download the videos if 'download'.\n         Returns the resolved ie_result.\n         \"\"\"\n+        \n+        extra_info = extra_info or {}\n         result_type = ie_result.get('_type', 'video')\n \n         if result_type in ('url', 'url_transparent'):\n@@ -957,7 +962,7 @@ class YoutubeDL(object):\n             ]\n             return ie_result\n         else:\n-            raise Exception('Invalid result type: %s' % result_type)\n+            raise ValueError('Invalid result type: %s' % result_type)\n \n     def __process_playlist(self, ie_result, download):\n         # We process each entry in the playlist\n@@ -976,8 +981,8 @@ class YoutubeDL(object):\n         playlistitems_str = self.params.get('playlist_items')\n         playlistitems = None\n         if playlistitems_str is not None:\n-            def iter_playlistitems(format):\n-                for string_segment in format.split(','):\n+            def iter_playlistitems(format_str):\n+                for string_segment in format_str.split(','):\n                     if '-' in string_segment:\n                         start, end = string_segment.split('-')\n                         for item in range(int(start), int(end) + 1):\n@@ -1589,45 +1594,45 @@ class YoutubeDL(object):\n         formats_dict = {}\n \n         # We check that all the formats have the format and format_id fields\n-        for i, format in enumerate(formats):\n-            sanitize_string_field(format, 'format_id')\n-            sanitize_numeric_fields(format)\n-            format['url'] = sanitize_url(format['url'])\n-            if not format.get('format_id'):\n-                format['format_id'] = compat_str(i)\n+        for i, fmt in enumerate(formats):\n+            sanitize_string_field(fmt, 'format_id')\n+            sanitize_numeric_fields(fmt)\n+            fmt['url'] = sanitize_url(fmt['url'])\n+            if not fmt.get('format_id'):\n+                fmt['format_id'] = compat_str(i)\n             else:\n                 # Sanitize format_id from characters used in format selector expression\n-                format['format_id'] = re.sub(r'[\\s,/+\\[\\]()]', '_', format['format_id'])\n-            format_id = format['format_id']\n+                fmt['format_id'] = re.sub(r'[\\s,/+\\[\\]()]', '_', fmt['format_id'])\n+            format_id = fmt['format_id']\n             if format_id not in formats_dict:\n                 formats_dict[format_id] = []\n-            formats_dict[format_id].append(format)\n+            formats_dict[format_id].append(fmt)\n \n         # Make sure all formats have unique format_id\n         for format_id, ambiguous_formats in formats_dict.items():\n             if len(ambiguous_formats) > 1:\n-                for i, format in enumerate(ambiguous_formats):\n-                    format['format_id'] = '%s-%d' % (format_id, i)\n-\n-        for i, format in enumerate(formats):\n-            if format.get('format') is None:\n-                format['format'] = '{id} - {res}{note}'.format(\n-                    id=format['format_id'],\n-                    res=self.format_resolution(format),\n-                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n+                for i, fmt in enumerate(ambiguous_formats):\n+                    fmt['format_id'] = '%s-%d' % (format_id, i)\n+\n+        for i, fmt in enumerate(formats):\n+            if fmt.get('format') is None:\n+                fmt['format'] = '{id} - {res}{note}'.format(\n+                    id=fmt['format_id'],\n+                    res=self.format_resolution(fmt),\n+                    note=' ({0})'.format(fmt['format_note']) if fmt.get('format_note') is not None else '',\n                 )\n             # Automatically determine file extension if missing\n-            if format.get('ext') is None:\n-                format['ext'] = determine_ext(format['url']).lower()\n+            if fmt.get('ext') is None:\n+                fmt['ext'] = determine_ext(fmt['url']).lower()\n             # Automatically determine protocol if missing (useful for format\n             # selection purposes)\n-            if format.get('protocol') is None:\n-                format['protocol'] = determine_protocol(format)\n+            if fmt.get('protocol') is None:\n+                fmt['protocol'] = determine_protocol(fmt)\n             # Add HTTP headers, so that external programs can use them from the\n             # json output\n             full_format_info = info_dict.copy()\n-            full_format_info.update(format)\n-            format['http_headers'] = self._calc_headers(full_format_info)\n+            full_format_info.update(fmt)\n+            fmt['http_headers'] = self._calc_headers(full_format_info)\n         # Remove private housekeeping stuff\n         if '__x_forwarded_for_ip' in info_dict:\n             del info_dict['__x_forwarded_for_ip']\n@@ -1686,9 +1691,9 @@ class YoutubeDL(object):\n         if download:\n             if len(formats_to_download) > 1:\n                 self.to_screen('[info] %s: downloading video in %s formats' % (info_dict['id'], len(formats_to_download)))\n-            for format in formats_to_download:\n+            for fmt in formats_to_download:\n                 new_info = dict(info_dict)\n-                new_info.update(format)\n+                new_info.update(fmt)\n                 self.process_info(new_info)\n         # We update the info dict with the best quality format (backwards compatibility)\n         info_dict.update(formats_to_download[-1])\n"
}