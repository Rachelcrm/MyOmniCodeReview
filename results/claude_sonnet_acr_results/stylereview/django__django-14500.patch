{
  "patch": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex 57042a8690..793e548290 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -141,7 +141,7 @@ class MigrationExecutor:\n                 if 'apps' not in state.__dict__:\n                     if self.progress_callback:\n                         self.progress_callback(\"render_start\")\n-                    state.apps  # Render all -- performance critical\n+                    _ = state.apps  # Render all -- performance critical\n                     if self.progress_callback:\n                         self.progress_callback(\"render_success\")\n                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)\n@@ -178,7 +178,7 @@ class MigrationExecutor:\n                 break\n             if migration in migrations_to_run:\n                 if 'apps' not in state.__dict__:\n-                    state.apps  # Render all -- performance critical\n+                    _ = state.apps  # Render all -- performance critical\n                 # The state before this migration\n                 states[migration] = state\n                 # The old state keeps as-is, we continue with the new state\n@@ -290,10 +290,10 @@ class MigrationExecutor:\n             models that can't be migrated on the current database.\n             \"\"\"\n             return (\n-                model._meta.proxy or not model._meta.managed or not\n+                model._meta.proxy or not model._meta.managed or not  # pylint: disable=protected-access\n                 router.allow_migrate(\n                     self.connection.alias, migration.app_label,\n-                    model_name=model._meta.model_name,\n+                    model_name=model._meta.model_name,  # pylint: disable=protected-access\n                 )\n             )\n \n@@ -321,13 +321,13 @@ class MigrationExecutor:\n         for operation in migration.operations:\n             if isinstance(operation, migrations.CreateModel):\n                 model = apps.get_model(migration.app_label, operation.name)\n-                if model._meta.swapped:\n+                if model._meta.swapped:  # pylint: disable=protected-access\n                     # We have to fetch the model to test with from the\n                     # main app cache, as it's not a direct dependency.\n-                    model = global_apps.get_model(model._meta.swapped)\n+                    model = global_apps.get_model(model._meta.swapped)  # pylint: disable=protected-access\n                 if should_skip_detecting_model(migration, model):\n                     continue\n-                db_table = model._meta.db_table\n+                db_table = model._meta.db_table  # pylint: disable=protected-access\n                 if fold_identifier_case:\n                     db_table = db_table.casefold()\n                 if db_table not in existing_table_names:\n@@ -335,19 +335,19 @@ class MigrationExecutor:\n                 found_create_model_migration = True\n             elif isinstance(operation, migrations.AddField):\n                 model = apps.get_model(migration.app_label, operation.model_name)\n-                if model._meta.swapped:\n+                if model._meta.swapped:  # pylint: disable=protected-access\n                     # We have to fetch the model to test with from the\n                     # main app cache, as it's not a direct dependency.\n-                    model = global_apps.get_model(model._meta.swapped)\n+                    model = global_apps.get_model(model._meta.swapped)  # pylint: disable=protected-access\n                 if should_skip_detecting_model(migration, model):\n                     continue\n \n-                table = model._meta.db_table\n-                field = model._meta.get_field(operation.name)\n+                table = model._meta.db_table  # pylint: disable=protected-access\n+                field = model._meta.get_field(operation.name)  # pylint: disable=protected-access\n \n                 # Handle implicit many-to-many tables created by AddField.\n                 if field.many_to_many:\n-                    through_db_table = field.remote_field.through._meta.db_table\n+                    through_db_table = field.remote_field.through._meta.db_table  # pylint: disable=protected-access\n                     if fold_identifier_case:\n                         through_db_table = through_db_table.casefold()\n                     if through_db_table not in existing_table_names:\n"
}