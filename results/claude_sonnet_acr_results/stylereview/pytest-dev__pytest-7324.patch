{
  "patch": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..2c4c2011b 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -74,23 +74,23 @@ class ParseError(Exception):\n class Scanner:\n     __slots__ = (\"tokens\", \"current\")\n \n-    def __init__(self, input: str) -> None:\n-        self.tokens = self.lex(input)\n+    def __init__(self, input_str: str) -> None:\n+        self.tokens = self.lex(input_str)\n         self.current = next(self.tokens)\n \n-    def lex(self, input: str) -> Iterator[Token]:\n+    def lex(self, input_str: str) -> Iterator[Token]:\n         pos = 0\n-        while pos < len(input):\n-            if input[pos] in (\" \", \"\\t\"):\n+        while pos < len(input_str):\n+            if input_str[pos] in (\" \", \"\\t\"):\n                 pos += 1\n-            elif input[pos] == \"(\":\n+            elif input_str[pos] == \"(\":\n                 yield Token(TokenType.LPAREN, \"(\", pos)\n                 pos += 1\n-            elif input[pos] == \")\":\n+            elif input_str[pos] == \")\":\n                 yield Token(TokenType.RPAREN, \")\", pos)\n                 pos += 1\n             else:\n-                match = re.match(r\"(:?\\w|:|\\+|-|\\.|\\[|\\])+\", input[pos:])\n+                match = re.match(r\"(:?\\w|:|\\+|-|\\.|\\[|\\])+\", input_str[pos:])\n                 if match:\n                     value = match.group(0)\n                     if value == \"or\":\n@@ -104,18 +104,18 @@ class Scanner:\n                     pos += len(value)\n                 else:\n                     raise ParseError(\n-                        pos + 1, 'unexpected character \"{}\"'.format(input[pos]),\n+                        pos + 1, 'unexpected character \"{}\"'.format(input_str[pos]),\n                     )\n         yield Token(TokenType.EOF, \"\", pos)\n \n-    def accept(self, type: TokenType, *, reject: bool = False) -> Optional[Token]:\n-        if self.current.type is type:\n+    def accept(self, token_type: TokenType, *, reject: bool = False) -> Optional[Token]:\n+        if self.current.type is token_type:\n             token = self.current\n             if token.type is not TokenType.EOF:\n                 self.current = next(self.tokens)\n             return token\n         if reject:\n-            self.reject((type,))\n+            self.reject((token_type,))\n         return None\n \n     def reject(self, expected: Sequence[TokenType]) -> \"NoReturn\":\n@@ -193,12 +193,12 @@ class Expression:\n         self.code = code\n \n     @classmethod\n-    def compile(self, input: str) -> \"Expression\":\n+    def compile(self, input_str: str) -> \"Expression\":\n         \"\"\"Compile a match expression.\n \n-        :param input: The input expression - one line.\n+        :param input_str: The input expression - one line.\n         \"\"\"\n-        astexpr = expression(Scanner(input))\n+        astexpr = expression(Scanner(input_str))\n         code = compile(\n             astexpr, filename=\"<pytest match expression>\", mode=\"eval\",\n         )  # type: types.CodeType\n@@ -212,7 +212,7 @@ class Expression:\n \n         Returns whether the expression matches or not.\n         \"\"\"\n-        ret = eval(\n+        ret = eval(  # pylint: disable=eval-used\n             self.code, {\"__builtins__\": {}}, MatcherAdapter(matcher)\n         )  # type: bool\n         return ret\n"
}