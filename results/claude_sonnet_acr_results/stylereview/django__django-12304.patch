{
  "patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex f48143ddaf..abc3527527 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -30,32 +30,32 @@ class ChoicesMeta(enum.EnumMeta):\n         # Add a label property to instances of enum which uses the enum member\n         # that is passed in as \"self\" as the value to use when looking up the\n         # label in the choices.\n-        cls.label = property(lambda self: cls._value2label_map_.get(self.value))\n+        cls.label = property(lambda self: cls._value2label_map_.get(self.value))  # pylint: disable=protected-access\n         return enum.unique(cls)\n \n     def __contains__(cls, member):\n         if not isinstance(member, enum.Enum):\n             # Allow non-enums to match against member values.\n-            return any(x.value == member for x in cls)\n+            return any(x.value == member for x in cls)  # pylint: disable=not-an-iterable\n         return super().__contains__(member)\n \n     @property\n     def names(cls):\n         empty = ['__empty__'] if hasattr(cls, '__empty__') else []\n-        return empty + [member.name for member in cls]\n+        return empty + [member.name for member in cls]  # pylint: disable=not-an-iterable\n \n     @property\n     def choices(cls):\n         empty = [(None, cls.__empty__)] if hasattr(cls, '__empty__') else []\n-        return empty + [(member.value, member.label) for member in cls]\n+        return empty + [(member.value, member.label) for member in cls]  # pylint: disable=not-an-iterable\n \n     @property\n     def labels(cls):\n-        return [label for _, label in cls.choices]\n+        return [label for _, label in cls.choices]  # pylint: disable=not-an-iterable\n \n     @property\n     def values(cls):\n-        return [value for value, _ in cls.choices]\n+        return [value for value, _ in cls.choices]  # pylint: disable=not-an-iterable\n \n \n class Choices(enum.Enum, metaclass=ChoicesMeta):\n@@ -71,11 +71,11 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n \n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n-    pass\n \n \n class TextChoices(str, Choices):\n     \"\"\"Class for creating enumerated string choices.\"\"\"\n \n+    @staticmethod\n     def _generate_next_value_(name, start, count, last_values):\n         return name\n"
}