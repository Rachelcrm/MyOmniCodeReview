{
  "patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..24ab650045 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -30,24 +30,24 @@ def PROTECT(collector, field, sub_objs, using):\n \n def SET(value):\n     if callable(value):\n-        def set_on_delete(collector, field, sub_objs, using):\n+        def set_on_delete(collector, field, sub_objs, using):  # pylint: disable=unused-argument\n             collector.add_field_update(field, value(), sub_objs)\n     else:\n-        def set_on_delete(collector, field, sub_objs, using):\n+        def set_on_delete(collector, field, sub_objs, using):  # pylint: disable=unused-argument\n             collector.add_field_update(field, value, sub_objs)\n     set_on_delete.deconstruct = lambda: ('django.db.models.SET', (value,), {})\n     return set_on_delete\n \n \n-def SET_NULL(collector, field, sub_objs, using):\n+def SET_NULL(collector, field, sub_objs, using):  # pylint: disable=unused-argument\n     collector.add_field_update(field, None, sub_objs)\n \n \n-def SET_DEFAULT(collector, field, sub_objs, using):\n+def SET_DEFAULT(collector, field, sub_objs, using):  # pylint: disable=unused-argument\n     collector.add_field_update(field, field.get_default(), sub_objs)\n \n \n-def DO_NOTHING(collector, field, sub_objs, using):\n+def DO_NOTHING(collector, field, sub_objs, using):  # pylint: disable=unused-argument\n     pass\n \n \n@@ -101,7 +101,7 @@ class Collector:\n             if reverse_dependency:\n                 source, model = model, source\n             self.dependencies.setdefault(\n-                source._meta.concrete_model, set()).add(model._meta.concrete_model)\n+                source._meta.concrete_model, set()).add(model._meta.concrete_model)  # pylint: disable=protected-access\n         return new_objs\n \n     def add_field_update(self, field, value, objs):\n@@ -141,9 +141,9 @@ class Collector:\n             return False\n         # The use of from_field comes from the need to avoid cascade back to\n         # parent when parent delete is cascading to child.\n-        opts = model._meta\n+        opts = model._meta  # pylint: disable=protected-access\n         return (\n-            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n+            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and  # pylint: disable=protected-access\n             # Foreign keys pointing to this model.\n             all(\n                 related.field.remote_field.on_delete is DO_NOTHING\n@@ -167,7 +167,7 @@ class Collector:\n             return [objs]\n \n     def collect(self, objs, source=None, nullable=False, collect_related=True,\n-                source_attr=None, reverse_dependency=False, keep_parents=False):\n+                source_attr=None, reverse_dependency=False, keep_parents=False):  # pylint: disable=unused-argument\n         \"\"\"\n         Add 'objs' to the collection of objects to be deleted as well as all\n         parent instances.  'objs' must be a homogeneous iterable collection of\n@@ -198,8 +198,8 @@ class Collector:\n         if not keep_parents:\n             # Recursively collect concrete model's parent models, but not their\n             # related objects. These will be found by meta.get_fields()\n-            concrete_model = model._meta.concrete_model\n-            for ptr in concrete_model._meta.parents.values():\n+            concrete_model = model._meta.concrete_model  # pylint: disable=protected-access\n+            for ptr in concrete_model._meta.parents.values():  # pylint: disable=protected-access\n                 if ptr:\n                     parent_objs = [getattr(obj, ptr.name) for obj in new_objs]\n                     self.collect(parent_objs, source=model,\n@@ -207,13 +207,13 @@ class Collector:\n                                  collect_related=False,\n                                  reverse_dependency=True)\n         if collect_related:\n-            parents = model._meta.parents\n-            for related in get_candidate_relations_to_delete(model._meta):\n+            parents = model._meta.parents  # pylint: disable=protected-access\n+            for related in get_candidate_relations_to_delete(model._meta):  # pylint: disable=protected-access\n                 # Preserve parent reverse relationships if keep_parents=True.\n                 if keep_parents and related.model in parents:\n                     continue\n                 field = related.field\n-                if field.remote_field.on_delete == DO_NOTHING:\n+                if field.remote_field.on_delete is DO_NOTHING:\n                     continue\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n@@ -222,7 +222,7 @@ class Collector:\n                         self.fast_deletes.append(sub_objs)\n                     elif sub_objs:\n                         field.remote_field.on_delete(self, field, sub_objs, self.using)\n-            for field in model._meta.private_fields:\n+            for field in model._meta.private_fields:  # pylint: disable=protected-access\n                 if hasattr(field, 'bulk_related_objects'):\n                     # It's something like generic foreign key.\n                     sub_objs = field.bulk_related_objects(new_objs, self.using)\n@@ -232,7 +232,7 @@ class Collector:\n         \"\"\"\n         Get a QuerySet of objects related to `objs` via the relation `related`.\n         \"\"\"\n-        return related.related_model._base_manager.using(self.using).filter(\n+        return related.related_model._base_manager.using(self.using).filter(  # pylint: disable=protected-access\n             **{\"%s__in\" % related.field.name: objs}\n         )\n \n"
}