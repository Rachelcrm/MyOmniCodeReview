{
  "patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 2307dcae25..2143823457 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -57,7 +57,7 @@ BLANK_CHOICE_DASH = [(\"\", \"---------\")]\n \n \n def _load_field(app_label, model_name, field_name):\n-    return apps.get_model(app_label, model_name)._meta.get_field(field_name)\n+    return apps.get_model(app_label, model_name)._meta.get_field(field_name)  # pylint: disable=protected-access\n \n \n # A guide to Field parameters:\n@@ -135,7 +135,7 @@ class Field(RegisterLookupMixin):\n                  db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n                  serialize=True, unique_for_date=None, unique_for_month=None,\n                  unique_for_year=None, choices=None, help_text='', db_column=None,\n-                 db_tablespace=None, auto_created=False, validators=(),\n+                 db_tablespace=None, auto_created=False, validators=(),  # pylint: disable=redefined-outer-name\n                  error_messages=None):\n         self.name = name\n         self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n@@ -320,9 +320,9 @@ class Field(RegisterLookupMixin):\n             return []\n \n     def _check_backend_specific_checks(self, **kwargs):\n-        app_label = self.model._meta.app_label\n+        app_label = self.model._meta.app_label  # pylint: disable=protected-access\n         for db in connections:\n-            if router.allow_migrate(db, app_label, model_name=self.model._meta.model_name):\n+            if router.allow_migrate(db, app_label, model_name=self.model._meta.model_name):  # pylint: disable=protected-access\n                 return connections[db].validation.check_field(self, **kwargs)\n         return []\n \n@@ -376,7 +376,7 @@ class Field(RegisterLookupMixin):\n     def get_col(self, alias, output_field=None):\n         if output_field is None:\n             output_field = self\n-        if alias != self.model._meta.db_table or output_field != self:\n+        if alias != self.model._meta.db_table or output_field != self:  # pylint: disable=protected-access\n             from django.db.models.expressions import Col\n             return Col(alias, self, output_field)\n         else:\n@@ -385,9 +385,9 @@ class Field(RegisterLookupMixin):\n     @cached_property\n     def cached_col(self):\n         from django.db.models.expressions import Col\n-        return Col(self.model._meta.db_table, self)\n+        return Col(self.model._meta.db_table, self)  # pylint: disable=protected-access\n \n-    def select_format(self, compiler, sql, params):\n+    def select_format(self, compiler, sql, params):  # pylint: disable=unused-argument\n         \"\"\"\n         Custom format for select clauses. For example, GIS columns need to be\n         selected as AsText(table.col) on MySQL as the table.col data can't be\n@@ -489,7 +489,7 @@ class Field(RegisterLookupMixin):\n         Uses deconstruct() to clone a new copy of this Field.\n         Will not preserve any class attachments/attribute names.\n         \"\"\"\n-        name, path, args, kwargs = self.deconstruct()\n+        _name, _path, args, kwargs = self.deconstruct()  # pylint: disable=unused-variable\n         return self.__class__(*args, **kwargs)\n \n     def __eq__(self, other):\n@@ -512,9 +512,9 @@ class Field(RegisterLookupMixin):\n         # intended to be altered after initial creation.\n         obj = copy.copy(self)\n         if self.remote_field:\n-            obj.remote_field = copy.copy(self.remote_field)\n+            obj.remote_field = copy.copy(self.remote_field)  # pylint: disable=attribute-defined-outside-init\n             if hasattr(self.remote_field, 'field') and self.remote_field.field is self:\n-                obj.remote_field.field = obj\n+                obj.remote_field.field = obj  # pylint: disable=attribute-defined-outside-init\n         memodict[id(self)] = obj\n         return obj\n \n@@ -546,7 +546,7 @@ class Field(RegisterLookupMixin):\n         return _load_field, (self.model._meta.app_label, self.model._meta.object_name,\n                              self.name)\n \n-    def get_pk_value_on_save(self, instance):\n+    def get_pk_value_on_save(self, instance):  # pylint: disable=unused-argument\n         \"\"\"\n         Hook to generate new PK values on save. This method is called when\n         saving instances with no primary key value set. If this method returns\n@@ -589,7 +589,7 @@ class Field(RegisterLookupMixin):\n         if errors:\n             raise exceptions.ValidationError(errors)\n \n-    def validate(self, value, model_instance):\n+    def validate(self, value, model_instance):  # pylint: disable=unused-argument\n         \"\"\"\n         Validate value and raise ValidationError if necessary. Subclasses\n         should override this to provide validation logic.\n@@ -603,7 +603,7 @@ class Field(RegisterLookupMixin):\n                 if isinstance(option_value, (list, tuple)):\n                     # This is an optgroup, so look inside the group for\n                     # options.\n-                    for optgroup_key, optgroup_value in option_value:\n+                    for optgroup_key, _optgroup_value in option_value:  # pylint: disable=unused-variable\n                         if value == optgroup_key:\n                             return\n                 elif value == option_key:\n@@ -631,10 +631,10 @@ class Field(RegisterLookupMixin):\n         self.run_validators(value)\n         return value\n \n-    def db_type_parameters(self, connection):\n+    def db_type_parameters(self, connection):  # pylint: disable=redefined-outer-name\n         return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')\n \n-    def db_check(self, connection):\n+    def db_check(self, connection):  # pylint: disable=redefined-outer-name\n         \"\"\"\n         Return the database column check constraint for this field, for the\n         provided connection. Works the same way as db_type() for the case that\n"
}