{
  "patch": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..1dd2b86ec7 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -186,7 +186,7 @@ workaround is not used by default (see issue #1188).\n        textwrap.indent(_colormap_kw_doc, \"    \")))\n \n \n-def _set_ticks_on_axis_warn(*args, **kwargs):\n+def _set_ticks_on_axis_warn(*_args, **_kwargs):\n     # a top level function which gets put in at the axes'\n     # set_xticks and set_yticks by Colorbar.__init__.\n     _api.warn_external(\"Use the colorbar set_ticks() method instead.\")\n@@ -195,6 +195,7 @@ def _set_ticks_on_axis_warn(*args, **kwargs):\n class _ColorbarSpine(mspines.Spine):\n     def __init__(self, axes):\n         self._ax = axes\n+        self._xy = None  # Initialize _xy attribute\n         super().__init__(axes, 'colorbar',\n                          mpath.Path(np.empty((0, 2)), closed=True))\n         mpatches.Patch.set_transform(self, axes.transAxes)\n@@ -232,7 +233,7 @@ class _ColorbarAxesLocator:\n         if self._cbar.extend == 'neither':\n             return pos\n \n-        y, extendlen = self._cbar._proportional_y()\n+        _, extendlen = self._cbar._proportional_y()\n         if not self._cbar._extend_lower():\n             extendlen[0] = 0\n         if not self._cbar._extend_upper():\n@@ -344,7 +345,7 @@ class Colorbar:\n                  extend=None,\n                  spacing='uniform',  # uniform or proportional\n                  ticks=None,\n-                 format=None,\n+                 fmt=None,\n                  drawedges=False,\n                  filled=True,\n                  extendfrac=None,\n@@ -456,15 +457,15 @@ class Colorbar:\n         else:\n             self._locator = ticks  # Handle default in _ticker()\n \n-        if isinstance(format, str):\n+        if isinstance(fmt, str):\n             # Check format between FormatStrFormatter and StrMethodFormatter\n             try:\n-                self._formatter = ticker.FormatStrFormatter(format)\n+                self._formatter = ticker.FormatStrFormatter(fmt)\n                 _ = self._formatter(0)\n             except TypeError:\n-                self._formatter = ticker.StrMethodFormatter(format)\n+                self._formatter = ticker.StrMethodFormatter(fmt)\n         else:\n-            self._formatter = format  # Assume it is a Formatter or None\n+            self._formatter = fmt  # Assume it is a Formatter or None\n         self._draw_all()\n \n         if isinstance(mappable, contour.ContourSet) and not mappable.filled:\n@@ -670,11 +671,11 @@ class Colorbar:\n             patches.append(patch)\n         self.solids_patches = patches\n \n-    def _do_extends(self, ax=None):\n+    def _do_extends(self, _ax=None):\n         \"\"\"\n         Add the extend tri/rectangles on the outside of the axes.\n \n-        ax is unused, but required due to the callbacks on xlim/ylim changed\n+        _ax is unused, but required due to the callbacks on xlim/ylim changed\n         \"\"\"\n         # Clean up any previous extend patches\n         for patch in self._extend_patches:\n@@ -788,7 +789,7 @@ class Colorbar:\n              lambda self, levels, colors, linewidths, erase=True: locals()],\n             self, *args, **kwargs)\n         if \"CS\" in params:\n-            self, CS, erase = params.values()\n+            _, CS, erase = params.values()\n             if not isinstance(CS, contour.ContourSet) or CS.filled:\n                 raise ValueError(\"If a single artist is passed to add_lines, \"\n                                  \"it must be a ContourSet of lines\")\n@@ -799,14 +800,14 @@ class Colorbar:\n                 [t[0] for t in CS.tlinewidths],\n                 erase=erase)\n         else:\n-            self, levels, colors, linewidths, erase = params.values()\n+            _, levels, line_colors, linewidths, erase = params.values()\n \n         y = self._locate(levels)\n         rtol = (self._y[-1] - self._y[0]) * 1e-10\n         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)\n         y = y[igood]\n-        if np.iterable(colors):\n-            colors = np.asarray(colors)[igood]\n+        if np.iterable(line_colors):\n+            line_colors = np.asarray(line_colors)[igood]\n         if np.iterable(linewidths):\n             linewidths = np.asarray(linewidths)[igood]\n         X, Y = np.meshgrid([0, 1], y)\n@@ -815,7 +816,7 @@ class Colorbar:\n         else:\n             xy = np.stack([Y, X], axis=-1)\n         col = collections.LineCollection(xy, linewidths=linewidths,\n-                                         colors=colors)\n+                                         colors=line_colors)\n \n         if erase and self.lines:\n             for lc in self.lines:\n@@ -897,7 +898,7 @@ class Colorbar:\n         _log.debug('locator: %r', locator)\n \n     @_api.delete_parameter(\"3.5\", \"update_ticks\")\n-    def set_ticks(self, ticks, update_ticks=True, labels=None, *,\n+    def set_ticks(self, ticks, _update_ticks=True, labels=None, *,\n                   minor=False, **kwargs):\n         \"\"\"\n         Set tick locations.\n@@ -938,7 +939,7 @@ class Colorbar:\n             return self._long_axis().get_majorticklocs()\n \n     @_api.delete_parameter(\"3.5\", \"update_ticks\")\n-    def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,\n+    def set_ticklabels(self, ticklabels, _update_ticks=True, *, minor=False,\n                        **kwargs):\n         \"\"\"\n         Set tick labels.\n"
}