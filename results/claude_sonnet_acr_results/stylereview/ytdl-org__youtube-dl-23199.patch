{
  "patch": "diff --git a/youtube_dl/utils.py b/youtube_dl/utils.py\nindex aed988b88..6bf594fe0 100644\n--- a/youtube_dl/utils.py\n+++ b/youtube_dl/utils.py\n@@ -1780,7 +1780,7 @@ def preferredencoding():\n     try:\n         pref = locale.getpreferredencoding()\n         'TEST'.encode(pref)\n-    except Exception:\n+    except (LookupError, TypeError):\n         pref = 'UTF-8'\n \n     return pref\n@@ -1922,9 +1922,9 @@ def xpath_attr(node, xpath, key, name=None, fatal=False, default=NO_DEFAULT):\n     return n.attrib[key]\n \n \n-def get_element_by_id(id, html):\n+def get_element_by_id(element_id, html):\n     \"\"\"Return the content of the tag with the specified ID in the passed HTML document\"\"\"\n-    return get_element_by_attribute('id', id, html)\n+    return get_element_by_attribute('id', element_id, html)\n \n \n def get_element_by_class(class_name, html):\n@@ -1979,6 +1979,9 @@ class HTMLAttributeParser(compat_HTMLParser):\n     def handle_starttag(self, tag, attrs):\n         self.attrs = dict(attrs)\n \n+    def error(self, message):\n+        raise ValueError(message)\n+\n \n def extract_attributes(html_element):\n     \"\"\"Given a string for an HTML element such as\n@@ -2036,10 +2039,10 @@ def sanitize_open(filename, open_mode):\n     try:\n         if filename == '-':\n             if sys.platform == 'win32':\n-                import msvcrt\n-                msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n+                import msvcrt as win_msvcrt\n+                win_msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n             return (sys.stdout.buffer if hasattr(sys.stdout, 'buffer') else sys.stdout, filename)\n-        stream = open(encodeFilename(filename), open_mode)\n+        stream = open(encodeFilename(filename), open_mode, encoding='utf-8')\n         return (stream, filename)\n     except (IOError, OSError) as err:\n         if err.errno in (errno.EACCES,):\n@@ -2051,7 +2054,7 @@ def sanitize_open(filename, open_mode):\n             raise\n         else:\n             # An exception here should be caught in the caller\n-            stream = open(encodeFilename(alt_filename), open_mode)\n+            stream = open(encodeFilename(alt_filename), open_mode, encoding='utf-8')\n             return (stream, alt_filename)\n \n \n@@ -2111,7 +2114,15 @@ def sanitize_path(s):\n         return s\n     drive_or_unc, _ = os.path.splitdrive(s)\n     if sys.version_info < (2, 7) and not drive_or_unc:\n-        drive_or_unc, _ = os.path.splitunc(s)\n+        # Handle UNC paths for older Python versions\n+        if s.startswith('\\\\\\\\'):\n+            unc_end = s.find('\\\\', 2)\n+            if unc_end != -1:\n+                share_end = s.find('\\\\', unc_end + 1)\n+                if share_end != -1:\n+                    drive_or_unc = s[:share_end]\n+                else:\n+                    drive_or_unc = s\n     norm_path = os.path.normpath(remove_start(s, drive_or_unc)).split(os.path.sep)\n     if drive_or_unc:\n         norm_path.pop(0)\n@@ -2200,7 +2211,7 @@ def unescapeHTML(s):\n \n \n def get_subprocess_encoding():\n-    if sys.platform == 'win32' and sys.getwindowsversion()[0] >= 5:\n+    if sys.platform == 'win32' and hasattr(sys, 'getwindowsversion') and sys.getwindowsversion()[0] >= 5:\n         # For subprocess calls, encode with locale encoding\n         # Refer to http://stackoverflow.com/a/9951851/35070\n         encoding = preferredencoding()\n@@ -2225,7 +2236,7 @@ def encodeFilename(s, for_subprocess=False):\n     # Pass '' directly to use Unicode APIs on Windows 2000 and up\n     # (Detecting Windows NT 4 is tricky because 'major >= 4' would\n     # match Windows 9x series as well. Besides, NT 4 is obsolete.)\n-    if not for_subprocess and sys.platform == 'win32' and sys.getwindowsversion()[0] >= 5:\n+    if not for_subprocess and sys.platform == 'win32' and hasattr(sys, 'getwindowsversion') and sys.getwindowsversion()[0] >= 5:\n         return s\n \n     # Jython assumes filenames are Unicode strings though reported as Python 2.x compatible\n@@ -2235,7 +2246,7 @@ def encodeFilename(s, for_subprocess=False):\n     return s.encode(get_subprocess_encoding(), 'ignore')\n \n \n-def decodeFilename(b, for_subprocess=False):\n+def decodeFilename(b, _for_subprocess=False):\n \n     if sys.version_info >= (3, 0):\n         return b\n@@ -2316,7 +2327,6 @@ def bug_reports_message():\n \n class YoutubeDLError(Exception):\n     \"\"\"Base exception for YoutubeDL errors.\"\"\"\n-    pass\n \n \n class ExtractorError(YoutubeDLError):\n@@ -2357,7 +2367,6 @@ class UnsupportedError(ExtractorError):\n \n class RegexNotFoundError(ExtractorError):\n     \"\"\"Error when a regex didn't match\"\"\"\n-    pass\n \n \n class GeoRestrictedError(ExtractorError):\n@@ -2409,7 +2418,6 @@ class PostProcessingError(YoutubeDLError):\n \n class MaxDownloadsReached(YoutubeDLError):\n     \"\"\" --max-downloads limit has been reached. \"\"\"\n-    pass\n \n \n class UnavailableVideoError(YoutubeDLError):\n@@ -2418,7 +2426,6 @@ class UnavailableVideoError(YoutubeDLError):\n     This exception will be thrown when a video is requested\n     in a format that is not available for that video.\n     \"\"\"\n-    pass\n \n \n class ContentTooShortError(YoutubeDLError):\n@@ -2485,7 +2492,7 @@ def _create_http_connection(ydl_handler, http_class, is_https, *args, **kwargs):\n                     \"No remote IP%s addresses available for connect, can't use '%s' as source address\"\n                     % (ip_version, source_address[0]))\n             for res in ip_addrs:\n-                af, socktype, proto, canonname, sa = res\n+                af, socktype, proto, _, sa = res\n                 sock = None\n                 try:\n                     sock = socket.socket(af, socktype, proto)\n"
}