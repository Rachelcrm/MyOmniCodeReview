{
  "patch": "diff --git a/django/utils/timezone.py b/django/utils/timezone.py\nindex bb2b6b9594..77dccae17f 100644\n--- a/django/utils/timezone.py\n+++ b/django/utils/timezone.py\n@@ -24,9 +24,13 @@ __all__ = [\n # UTC time zone as a tzinfo instance.\n utc = pytz.utc\n \n-_PYTZ_BASE_CLASSES = (pytz.tzinfo.BaseTzInfo, pytz._FixedOffset)\n+# Build pytz base classes without accessing protected members\n+_PYTZ_BASE_CLASSES = (pytz.tzinfo.BaseTzInfo,)\n+# Check if pytz has _FixedOffset and add it if available\n+if hasattr(pytz, '_FixedOffset'):\n+    _PYTZ_BASE_CLASSES = _PYTZ_BASE_CLASSES + (pytz._FixedOffset,)\n # In releases prior to 2018.4, pytz.UTC was not a subclass of BaseTzInfo\n-if not isinstance(pytz.UTC, pytz._FixedOffset):\n+if not isinstance(pytz.UTC, _PYTZ_BASE_CLASSES):\n     _PYTZ_BASE_CLASSES = _PYTZ_BASE_CLASSES + (type(pytz.UTC),)\n \n \n@@ -71,9 +75,9 @@ def get_current_timezone_name():\n     return _get_timezone_name(get_current_timezone())\n \n \n-def _get_timezone_name(timezone):\n-    \"\"\"Return the name of ``timezone``.\"\"\"\n-    return str(timezone)\n+def _get_timezone_name(tz):\n+    \"\"\"Return the name of ``tz``.\"\"\"\n+    return str(tz)\n \n # Timezone selection functions.\n \n@@ -81,19 +85,19 @@ def _get_timezone_name(timezone):\n # because it isn't thread safe.\n \n \n-def activate(timezone):\n+def activate(tz):\n     \"\"\"\n     Set the time zone for the current thread.\n \n-    The ``timezone`` argument must be an instance of a tzinfo subclass or a\n+    The ``tz`` argument must be an instance of a tzinfo subclass or a\n     time zone name.\n     \"\"\"\n-    if isinstance(timezone, tzinfo):\n-        _active.value = timezone\n-    elif isinstance(timezone, str):\n-        _active.value = pytz.timezone(timezone)\n+    if isinstance(tz, tzinfo):\n+        _active.value = tz\n+    elif isinstance(tz, str):\n+        _active.value = pytz.timezone(tz)\n     else:\n-        raise ValueError(\"Invalid timezone: %r\" % timezone)\n+        raise ValueError(\"Invalid timezone: %r\" % tz)\n \n \n def deactivate():\n@@ -114,12 +118,13 @@ class override(ContextDecorator):\n     to set the timezone on entry and restores the previously active timezone\n     on exit.\n \n-    The ``timezone`` argument must be an instance of a ``tzinfo`` subclass, a\n+    The ``tz`` argument must be an instance of a ``tzinfo`` subclass, a\n     time zone name, or ``None``. If it is ``None``, Django enables the default\n     time zone.\n     \"\"\"\n-    def __init__(self, timezone):\n-        self.timezone = timezone\n+    def __init__(self, tz):\n+        self.timezone = tz\n+        self.old_timezone = None\n \n     def __enter__(self):\n         self.old_timezone = getattr(_active, 'value', None)\n@@ -157,7 +162,7 @@ def template_localtime(value, use_tz=None):\n \n # Utilities\n \n-def localtime(value=None, timezone=None):\n+def localtime(value=None, tz=None):\n     \"\"\"\n     Convert an aware datetime.datetime to local time.\n \n@@ -169,15 +174,15 @@ def localtime(value=None, timezone=None):\n     \"\"\"\n     if value is None:\n         value = now()\n-    if timezone is None:\n-        timezone = get_current_timezone()\n+    if tz is None:\n+        tz = get_current_timezone()\n     # Emulate the behavior of astimezone() on Python < 3.6.\n     if is_naive(value):\n         raise ValueError(\"localtime() cannot be applied to a naive datetime\")\n-    return value.astimezone(timezone)\n+    return value.astimezone(tz)\n \n \n-def localdate(value=None, timezone=None):\n+def localdate(value=None, tz=None):\n     \"\"\"\n     Convert an aware datetime to local time and return the value's date.\n \n@@ -187,7 +192,7 @@ def localdate(value=None, timezone=None):\n     Local time is defined by the current time zone, unless another time zone is\n     specified.\n     \"\"\"\n-    return localtime(value, timezone).date()\n+    return localtime(value, tz).date()\n \n \n def now():\n@@ -226,30 +231,30 @@ def is_naive(value):\n     return value.utcoffset() is None\n \n \n-def make_aware(value, timezone=None, is_dst=None):\n+def make_aware(value, tz=None, is_dst=None):\n     \"\"\"Make a naive datetime.datetime in a given time zone aware.\"\"\"\n-    if timezone is None:\n-        timezone = get_current_timezone()\n-    if _is_pytz_zone(timezone):\n+    if tz is None:\n+        tz = get_current_timezone()\n+    if _is_pytz_zone(tz):\n         # This method is available for pytz time zones.\n-        return timezone.localize(value, is_dst=is_dst)\n+        return tz.localize(value, is_dst=is_dst)\n     else:\n         # Check that we won't overwrite the timezone of an aware datetime.\n         if is_aware(value):\n             raise ValueError(\n                 \"make_aware expects a naive datetime, got %s\" % value)\n         # This may be wrong around DST changes!\n-        return value.replace(tzinfo=timezone)\n+        return value.replace(tzinfo=tz)\n \n \n-def make_naive(value, timezone=None):\n+def make_naive(value, tz=None):\n     \"\"\"Make an aware datetime.datetime naive in a given time zone.\"\"\"\n-    if timezone is None:\n-        timezone = get_current_timezone()\n+    if tz is None:\n+        tz = get_current_timezone()\n     # Emulate the behavior of astimezone() on Python < 3.6.\n     if is_naive(value):\n         raise ValueError(\"make_naive() cannot be applied to a naive datetime\")\n-    return value.astimezone(timezone).replace(tzinfo=None)\n+    return value.astimezone(tz).replace(tzinfo=None)\n \n \n def _is_pytz_zone(tz):\n"
}