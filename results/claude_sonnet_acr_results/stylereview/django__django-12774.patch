{
  "patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex d9c9b0db04..3890cebcd5 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -216,7 +216,7 @@ class QuerySet:\n         # Address the circular dependency between `Queryset` and `Manager`.\n         from django.db.models.manager import Manager\n         manager = Manager.from_queryset(cls)()\n-        manager._built_with_as_manager = True\n+        manager._built_with_as_manager = True  # pylint: disable=protected-access\n         return manager\n     as_manager.queryset_only = True\n     as_manager = classmethod(as_manager)\n@@ -323,7 +323,7 @@ class QuerySet:\n         qs._fetch_all()\n         return qs._result_cache[0]\n \n-    def __class_getitem__(cls, *args, **kwargs):\n+    def __class_getitem__(cls, *_args, **_kwargs):\n         return cls\n \n     def __and__(self, other):\n@@ -385,8 +385,8 @@ class QuerySet:\n             # attribute.\n             try:\n                 arg.default_alias\n-            except (AttributeError, TypeError):\n-                raise TypeError(\"Complex aggregates require an alias\")\n+            except (AttributeError, TypeError) as e:\n+                raise TypeError(\"Complex aggregates require an alias\") from e\n             kwargs[arg.default_alias] = arg\n \n         query = self.query.chain()\n@@ -423,15 +423,15 @@ class QuerySet:\n             clone.query.set_limits(high=limit)\n         num = len(clone)\n         if num == 1:\n-            return clone._result_cache[0]\n+            return clone._result_cache[0]  # pylint: disable=protected-access\n         if not num:\n             raise self.model.DoesNotExist(\n                 \"%s matching query does not exist.\" %\n-                self.model._meta.object_name\n+                self.model._meta.object_name  # pylint: disable=protected-access\n             )\n         raise self.model.MultipleObjectsReturned(\n             'get() returned more than one %s -- it returned %s!' % (\n-                self.model._meta.object_name,\n+                self.model._meta.object_name,  # pylint: disable=protected-access\n                 num if not limit or num < limit else 'more than %s' % (limit - 1),\n             )\n         )\n@@ -449,7 +449,7 @@ class QuerySet:\n     def _populate_pk_values(self, objs):\n         for obj in objs:\n             if obj.pk is None:\n-                obj.pk = obj._meta.pk.get_pk_value_on_save(obj)\n+                obj.pk = obj._meta.pk.get_pk_value_on_save(obj)  # pylint: disable=protected-access\n \n     def bulk_create(self, objs, batch_size=None, ignore_conflicts=False):\n         \"\"\"\n@@ -476,14 +476,14 @@ class QuerySet:\n         # model to detect the inheritance pattern ConcreteGrandParent ->\n         # MultiTableParent -> ProxyChild. Simply checking self.model._meta.proxy\n         # would not identify that case as involving multiple tables.\n-        for parent in self.model._meta.get_parent_list():\n-            if parent._meta.concrete_model is not self.model._meta.concrete_model:\n+        for parent in self.model._meta.get_parent_list():  # pylint: disable=protected-access\n+            if parent._meta.concrete_model is not self.model._meta.concrete_model:  # pylint: disable=protected-access\n                 raise ValueError(\"Can't bulk create a multi-table inherited model\")\n         if not objs:\n             return objs\n         self._for_write = True\n         connection = connections[self.db]\n-        opts = self.model._meta\n+        opts = self.model._meta  # pylint: disable=protected-access\n         fields = opts.concrete_fields\n         objs = list(objs)\n         self._populate_pk_values(objs)\n@@ -498,8 +498,8 @@ class QuerySet:\n                         if field != opts.pk:\n                             setattr(obj_with_pk, field.attname, result)\n                 for obj_with_pk in objs_with_pk:\n-                    obj_with_pk._state.adding = False\n-                    obj_with_pk._state.db = self.db\n+                    obj_with_pk._state.adding = False  # pylint: disable=protected-access\n+                    obj_with_pk._state.db = self.db  # pylint: disable=protected-access\n             if objs_without_pk:\n                 fields = [f for f in fields if not isinstance(f, AutoField)]\n                 returned_columns = self._batched_insert(\n@@ -510,8 +510,8 @@ class QuerySet:\n                 for obj_without_pk, results in zip(objs_without_pk, returned_columns):\n                     for result, field in zip(results, opts.db_returning_fields):\n                         setattr(obj_without_pk, field.attname, result)\n-                    obj_without_pk._state.adding = False\n-                    obj_without_pk._state.db = self.db\n+                    obj_without_pk._state.adding = False  # pylint: disable=protected-access\n+                    obj_without_pk._state.db = self.db  # pylint: disable=protected-access\n \n         return objs\n \n@@ -526,7 +526,7 @@ class QuerySet:\n         objs = tuple(objs)\n         if any(obj.pk is None for obj in objs):\n             raise ValueError('All bulk_update() objects must have a primary key set.')\n-        fields = [self.model._meta.get_field(name) for name in fields]\n+        fields = [self.model._meta.get_field(name) for name in fields]  # pylint: disable=protected-access\n         if any(not f.concrete or f.many_to_many for f in fields):\n             raise ValueError('bulk_update() can only be used with concrete fields.')\n         if any(f.primary_key for f in fields):\n@@ -624,11 +624,11 @@ class QuerySet:\n         defaults = defaults or {}\n         params = {k: v for k, v in kwargs.items() if LOOKUP_SEP not in k}\n         params.update(defaults)\n-        property_names = self.model._meta._property_names\n+        property_names = self.model._meta._property_names  # pylint: disable=protected-access\n         invalid_params = []\n         for param in params:\n             try:\n-                self.model._meta.get_field(param)\n+                self.model._meta.get_field(param)  # pylint: disable=protected-access\n             except exceptions.FieldDoesNotExist:\n                 # It's okay to use a model's property if it has a setter.\n                 if not (param in property_names and getattr(self.model, param).fset):\n"
}