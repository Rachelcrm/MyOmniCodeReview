{
  "patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 66f3396a6b..6b459264ee 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -117,6 +117,11 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n     show_full_result_count = True\n     checks_class = BaseModelAdminChecks\n \n+    @property\n+    def opts(self):\n+        \"\"\"Return model options, handling cases where it's not set.\"\"\"\n+        return getattr(self, '_opts', None)\n+\n     def check(self, **kwargs):\n         return self.checks_class().check(self, **kwargs)\n \n@@ -127,6 +132,11 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n         for k, v in self.formfield_overrides.items():\n             overrides.setdefault(k, {}).update(v)\n         self.formfield_overrides = overrides\n+        \n+        # Initialize attributes that may be accessed but not set in subclasses\n+        self.admin_site = None\n+        self.inlines = ()\n+        self.empty_value_display = None\n \n     def formfield_for_dbfield(self, db_field, request, **kwargs):\n         \"\"\"\n@@ -159,8 +169,8 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n             # extra HTML -- the \"add other\" interface -- to the end of the\n             # rendered output. formfield can be None if it came from a\n             # OneToOneField with parent_link=True or a M2M intermediary.\n-            if formfield and db_field.name not in self.raw_id_fields:\n-                related_modeladmin = self.admin_site._registry.get(db_field.remote_field.model)\n+            if formfield and db_field.name not in self.raw_id_fields and self.admin_site is not None:\n+                related_modeladmin = self.admin_site._registry.get(db_field.remote_field.model)  # pylint: disable=protected-access\n                 wrapper_kwargs = {}\n                 if related_modeladmin:\n                     wrapper_kwargs.update(\n@@ -185,7 +195,7 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n         # For any other type of field, just call its formfield() method.\n         return db_field.formfield(**kwargs)\n \n-    def formfield_for_choice_field(self, db_field, request, **kwargs):\n+    def formfield_for_choice_field(self, db_field, request, **kwargs):  # pylint: disable=unused-argument\n         \"\"\"\n         Get a form Field for a database Field that has declared choices.\n         \"\"\"\n@@ -209,11 +219,13 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n         ordering.  Otherwise don't specify the queryset, let the field decide\n         (return None in that case).\n         \"\"\"\n-        related_admin = self.admin_site._registry.get(db_field.remote_field.model)\n+        if self.admin_site is None:\n+            return None\n+        related_admin = self.admin_site._registry.get(db_field.remote_field.model)  # pylint: disable=protected-access\n         if related_admin is not None:\n             ordering = related_admin.get_ordering(request)\n             if ordering is not None and ordering != ():\n-                return db_field.remote_field.model._default_manager.using(db).order_by(*ordering)\n+                return db_field.remote_field.model._default_manager.using(db).order_by(*ordering)  # pylint: disable=protected-access\n         return None\n \n     def formfield_for_foreignkey(self, db_field, request, **kwargs):\n@@ -224,9 +236,11 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n \n         if 'widget' not in kwargs:\n             if db_field.name in self.get_autocomplete_fields(request):\n-                kwargs['widget'] = AutocompleteSelect(db_field, self.admin_site, using=db)\n+                if self.admin_site is not None:\n+                    kwargs['widget'] = AutocompleteSelect(db_field, self.admin_site, using=db)\n             elif db_field.name in self.raw_id_fields:\n-                kwargs['widget'] = widgets.ForeignKeyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n+                if self.admin_site is not None:\n+                    kwargs['widget'] = widgets.ForeignKeyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n             elif db_field.name in self.radio_fields:\n                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={\n                     'class': get_ul_class(self.radio_fields[db_field.name]),\n@@ -246,24 +260,26 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n         \"\"\"\n         # If it uses an intermediary model that isn't auto created, don't show\n         # a field in admin.\n-        if not db_field.remote_field.through._meta.auto_created:\n+        if not db_field.remote_field.through._meta.auto_created:  # pylint: disable=protected-access\n             return None\n         db = kwargs.get('using')\n \n         if 'widget' not in kwargs:\n             autocomplete_fields = self.get_autocomplete_fields(request)\n             if db_field.name in autocomplete_fields:\n-                kwargs['widget'] = AutocompleteSelectMultiple(\n-                    db_field,\n-                    self.admin_site,\n-                    using=db,\n-                )\n+                if self.admin_site is not None:\n+                    kwargs['widget'] = AutocompleteSelectMultiple(\n+                        db_field,\n+                        self.admin_site,\n+                        using=db,\n+                    )\n             elif db_field.name in self.raw_id_fields:\n-                kwargs['widget'] = widgets.ManyToManyRawIdWidget(\n-                    db_field.remote_field,\n-                    self.admin_site,\n-                    using=db,\n-                )\n+                if self.admin_site is not None:\n+                    kwargs['widget'] = widgets.ManyToManyRawIdWidget(\n+                        db_field.remote_field,\n+                        self.admin_site,\n+                        using=db,\n+                    )\n             elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n                 kwargs['widget'] = widgets.FilteredSelectMultiple(\n                     db_field.verbose_name,\n@@ -282,7 +298,7 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n             form_field.help_text = format_lazy('{} {}', help_text, msg) if help_text else msg\n         return form_field\n \n-    def get_autocomplete_fields(self, request):\n+    def get_autocomplete_fields(self, request):  # pylint: disable=unused-argument\n         \"\"\"\n         Return a list of ForeignKey and/or ManyToMany fields which should use\n         an autocomplete widget.\n@@ -294,7 +310,9 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n             return None\n \n         if callable(self.view_on_site):\n-            return self.view_on_site(obj)\n+            # Ensure view_on_site is callable before calling it\n+            view_on_site_func = self.view_on_site\n+            return view_on_site_func(obj)\n         elif hasattr(obj, 'get_absolute_url'):\n             # use the ContentType lookup if view_on_site is True\n             return reverse('admin:view_on_site', kwargs={\n@@ -309,7 +327,9 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n         try:\n             return mark_safe(self.empty_value_display)\n         except AttributeError:\n-            return mark_safe(self.admin_site.empty_value_display)\n+            if self.admin_site is not None:\n+                return mark_safe(self.admin_site.empty_value_display)\n+            return mark_safe('-')  # Default fallback\n \n     def get_exclude(self, request, obj=None):\n         \"\"\"\n"
}