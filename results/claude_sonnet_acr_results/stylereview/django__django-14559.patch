{
  "patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..0ba24ceaf3 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -209,7 +209,7 @@ class QuerySet:\n         # Address the circular dependency between `Queryset` and `Manager`.\n         from django.db.models.manager import Manager\n         manager = Manager.from_queryset(cls)()\n-        manager._built_with_as_manager = True\n+        manager._built_with_as_manager = True  # pylint: disable=protected-access\n         return manager\n     as_manager.queryset_only = True\n     as_manager = classmethod(as_manager)\n@@ -317,7 +317,7 @@ class QuerySet:\n         qs._fetch_all()\n         return qs._result_cache[0]\n \n-    def __class_getitem__(cls, *args, **kwargs):\n+    def __class_getitem__(cls, *_args, **_kwargs):\n         return cls\n \n     def __and__(self, other):\n@@ -379,8 +379,8 @@ class QuerySet:\n             # attribute.\n             try:\n                 arg.default_alias\n-            except (AttributeError, TypeError):\n-                raise TypeError(\"Complex aggregates require an alias\")\n+            except (AttributeError, TypeError) as exc:\n+                raise TypeError(\"Complex aggregates require an alias\") from exc\n             kwargs[arg.default_alias] = arg\n \n         query = self.query.chain()\n@@ -605,7 +605,7 @@ class QuerySet:\n         with transaction.atomic(using=self.db):\n             # Lock the row so that a concurrent update is blocked until\n             # update_or_create() has performed its save.\n-            obj, created = self.select_for_update().get_or_create(defaults, **kwargs)\n+            obj, created = self.select_for_update().get_or_create(defaults, **kwargs)  # pylint: disable=not-callable\n             if created:\n                 return obj, created\n             for k, v in resolve_callables(defaults):\n"
}