{
  "patch": "diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex 3a72ab606c..54452c59ea 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -60,17 +60,6 @@\n     'ComplexInfinity': 'nan'\n }\n \n-def _print_known_func(self, expr):\n-    known = self.known_functions[expr.__class__.__name__]\n-    return '{name}({args})'.format(name=self._module_format(known),\n-                                   args=', '.join(map(lambda arg: self._print(arg), expr.args)))\n-\n-\n-def _print_known_const(self, expr):\n-    known = self.known_constants[expr.__class__.__name__]\n-    return self._module_format(known)\n-\n-\n class AbstractPythonCodePrinter(CodePrinter):\n     printmethod = \"_pythoncode\"\n     language = \"Python\"\n@@ -179,10 +168,19 @@ def _expand_reduce_binary_op(self, op, args):\n             Nhalf = N // 2\n             return \"%s(%s, %s)\" % (\n                 self._module_format(op),\n-                self._expand_reduce_binary_op(args[:Nhalf]),\n-                self._expand_reduce_binary_op(args[Nhalf:]),\n+                self._expand_reduce_binary_op(op, args[:Nhalf]),\n+                self._expand_reduce_binary_op(op, args[Nhalf:]),\n             )\n \n+    def _get_letter_generator_for_einsum(self):\n+        \"\"\"Generate letters for einsum operations.\"\"\"\n+        import string\n+        for letter in string.ascii_lowercase:\n+            yield letter\n+        for letter in string.ascii_uppercase:\n+            yield letter\n+        raise ValueError(\"Ran out of letters for einsum\")\n+\n     def _get_einsum_string(self, subranks, contraction_indices):\n         letters = self._get_letter_generator_for_einsum()\n         contraction_string = \"\"\n@@ -218,13 +216,30 @@ def _get_einsum_string(self, subranks, contraction_indices):\n         contraction_string = contraction_string[:-1]\n         return contraction_string, letters_free, letters_dum\n \n-    def _print_NaN(self, expr):\n+    def _print_known_func(self, expr):\n+        known = self.known_functions[expr.__class__.__name__]\n+        return '{name}({args})'.format(name=self._module_format(known),\n+                                       args=', '.join(map(self._print, expr.args)))\n+\n+    def _print_known_const(self, expr):\n+        known = self.known_constants[expr.__class__.__name__]\n+        return self._module_format(known)\n+\n+    def _get_loop_opening_ending(self, indices):\n+        \"\"\"Return opening and closing lines for loops.\"\"\"\n+        return [], []\n+\n+    def _rate_index_position(self, p):\n+        \"\"\"Rate the index position.\"\"\"\n+        return p*5\n+\n+    def _print_NaN(self, _expr):\n         return \"float('nan')\"\n \n-    def _print_Infinity(self, expr):\n+    def _print_Infinity(self, _expr):\n         return \"float('inf')\"\n \n-    def _print_NegativeInfinity(self, expr):\n+    def _print_NegativeInfinity(self, _expr):\n         return \"float('-inf')\"\n \n     def _print_ComplexInfinity(self, expr):\n@@ -312,13 +327,13 @@ def _print_MatrixBase(self, expr):\n         _print_MutableDenseMatrix = \\\n         _print_ImmutableMatrix = \\\n         _print_ImmutableDenseMatrix = \\\n-        lambda self, expr: self._print_MatrixBase(expr)\n+        _print_MatrixBase\n \n     def _indent_codestring(self, codestring):\n         return '\\n'.join([self.tab + line for line in codestring.split('\\n')])\n \n     def _print_FunctionDefinition(self, fd):\n-        body = '\\n'.join(map(lambda arg: self._print(arg), fd.body))\n+        body = '\\n'.join(map(self._print, fd.body))\n         return \"def {name}({parameters}):\\n{body}\".format(\n             name=self._print(fd.name),\n             parameters=', '.join([self._print(var.symbol) for var in fd.parameters]),\n@@ -326,7 +341,7 @@ def _print_FunctionDefinition(self, fd):\n         )\n \n     def _print_While(self, whl):\n-        body = '\\n'.join(map(lambda arg: self._print(arg), whl.body))\n+        body = '\\n'.join(map(self._print, whl.body))\n         return \"while {cond}:\\n{body}\".format(\n             cond=self._print(whl.condition),\n             body=self._indent_codestring(body)\n@@ -343,7 +358,7 @@ def _print_Return(self, ret):\n         return 'return %s' % self._print(arg)\n \n     def _print_Print(self, prnt):\n-        print_args = ', '.join(map(lambda arg: self._print(arg), prnt.print_args))\n+        print_args = ', '.join(map(self._print, prnt.print_args))\n         if prnt.format_string != None: # Must be '!= None', cannot be 'is not None'\n             print_args = '{} % ({})'.format(\n                 self._print(prnt.format_string), print_args)\n@@ -360,7 +375,7 @@ def _print_Stream(self, strm):\n         else:\n             return self._print(strm.name)\n \n-    def _print_NoneToken(self, arg):\n+    def _print_NoneToken(self, _arg):\n         return 'None'\n \n     def _hprint_Pow(self, expr, rational=False, sqrt='math.sqrt'):\n@@ -465,10 +480,17 @@ def _print_Symbol(self, expr):\n         else:\n             return name\n \n-    _print_lowergamma = CodePrinter._print_not_supported\n-    _print_uppergamma = CodePrinter._print_not_supported\n-    _print_fresnelc = CodePrinter._print_not_supported\n-    _print_fresnels = CodePrinter._print_not_supported\n+    def _print_lowergamma(self, expr):\n+        return super()._print_not_supported(expr)\n+    \n+    def _print_uppergamma(self, expr):\n+        return super()._print_not_supported(expr)\n+    \n+    def _print_fresnelc(self, expr):\n+        return super()._print_not_supported(expr)\n+    \n+    def _print_fresnels(self, expr):\n+        return super()._print_not_supported(expr)\n \n \n for k in PythonCodePrinter._kf:\n"
}