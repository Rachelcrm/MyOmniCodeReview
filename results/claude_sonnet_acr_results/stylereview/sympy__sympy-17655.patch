{
  "patch": "diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py\nindex 7c978c47be..356dd51f8e 100644\n--- a/sympy/geometry/point.py\n+++ b/sympy/geometry/point.py\n@@ -215,8 +215,8 @@ def __add__(self, other):\n         \"\"\"\n         try:\n             s, o = Point._normalize_dimension(self, Point(other, evaluate=False))\n-        except TypeError:\n-            raise GeometryError(\"Don't know how to add {} and a Point object\".format(other))\n+        except TypeError as exc:\n+            raise GeometryError(\"Don't know how to add {} and a Point object\".format(other)) from exc\n \n         coords = [simplify(a + b) for a, b in zip(s, o)]\n         return Point(coords, evaluate=False)\n@@ -421,8 +421,8 @@ def distance(self, other):\n         if not isinstance(other, GeometryEntity):\n             try:\n                 other = Point(other, dim=self.ambient_dimension)\n-            except TypeError:\n-                raise TypeError(\"not recognized as a GeometricEntity: %s\" % type(other))\n+            except TypeError as exc:\n+                raise TypeError(\"not recognized as a GeometricEntity: %s\" % type(other)) from exc\n         if isinstance(other, Point):\n             s, p = Point._normalize_dimension(self, Point(other))\n             return sqrt(Add(*((a - b)**2 for a, b in zip(s, p))))\n@@ -437,12 +437,12 @@ def dot(self, p):\n             p = Point(p)  # raise the error via Point\n         return Add(*(a*b for a, b in zip(self, p)))\n \n-    def equals(self, other):\n+    def equals(self, o):\n         \"\"\"Returns whether the coordinates of self and other agree.\"\"\"\n         # a point is equal to another point if all its components are equal\n-        if not isinstance(other, Point) or len(self) != len(other):\n+        if not isinstance(o, Point) or len(self) != len(o):\n             return False\n-        return all(a.equals(b) for a, b in zip(self, other))\n+        return all(a.equals(b) for a, b in zip(self, o))\n \n     def evalf(self, prec=None, **options):\n         \"\"\"Evaluate the coordinates of the point.\n@@ -475,13 +475,13 @@ def evalf(self, prec=None, **options):\n         coords = [x.evalf(prec, **options) for x in self.args]\n         return Point(*coords, evaluate=False)\n \n-    def intersection(self, other):\n+    def intersection(self, o):\n         \"\"\"The intersection between this point and another GeometryEntity.\n \n         Parameters\n         ==========\n \n-        other : GeometryEntity or sequence of coordinates\n+        o : GeometryEntity or sequence of coordinates\n \n         Returns\n         =======\n@@ -505,16 +505,16 @@ def intersection(self, other):\n         [Point2D(0, 0)]\n \n         \"\"\"\n-        if not isinstance(other, GeometryEntity):\n-            other = Point(other)\n-        if isinstance(other, Point):\n-            if self == other:\n+        if not isinstance(o, GeometryEntity):\n+            o = Point(o)\n+        if isinstance(o, Point):\n+            if self == o:\n                 return [self]\n-            p1, p2 = Point._normalize_dimension(self, other)\n+            p1, p2 = Point._normalize_dimension(self, o)\n             if p1 == self and p1 == p2:\n                 return [self]\n             return []\n-        return other.intersection(self)\n+        return o.intersection(self)\n \n     def is_collinear(self, *args):\n         \"\"\"Returns `True` if there exists a line\n@@ -605,7 +605,7 @@ def is_concyclic(self, *args):\n         # condition: the matrix `mat` must not a pivot in the last\n         # column.\n         mat = Matrix([list(i) + [i.dot(i)] for i in points])\n-        rref, pivots = mat.rref()\n+        _, pivots = mat.rref()\n         if len(origin) not in pivots:\n             return True\n         return False\n@@ -850,6 +850,37 @@ def unit(self):\n         and a distance of 1 from the origin\"\"\"\n         return self / abs(self)\n \n+    def _svg(self, scale_factor=1, fill_color=\"#66cc99\"):\n+        \"\"\"Return SVG representation of the point as a circle.\"\"\"\n+        # For n-dimensional points, we can only show the first 2 coordinates\n+        if len(self.args) >= 2:\n+            x, y = float(self.args[0]), float(self.args[1])\n+        else:\n+            x, y = float(self.args[0]), 0\n+        \n+        return '<circle cx=\"{}\" cy=\"{}\" r=\"3\" stroke=\"black\" stroke-width=\"1\" fill=\"{}\"/>'.format(\n+            x * scale_factor, y * scale_factor, fill_color)\n+\n+    @property\n+    def bounds(self):\n+        \"\"\"Return a tuple (xmin, ymin, xmax, ymax) representing the bounding\n+        rectangle for the geometric figure.\n+        \"\"\"\n+        # For n-dimensional points, use first 2 coordinates for bounds\n+        if len(self.args) >= 2:\n+            x, y = self.args[0], self.args[1]\n+        else:\n+            x, y = self.args[0], 0\n+        return (x, y, x, y)\n+\n+    def is_similar(self, other):\n+        \"\"\"Return True if other is a Point, False otherwise.\n+        \n+        Two points are always similar to each other regardless of their coordinates,\n+        since any point can be scaled to any other point.\n+        \"\"\"\n+        return isinstance(other, Point)\n+\n     n = evalf\n \n     __truediv__ = __div__\n@@ -943,17 +974,18 @@ def rotate(self, angle, pt=None):\n         Point2D(2, -1)\n \n         \"\"\"\n-        from sympy import cos, sin, Point\n+        from sympy import cos, sin\n+        from sympy.geometry.point import Point as PointClass\n \n         c = cos(angle)\n         s = sin(angle)\n \n         rv = self\n         if pt is not None:\n-            pt = Point(pt, dim=2)\n+            pt = PointClass(pt, dim=2)\n             rv -= pt\n         x, y = rv.args\n-        rv = Point(c*x - s*y, s*x + c*y)\n+        rv = PointClass(c*x - s*y, s*x + c*y)\n         if pt is not None:\n             rv += pt\n         return rv\n@@ -998,9 +1030,9 @@ def transform(self, matrix):\n         if not (matrix.is_Matrix and matrix.shape == (3, 3)):\n             raise ValueError(\"matrix must be a 3x3 matrix\")\n \n-        col, row = matrix.shape\n         x, y = self.args\n-        return Point(*(Matrix(1, 3, [x, y, 1])*matrix).tolist()[0][:2])\n+        result = (Matrix(1, 3, [x, y, 1])*matrix).tolist()[0][:2]\n+        return Point(*result)\n \n     def translate(self, x=0, y=0):\n         \"\"\"Shift the Point by adding x and y to the coordinates of the Point.\n@@ -1055,6 +1087,16 @@ def y(self):\n         \"\"\"\n         return self.args[1]\n \n+    def _svg(self, scale_factor=1, fill_color=\"#66cc99\"):\n+        \"\"\"Return SVG representation of the 2D point as a circle.\"\"\"\n+        x, y = float(self.x), float(self.y)\n+        return '<circle cx=\"{}\" cy=\"{}\" r=\"3\" stroke=\"black\" stroke-width=\"1\" fill=\"{}\"/>'.format(\n+            x * scale_factor, y * scale_factor, fill_color)\n+\n+    def is_similar(self, other):\n+        \"\"\"Return True if other is a Point2D, False otherwise.\"\"\"\n+        return isinstance(other, Point2D)\n+\n class Point3D(Point):\n     \"\"\"A point in a 3-dimensional Euclidean space.\n \n@@ -1236,7 +1278,7 @@ def intersection(self, other):\n             return []\n         return other.intersection(self)\n \n-    def scale(self, x=1, y=1, z=1, pt=None):\n+    def scale(self, x=1, y=1, pt=1, z=None):\n         \"\"\"Scale the coordinates of the Point by multiplying by\n         ``x`` and ``y`` after subtracting ``pt`` -- default is (0, 0) --\n         and then adding ``pt`` back again (i.e. ``pt`` is the point of\n@@ -1276,11 +1318,11 @@ def transform(self, matrix):\n         if not (matrix.is_Matrix and matrix.shape == (4, 4)):\n             raise ValueError(\"matrix must be a 4x4 matrix\")\n \n-        col, row = matrix.shape\n         from sympy.matrices.expressions import Transpose\n         x, y, z = self.args\n         m = Transpose(matrix)\n-        return Point3D(*(Matrix(1, 4, [x, y, z, 1])*m).tolist()[0][:3])\n+        result = (Matrix(1, 4, [x, y, z, 1])*m).tolist()[0][:3]\n+        return Point3D(*result)\n \n     def translate(self, x=0, y=0, z=0):\n         \"\"\"Shift the Point by adding x and y to the coordinates of the Point.\n"
}