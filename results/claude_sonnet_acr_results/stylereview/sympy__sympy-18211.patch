{
  "patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex f581bfa3c4..0079c62a2e 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -70,20 +70,19 @@ def __new__(cls, lhs, rhs, rop=None, **assumptions):\n         #\n         # If called directly with an operator, look up the subclass\n         # corresponding to that operator and delegate to it\n-        cls = cls.ValidRelationOperator.get(rop, None)\n-        if cls is None:\n+        relation_cls = cls.ValidRelationOperator.get(rop, None)\n+        if relation_cls is None:\n             raise ValueError(\"Invalid relational operator symbol: %r\" % rop)\n \n         # XXX: Why should the below be removed when Py2 is not supported?\n         #\n         # /// drop when Py2 is no longer supported\n-        if not issubclass(cls, (Eq, Ne)):\n+        if not issubclass(relation_cls, (Eq, Ne)):\n             # validate that Booleans are not being used in a relational\n             # other than Eq/Ne;\n             # Note: Symbol is a subclass of Boolean but is considered\n             # acceptable here.\n             from sympy.core.symbol import Symbol\n-            from sympy.logic.boolalg import Boolean\n             def unacceptable(side):\n                 return isinstance(side, Boolean) and not isinstance(side, Symbol)\n \n@@ -96,7 +95,7 @@ def unacceptable(side):\n                 '''))\n         # \\\\\\\n \n-        return cls(lhs, rhs, **assumptions)\n+        return relation_cls(lhs, rhs, **assumptions)\n \n     @property\n     def lhs(self):\n@@ -187,11 +186,20 @@ def negated(self):\n         # will work until it is properly sorted out\n         # return ops.get(self.func, lambda a, b, evaluate=False: ~(self.func(a,\n         #      b, evaluate=evaluate)))(*self.args, evaluate=False)\n-        return Relational.__new__(ops.get(self.func), *self.args)\n+        return ops.get(self.func)(*self.args)\n \n     def _eval_evalf(self, prec):\n         return self.func(*[s._evalf(prec) for s in self.args])\n \n+    @classmethod\n+    def _eval_relation(cls, lhs, rhs):\n+        \"\"\"Default implementation for relation evaluation.\n+        \n+        Subclasses should override this method to provide specific\n+        relation evaluation logic.\n+        \"\"\"\n+        return None\n+\n     @property\n     def canonical(self):\n         \"\"\"Return a canonical form of the relational by putting a\n@@ -304,7 +312,9 @@ def _eval_simplify(self, **kwargs):\n             elif dif.equals(0):  # XXX this is expensive\n                 v = S.Zero\n             if v is not None:\n-                r = r.func._eval_relation(v, S.Zero)\n+                eval_result = r.func._eval_relation(v, S.Zero)\n+                if eval_result is not None:\n+                    r = eval_result\n             r = r.canonical\n             # If there is only one symbol in the expression,\n             # try to write it on a simplified form\n@@ -464,7 +474,6 @@ class Equality(Relational):\n \n     def __new__(cls, lhs, rhs=None, **options):\n         from sympy.core.add import Add\n-        from sympy.core.containers import Tuple\n         from sympy.core.logic import fuzzy_bool, fuzzy_xor, fuzzy_and, fuzzy_not\n         from sympy.core.expr import _n2\n         from sympy.functions.elementary.complexes import arg\n@@ -709,7 +718,7 @@ class Unequality(Relational):\n \n     __slots__ = []\n \n-    def __new__(cls, lhs, rhs, **options):\n+    def __new__(cls, lhs, rhs, rop=None, **options):\n         lhs = _sympify(lhs)\n         rhs = _sympify(rhs)\n \n@@ -756,7 +765,7 @@ class _Inequality(Relational):\n     \"\"\"\n     __slots__ = []\n \n-    def __new__(cls, lhs, rhs, **options):\n+    def __new__(cls, lhs, rhs, rop=None, **options):\n         lhs = _sympify(lhs)\n         rhs = _sympify(rhs)\n \n"
}