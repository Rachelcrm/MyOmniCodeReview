{
  "patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex c1a76584f0..0c918d149e 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -18,8 +18,8 @@ class SQLiteNumericMixin:\n     Some expressions with output_field=DecimalField() must be cast to\n     numeric to be properly filtered.\n     \"\"\"\n-    def as_sqlite(self, compiler, connection, **extra_context):\n-        sql, params = self.as_sql(compiler, connection, **extra_context)\n+    def as_sqlite(self, compiler, db_connection, **extra_context):\n+        sql, params = self.as_sql(compiler, db_connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == 'DecimalField':\n                 sql = 'CAST(%s AS NUMERIC)' % sql\n@@ -53,7 +53,7 @@ class Combinable:\n     BITRIGHTSHIFT = '>>'\n     BITXOR = '#'\n \n-    def _combine(self, other, connector, reversed):\n+    def _combine(self, other, connector, is_reversed):\n         if not hasattr(other, 'resolve_expression'):\n             # everything must be resolvable to an expression\n             if isinstance(other, datetime.timedelta):\n@@ -61,7 +61,7 @@ class Combinable:\n             else:\n                 other = Value(other)\n \n-        if reversed:\n+        if is_reversed:\n             return CombinedExpression(other, connector, self)\n         return CombinedExpression(self, connector, other)\n \n@@ -161,20 +161,21 @@ class BaseExpression:\n     window_compatible = False\n \n     def __init__(self, output_field=None):\n+        self._constructor_args = ((), {'output_field': output_field})\n         if output_field is not None:\n-            self.output_field = output_field\n+            self._output_field = output_field\n \n     def __getstate__(self):\n         state = self.__dict__.copy()\n         state.pop('convert_value', None)\n         return state\n \n-    def get_db_converters(self, connection):\n+    def get_db_converters(self, db_connection):\n         return (\n             []\n             if self.convert_value is self._convert_value_noop else\n             [self.convert_value]\n-        ) + self.output_field.get_db_converters(connection)\n+        ) + self.output_field.get_db_converters(db_connection)\n \n     def get_source_expressions(self):\n         return []\n@@ -189,7 +190,7 @@ class BaseExpression:\n             ) for arg in expressions\n         ]\n \n-    def as_sql(self, compiler, connection):\n+    def as_sql(self, compiler, db_connection):\n         \"\"\"\n         Responsible for returning a (sql, [params]) tuple to be included\n         in the current query.\n@@ -198,10 +199,10 @@ class BaseExpression:\n         providing an `as_{vendor}` method and patching the Expression:\n \n         ```\n-        def override_as_sql(self, compiler, connection):\n+        def override_as_sql(self, compiler, db_connection):\n             # custom logic\n-            return super().as_sql(compiler, connection)\n-        setattr(Expression, 'as_' + connection.vendor, override_as_sql)\n+            return super().as_sql(compiler, db_connection)\n+        setattr(Expression, 'as_' + db_connection.vendor, override_as_sql)\n         ```\n \n         Arguments:\n@@ -209,7 +210,7 @@ class BaseExpression:\n            Must have a compile method, returning a (sql, [params]) tuple.\n            Calling compiler(value) will return a quoted `value`.\n \n-         * connection: the database connection used for the current query.\n+         * db_connection: the database connection used for the current query.\n \n         Return: (sql, params)\n           Where `sql` is a string containing ordered sql parameters to be\n@@ -229,7 +230,7 @@ class BaseExpression:\n     def contains_column_references(self):\n         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):  # pylint: disable=unused-argument\n         \"\"\"\n         Provide the chance to do any preprocessing or validation before being\n         added to the query.\n@@ -264,6 +265,8 @@ class BaseExpression:\n     @cached_property\n     def output_field(self):\n         \"\"\"Return the output type of this expressions.\"\"\"\n+        if hasattr(self, '_output_field'):\n+            return self._output_field\n         output_field = self._resolve_output_field()\n         if output_field is None:\n             self._output_field_resolved_to_none = True\n@@ -310,7 +313,7 @@ class BaseExpression:\n             return output_field\n \n     @staticmethod\n-    def _convert_value_noop(value, expression, connection):\n+    def _convert_value_noop(value, expression, db_connection):  # pylint: disable=unused-argument\n         return value\n \n     @cached_property\n@@ -347,7 +350,7 @@ class BaseExpression:\n     def copy(self):\n         return copy.copy(self)\n \n-    def get_group_by_cols(self, alias=None):\n+    def get_group_by_cols(self, alias=None):  # pylint: disable=unused-argument\n         if not self.contains_aggregate:\n             return [self]\n         cols = []\n@@ -415,7 +418,16 @@ class BaseExpression:\n \n class Expression(BaseExpression, Combinable):\n     \"\"\"An expression that can be combined with other expressions.\"\"\"\n-    pass\n+    \n+    def __rand__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __ror__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n \n \n class CombinedExpression(SQLiteNumericMixin, Expression):\n@@ -471,8 +483,8 @@ class CombinedExpression(SQLiteNumericMixin, Expression):\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n         c = self.copy()\n         c.is_summary = summarize\n-        c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n-        c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)  # pylint: disable=attribute-defined-outside-init\n+        c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)  # pylint: disable=attribute-defined-outside-init\n         return c\n \n \n@@ -912,8 +924,8 @@ class When(Expression):\n         c = self.copy()\n         c.is_summary = summarize\n         if hasattr(c.condition, 'resolve_expression'):\n-            c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)\n-        c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+            c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)  # pylint: disable=attribute-defined-outside-init\n+        c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)  # pylint: disable=attribute-defined-outside-init\n         return c\n \n     def as_sql(self, compiler, connection, template=None, **extra_context):\n@@ -1162,7 +1174,7 @@ class OrderBy(BaseExpression):\n         # a CASE WHEN.\n         if isinstance(self.expression, Exists):\n             copy = self.copy()\n-            copy.expression = Case(\n+            copy.expression = Case(  # pylint: disable=attribute-defined-outside-init\n                 When(self.expression, then=True),\n                 default=False,\n                 output_field=fields.BooleanField(),\n"
}