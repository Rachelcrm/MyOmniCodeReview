{
  "patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex d517d7269b..8dd666f33b 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -54,7 +54,7 @@ def resolve_relation(scope_model, relation):\n     # Look for an \"app.Model\" relation\n     if isinstance(relation, str):\n         if \".\" not in relation:\n-            relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n+            relation = \"%s.%s\" % (scope_model._meta.app_label, relation)  # pylint: disable=protected-access\n \n     return relation\n \n@@ -76,8 +76,8 @@ def lazy_related_operation(function, model, *related_models, **kwargs):\n     \"\"\"\n     models = [model] + [resolve_relation(model, rel) for rel in related_models]\n     model_keys = (make_model_tuple(m) for m in models)\n-    apps = model._meta.apps\n-    return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n+    model_apps = model._meta.apps  # pylint: disable=protected-access\n+    return model_apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n \n \n class RelatedField(FieldCacheMixin, Field):\n@@ -115,7 +115,7 @@ class RelatedField(FieldCacheMixin, Field):\n             return [\n                 checks.Error(\n                     \"The name '%s' is invalid related_name for field %s.%s\" %\n-                    (self.remote_field.related_name, self.model._meta.object_name,\n+                    (self.remote_field.related_name, self.model._meta.object_name,  # pylint: disable=protected-access\n                      self.name),\n                     hint=\"Related name must be a valid Python identifier or end with a '+'\",\n                     obj=self,\n@@ -156,8 +156,8 @@ class RelatedField(FieldCacheMixin, Field):\n     def _check_relation_model_exists(self):\n         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\n         rel_is_string = isinstance(self.remote_field.model, str)\n-        model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name\n-        if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):\n+        model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name  # pylint: disable=protected-access\n+        if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):  # pylint: disable=protected-access\n             return [\n                 checks.Error(\n                     \"Field defines a relation with model '%s', which is either \"\n@@ -171,16 +171,16 @@ class RelatedField(FieldCacheMixin, Field):\n     def _check_referencing_to_swapped_model(self):\n         if (self.remote_field.model not in self.opts.apps.get_models() and\n                 not isinstance(self.remote_field.model, str) and\n-                self.remote_field.model._meta.swapped):\n+                self.remote_field.model._meta.swapped):  # pylint: disable=protected-access\n             model = \"%s.%s\" % (\n-                self.remote_field.model._meta.app_label,\n-                self.remote_field.model._meta.object_name\n+                self.remote_field.model._meta.app_label,  # pylint: disable=protected-access\n+                self.remote_field.model._meta.object_name  # pylint: disable=protected-access\n             )\n             return [\n                 checks.Error(\n                     \"Field defines a relation with the model '%s', which has \"\n                     \"been swapped out.\" % model,\n-                    hint=\"Update the relation to point at 'settings.%s'.\" % self.remote_field.model._meta.swappable,\n+                    hint=\"Update the relation to point at 'settings.%s'.\" % self.remote_field.model._meta.swappable,  # pylint: disable=protected-access\n                     obj=self,\n                     id='fields.E301',\n                 )\n@@ -192,7 +192,7 @@ class RelatedField(FieldCacheMixin, Field):\n         from django.db.models.base import ModelBase\n \n         errors = []\n-        opts = self.model._meta\n+        opts = self.model._meta  # pylint: disable=protected-access\n \n         # `f.remote_field.model` may be a string instead of a model. Skip if model name is\n         # not resolved.\n@@ -211,7 +211,7 @@ class RelatedField(FieldCacheMixin, Field):\n         #         m2m = models.ManyToManyField(Target)\n \n         # rel_opts.object_name == \"Target\"\n-        rel_opts = self.remote_field.model._meta\n+        rel_opts = self.remote_field.model._meta  # pylint: disable=protected-access\n         # If the field doesn't install a backward relation on the target model\n         # (so `is_hidden` returns True), then there are no clashes to check\n         # and we can skip these fields.\n@@ -254,7 +254,7 @@ class RelatedField(FieldCacheMixin, Field):\n         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)\n         for clash_field in potential_clashes:\n             clash_name = \"%s.%s\" % (  # i. e. \"Model.m2m\"\n-                clash_field.related_model._meta.object_name,\n+                clash_field.related_model._meta.object_name,  # pylint: disable=protected-access\n                 clash_field.field.name)\n             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:\n                 errors.append(\n@@ -281,7 +281,7 @@ class RelatedField(FieldCacheMixin, Field):\n \n         return errors\n \n-    def db_type(self, connection):\n+    def db_type(self, db_connection):\n         # By default related field will not have a column as it relates to\n         # columns from another table.\n         return None\n"
}