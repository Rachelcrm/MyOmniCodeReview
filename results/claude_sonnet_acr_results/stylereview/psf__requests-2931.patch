{
  "patch": "diff --git a/requests/models.py b/requests/models.py\nindex 9c624d3c..141c6eed 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -294,7 +294,7 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         self.prepare_headers(headers)\n         self.prepare_cookies(cookies)\n         self.prepare_body(data, files, json)\n-        self.prepare_auth(auth, url)\n+        self.prepare_auth(auth)\n \n         # Note that prepare_auth must be last to enable authentication schemes\n         # such as OAuth to work on a fully prepared request.\n@@ -331,7 +331,7 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         if isinstance(url, bytes):\n             url = url.decode('utf8')\n         else:\n-            url = unicode(url) if is_py2 else str(url)\n+            url = str(url)\n \n         # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n         # `data` etc to work around exceptions from `url_parse`, which\n@@ -344,7 +344,7 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         try:\n             scheme, auth, host, port, path, query, fragment = parse_url(url)\n         except LocationParseError as e:\n-            raise InvalidURL(*e.args)\n+            raise InvalidURL(*e.args) from e\n \n         if not scheme:\n             error = (\"Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?\")\n@@ -358,8 +358,8 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         # Only want to apply IDNA to the hostname\n         try:\n             host = host.encode('idna').decode('utf-8')\n-        except UnicodeError:\n-            raise InvalidURL('URL has an invalid label.')\n+        except UnicodeError as e:\n+            raise InvalidURL('URL has an invalid label.') from e\n \n         # Carefully reconstruct the network location\n         netloc = auth or ''\n@@ -470,7 +470,7 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         elif (self.method not in ('GET', 'HEAD')) and (self.headers.get('Content-Length') is None):\n             self.headers['Content-Length'] = '0'\n \n-    def prepare_auth(self, auth, url=''):\n+    def prepare_auth(self, auth):\n         \"\"\"Prepares the given HTTP auth data.\"\"\"\n \n         # If no Auth is explicitly provided, extract it from the URL first.\n@@ -657,11 +657,11 @@ class Response(object):\n                     for chunk in self.raw.stream(chunk_size, decode_content=True):\n                         yield chunk\n                 except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n+                    raise ChunkedEncodingError(e) from e\n                 except DecodeError as e:\n-                    raise ContentDecodingError(e)\n+                    raise ContentDecodingError(e) from e\n                 except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n+                    raise ConnectionError(e) from e\n             else:\n                 # Standard file-like object.\n                 while True:\n@@ -782,7 +782,7 @@ class Response(object):\n     def json(self, **kwargs):\n         \"\"\"Returns the json-encoded content of a response, if any.\n \n-        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n+        :param \\\\*\\\\*kwargs: Optional arguments that ``json.loads`` takes.\n         \"\"\"\n \n         if not self.encoding and len(self.content) > 3:\n"
}