{
  "patch": "diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex a3f0310735..cc8bb0fc3a 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -67,7 +67,7 @@\n def _print_known_func(self, expr):\n     known = self.known_functions[expr.__class__.__name__]\n     return '{name}({args})'.format(name=self._module_format(known),\n-                                   args=', '.join(map(lambda arg: self._print(arg), expr.args)))\n+                                   args=', '.join(self._print(arg) for arg in expr.args))\n \n \n def _print_known_const(self, expr):\n@@ -171,10 +171,27 @@ def _expand_reduce_binary_op(self, op, args):\n             Nhalf = N // 2\n             return \"%s(%s, %s)\" % (\n                 self._module_format(op),\n-                self._expand_reduce_binary_op(args[:Nhalf]),\n-                self._expand_reduce_binary_op(args[Nhalf:]),\n+                self._expand_reduce_binary_op(op, args[:Nhalf]),\n+                self._expand_reduce_binary_op(op, args[Nhalf:]),\n             )\n \n+    def _get_letter_generator_for_einsum(self):\n+        \"\"\"Generate letters for einsum operations.\"\"\"\n+        import string\n+        for letter in string.ascii_lowercase:\n+            yield letter\n+        for letter in string.ascii_uppercase:\n+            yield letter\n+        raise ValueError(\"Ran out of letters for einsum\")\n+\n+    def _get_loop_opening_ending(self, indices):\n+        \"\"\"Return opening and closing lines for loops.\"\"\"\n+        return [], []\n+\n+    def _rate_index_position(self, p):\n+        \"\"\"Rate index position for loop optimization.\"\"\"\n+        return p\n+\n     def _get_einsum_string(self, subranks, contraction_indices):\n         letters = self._get_letter_generator_for_einsum()\n         contraction_string = \"\"\n@@ -210,13 +227,13 @@ def _get_einsum_string(self, subranks, contraction_indices):\n         contraction_string = contraction_string[:-1]\n         return contraction_string, letters_free, letters_dum\n \n-    def _print_NaN(self, expr):\n+    def _print_NaN(self, _expr):\n         return \"float('nan')\"\n \n-    def _print_Infinity(self, expr):\n+    def _print_Infinity(self, _expr):\n         return \"float('inf')\"\n \n-    def _print_NegativeInfinity(self, expr):\n+    def _print_NegativeInfinity(self, _expr):\n         return \"float('-inf')\"\n \n     def _print_ComplexInfinity(self, expr):\n@@ -288,21 +305,23 @@ def _print_MatrixBase(self, expr):\n         func = self.known_functions.get(name, name)\n         return \"%s(%s)\" % (func, self._print(expr.tolist()))\n \n-    _print_SparseMatrix = \\\n-        _print_MutableSparseMatrix = \\\n+    def _print_SparseMatrix(self, expr):\n+        return self._print_MatrixBase(expr)\n+    \n+    _print_MutableSparseMatrix = \\\n         _print_ImmutableSparseMatrix = \\\n         _print_Matrix = \\\n         _print_DenseMatrix = \\\n         _print_MutableDenseMatrix = \\\n         _print_ImmutableMatrix = \\\n         _print_ImmutableDenseMatrix = \\\n-        lambda self, expr: self._print_MatrixBase(expr)\n+        _print_SparseMatrix\n \n     def _indent_codestring(self, codestring):\n         return '\\n'.join([self.tab + line for line in codestring.split('\\n')])\n \n     def _print_FunctionDefinition(self, fd):\n-        body = '\\n'.join(map(lambda arg: self._print(arg), fd.body))\n+        body = '\\n'.join(self._print(arg) for arg in fd.body)\n         return \"def {name}({parameters}):\\n{body}\".format(\n             name=self._print(fd.name),\n             parameters=', '.join([self._print(var.symbol) for var in fd.parameters]),\n@@ -310,7 +329,7 @@ def _print_FunctionDefinition(self, fd):\n         )\n \n     def _print_While(self, whl):\n-        body = '\\n'.join(map(lambda arg: self._print(arg), whl.body))\n+        body = '\\n'.join(self._print(arg) for arg in whl.body)\n         return \"while {cond}:\\n{body}\".format(\n             cond=self._print(whl.condition),\n             body=self._indent_codestring(body)\n@@ -327,7 +346,7 @@ def _print_Return(self, ret):\n         return 'return %s' % self._print(arg)\n \n     def _print_Print(self, prnt):\n-        print_args = ', '.join(map(lambda arg: self._print(arg), prnt.print_args))\n+        print_args = ', '.join(self._print(arg) for arg in prnt.print_args)\n         if prnt.format_string != None: # Must be '!= None', cannot be 'is not None'\n             print_args = '{0} % ({1})'.format(\n                 self._print(prnt.format_string), print_args)\n@@ -343,12 +362,20 @@ def _print_Stream(self, strm):\n         else:\n             return self._print(strm.name)\n \n-    def _print_NoneToken(self, arg):\n+    def _print_NoneToken(self, _arg):\n         return 'None'\n \n \n class PythonCodePrinter(AbstractPythonCodePrinter):\n \n+    def _get_loop_opening_ending(self, indices):\n+        \"\"\"Return opening and closing lines for loops.\"\"\"\n+        return [], []\n+\n+    def _rate_index_position(self, p):\n+        \"\"\"Rate index position for loop optimization.\"\"\"\n+        return p\n+\n     def _print_sign(self, e):\n         return '(0.0 if {e} == 0 else {f}(1, {e}))'.format(\n             f=self._module_format('math.copysign'), e=self._print(e.args[0]))\n"
}