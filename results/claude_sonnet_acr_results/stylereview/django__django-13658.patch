{
  "patch": "diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py\nindex 1ba093e51f..acbae357a9 100644\n--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -104,7 +104,7 @@ def call_command(command_name, *args, **options):\n         try:\n             app_name = get_commands()[command_name]\n         except KeyError:\n-            raise CommandError(\"Unknown command: %r\" % command_name)\n+            raise CommandError(\"Unknown command: %r\" % command_name) from None\n \n         if isinstance(app_name, BaseCommand):\n             # If the command is already loaded, use it directly.\n@@ -115,6 +115,7 @@ def call_command(command_name, *args, **options):\n     # Simulate argument parsing to get the option defaults (see #10080 for details).\n     parser = command.create_parser('', command_name)\n     # Use the `dest` option name from the parser option\n+    # pylint: disable=protected-access\n     opt_mapping = {\n         min(s_opt.option_strings).lstrip('-').replace('-', '_'): s_opt.dest\n         for s_opt in parser._actions if s_opt.option_strings\n@@ -129,6 +130,7 @@ def call_command(command_name, *args, **options):\n \n     def get_actions(parser):\n         # Parser actions and actions from sub-parser choices.\n+        # pylint: disable=protected-access\n         for opt in parser._actions:\n             if isinstance(opt, _SubParsersAction):\n                 for sub_opt in opt.choices.values():\n@@ -137,6 +139,7 @@ def call_command(command_name, *args, **options):\n                 yield opt\n \n     parser_actions = list(get_actions(parser))\n+    # pylint: disable=protected-access\n     mutually_exclusive_required_options = {\n         opt\n         for group in parser._mutually_exclusive_groups\n@@ -158,6 +161,7 @@ def call_command(command_name, *args, **options):\n             else:\n                 parse_args.append(str(value))\n     defaults = parser.parse_args(args=parse_args)\n+    # pylint: disable=protected-access\n     defaults = dict(defaults._get_kwargs(), **arg_options)\n     # Raise an error if any unknown options were passed.\n     stealth_options = set(command.base_stealth_options + command.stealth_options)\n@@ -213,11 +217,13 @@ class ManagementUtility:\n             style = color_style()\n             for app in sorted(commands_dict):\n                 usage.append(\"\")\n+                # pylint: disable=no-member\n                 usage.append(style.NOTICE(\"[%s]\" % app))\n                 for name in sorted(commands_dict[app]):\n                     usage.append(\"    %s\" % name)\n             # Output an extra note if settings are not properly configured\n             if self.settings_exception is not None:\n+                # pylint: disable=no-member\n                 usage.append(style.NOTICE(\n                     \"Note that only Django core commands are listed \"\n                     \"as settings are not properly configured (error: %s).\"\n@@ -241,7 +247,7 @@ class ManagementUtility:\n                 # following line will retrigger an ImproperlyConfigured exception\n                 # (get_commands() swallows the original one) so the user is\n                 # informed about it.\n-                settings.INSTALLED_APPS\n+                _ = settings.INSTALLED_APPS\n             elif not settings.configured:\n                 sys.stderr.write(\"No Django settings specified.\\n\")\n             possible_matches = get_close_matches(subcommand, commands)\n@@ -311,6 +317,7 @@ class ManagementUtility:\n                     # user will find out once they execute the command.\n                     pass\n             parser = subcommand_cls.create_parser('', cwords[0])\n+            # pylint: disable=protected-access\n             options.extend(\n                 (min(s_opt.option_strings), s_opt.nargs != 0)\n                 for s_opt in parser._actions if s_opt.option_strings\n@@ -368,6 +375,7 @@ class ManagementUtility:\n             if subcommand == 'runserver' and '--noreload' not in self.argv:\n                 try:\n                     autoreload.check_errors(django.setup)()\n+                # pylint: disable=broad-except\n                 except Exception:\n                     # The exception will be raised later in the child process\n                     # started by the autoreloader. Pretend it didn't happen by\n"
}