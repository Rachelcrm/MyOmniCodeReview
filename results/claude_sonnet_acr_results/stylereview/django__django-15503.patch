{
  "patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..a7faf69015 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -50,12 +50,12 @@ class JSONField(CheckFieldDefaultMixin, Field):\n                 continue\n             connection = connections[db]\n             if (\n-                self.model._meta.required_db_vendor\n-                and self.model._meta.required_db_vendor != connection.vendor\n+                self.model._meta.required_db_vendor  # pylint: disable=protected-access\n+                and self.model._meta.required_db_vendor != connection.vendor  # pylint: disable=protected-access\n             ):\n                 continue\n             if not (\n-                \"supports_json_field\" in self.model._meta.required_db_features\n+                \"supports_json_field\" in self.model._meta.required_db_features  # pylint: disable=protected-access\n                 or connection.features.supports_json_field\n             ):\n                 errors.append(\n@@ -75,7 +75,7 @@ class JSONField(CheckFieldDefaultMixin, Field):\n             kwargs[\"decoder\"] = self.decoder\n         return name, path, args, kwargs\n \n-    def from_db_value(self, value, expression, connection):\n+    def from_db_value(self, value, expression, _connection):\n         if value is None:\n             return value\n         # Some backends (SQLite at least) extract non-string values in their\n@@ -95,30 +95,30 @@ class JSONField(CheckFieldDefaultMixin, Field):\n             return value\n         return json.dumps(value, cls=self.encoder)\n \n-    def get_transform(self, name):\n-        transform = super().get_transform(name)\n+    def get_transform(self, lookup_name):\n+        transform = super().get_transform(lookup_name)\n         if transform:\n             return transform\n-        return KeyTransformFactory(name)\n+        return KeyTransformFactory(lookup_name)\n \n     def validate(self, value, model_instance):\n         super().validate(value, model_instance)\n         try:\n             json.dumps(value, cls=self.encoder)\n-        except TypeError:\n+        except TypeError as exc:\n             raise exceptions.ValidationError(\n                 self.error_messages[\"invalid\"],\n                 code=\"invalid\",\n                 params={\"value\": value},\n-            )\n+            ) from exc\n \n     def value_to_string(self, obj):\n         return self.value_from_object(obj)\n \n-    def formfield(self, **kwargs):\n+    def formfield(self, form_class=None, **kwargs):  # pylint: disable=arguments-differ\n         return super().formfield(\n             **{\n-                \"form_class\": forms.JSONField,\n+                \"form_class\": form_class or forms.JSONField,\n                 \"encoder\": self.encoder,\n                 \"decoder\": self.decoder,\n                 **kwargs,\n@@ -153,6 +153,21 @@ class DataContains(PostgresOperatorLookup):\n         params = tuple(lhs_params) + tuple(rhs_params)\n         return \"JSON_CONTAINS(%s, %s)\" % (lhs, rhs), params\n \n+    def __rand__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __ror__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __rxor__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n \n class ContainedBy(PostgresOperatorLookup):\n     lookup_name = \"contained_by\"\n@@ -168,6 +183,21 @@ class ContainedBy(PostgresOperatorLookup):\n         params = tuple(rhs_params) + tuple(lhs_params)\n         return \"JSON_CONTAINS(%s, %s)\" % (rhs, lhs), params\n \n+    def __rand__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __ror__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __rxor__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n \n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n@@ -231,6 +261,21 @@ class HasKeyLookup(PostgresOperatorLookup):\n             compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n         )\n \n+    def __rand__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __ror__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __rxor__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n \n class HasKey(HasKeyLookup):\n     lookup_name = \"has_key\"\n"
}