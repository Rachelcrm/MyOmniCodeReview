{
  "patch": "diff --git a/django/db/migrations/state.py b/django/db/migrations/state.py\nindex 088f5c41f0..af9bfcb5d0 100644\n--- a/django/db/migrations/state.py\n+++ b/django/db/migrations/state.py\n@@ -26,7 +26,7 @@ def _get_app_label_and_model_name(model, app_label=''):\n         split = model.split('.', 1)\n         return tuple(split) if len(split) == 2 else (app_label, split[0])\n     else:\n-        return model._meta.app_label, model._meta.model_name\n+        return model._meta.app_label, model._meta.model_name  # pylint: disable=protected-access\n \n \n def _get_related_models(m):\n@@ -36,13 +36,13 @@ def _get_related_models(m):\n         if issubclass(subclass, models.Model)\n     ]\n     related_fields_models = set()\n-    for f in m._meta.get_fields(include_parents=True, include_hidden=True):\n+    for f in m._meta.get_fields(include_parents=True, include_hidden=True):  # pylint: disable=protected-access\n         if f.is_relation and f.related_model is not None and not isinstance(f.related_model, str):\n             related_fields_models.add(f.model)\n             related_models.append(f.related_model)\n     # Reverse accessors of foreign keys to proxy models are attached to their\n     # concrete proxied model.\n-    opts = m._meta\n+    opts = m._meta  # pylint: disable=protected-access\n     if opts.proxy and m in related_fields_models:\n         related_models.append(opts.concrete_model)\n     return related_models\n@@ -54,7 +54,7 @@ def get_related_models_tuples(model):\n     models for the given model.\n     \"\"\"\n     return {\n-        (rel_mod._meta.app_label, rel_mod._meta.model_name)\n+        (rel_mod._meta.app_label, rel_mod._meta.model_name)  # pylint: disable=protected-access\n         for rel_mod in _get_related_models(model)\n     }\n \n@@ -73,12 +73,12 @@ def get_related_models_recursive(model):\n     seen = set()\n     queue = _get_related_models(model)\n     for rel_mod in queue:\n-        rel_app_label, rel_model_name = rel_mod._meta.app_label, rel_mod._meta.model_name\n+        rel_app_label, rel_model_name = rel_mod._meta.app_label, rel_mod._meta.model_name  # pylint: disable=protected-access\n         if (rel_app_label, rel_model_name) in seen:\n             continue\n         seen.add((rel_app_label, rel_model_name))\n         queue.extend(_get_related_models(rel_mod))\n-    return seen - {(model._meta.app_label, model._meta.model_name)}\n+    return seen - {(model._meta.app_label, model._meta.model_name)}  # pylint: disable=protected-access\n \n \n class ProjectState:\n@@ -88,8 +88,8 @@ class ProjectState:\n     FKs/etc. resolve properly.\n     \"\"\"\n \n-    def __init__(self, models=None, real_apps=None):\n-        self.models = models or {}\n+    def __init__(self, model_states=None, real_apps=None):\n+        self.models = model_states or {}\n         # Apps to include from main registry, usually unmigrated ones\n         if real_apps:\n             self.real_apps = real_apps if isinstance(real_apps, set) else set(real_apps)\n@@ -184,8 +184,6 @@ class ProjectState:\n         if not preserve_default:\n             field = field.clone()\n             field.default = NOT_PROVIDED\n-        else:\n-            field = field\n         self.models[app_label, model_name].fields[name] = field\n         # Delay rendering of relationships if it's not a relational field.\n         delay = not field.is_relation\n@@ -202,8 +200,6 @@ class ProjectState:\n         if not preserve_default:\n             field = field.clone()\n             field.default = NOT_PROVIDED\n-        else:\n-            field = field\n         model_state = self.models[app_label, model_name]\n         model_state.fields[name] = field\n         # TODO: investigate if old relational fields must be reloaded or if\n@@ -222,10 +218,10 @@ class ProjectState:\n         fields = model_state.fields\n         try:\n             found = fields.pop(old_name)\n-        except KeyError:\n+        except KeyError as exc:\n             raise FieldDoesNotExist(\n                 f\"{app_label}.{model_name} has no field named '{old_name}'\"\n-            )\n+            ) from exc\n         fields[new_name] = found\n         for field in fields.values():\n             # Fix from_fields to refer to the new field.\n@@ -312,10 +308,10 @@ class ProjectState:\n             related_models = self._find_reload_model(app_label, model_name, delay)\n             self._reload(related_models)\n \n-    def reload_models(self, models, delay=True):\n+    def reload_models(self, model_tuples, delay=True):\n         if 'apps' in self.__dict__:  # hasattr would cache the property\n             related_models = set()\n-            for app_label, model_name in models:\n+            for app_label, model_name in model_tuples:\n                 related_models.update(self._find_reload_model(app_label, model_name, delay))\n             self._reload(related_models)\n \n@@ -421,7 +417,7 @@ class ProjectState:\n             del self.__dict__['apps']\n \n     @cached_property\n-    def apps(self):\n+    def apps(self):  # pylint: disable=method-hidden\n         return StateApps(self.real_apps, self.models)\n \n     @classmethod\n@@ -440,6 +436,7 @@ class ProjectState:\n class AppConfigStub(AppConfig):\n     \"\"\"Stub of an AppConfig. Only provides a label and a dict of models.\"\"\"\n     def __init__(self, label):\n+        super().__init__(label)\n         self.apps = None\n         self.models = {}\n         # App-label and app-name are not the same thing, so technically passing\n@@ -449,7 +446,7 @@ class AppConfigStub(AppConfig):\n         self.name = label\n \n     def import_models(self):\n-        self.models = self.apps.all_models[self.label]\n+        self.models = self.apps.all_models[self.label]  # pylint: disable=no-member\n \n \n class StateApps(Apps):\n"
}