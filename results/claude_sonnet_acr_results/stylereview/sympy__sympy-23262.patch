{
  "patch": "diff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py\nindex da67263b19..c2d4d93fe7 100644\n--- a/sympy/utilities/lambdify.py\n+++ b/sympy/utilities/lambdify.py\n@@ -128,9 +128,9 @@ def _import(module, reload=False):\n     try:\n         namespace, namespace_default, translations, import_commands = MODULES[\n             module]\n-    except KeyError:\n+    except KeyError as exc:\n         raise NameError(\n-            \"'%s' module cannot be used for lambdification\" % module)\n+            \"'%s' module cannot be used for lambdification\" % module) from exc\n \n     # Clear namespace or exit\n     if namespace != namespace_default:\n@@ -143,6 +143,7 @@ def _import(module, reload=False):\n \n     for import_command in import_commands:\n         if import_command.startswith('import_module'):\n+            # pylint: disable=eval-used\n             module = eval(import_command)\n \n             if module is not None:\n@@ -150,6 +151,7 @@ def _import(module, reload=False):\n                 continue\n         else:\n             try:\n+                # pylint: disable=exec-used\n                 exec(import_command, {}, namespace)\n                 continue\n             except ImportError:\n@@ -881,12 +883,14 @@ def _lambdifygenerated(x):\n             if k not in namespace:\n                 ln = \"from %s import %s\" % (mod, k)\n                 try:\n+                    # pylint: disable=exec-used\n                     exec(ln, {}, namespace)\n                 except ImportError:\n                     # Tensorflow 2.0 has issues with importing a specific\n                     # function from its submodule.\n                     # https://github.com/tensorflow/tensorflow/issues/33022\n                     ln = \"%s = %s.%s\" % (k, mod, k)\n+                    # pylint: disable=exec-used\n                     exec(ln, {}, namespace)\n                 imp_mod_lines.append(ln)\n \n@@ -894,10 +898,12 @@ def _lambdifygenerated(x):\n     namespace.update({'builtins':builtins, 'range':range})\n \n     funclocals = {} # type: tDict[str, Any]\n+    # pylint: disable=global-statement\n     global _lambdify_generated_counter\n     filename = '<lambdifygenerated-%s>' % _lambdify_generated_counter\n     _lambdify_generated_counter += 1\n     c = compile(funcstr, filename, 'exec')\n+    # pylint: disable=exec-used\n     exec(c, namespace, funclocals)\n     # mtime has to be None or else linecache.checkcache will remove it\n     linecache.cache[filename] = (len(funcstr), None, funcstr.splitlines(True), filename) # type: ignore\n@@ -1003,7 +1009,7 @@ def lambdastr(args, expr, printer=None, dummify=None):\n             if inspect.isclass(printer):\n                 lambdarepr = lambda expr: printer().doprint(expr)\n             else:\n-                lambdarepr = lambda expr: printer.doprint(expr)\n+                lambdarepr = printer.doprint\n     else:\n         #XXX: This has to be done here because of circular imports\n         from sympy.printing.lambdarepr import lambdarepr\n@@ -1039,10 +1045,10 @@ def sub_expr(expr, dummies_dict):\n     def isiter(l):\n         return iterable(l, exclude=(str, DeferredVector, NotIterable))\n \n-    def flat_indexes(iterable):\n+    def flat_indexes(elems):\n         n = 0\n \n-        for el in iterable:\n+        for el in elems:\n             if isiter(el):\n                 for ndeep in flat_indexes(el):\n                     yield (n,) + ndeep\n@@ -1230,10 +1236,10 @@ def _subexpr(self, expr, dummies_dict):\n                 expr = [self._subexpr(sympify(a), dummies_dict) for a in expr]\n         return expr\n \n-    def _print_funcargwrapping(self, args):\n+    def _print_funcargwrapping(self, _args):\n         \"\"\"Generate argument wrapping code.\n \n-        args is the argument list of the generated function (strings).\n+        _args is the argument list of the generated function (strings).\n \n         Return value is a list of lines of code that will be inserted  at\n         the beginning of the function definition.\n@@ -1254,7 +1260,7 @@ def unpack_lhs(lvalues):\n         return ['{} = {}'.format(unpack_lhs(unpackto), arg)]\n \n class _TensorflowEvaluatorPrinter(_EvaluatorPrinter):\n-    def _print_unpacking(self, lvalues, rvalue):\n+    def _print_unpacking(self, unpackto, arg):\n         \"\"\"Generate argument unpacking code.\n \n         This method is used when the input value is not interable,\n@@ -1273,10 +1279,10 @@ def flat_indexes(elems):\n \n                 n += 1\n \n-        indexed = ', '.join('{}[{}]'.format(rvalue, ']['.join(map(str, ind)))\n-                                for ind in flat_indexes(lvalues))\n+        indexed = ', '.join('{}[{}]'.format(arg, ']['.join(map(str, ind)))\n+                                for ind in flat_indexes(unpackto))\n \n-        return ['[{}] = [{}]'.format(', '.join(flatten(lvalues)), indexed)]\n+        return ['[{}] = [{}]'.format(', '.join(flatten(unpackto)), indexed)]\n \n def _imp_namespace(expr, namespace=None):\n     \"\"\" Return namespace dict with function implementations\n@@ -1388,6 +1394,7 @@ def implemented_function(symfunc, implementation):\n     # if name, create function to hold implementation\n     kwargs = {}\n     if isinstance(symfunc, UndefinedFunction):\n+        # pylint: disable=protected-access\n         kwargs = symfunc._kwargs\n         symfunc = symfunc.__name__\n     if isinstance(symfunc, str):\n"
}