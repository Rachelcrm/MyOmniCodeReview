{
  "patch": "diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py\nindex da4ff928aa..33fb767d55 100644\n--- a/django/db/models/aggregates.py\n+++ b/django/db/models/aggregates.py\n@@ -21,16 +21,36 @@ class Aggregate(Func):\n     window_compatible = True\n     allow_distinct = False\n \n-    def __init__(self, *expressions, distinct=False, filter=None, **extra):\n+    def __init__(self, *expressions, distinct=False, filter_=None, **extra):\n         if distinct and not self.allow_distinct:\n             raise TypeError(\"%s does not allow distinct.\" % self.__class__.__name__)\n         self.distinct = distinct\n-        self.filter = filter\n+        self.filter = filter_\n         super().__init__(*expressions, **extra)\n \n+    def __and__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __or__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __rand__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __ror__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def get_source_fields(self):\n         # Don't return the filter expression since it's not a source field.\n-        return [e._output_field_or_none for e in super().get_source_expressions()]\n+        return [e._output_field_or_none for e in super().get_source_expressions()]  # pylint: disable=protected-access\n \n     def get_source_expressions(self):\n         source_expressions = super().get_source_expressions()\n@@ -67,14 +87,14 @@ class Aggregate(Func):\n     def get_group_by_cols(self, alias=None):\n         return []\n \n-    def as_sql(self, compiler, connection, **extra_context):\n+    def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):\n         extra_context['distinct'] = 'DISTINCT ' if self.distinct else ''\n         if self.filter:\n             if connection.features.supports_aggregate_filter_clause:\n                 filter_sql, filter_params = self.filter.as_sql(compiler, connection)\n                 template = self.filter_template % extra_context.get('template', self.template)\n                 sql, params = super().as_sql(\n-                    compiler, connection, template=template, filter=filter_sql,\n+                    compiler, connection, function=function, template=template, arg_joiner=arg_joiner, filter=filter_sql,\n                     **extra_context\n                 )\n                 return sql, params + filter_params\n@@ -84,8 +104,8 @@ class Aggregate(Func):\n                 source_expressions = copy.get_source_expressions()\n                 condition = When(self.filter, then=source_expressions[0])\n                 copy.set_source_expressions([Case(condition)] + source_expressions[1:])\n-                return super(Aggregate, copy).as_sql(compiler, connection, **extra_context)\n-        return super().as_sql(compiler, connection, **extra_context)\n+                return super(Aggregate, copy).as_sql(compiler, connection, function=function, template=template, arg_joiner=arg_joiner, **extra_context)\n+        return super().as_sql(compiler, connection, function=function, template=template, arg_joiner=arg_joiner, **extra_context)\n \n     def _get_repr_options(self):\n         options = super()._get_repr_options()\n@@ -107,14 +127,14 @@ class Count(Aggregate):\n     output_field = IntegerField()\n     allow_distinct = True\n \n-    def __init__(self, expression, filter=None, **extra):\n+    def __init__(self, expression, filter_=None, **extra):\n         if expression == '*':\n             expression = Star()\n-        if isinstance(expression, Star) and filter is not None:\n+        if isinstance(expression, Star) and filter_ is not None:\n             raise ValueError('Star cannot be used with filter. Please specify a field.')\n-        super().__init__(expression, filter=filter, **extra)\n+        super().__init__(expression, filter_=filter_, **extra)\n \n-    def convert_value(self, value, expression, connection):\n+    def convert_value(self, value, _expression, _connection):\n         return 0 if value is None else value\n \n \n"
}