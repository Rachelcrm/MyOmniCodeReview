{
  "patch": "diff --git a/youtube_dl/extractor/youtube.py b/youtube_dl/extractor/youtube.py\nindex 90c16e172..5a45864a1 100644\n--- a/youtube_dl/extractor/youtube.py\n+++ b/youtube_dl/extractor/youtube.py\n@@ -14,13 +14,13 @@ from .common import InfoExtractor, SearchInfoExtractor\n from ..compat import (\n     compat_chr,\n     compat_HTTPError,\n-    compat_map as map,\n+    compat_map,\n     compat_str,\n     compat_urllib_parse,\n     compat_urllib_parse_parse_qs as compat_parse_qs,\n     compat_urllib_parse_unquote_plus,\n     compat_urllib_parse_urlparse,\n-    compat_zip as zip,\n+    compat_zip,\n )\n from ..jsinterp import JSInterpreter\n from ..utils import (\n@@ -78,6 +78,15 @@ class YoutubeBaseInfoExtractor(InfoExtractor):\n \n     _PLAYLIST_ID_RE = r'(?:(?:PL|LL|EC|UU|FL|RD|UL|TL|PU|OLAK5uy_)[0-9A-Za-z-_]{10,}|RDMM)'\n \n+    def _get_automatic_captions(self, *args, **kwargs):\n+        raise NotImplementedError('This method must be implemented by subclasses')\n+\n+    def _get_subtitles(self, *args, **kwargs):\n+        raise NotImplementedError('This method must be implemented by subclasses')\n+\n+    def _mark_watched(self, *args, **kwargs):\n+        raise NotImplementedError('This method must be implemented by subclasses')\n+\n     def _login(self):\n         \"\"\"\n         Attempt to log in to YouTube.\n@@ -412,7 +421,10 @@ class YoutubeBaseInfoExtractor(InfoExtractor):\n             ('owner', 'videoOwner'), 'videoOwnerRenderer', 'title',\n             'runs', Ellipsis]\n \n-    def _extract_channel_id(self, webpage, videodetails={}, metadata={}, renderers=[]):\n+    def _extract_channel_id(self, webpage, videodetails=None, metadata=None, renderers=None):\n+        videodetails = videodetails or {}\n+        metadata = metadata or {}\n+        renderers = renderers or []\n         channel_id = None\n         if any((videodetails, metadata, renderers)):\n             channel_id = (\n@@ -427,7 +439,10 @@ class YoutubeBaseInfoExtractor(InfoExtractor):\n             'channelId', webpage, 'channel id', default=None)\n \n     def _extract_author_var(self, webpage, var_name,\n-                            videodetails={}, metadata={}, renderers=[]):\n+                            videodetails=None, metadata=None, renderers=None):\n+        videodetails = videodetails or {}\n+        metadata = metadata or {}\n+        renderers = renderers or []\n         result = None\n         paths = {\n             #       (HTML, videodetails, metadata, renderers)\n@@ -1550,7 +1565,8 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n             step = None\n             # Quelch pyflakes warnings - start will be set when step is set\n             start = '(Never used)'\n-            for i, prev in zip(idxs[1:], idxs[:-1]):\n+            i = None  # Initialize i to handle empty loop case\n+            for i, prev in compat_zip(idxs[1:], idxs[:-1]):\n                 if step is not None:\n                     if i - prev == step:\n                         continue\n@@ -1563,10 +1579,11 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n                     continue\n                 else:\n                     yield 's[%d]' % prev\n-            if step is None:\n-                yield 's[%d]' % i\n-            else:\n-                yield _genslice(start, i, step)\n+            if i is not None:  # Only proceed if loop executed\n+                if step is None:\n+                    yield 's[%d]' % i\n+                else:\n+                    yield _genslice(start, i, step)\n \n         test_string = ''.join(map(compat_chr, range(len(example_sig))))\n         cache_res = func(test_string)\n@@ -1636,7 +1653,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n         try:\n             jsi, player_id, func_code = self._extract_n_function_code(video_id, player_url)\n         except ExtractorError as e:\n-            raise ExtractorError('Unable to extract nsig jsi, player_id, func_codefunction code', cause=e)\n+            raise ExtractorError('Unable to extract nsig jsi, player_id, func_codefunction code', cause=e) from e\n         if self.get_param('youtube_print_sig_code'):\n             self.to_screen('Extracted nsig function from {0}:\\n{1}\\n'.format(\n                 player_id, func_code[1]))\n@@ -1749,7 +1766,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n                 'JS player signature timestamp', group='sts', fatal=fatal))\n         return sts\n \n-    def _mark_watched(self, video_id, player_response):\n+    def _mark_watched(self, video_id, player_response, *args, **kwargs):\n         playback_url = url_or_none(try_get(\n             player_response,\n             lambda x: x['playbackTracking']['videostatsPlaybackUrl']['baseUrl']))\n@@ -1822,7 +1839,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n         video_id = mobj.group(2)\n         return video_id\n \n-    def _extract_chapters_from_json(self, data, video_id, duration):\n+    def _extract_chapters_from_json(self, data, _video_id, duration):\n         chapters_list = try_get(\n             data,\n             lambda x: x['playerOverlays']\n"
}