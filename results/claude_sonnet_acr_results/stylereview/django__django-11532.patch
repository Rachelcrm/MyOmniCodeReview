{
  "patch": "diff --git a/django/core/mail/message.py b/django/core/mail/message.py\nindex e393b4cf5c..7778dfd5d8 100644\n--- a/django/core/mail/message.py\n+++ b/django/core/mail/message.py\n@@ -81,7 +81,7 @@ def sanitize_address(addr, encoding):\n         try:\n             token, rest = parser.get_mailbox(addr)\n         except (HeaderParseError, ValueError, IndexError):\n-            raise ValueError('Invalid address \"%s\"' % addr)\n+            raise ValueError('Invalid address \"%s\"' % addr) from None\n         else:\n             if rest:\n                 # The entire email address must be parsed.\n@@ -297,7 +297,7 @@ class EmailMessage:\n         else:\n             assert content is not None\n             mimetype = mimetype or mimetypes.guess_type(filename)[0] or DEFAULT_ATTACHMENT_MIME_TYPE\n-            basetype, subtype = mimetype.split('/', 1)\n+            basetype, _ = mimetype.split('/', 1)\n \n             if basetype == 'text':\n                 if isinstance(content, bytes):\ndiff --git a/django/core/mail/utils.py b/django/core/mail/utils.py\nindex d18dfe4667..cb66358cda 100644\n--- a/django/core/mail/utils.py\n+++ b/django/core/mail/utils.py\n@@ -8,11 +8,14 @@ import socket\n # Cache the hostname, but do it lazily: socket.getfqdn() can take a couple of\n # seconds, which slows down the restart of the server.\n class CachedDnsName:\n+    def __init__(self):\n+        self._fqdn = None\n+\n     def __str__(self):\n         return self.get_fqdn()\n \n     def get_fqdn(self):\n-        if not hasattr(self, '_fqdn'):\n+        if self._fqdn is None:\n             self._fqdn = socket.getfqdn()\n         return self._fqdn\n \ndiff --git a/django/core/validators.py b/django/core/validators.py\nindex 827b1eea09..ab0b7ad8b6 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -126,7 +126,7 @@ class URLValidator(RegexValidator):\n                 try:\n                     netloc = netloc.encode('idna').decode('ascii')  # IDN -> ACE\n                 except UnicodeError:  # invalid domain part\n-                    raise e\n+                    raise e from None\n                 url = urlunsplit((scheme, netloc, path, query, fragment))\n                 super().__call__(url)\n             else:\n@@ -139,7 +139,7 @@ class URLValidator(RegexValidator):\n                 try:\n                     validate_ipv6_address(potential_ip)\n                 except ValidationError:\n-                    raise ValidationError(self.message, code=self.code)\n+                    raise ValidationError(self.message, code=self.code) from None\n \n         # The maximum length of a full host name is 253 characters per RFC 1034\n         # section 3.1. It's defined to be 255 bytes or less, but this includes\n@@ -252,7 +252,7 @@ def validate_ipv4_address(value):\n     try:\n         ipaddress.IPv4Address(value)\n     except ValueError:\n-        raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')\n+        raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid') from None\n \n \n def validate_ipv6_address(value):\n@@ -267,7 +267,7 @@ def validate_ipv46_address(value):\n         try:\n             validate_ipv6_address(value)\n         except ValidationError:\n-            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')\n+            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid') from None\n \n \n ip_address_validator_map = {\n@@ -289,7 +289,7 @@ def ip_address_validators(protocol, unpack_ipv4):\n         return ip_address_validator_map[protocol.lower()]\n     except KeyError:\n         raise ValueError(\"The protocol '%s' is unknown. Supported: %s\"\n-                         % (protocol, list(ip_address_validator_map)))\n+                         % (protocol, list(ip_address_validator_map))) from None\n \n \n def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False):\ndiff --git a/django/utils/encoding.py b/django/utils/encoding.py\nindex 94b63762db..68f4d62390 100644\n--- a/django/utils/encoding.py\n+++ b/django/utils/encoding.py\n@@ -63,7 +63,7 @@ def force_str(s, encoding='utf-8', strings_only=False, errors='strict'):\n         else:\n             s = str(s)\n     except UnicodeDecodeError as e:\n-        raise DjangoUnicodeDecodeError(s, *e.args)\n+        raise DjangoUnicodeDecodeError(s, *e.args) from e\n     return s\n \n \n@@ -190,8 +190,8 @@ def uri_to_iri(uri):\n         append = parts.append\n         hextobyte = _hextobyte\n         for item in bits[1:]:\n-            hex = item[:2]\n-            if hex in hextobyte:\n+            hex_part = item[:2]\n+            if hex_part in hextobyte:\n                 append(hextobyte[item[:2]])\n                 append(item[2:])\n             else:\ndiff --git a/django/utils/html.py b/django/utils/html.py\nindex fb636600c9..c46ce6a5ec 100644\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -149,8 +149,11 @@ class MLStripper(HTMLParser):\n         self.reset()\n         self.fed = []\n \n-    def handle_data(self, d):\n-        self.fed.append(d)\n+    def handle_data(self, data):\n+        self.fed.append(data)\n+\n+    def error(self, message):\n+        pass\n \n     def handle_entityref(self, name):\n         self.fed.append('&%s;' % name)\n@@ -290,7 +293,7 @@ def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):\n         if '@' not in value or value.startswith('@') or value.endswith('@'):\n             return False\n         try:\n-            p1, p2 = value.split('@')\n+            _, p2 = value.split('@')\n         except ValueError:\n             # value contains more than one @.\n             return False\n@@ -370,5 +373,5 @@ def html_safe(klass):\n         )\n     klass_str = klass.__str__\n     klass.__str__ = lambda self: mark_safe(klass_str(self))\n-    klass.__html__ = lambda self: str(self)\n+    klass.__html__ = klass.__str__\n     return klass\n"
}