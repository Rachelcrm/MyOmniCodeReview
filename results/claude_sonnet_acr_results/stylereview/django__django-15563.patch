{
  "patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 59a5d6abbb..35fedf7edf 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -48,6 +48,7 @@ class SQLCompiler:\n         self.annotation_col_map = None\n         self.klass_info = None\n         self._meta_ordering = None\n+        self.col_count = None\n \n     def __repr__(self):\n         return (\n@@ -174,7 +175,7 @@ class SQLCompiler:\n                 # Is this a reference to query's base table primary key? If the\n                 # expression isn't a Col-like, then skip the expression.\n                 if (\n-                    getattr(expr, \"target\", None) == self.query.model._meta.pk\n+                    getattr(expr, \"target\", None) == self.query.model._meta.pk  # pylint: disable=protected-access\n                     and getattr(expr, \"alias\", None) == self.query.base_table\n                 ):\n                     pk = expr\n@@ -503,7 +504,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n-    def get_combinator_sql(self, combinator, all):\n+    def get_combinator_sql(self, combinator, all_flag):\n         features = self.connection.features\n         compilers = [\n             query.get_compiler(self.using, self.connection, self.elide_empty)\n@@ -558,7 +559,7 @@ class SQLCompiler:\n         if not parts:\n             raise EmptyResultSet\n         combinator_sql = self.connection.ops.set_operators[combinator]\n-        if all and combinator == \"union\":\n+        if all_flag and combinator == \"union\":\n             combinator_sql += \" ALL\"\n         braces = \"{}\"\n         if not self.query.subquery and features.supports_slicing_ordering_in_compound:\n@@ -1024,11 +1025,11 @@ class SQLCompiler:\n             fields_found.add(f.name)\n \n             if restricted:\n-                next = requested.get(f.name, {})\n+                next_fields = requested.get(f.name, {})\n                 if not f.is_relation:\n                     # If a non-related field is used like a relation,\n                     # or if a single non-relational field is given.\n-                    if next or f.name in requested:\n+                    if next_fields or f.name in requested:\n                         raise FieldError(\n                             \"Non-relational field given in select_related: '%s'. \"\n                             \"Choices are: %s\"\n@@ -1038,7 +1039,7 @@ class SQLCompiler:\n                             )\n                         )\n             else:\n-                next = False\n+                next_fields = False\n \n             if not select_related_descend(\n                 f, restricted, requested, only_load.get(field_model)\n@@ -1070,7 +1071,7 @@ class SQLCompiler:\n                 f.remote_field.model._meta,\n                 alias,\n                 cur_depth + 1,\n-                next,\n+                next_fields,\n                 restricted,\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n@@ -1112,9 +1113,9 @@ class SQLCompiler:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n                 klass_info[\"select_fields\"] = select_fields\n-                next = requested.get(f.related_query_name(), {})\n+                next_fields = requested.get(f.related_query_name(), {})\n                 next_klass_infos = self.get_related_selections(\n-                    select, model._meta, alias, cur_depth + 1, next, restricted\n+                    select, model._meta, alias, cur_depth + 1, next_fields, restricted\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n"
}