{
  "patch": "diff --git a/sympy/utilities/iterables.py b/sympy/utilities/iterables.py\nindex dd36dea304..2720c84cbb 100644\n--- a/sympy/utilities/iterables.py\n+++ b/sympy/utilities/iterables.py\n@@ -1,7 +1,7 @@\n from collections import defaultdict, OrderedDict\n from itertools import (\n     combinations, combinations_with_replacement, permutations,\n-    product, product as cartes\n+    product\n )\n import random\n from operator import gt\n@@ -53,7 +53,7 @@ def is_palindromic(s, i=0, j=None):\n     return all(s[i + k] == s[j - 1 - k] for k in range(m))\n \n \n-def flatten(iterable, levels=None, cls=None):\n+def flatten(seq, levels=None, cls=None):\n     \"\"\"\n     Recursively denest iterable containers.\n \n@@ -92,7 +92,7 @@ def flatten(iterable, levels=None, cls=None):\n     from sympy.tensor.array import NDimArray\n     if levels is not None:\n         if not levels:\n-            return iterable\n+            return seq\n         elif levels > 0:\n             levels -= 1\n         else:\n@@ -106,7 +106,7 @@ def flatten(iterable, levels=None, cls=None):\n \n     result = []\n \n-    for el in iterable:\n+    for el in seq:\n         if reducible(el):\n             if hasattr(el, 'args') and not isinstance(el, NDimArray):\n                 el = el.args\n@@ -117,13 +117,13 @@ def flatten(iterable, levels=None, cls=None):\n     return result\n \n \n-def unflatten(iter, n=2):\n-    \"\"\"Group ``iter`` into tuples of length ``n``. Raise an error if\n-    the length of ``iter`` is not a multiple of ``n``.\n+def unflatten(sequence, n=2):\n+    \"\"\"Group ``sequence`` into tuples of length ``n``. Raise an error if\n+    the length of ``sequence`` is not a multiple of ``n``.\n     \"\"\"\n-    if n < 1 or len(iter) % n:\n-        raise ValueError('iter length is not a multiple of %i' % n)\n-    return list(zip(*(iter[i::n] for i in range(n))))\n+    if n < 1 or len(sequence) % n:\n+        raise ValueError('sequence length is not a multiple of %i' % n)\n+    return list(zip(*(sequence[i::n] for i in range(n))))\n \n \n def reshape(seq, how):\n@@ -385,10 +385,8 @@ def interactive_traversal(expr):\n \n     RED, BRED = '\\033[0;31m', '\\033[1;31m'\n     GREEN, BGREEN = '\\033[0;32m', '\\033[1;32m'\n-    YELLOW, BYELLOW = '\\033[0;33m', '\\033[1;33m'  # noqa\n-    BLUE, BBLUE = '\\033[0;34m', '\\033[1;34m'      # noqa\n-    MAGENTA, BMAGENTA = '\\033[0;35m', '\\033[1;35m'# noqa\n-    CYAN, BCYAN = '\\033[0;36m', '\\033[1;36m'      # noqa\n+    BYELLOW = '\\033[1;33m'\n+    BCYAN = '\\033[0;36m'\n     END = '\\033[0m'\n \n     def cprint(*args):\n@@ -472,7 +470,7 @@ def _interactive_traversal(expr, stage):\n     return _interactive_traversal(expr, 0)\n \n \n-def ibin(n, bits=None, str=False):\n+def ibin(n, bits=None, as_str=False):\n     \"\"\"Return a list of length ``bits`` corresponding to the binary value\n     of ``n`` with small bits to the right (last). If bits is omitted, the\n     length will be the number required to represent ``n``. If the bits are\n@@ -482,7 +480,7 @@ def ibin(n, bits=None, str=False):\n     through ``[1, 1, ..., 1]`` are desired, pass a non-integer for bits, e.g.\n     ``'all'``.\n \n-    If the bit *string* is desired pass ``str=True``.\n+    If the bit *string* is desired pass ``as_str=True``.\n \n     Examples\n     ========\n@@ -504,15 +502,15 @@ def ibin(n, bits=None, str=False):\n     (1, 0)\n     (1, 1)\n \n-    If a bit string is desired of a given length, use str=True:\n+    If a bit string is desired of a given length, use as_str=True:\n \n     >>> n = 123\n     >>> bits = 10\n-    >>> ibin(n, bits, str=True)\n+    >>> ibin(n, bits, as_str=True)\n     '0001111011'\n-    >>> ibin(n, bits, str=True)[::-1]  # small bits left\n+    >>> ibin(n, bits, as_str=True)[::-1]  # small bits left\n     '1101111000'\n-    >>> list(ibin(3, 'all', str=True))\n+    >>> list(ibin(3, 'all', as_str=True))\n     ['000', '001', '010', '011', '100', '101', '110', '111']\n \n     \"\"\"\n@@ -524,7 +522,7 @@ def ibin(n, bits=None, str=False):\n         bits = 0\n     else:\n         try:\n-             bits = as_int(bits)\n+            bits = as_int(bits)\n         except ValueError:\n             bits = -1\n         else:\n@@ -532,7 +530,7 @@ def ibin(n, bits=None, str=False):\n                 raise ValueError(\n                     \"`bits` must be >= {}\".format(n.bit_length()))\n \n-    if not str:\n+    if not as_str:\n         if bits >= 0:\n             return [1 if i == \"1\" else 0 for i in bin(n)[2:].rjust(bits, \"0\")]\n         else:\n@@ -663,7 +661,7 @@ def filter_symbols(iterator, exclude):\n         if s not in exclude:\n             yield s\n \n-def numbered_symbols(prefix='x', cls=None, start=0, exclude=[], *args, **assumptions):\n+def numbered_symbols(prefix='x', cls=None, start=0, *args, exclude=None, **assumptions):\n     \"\"\"\n     Generate an infinite stream of Symbols consisting of a prefix and\n     increasing subscripts provided that they do not occur in ``exclude``.\n@@ -810,26 +808,26 @@ def sift(seq, keyfunc, binary=False):\n         for i in seq:\n             m[keyfunc(i)].append(i)\n         return m\n-    sift = F, T = [], []\n+    bins = F, T = [], []\n     for i in seq:\n         try:\n-            sift[keyfunc(i)].append(i)\n-        except (IndexError, TypeError):\n-            raise ValueError('keyfunc gave non-binary output')\n+            bins[keyfunc(i)].append(i)\n+        except (IndexError, TypeError) as exc:\n+            raise ValueError('keyfunc gave non-binary output') from exc\n     return T, F\n \n \n-def take(iter, n):\n-    \"\"\"Return ``n`` items from ``iter`` iterator. \"\"\"\n-    return [ value for _, value in zip(range(n), iter) ]\n+def take(iterable, n):\n+    \"\"\"Return ``n`` items from ``iterable`` iterator. \"\"\"\n+    return [ value for _, value in zip(range(n), iterable) ]\n \n \n def dict_merge(*dicts):\n     \"\"\"Merge dictionaries into a single dictionary. \"\"\"\n     merged = {}\n \n-    for dict in dicts:\n-        merged.update(dict)\n+    for d in dicts:\n+        merged.update(d)\n \n     return merged\n \n@@ -2010,14 +2008,14 @@ def binary_partitions(n):\n \n     \"\"\"\n     from math import ceil, log\n-    pow = int(2**(ceil(log(n, 2))))\n-    sum = 0\n+    power = int(2**(ceil(log(n, 2))))\n+    total = 0\n     partition = []\n-    while pow:\n-        if sum + pow <= n:\n-            partition.append(pow)\n-            sum += pow\n-        pow >>= 1\n+    while power:\n+        if total + power <= n:\n+            partition.append(power)\n+            total += power\n+        power >>= 1\n \n     last_num = len(partition) - 1 - (n & 1)\n     while last_num >= 0:\n@@ -2061,8 +2059,8 @@ def has_dups(seq):\n     from sympy.sets.sets import Set\n     if isinstance(seq, (dict, set, Dict, Set)):\n         return False\n-    uniq = set()\n-    return any(True for s in seq if s in uniq or uniq.add(s))\n+    seen = set()\n+    return any(True for s in seq if s in seen or seen.add(s))\n \n \n def has_variety(seq):\n"
}