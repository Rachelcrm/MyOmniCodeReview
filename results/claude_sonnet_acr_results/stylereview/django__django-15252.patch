{
  "patch": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex aa2fe0883b..96a1be0660 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -154,7 +154,7 @@ class MigrationExecutor:\n                     if self.progress_callback:\n                         self.progress_callback(\"render_success\")\n                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)\n-                migrations_to_run.remove(migration)\n+                migrations_to_run.remove(migration)  # pylint: disable=pointless-statement\n \n         return state\n \n@@ -192,7 +192,7 @@ class MigrationExecutor:\n                 states[migration] = state\n                 # The old state keeps as-is, we continue with the new state\n                 state = migration.mutate_state(state, preserve=True)\n-                migrations_to_run.remove(migration)\n+                migrations_to_run.remove(migration)  # pylint: disable=pointless-statement\n             elif migration in applied_migrations:\n                 # Only mutate the state if the migration is actually applied\n                 # to make sure the resulting state doesn't include changes\n@@ -298,10 +298,10 @@ class MigrationExecutor:\n             models that can't be migrated on the current database.\n             \"\"\"\n             return (\n-                model._meta.proxy or not model._meta.managed or not\n+                model._meta.proxy or not model._meta.managed or not  # pylint: disable=protected-access\n                 router.allow_migrate(\n                     self.connection.alias, migration.app_label,\n-                    model_name=model._meta.model_name,\n+                    model_name=model._meta.model_name,  # pylint: disable=protected-access\n                 )\n             )\n \n@@ -329,13 +329,13 @@ class MigrationExecutor:\n         for operation in migration.operations:\n             if isinstance(operation, migrations.CreateModel):\n                 model = apps.get_model(migration.app_label, operation.name)\n-                if model._meta.swapped:\n+                if model._meta.swapped:  # pylint: disable=protected-access\n                     # We have to fetch the model to test with from the\n                     # main app cache, as it's not a direct dependency.\n-                    model = global_apps.get_model(model._meta.swapped)\n+                    model = global_apps.get_model(model._meta.swapped)  # pylint: disable=protected-access\n                 if should_skip_detecting_model(migration, model):\n                     continue\n-                db_table = model._meta.db_table\n+                db_table = model._meta.db_table  # pylint: disable=protected-access\n                 if fold_identifier_case:\n                     db_table = db_table.casefold()\n                 if db_table not in existing_table_names:\n@@ -343,19 +343,19 @@ class MigrationExecutor:\n                 found_create_model_migration = True\n             elif isinstance(operation, migrations.AddField):\n                 model = apps.get_model(migration.app_label, operation.model_name)\n-                if model._meta.swapped:\n+                if model._meta.swapped:  # pylint: disable=protected-access\n                     # We have to fetch the model to test with from the\n                     # main app cache, as it's not a direct dependency.\n-                    model = global_apps.get_model(model._meta.swapped)\n+                    model = global_apps.get_model(model._meta.swapped)  # pylint: disable=protected-access\n                 if should_skip_detecting_model(migration, model):\n                     continue\n \n-                table = model._meta.db_table\n-                field = model._meta.get_field(operation.name)\n+                table = model._meta.db_table  # pylint: disable=protected-access\n+                field = model._meta.get_field(operation.name)  # pylint: disable=protected-access\n \n                 # Handle implicit many-to-many tables created by AddField.\n                 if field.many_to_many:\n-                    through_db_table = field.remote_field.through._meta.db_table\n+                    through_db_table = field.remote_field.through._meta.db_table  # pylint: disable=protected-access\n                     if fold_identifier_case:\n                         through_db_table = through_db_table.casefold()\n                     if through_db_table not in existing_table_names:\n"
}