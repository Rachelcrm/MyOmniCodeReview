{
  "patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex a415a7074..8f5a0d380 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -19,10 +19,10 @@ import typing\n import warnings\n from functools import partial, partialmethod\n from importlib import import_module\n-from inspect import Parameter, isclass, ismethod, ismethoddescriptor, ismodule  # NOQA\n+from inspect import Parameter, isclass  # NOQA\n from io import StringIO\n from types import ModuleType\n-from typing import Any, Callable, Dict, Mapping, Optional, Sequence, Tuple, Type, cast\n+from typing import Any, Callable, Dict, Mapping, Optional, Sequence, Tuple, Type, cast, TYPE_CHECKING\n \n from sphinx.deprecation import RemovedInSphinx50Warning\n from sphinx.pycode.ast import ast  # for py36-37\n@@ -38,9 +38,9 @@ else:\n     MethodDescriptorType = type(str.join)\n     WrapperDescriptorType = type(dict.__dict__['fromkeys'])\n \n-if False:\n+if TYPE_CHECKING:\n     # For type annotation\n-    from typing import Type  # NOQA\n+    pass\n \n logger = logging.getLogger(__name__)\n \n@@ -396,13 +396,13 @@ def isproperty(obj: Any) -> bool:\n def isgenericalias(obj: Any) -> bool:\n     \"\"\"Check if the object is GenericAlias.\"\"\"\n     if (hasattr(typing, '_GenericAlias') and  # only for py37+\n-            isinstance(obj, typing._GenericAlias)):  # type: ignore\n+            isinstance(obj, typing._GenericAlias)):  # type: ignore  # pylint: disable=protected-access\n         return True\n     elif (hasattr(types, 'GenericAlias') and  # only for py39+\n           isinstance(obj, types.GenericAlias)):  # type: ignore\n         return True\n     elif (hasattr(typing, '_SpecialGenericAlias') and  # for py39+\n-            isinstance(obj, typing._SpecialGenericAlias)):  # type: ignore\n+            isinstance(obj, typing._SpecialGenericAlias)):  # type: ignore  # pylint: disable=protected-access\n         return True\n     else:\n         return False\n@@ -412,14 +412,14 @@ def safe_getattr(obj: Any, name: str, *defargs: Any) -> Any:\n     \"\"\"A getattr() that turns all exceptions into AttributeErrors.\"\"\"\n     try:\n         return getattr(obj, name, *defargs)\n-    except Exception as exc:\n+    except Exception as exc:  # pylint: disable=broad-exception-caught\n         # sometimes accessing a property raises an exception (e.g.\n         # NotImplementedError), so let's try to read the attribute directly\n         try:\n             # In case the object does weird things with attribute access\n             # such that accessing `obj.__dict__` may raise an exception\n             return obj.__dict__[name]\n-        except Exception:\n+        except Exception:  # pylint: disable=broad-exception-caught\n             pass\n \n         # this is a catch-all for all the weird things that some modules do\n@@ -430,36 +430,36 @@ def safe_getattr(obj: Any, name: str, *defargs: Any) -> Any:\n         raise AttributeError(name) from exc\n \n \n-def object_description(object: Any) -> str:\n+def object_description(obj: Any) -> str:\n     \"\"\"A repr() implementation that returns text safe to use in reST context.\"\"\"\n-    if isinstance(object, dict):\n+    if isinstance(obj, dict):\n         try:\n-            sorted_keys = sorted(object)\n-        except Exception:\n+            sorted_keys = sorted(obj)\n+        except Exception:  # pylint: disable=broad-exception-caught\n             pass  # Cannot sort dict keys, fall back to generic repr\n         else:\n             items = (\"%s: %s\" %\n-                     (object_description(key), object_description(object[key]))\n+                     (object_description(key), object_description(obj[key]))\n                      for key in sorted_keys)\n             return \"{%s}\" % \", \".join(items)\n-    if isinstance(object, set):\n+    if isinstance(obj, set):\n         try:\n-            sorted_values = sorted(object)\n+            sorted_values = sorted(obj)\n         except TypeError:\n             pass  # Cannot sort set values, fall back to generic repr\n         else:\n             return \"{%s}\" % \", \".join(object_description(x) for x in sorted_values)\n-    if isinstance(object, frozenset):\n+    if isinstance(obj, frozenset):\n         try:\n-            sorted_values = sorted(object)\n+            sorted_values = sorted(obj)\n         except TypeError:\n             pass  # Cannot sort frozenset values, fall back to generic repr\n         else:\n             return \"frozenset({%s})\" % \", \".join(object_description(x)\n                                                  for x in sorted_values)\n     try:\n-        s = repr(object)\n-    except Exception as exc:\n+        s = repr(obj)\n+    except Exception as exc:  # pylint: disable=broad-exception-caught\n         raise ValueError from exc\n     # Strip non-deterministic memory addresses such as\n     # ``<__main__.A at 0x7f68cb685710>``\n@@ -587,12 +587,14 @@ def _should_unwrap(subject: Callable) -> bool:\n \n \n def signature(subject: Callable, bound_method: bool = False, follow_wrapped: bool = None,\n-              type_aliases: Dict = {}) -> inspect.Signature:\n+              type_aliases: Dict = None) -> inspect.Signature:\n     \"\"\"Return a Signature object for the given *subject*.\n \n     :param bound_method: Specify *subject* is a bound method or not\n     :param follow_wrapped: Same as ``inspect.signature()``.\n     \"\"\"\n+    if type_aliases is None:\n+        type_aliases = {}\n \n     if follow_wrapped is None:\n         follow_wrapped = True\n@@ -603,14 +605,14 @@ def signature(subject: Callable, bound_method: bool = False, follow_wrapped: boo\n     try:\n         try:\n             if _should_unwrap(subject):\n-                signature = inspect.signature(subject)\n+                sig = inspect.signature(subject)\n             else:\n-                signature = inspect.signature(subject, follow_wrapped=follow_wrapped)\n+                sig = inspect.signature(subject, follow_wrapped=follow_wrapped)\n         except ValueError:\n             # follow built-in wrappers up (ex. functools.lru_cache)\n-            signature = inspect.signature(subject)\n-        parameters = list(signature.parameters.values())\n-        return_annotation = signature.return_annotation\n+            sig = inspect.signature(subject)\n+        parameters = list(sig.parameters.values())\n+        return_annotation = sig.return_annotation\n     except IndexError:\n         # Until python 3.6.4, cpython has been crashed on inspection for\n         # partialmethods not having any arguments.\n@@ -636,7 +638,7 @@ def signature(subject: Callable, bound_method: bool = False, follow_wrapped: boo\n                 return_annotation = annotations['return'].name\n             else:\n                 return_annotation = annotations['return']\n-    except Exception:\n+    except Exception:  # pylint: disable=broad-exception-caught\n         # ``get_type_hints()`` does not support some kind of objects like partial,\n         # ForwardRef and so on.\n         pass\n@@ -665,9 +667,9 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     def evaluate_forwardref(ref: ForwardRef, globalns: Dict, localns: Dict) -> Any:\n         \"\"\"Evaluate a forward reference.\"\"\"\n         if sys.version_info > (3, 9):\n-            return ref._evaluate(globalns, localns, frozenset())\n+            return ref._evaluate(globalns, localns, frozenset())  # pylint: disable=protected-access\n         else:\n-            return ref._evaluate(globalns, localns)\n+            return ref._evaluate(globalns, localns)  # pylint: disable=protected-access\n \n     def evaluate(annotation: Any, globalns: Dict, localns: Dict) -> Any:\n         \"\"\"Evaluate unresolved type annotation.\"\"\"\n@@ -758,9 +760,9 @@ def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n         return '(%s) -> %s' % (', '.join(args), annotation)\n \n \n-def signature_from_str(signature: str) -> inspect.Signature:\n+def signature_from_str(signature_str: str) -> inspect.Signature:\n     \"\"\"Create a Signature object from string.\"\"\"\n-    code = 'def func' + signature + ': pass'\n+    code = 'def func' + signature_str + ': pass'\n     module = ast.parse(code)\n     function = cast(ast.FunctionDef, module.body[0])  # type: ignore\n \n"
}