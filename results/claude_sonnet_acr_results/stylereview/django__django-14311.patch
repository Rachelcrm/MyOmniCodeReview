{
  "patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex b6af5f5491..eb12a2dd57 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -12,7 +12,10 @@ import weakref\n from collections import defaultdict\n from pathlib import Path\n from types import ModuleType\n-from zipimport import zipimporter\n+try:\n+    from zipimport import zipimporter\n+except ImportError:\n+    zipimporter = None\n \n import django\n from django.apps import apps\n@@ -65,7 +68,7 @@ def check_errors(fn):\n         except Exception:\n             _exception = sys.exc_info()\n \n-            et, ev, tb = _exception\n+            _, ev, tb = _exception\n \n             if getattr(ev, 'filename', None) is None:\n                 # get the filename from the last item in the stack\n@@ -140,7 +143,7 @@ def iter_modules_and_files(modules, extra_files):\n         # Modules could be loaded from places without a concrete location. If\n         # this is the case, skip them.\n         if spec.has_location:\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n+            origin = spec.loader.archive if zipimporter and isinstance(spec.loader, zipimporter) else spec.origin\n             sys_file_paths.append(origin)\n \n     results = set()\n@@ -252,7 +255,7 @@ def restart_with_reloader():\n     new_environ = {**os.environ, DJANGO_AUTORELOAD_ENV: 'true'}\n     args = get_child_arguments()\n     while True:\n-        p = subprocess.run(args, env=new_environ, close_fds=False)\n+        p = subprocess.run(args, env=new_environ, close_fds=False, check=False)\n         if p.returncode != 3:\n             return p.returncode\n \n@@ -303,9 +306,8 @@ class BaseReloader:\n         while django_main_thread.is_alive():\n             if app_reg.ready_event.wait(timeout=0.1):\n                 return True\n-        else:\n-            logger.debug('Main Django thread has terminated before apps are ready.')\n-            return False\n+        logger.debug('Main Django thread has terminated before apps are ready.')\n+        return False\n \n     def run(self, django_main_thread):\n         logger.debug('Waiting for apps ready_event.')\n@@ -542,7 +544,7 @@ class WatchmanReloader(BaseReloader):\n             for file in result.get('files', []):\n                 self.notify_file_changed(root_directory / file)\n \n-    def request_processed(self, **kwargs):\n+    def request_processed(self, **_kwargs):\n         logger.debug('Request processed. Setting update_watches event.')\n         self.processed_request.set()\n \n@@ -586,9 +588,9 @@ class WatchmanReloader(BaseReloader):\n         client = pywatchman.client(timeout=0.1)\n         try:\n             result = client.capabilityCheck()\n-        except Exception:\n+        except Exception as exc:\n             # The service is down?\n-            raise WatchmanUnavailable('Cannot connect to the watchman service.')\n+            raise WatchmanUnavailable('Cannot connect to the watchman service.') from exc\n         version = get_version_tuple(result['version'])\n         # Watchman 4.9 includes multiple improvements to watching project\n         # directories as well as case insensitive filesystems.\n"
}