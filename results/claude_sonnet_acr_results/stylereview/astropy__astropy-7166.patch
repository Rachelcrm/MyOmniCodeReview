{
  "patch": "diff --git a/astropy/utils/misc.py b/astropy/utils/misc.py\nindex de3fb01d18..5644176f3e 100644\n--- a/astropy/utils/misc.py\n+++ b/astropy/utils/misc.py\n@@ -145,6 +145,7 @@ class NumpyRNGContext:\n \n     def __init__(self, seed):\n         self.seed = seed\n+        self.startstate = None\n \n     def __enter__(self):\n         from numpy import random\n@@ -152,7 +153,7 @@ class NumpyRNGContext:\n         self.startstate = random.get_state()\n         random.seed(self.seed)\n \n-    def __exit__(self, exc_type, exc_value, traceback):\n+    def __exit__(self, exc_type, exc_value, tb):\n         from numpy import random\n \n         random.set_state(self.startstate)\n@@ -247,7 +248,7 @@ def find_api_page(obj, version=None, openinbrowser=True, timeout=None):\n             headerlines.append(oiread[(oldidx+1):idx].decode('utf-8'))\n \n         # intersphinx version line, project name, and project version\n-        ivers, proj, vers, compr = headerlines\n+        *_, compr = headerlines\n         if 'The remainder of this file is compressed using zlib' not in compr:\n             raise ValueError('The file downloaded from {0} does not seem to be'\n                              'the usual Sphinx objects.inv format.  Maybe it '\n@@ -383,26 +384,26 @@ class JsonCustomEncoder(json.JSONEncoder):\n \n     \"\"\"\n \n-    def default(self, obj):\n+    def default(self, o):\n         from .. import units as u\n         import numpy as np\n-        if isinstance(obj, u.Quantity):\n-            return dict(value=obj.value, unit=obj.unit.to_string())\n-        if isinstance(obj, (np.number, np.ndarray)):\n-            return obj.tolist()\n-        elif isinstance(obj, complex):\n-            return [obj.real, obj.imag]\n-        elif isinstance(obj, set):\n-            return list(obj)\n-        elif isinstance(obj, bytes):  # pragma: py3\n-            return obj.decode()\n-        elif isinstance(obj, (u.UnitBase, u.FunctionUnitBase)):\n-            if obj == u.dimensionless_unscaled:\n-                obj = 'dimensionless_unit'\n+        if isinstance(o, u.Quantity):\n+            return dict(value=o.value, unit=o.unit.to_string())\n+        if isinstance(o, (np.number, np.ndarray)):\n+            return o.tolist()\n+        elif isinstance(o, complex):\n+            return [o.real, o.imag]\n+        elif isinstance(o, set):\n+            return list(o)\n+        elif isinstance(o, bytes):  # pragma: py3\n+            return o.decode()\n+        elif isinstance(o, (u.UnitBase, u.FunctionUnitBase)):\n+            if o == u.dimensionless_unscaled:\n+                o = 'dimensionless_unit'\n             else:\n-                return obj.to_string()\n+                return o.to_string()\n \n-        return json.JSONEncoder.default(self, obj)\n+        return json.JSONEncoder.default(self, o)\n \n \n def strip_accents(s):\n@@ -893,7 +894,7 @@ class ShapedLikeNDArray(metaclass=abc.ABCMeta):\n         \"\"\"The shape of the instance and underlying arrays.\"\"\"\n \n     @abc.abstractmethod\n-    def _apply(method, *args, **kwargs):\n+    def _apply(self, method, *args, **kwargs):\n         \"\"\"Create a new instance, with ``method`` applied to underlying data.\n \n         The method is any of the shape-changing methods for `~numpy.ndarray`\n@@ -1055,8 +1056,7 @@ class ShapedLikeNDArray(metaclass=abc.ABCMeta):\n \n \n class IncompatibleShapeError(ValueError):\n-    def __init__(self, shape_a, shape_a_idx, shape_b, shape_b_idx):\n-        super().__init__(shape_a, shape_a_idx, shape_b, shape_b_idx)\n+    pass\n \n \n def check_broadcast(*shapes):\n@@ -1099,8 +1099,12 @@ def check_broadcast(*shapes):\n                 max_dim = dim\n                 max_dim_idx = idx\n             elif dim != max_dim:\n-                raise IncompatibleShapeError(\n-                    shapes[max_dim_idx], max_dim_idx, shapes[idx], idx)\n+                if max_dim_idx is not None:\n+                    raise IncompatibleShapeError(\n+                        shapes[max_dim_idx], max_dim_idx, shapes[idx], idx)\n+                else:\n+                    raise IncompatibleShapeError(\n+                        None, None, shapes[idx], idx)\n \n         full_shape.append(max_dim)\n \n"
}