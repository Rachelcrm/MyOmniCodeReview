{
  "patch": "diff --git a/django/db/models/manager.py b/django/db/models/manager.py\nindex e37e56cd17..9effc846ec 100644\n--- a/django/db/models/manager.py\n+++ b/django/db/models/manager.py\n@@ -35,7 +35,7 @@ class BaseManager:\n         \"\"\"Return \"app_label.model_label.manager_name\".\"\"\"\n         return \"%s.%s\" % (self.model._meta.label, self.name)\n \n-    def __class_getitem__(cls, *args, **kwargs):\n+    def __class_getitem__(cls, *_args, **_kwargs):\n         return cls\n \n     def deconstruct(self):\n@@ -45,7 +45,7 @@ class BaseManager:\n \n         Raise a ValueError if the manager is dynamically generated.\n         \"\"\"\n-        qs_class = self._queryset_class\n+        qs_class = getattr(self, '_queryset_class', None)\n         if getattr(self, \"_built_with_as_manager\", False):\n             # using MyQuerySet.as_manager()\n             return (\n@@ -75,7 +75,7 @@ class BaseManager:\n                 self._constructor_args[1],  # kwargs\n             )\n \n-    def check(self, **kwargs):\n+    def check(self, **_kwargs):\n         return []\n \n     @classmethod\n@@ -152,7 +152,13 @@ class BaseManager:\n         Return a new QuerySet object. Subclasses can override this method to\n         customize the behavior of the Manager.\n         \"\"\"\n-        return self._queryset_class(model=self.model, using=self._db, hints=self._hints)\n+        queryset_class = getattr(self, '_queryset_class', None)\n+        if queryset_class is None:\n+            raise NotImplementedError(\n+                \"Manager.get_queryset() must be implemented by subclasses or \"\n+                \"use Manager.from_queryset() to create a manager with a queryset class.\"\n+            )\n+        return queryset_class(model=self.model, using=self._db, hints=self._hints)\n \n     def all(self):\n         # We can't proxy this method through the `QuerySet` like we do for the\n"
}