{
  "patch": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 917717bb74..4835f20219 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -10,7 +10,7 @@\n from sympy.core.evalf import EvalfMixin\n from sympy.core.numbers import Float\n from sympy.core.compatibility import (iterable, with_metaclass,\n-    ordered, range, PY3)\n+    ordered, range as range_, PY3)\n from sympy.core.evaluate import global_evaluate\n from sympy.core.function import FunctionClass\n from sympy.core.mul import Mul\n@@ -114,7 +114,7 @@ def intersection(self, other):\n         \"\"\"\n         return self.intersect(other)\n \n-    def _intersect(self, other):\n+    def _intersect(self, _other):\n         \"\"\"\n         This function should only be used internally\n \n@@ -154,7 +154,7 @@ def isdisjoint(self, other):\n         \"\"\"\n         return self.is_disjoint(other)\n \n-    def _union(self, other):\n+    def _union(self, _other):\n         \"\"\"\n         This function should only be used internally\n \n@@ -198,7 +198,7 @@ def _complement(self, other):\n             # A - B is essentially same as A if B has a different\n             # dimensionality than A\n             switch_sets = ProductSet(FiniteSet(o, o - s) for s, o in\n-                                     zip(self.sets, other.sets))\n+                                     zip(self.args, other.sets))\n             product_sets = (ProductSet(*set) for set in switch_sets)\n             # Union of all combinations but this one\n             return Union(p for p in product_sets if p != other)\n@@ -217,7 +217,7 @@ def _complement(self, other):\n             return S.EmptySet\n \n         elif isinstance(other, FiniteSet):\n-            return FiniteSet(*[el for el in other if self.contains(el) != True])\n+            return FiniteSet(*[elem for elem in other if self.contains(elem) != True])\n \n     def symmetric_difference(self, other):\n         \"\"\"\n@@ -653,7 +653,7 @@ def _eval_Eq(self, other):\n \n         return And(*(Eq(x, y) for x, y in zip(self.args, other.args)))\n \n-    def _contains(self, element):\n+    def _contains(self, other):\n         \"\"\"\n         'in' operator for ProductSets\n \n@@ -670,12 +670,12 @@ def _contains(self, element):\n         Passes operation on to constituent sets\n         \"\"\"\n         try:\n-            if len(element) != len(self.args):\n+            if len(other) != len(self.args):\n                 return false\n-        except TypeError:  # maybe element isn't an iterable\n+        except TypeError:  # maybe other isn't an iterable\n             return false\n         return And(*\n-            [set.contains(item) for set, item in zip(self.sets, element)])\n+            [s.contains(item) for s, item in zip(self.sets, other)])\n \n     def _intersect(self, other):\n         \"\"\"\n@@ -750,18 +750,38 @@ def __iter__(self):\n     @property\n     def _measure(self):\n         measure = 1\n-        for set in self.sets:\n-            measure *= set.measure\n+        for s in self.sets:\n+            measure *= s.measure\n         return measure\n \n     def __len__(self):\n-        return Mul(*[len(s) for s in self.args])\n+        try:\n+            lengths = [len(s) for s in self.args]\n+            result = Mul(*lengths)\n+            # Check if result is a finite integer\n+            if result.is_Integer and result.is_finite:\n+                return int(result)\n+            else:\n+                raise TypeError(\"ProductSet length is not a finite integer\")\n+        except (TypeError, AttributeError):\n+            raise TypeError(\"Cannot compute length of ProductSet with infinite constituent sets\")\n \n     def __bool__(self):\n         return all([bool(s) for s in self.args])\n \n     __nonzero__ = __bool__\n \n+    def _eval_powerset(self):\n+        raise NotImplementedError('Power set not defined for ProductSet')\n+\n+    @property\n+    def _inf(self):\n+        raise NotImplementedError('Infimum not defined for ProductSet')\n+\n+    @property\n+    def _sup(self):\n+        raise NotImplementedError('Supremum not defined for ProductSet')\n+\n \n class Interval(Set, EvalfMixin):\n     \"\"\"\n@@ -1126,6 +1146,9 @@ def _eval_imageset(self, f):\n         except NotImplementedError:\n             return\n \n+        _start = None\n+        _end = None\n+\n         if self.left_open:\n             _start = limit(expr, var, self.start, dir=\"+\")\n         elif self.start not in sing:\n@@ -1162,7 +1185,7 @@ def _eval_imageset(self, f):\n             return imageset(f, Interval(self.start, sing[0],\n                                         self.left_open, True)) + \\\n                 Union(*[imageset(f, Interval(sing[i], sing[i + 1], True, True))\n-                        for i in range(0, len(sing) - 1)]) + \\\n+                        for i in range_(0, len(sing) - 1)]) + \\\n                 imageset(f, Interval(sing[-1], self.end, True, self.right_open))\n \n     @property\n@@ -1222,6 +1245,9 @@ def _eval_Eq(self, other):\n                    self.left_open == other.left_open,\n                    self.right_open == other.right_open)\n \n+    def _eval_powerset(self):\n+        raise NotImplementedError('Power set not defined for Interval')\n+\n \n class Union(Set, EvalfMixin):\n     \"\"\"\n@@ -1400,7 +1426,7 @@ def boundary_of_set(i):\n                 if j != i:\n                     b = b - a.interior\n             return b\n-        return Union(map(boundary_of_set, range(len(self.args))))\n+        return Union(map(boundary_of_set, range_(len(self.args))))\n \n     def _eval_imageset(self, f):\n         return Union(imageset(f, arg) for arg in self.args)\n@@ -1453,6 +1479,9 @@ def roundrobin(*iterables):\n         else:\n             raise TypeError(\"Not all constituent sets are iterable\")\n \n+    def _eval_powerset(self):\n+        raise NotImplementedError('Power set not defined for Union')\n+\n class Intersection(Set):\n     \"\"\"\n     Represents an intersection of sets as a :class:`Set`.\n"
}