{
  "patch": "diff --git a/django/contrib/contenttypes/fields.py b/django/contrib/contenttypes/fields.py\nindex 542368de3b..6587b92cdb 100644\n--- a/django/contrib/contenttypes/fields.py\n+++ b/django/contrib/contenttypes/fields.py\n@@ -53,10 +53,11 @@ class GenericForeignKey(FieldCacheMixin):\n         self.rel = None\n         self.column = None\n \n-    def contribute_to_class(self, cls, name, **kwargs):\n+    def contribute_to_class(self, cls, name, **_kwargs):\n+        # pylint: disable=attribute-defined-outside-init\n         self.name = name\n         self.model = cls\n-        cls._meta.add_field(self, private=True)\n+        cls._meta.add_field(self, private=True)  # pylint: disable=protected-access\n         setattr(cls, name, self)\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -77,7 +78,7 @@ class GenericForeignKey(FieldCacheMixin):\n         model = self.model\n         return \"%s.%s\" % (model._meta.label, self.name)\n \n-    def check(self, **kwargs):\n+    def check(self, **_kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_object_id_field(),\n@@ -98,7 +99,7 @@ class GenericForeignKey(FieldCacheMixin):\n \n     def _check_object_id_field(self):\n         try:\n-            self.model._meta.get_field(self.fk_field)\n+            self.model._meta.get_field(self.fk_field)  # pylint: disable=protected-access\n         except FieldDoesNotExist:\n             return [\n                 checks.Error(\n@@ -117,13 +118,13 @@ class GenericForeignKey(FieldCacheMixin):\n         valid content_type field (is a ForeignKey to ContentType).\n         \"\"\"\n         try:\n-            field = self.model._meta.get_field(self.ct_field)\n+            field = self.model._meta.get_field(self.ct_field)  # pylint: disable=protected-access\n         except FieldDoesNotExist:\n             return [\n                 checks.Error(\n                     \"The GenericForeignKey content type references the \"\n                     \"nonexistent field '%s.%s'.\"\n-                    % (self.model._meta.object_name, self.ct_field),\n+                    % (self.model._meta.object_name, self.ct_field),  # pylint: disable=protected-access\n                     obj=self,\n                     id=\"contenttypes.E002\",\n                 )\n@@ -133,7 +134,7 @@ class GenericForeignKey(FieldCacheMixin):\n                 return [\n                     checks.Error(\n                         \"'%s.%s' is not a ForeignKey.\"\n-                        % (self.model._meta.object_name, self.ct_field),\n+                        % (self.model._meta.object_name, self.ct_field),  # pylint: disable=protected-access\n                         hint=(\n                             \"GenericForeignKeys must use a ForeignKey to \"\n                             \"'contenttypes.ContentType' as the 'content_type' field.\"\n@@ -146,7 +147,7 @@ class GenericForeignKey(FieldCacheMixin):\n                 return [\n                     checks.Error(\n                         \"'%s.%s' is not a ForeignKey to 'contenttypes.ContentType'.\"\n-                        % (self.model._meta.object_name, self.ct_field),\n+                        % (self.model._meta.object_name, self.ct_field),  # pylint: disable=protected-access\n                         hint=(\n                             \"GenericForeignKeys must use a ForeignKey to \"\n                             \"'contenttypes.ContentType' as the 'content_type' field.\"\n@@ -161,16 +162,16 @@ class GenericForeignKey(FieldCacheMixin):\n     def get_cache_name(self):\n         return self.name\n \n-    def get_content_type(self, obj=None, id=None, using=None):\n+    def get_content_type(self, obj=None, content_type_id=None, using=None):\n         if obj is not None:\n-            return ContentType.objects.db_manager(obj._state.db).get_for_model(\n+            return ContentType.objects.db_manager(obj._state.db).get_for_model(  # pylint: disable=protected-access\n                 obj, for_concrete_model=self.for_concrete_model\n             )\n-        elif id is not None:\n-            return ContentType.objects.db_manager(using).get_for_id(id)\n+        elif content_type_id is not None:\n+            return ContentType.objects.db_manager(using).get_for_id(content_type_id)\n         else:\n             # This should never happen. I love comments like this, don't you?\n-            raise Exception(\"Impossible arguments to GFK.get_content_type!\")\n+            raise ValueError(\"Impossible arguments to GFK.get_content_type!\")\n \n     def get_prefetch_queryset(self, instances, queryset=None):\n         if queryset is not None:\n@@ -181,7 +182,7 @@ class GenericForeignKey(FieldCacheMixin):\n         fk_dict = defaultdict(set)\n         # We need one instance for each group in order to get the right db:\n         instance_dict = {}\n-        ct_attname = self.model._meta.get_field(self.ct_field).get_attname()\n+        ct_attname = self.model._meta.get_field(self.ct_field).get_attname()  # pylint: disable=protected-access\n         for instance in instances:\n             # We avoid looking for values if either ct_id or fkey value is None\n             ct_id = getattr(instance, ct_attname)\n@@ -194,7 +195,7 @@ class GenericForeignKey(FieldCacheMixin):\n         ret_val = []\n         for ct_id, fkeys in fk_dict.items():\n             instance = instance_dict[ct_id]\n-            ct = self.get_content_type(id=ct_id, using=instance._state.db)\n+            ct = self.get_content_type(content_type_id=ct_id, using=instance._state.db)  # pylint: disable=protected-access\n             ret_val.extend(ct.get_all_objects_for_this_type(pk__in=fkeys))\n \n         # For doing the join in Python, we have to match both the FK val and the\n@@ -205,10 +206,10 @@ class GenericForeignKey(FieldCacheMixin):\n                 return None\n             else:\n                 model = self.get_content_type(\n-                    id=ct_id, using=obj._state.db\n+                    content_type_id=ct_id, using=obj._state.db  # pylint: disable=protected-access\n                 ).model_class()\n                 return (\n-                    model._meta.pk.get_prep_value(getattr(obj, self.fk_field)),\n+                    model._meta.pk.get_prep_value(getattr(obj, self.fk_field)),  # pylint: disable=protected-access\n                     model,\n                 )\n \n@@ -364,7 +365,7 @@ class GenericRelation(ForeignObject):\n     def _check_generic_foreign_key_existence(self):\n         target = self.remote_field.model\n         if isinstance(target, ModelBase):\n-            fields = target._meta.private_fields\n+            fields = target._meta.private_fields  # pylint: disable=protected-access\n             if any(self._is_matching_generic_foreign_key(field) for field in fields):\n                 return []\n             else:\n@@ -372,7 +373,7 @@ class GenericRelation(ForeignObject):\n                     checks.Error(\n                         \"The GenericRelation defines a relation with the model \"\n                         \"'%s', but that model does not have a GenericForeignKey.\"\n-                        % target._meta.label,\n+                        % target._meta.label,  # pylint: disable=protected-access\n                         obj=self,\n                         id=\"contenttypes.E004\",\n                     )\n@@ -381,11 +382,11 @@ class GenericRelation(ForeignObject):\n             return []\n \n     def resolve_related_fields(self):\n-        self.to_fields = [self.model._meta.pk.name]\n+        self.to_fields = [self.model._meta.pk.name]  # pylint: disable=protected-access\n         return [\n             (\n-                self.remote_field.model._meta.get_field(self.object_id_field_name),\n-                self.model._meta.pk,\n+                self.remote_field.model._meta.get_field(self.object_id_field_name),  # pylint: disable=protected-access\n+                self.model._meta.pk,  # pylint: disable=protected-access\n             )\n         ]\n \n"
}