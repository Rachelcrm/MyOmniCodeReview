{
  "patch": "diff --git a/youtube_dl/extractor/youtube.py b/youtube_dl/extractor/youtube.py\nindex 63918924d..9bf98265d 100644\n--- a/youtube_dl/extractor/youtube.py\n+++ b/youtube_dl/extractor/youtube.py\n@@ -13,7 +13,7 @@ from .common import InfoExtractor, SearchInfoExtractor\n from ..compat import (\n     compat_chr,\n     compat_HTTPError,\n-    compat_map as map,\n+    compat_map,\n     compat_parse_qs,\n     compat_str,\n     compat_urllib_parse_unquote_plus,\n@@ -66,6 +66,15 @@ class YoutubeBaseInfoExtractor(InfoExtractor):\n \n     _PLAYLIST_ID_RE = r'(?:(?:PL|LL|EC|UU|FL|RD|UL|TL|PU|OLAK5uy_)[0-9A-Za-z-_]{10,}|RDMM)'\n \n+    def _get_automatic_captions(self, *args, **kwargs):\n+        raise NotImplementedError('This method must be implemented by subclasses')\n+\n+    def _get_subtitles(self, *args, **kwargs):\n+        raise NotImplementedError('This method must be implemented by subclasses')\n+\n+    def _mark_watched(self, *args, **kwargs):\n+        raise NotImplementedError('This method must be implemented by subclasses')\n+\n     def _login(self):\n         \"\"\"\n         Attempt to log in to YouTube.\n@@ -1229,8 +1238,8 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n     def suitable(cls, url):\n         # Hack for lazy extractors until more generic solution is implemented\n         # (see #28780)\n-        from .youtube import parse_qs\n-        qs = parse_qs(url)\n+        parsed_url = compat_urlparse.urlparse(url)\n+        qs = compat_parse_qs(parsed_url.query)\n         if qs.get('list', [None])[0]:\n             return False\n         return super(YoutubeIE, cls).suitable(url)\n@@ -1280,7 +1289,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n         code = self._get_player_code(video_id, player_url, player_id)\n         res = self._parse_sig_js(code)\n \n-        test_string = ''.join(map(compat_chr, range(len(example_sig))))\n+        test_string = ''.join(compat_map(compat_chr, range(len(example_sig))))\n         cache_res = res(test_string)\n         cache_spec = [ord(c) for c in cache_res]\n \n@@ -1298,6 +1307,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n             step = None\n             # Quelch pyflakes warnings - start will be set when step is set\n             start = '(Never used)'\n+            i = 0  # Initialize i to handle empty loop case\n             for i, prev in zip(idxs[1:], idxs[:-1]):\n                 if step is not None:\n                     if i - prev == step:\n@@ -1316,7 +1326,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n             else:\n                 yield _genslice(start, i, step)\n \n-        test_string = ''.join(map(compat_chr, range(len(example_sig))))\n+        test_string = ''.join(compat_map(compat_chr, range(len(example_sig))))\n         cache_res = func(test_string)\n         cache_spec = [ord(c) for c in cache_res]\n         expr_code = ' + '.join(gen_sig_code(cache_spec))\n@@ -1370,7 +1380,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n         except Exception as e:\n             tb = traceback.format_exc()\n             raise ExtractorError(\n-                'Signature extraction failed: ' + tb, cause=e)\n+                'Signature extraction failed: ' + tb, cause=e) from e\n \n     def _extract_player_url(self, webpage):\n         player_url = self._search_regex(\n@@ -1438,7 +1448,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n                 self._downloader.to_screen('[debug] [%s] %s' % (self.IE_NAME, 'Decrypted nsig {0} => {1}'.format(n_param, self._player_cache[sig_id])))\n             return self._player_cache[sig_id]\n         except Exception as e:\n-            raise ExtractorError(traceback.format_exc(), cause=e, video_id=video_id)\n+            raise ExtractorError(traceback.format_exc(), cause=e, video_id=video_id) from e\n \n     def _unthrottle_format_urls(self, video_id, player_url, formats):\n         for fmt in formats:\n@@ -1454,7 +1464,17 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n                 fmt['url'] = compat_urlparse.urlunparse(\n                     parsed_fmt_url._replace(query=compat_urllib_parse_urlencode(qs, True)))\n \n-    def _mark_watched(self, video_id, player_response):\n+    def _mark_watched(self, *args, **kwargs):\n+        # Extract video_id and player_response from arguments for compatibility\n+        if len(args) >= 2:\n+            video_id, player_response = args[0], args[1]\n+        else:\n+            video_id = kwargs.get('video_id')\n+            player_response = kwargs.get('player_response')\n+        \n+        if not video_id or not player_response:\n+            return\n+            \n         playback_url = url_or_none(try_get(\n             player_response,\n             lambda x: x['playbackTracking']['videostatsPlaybackUrl']['baseUrl']))\n@@ -1499,7 +1519,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n             \\1''', webpage)]\n \n         # lazyYT YouTube embed\n-        entries.extend(list(map(\n+        entries.extend(list(compat_map(\n             unescapeHTML,\n             re.findall(r'class=\"lazyYT\" data-youtube-id=\"([^\"]+)\"', webpage))))\n \n@@ -1524,7 +1544,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n         video_id = mobj.group(2)\n         return video_id\n \n-    def _extract_chapters_from_json(self, data, video_id, duration):\n+    def _extract_chapters_from_json(self, data, duration):\n         chapters_list = try_get(\n             data,\n             lambda x: x['playerOverlays']\n@@ -1971,7 +1991,7 @@ class YoutubeIE(YoutubeBaseInfoExtractor):\n \n         if initial_data:\n             chapters = self._extract_chapters_from_json(\n-                initial_data, video_id, duration)\n+                initial_data, duration)\n             if not chapters:\n                 for engagment_pannel in (initial_data.get('engagementPanels') or []):\n                     contents = try_get(\n@@ -2110,6 +2130,15 @@ class YoutubeTabIE(YoutubeBaseInfoExtractor):\n                     '''\n     IE_NAME = 'youtube:tab'\n \n+    def _get_automatic_captions(self, *args, **kwargs):\n+        raise NotImplementedError('This method must be implemented by subclasses')\n+\n+    def _get_subtitles(self, *args, **kwargs):\n+        raise NotImplementedError('This method must be implemented by subclasses')\n+\n+    def _mark_watched(self, *args, **kwargs):\n+        raise NotImplementedError('This method must be implemented by subclasses')\n+\n     _TESTS = [{\n         # playlists, multipage\n         'url': 'https://www.youtube.com/c/ИгорьКлейнер/playlists?view=1&flow=grid',\n@@ -2913,7 +2942,8 @@ class YoutubeTabIE(YoutubeBaseInfoExtractor):\n         url = compat_urlparse.urlunparse(\n             compat_urlparse.urlparse(url)._replace(netloc='www.youtube.com'))\n         # Handle both video/playlist URLs\n-        qs = parse_qs(url)\n+        parsed_url = compat_urlparse.urlparse(url)\n+        qs = compat_parse_qs(parsed_url.query)\n         video_id = qs.get('v', [None])[0]\n         playlist_id = qs.get('list', [None])[0]\n         if video_id and playlist_id:\n@@ -3013,8 +3043,8 @@ class YoutubePlaylistIE(InfoExtractor):\n             return False\n         # Hack for lazy extractors until more generic solution is implemented\n         # (see #28780)\n-        from .youtube import parse_qs\n-        qs = parse_qs(url)\n+        parsed_url = compat_urlparse.urlparse(url)\n+        qs = compat_parse_qs(parsed_url.query)\n         if qs.get('v', [None])[0]:\n             return False\n         return super(YoutubePlaylistIE, cls).suitable(url)\n"
}