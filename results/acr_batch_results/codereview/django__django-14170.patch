{
  "patch": "To address the issue of query optimization in `YearLookup` breaking filtering by `__iso_year`, we need to modify the `YearLookup` class to handle the `__iso_year` lookup differently. The current optimization uses `BETWEEN` instead of the `EXTRACT` operation, which is not suitable for `__iso_year` lookups.\n\nThe problem arises because the `as_sql` method in `YearLookup` checks if the right-hand side (`rhs`) is a direct value and, if so, uses the `BETWEEN` optimization. However, this optimization should not be applied for `__iso_year` lookups, as they require the `EXTRACT` operation to work correctly.\n\nHere's the step-by-step reasoning:\n\n1. **Identify the Problematic Code**: The issue lies in the `as_sql` method of the `YearLookup` class, specifically in how it handles the `rhs_is_direct_value` condition. This condition leads to the use of `BETWEEN` instead of `EXTRACT` for year lookups.\n\n2. **Understand the Requirement**: For `__iso_year` lookups, the `EXTRACT` operation must be used, not the `BETWEEN` optimization. This means we need a way to differentiate between `__iso_year` and other year lookups.\n\n3. **Propose a Solution**: We can solve this by checking if the lookup name is `__iso_year` and, if so, skipping the `BETWEEN` optimization and using the `EXTRACT` operation instead. This involves modifying the `as_sql` method to consider the lookup name.\n\nGiven the above reasoning, here is the patch:\n\n```\n<file>django/db/models/lookups.py</file>\n<original>\n552         if self.rhs_is_direct_value():\n553             # Skip the extract part by directly using the originating field,\n554             # that is self.lhs.lhs.\n555             lhs_sql, params = self.process_lhs(compiler, connection, self.lhs.lhs)\n556             rhs_sql, _ = self.process_rhs(compiler, connection)\n557             rhs_sql = self.get_direct_rhs_sql(connection, rhs_sql)\n558             start, finish = self.year_lookup_bounds(connection, self.rhs)\n559             params.extend(self.get_bound_params(start, finish))\n560             return '%s %s' % (lhs_sql, rhs_sql), params\n</original>\n<patched>\n552         if self.rhs_is_direct_value() and self.lookup_name != 'iso_year':\n553             # Skip the extract part by directly using the originating field,\n554             # that is self.lhs.lhs.\n555             lhs_sql, params = self.process_lhs(compiler, connection, self.lhs.lhs)\n556             rhs_sql, _ = self.process_rhs(compiler, connection)\n557             rhs_sql = self.get_direct_rhs_sql(connection, rhs_sql)\n558             start, finish = self.year_lookup_bounds(connection, self.rhs)\n559             params.extend(self.get_bound_params(start, finish))\n560             return '%s %s' % (lhs_sql, rhs_sql), params\n</patched>\n```\n\nThis modification ensures that for `__iso_year` lookups, the `BETWEEN` optimization is not used, preserving the correct functionality of filtering by `__iso_year`."
}