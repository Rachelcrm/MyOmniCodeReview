{
  "patch": "diff --git a/pylint/lint/pylinter.py b/pylint/lint/pylinter.py\nindex 53345a6b1..a8a45d1a2 100644\n--- a/pylint/lint/pylinter.py\n+++ b/pylint/lint/pylinter.py\n@@ -248,6 +248,9 @@ class PyLinter(\n         \"Reports\": \"Options related to output formatting and reporting\",\n     }\n \n+    import re\n+    from typing import Pattern\n+    \n     def __init__(\n         self,\n         options: Options = (),\n@@ -530,16 +533,15 @@ class PyLinter(\n         return needed_checkers\n \n     # pylint: disable=unused-argument\n-    @staticmethod\n     def should_analyze_file(modname: str, path: str, is_argument: bool = False) -> bool:\n         \"\"\"Returns whether a module should be checked.\n-\n+        \n         This implementation returns True for all python source file, indicating\n         that all files should be linted.\n-\n+        \n         Subclasses may override this method to indicate that modules satisfying\n         certain conditions should not be linted.\n-\n+        \n         :param str modname: The name of the module to be checked.\n         :param str path: The full path to the source code of the module.\n         :param bool is_argument: Whether the file is an argument to pylint or not.\n@@ -549,6 +551,19 @@ class PyLinter(\n         \"\"\"\n         if is_argument:\n             return True\n+        \n+        # Check if the file is ignored\n+        if self.config.ignore and modname in self.config.ignore:\n+            return False\n+        if self.config.ignore_patterns and any(\n+            modname.startswith(pattern) for pattern in self.config.ignore_patterns\n+        ):\n+            return False\n+        if self.config.ignore_paths and any(\n+            path.startswith(pattern) for pattern in self.config.ignore_paths\n+        ):\n+            return False\n+        \n         return path.endswith(\".py\")\n \n     # pylint: enable=unused-argument\n"
}