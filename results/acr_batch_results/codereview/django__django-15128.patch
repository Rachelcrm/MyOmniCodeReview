{
  "patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex aaf35ee37c..fdd99d9409 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -953,10 +953,10 @@ class Query(BaseExpression):\n         Return an alias for the 'join', either reusing an existing alias for\n         that join or creating a new one. 'join' is either a base_table_class or\n         join_class.\n-\n+        \n         The 'reuse' parameter can be either None which means all joins are\n         reusable, or it can be a set containing the aliases that can be reused.\n-\n+        \n         A join is always created as LOUTER if the lhs alias is LOUTER to make\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n@@ -974,7 +974,7 @@ class Query(BaseExpression):\n                 reuse_alias = reuse_aliases[-1]\n             self.ref_alias(reuse_alias)\n             return reuse_alias\n-\n+        \n         # No reuse is possible, so we need a new alias.\n         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)\n         if join.join_type:\n@@ -985,6 +985,11 @@ class Query(BaseExpression):\n             join.join_type = join_type\n         join.table_alias = alias\n         self.alias_map[alias] = join\n+\n+        # Ensure the new alias does not conflict with the existing aliases\n+        while alias in self.alias_map:\n+            alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n+            self.alias_map[alias] = self.alias_map.pop(join.table_alias)\n         return alias\n \n     def join_parent_model(self, opts, model, alias, seen):\n"
}