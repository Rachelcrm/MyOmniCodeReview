{
  "patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex cc65c043ab..896dc62165 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -57,28 +57,22 @@ def is_django_path(path):\n \n \n def check_errors(fn):\n-    @functools.wraps(fn)\n-    def wrapper(*args, **kwargs):\n-        global _exception\n-        try:\n-            fn(*args, **kwargs)\n-        except Exception:\n-            _exception = sys.exc_info()\n-\n-            et, ev, tb = _exception\n-\n-            if getattr(ev, 'filename', None) is None:\n-                # get the filename from the last item in the stack\n-                filename = traceback.extract_tb(tb)[-1][0]\n-            else:\n-                filename = ev.filename\n-\n-            if filename not in _error_files:\n-                _error_files.append(filename)\n-\n-            raise\n-\n-    return wrapper\n+ @functools.wraps(fn)\n+ def wrapper(*args, **kwargs):\n+     try:\n+         fn(*args, **kwargs)\n+     except Exception as e:\n+         _exception = sys.exc_info()\n+         et, ev, tb = _exception\n+         if getattr(ev, 'filename', None) is None:\n+             filename = traceback.extract_tb(tb)[-1][0]\n+         else:\n+             filename = ev.filename\n+         if filename not in _error_files:\n+             _error_files.append(filename)\n+         raise e\n+\n+ return wrapper\n \n \n def raise_last_exception():\n@@ -257,7 +251,7 @@ def restart_with_reloader():\n     new_environ = {**os.environ, DJANGO_AUTORELOAD_ENV: 'true'}\n     args = get_child_arguments()\n     while True:\n-        p = subprocess.run(args, env=new_environ, close_fds=False)\n+        p = subprocess.run(args, env=new_environ, close_fds=False, check=True)\n         if p.returncode != 3:\n             return p.returncode\n \n@@ -308,9 +302,8 @@ class BaseReloader:\n         while django_main_thread.is_alive():\n             if app_reg.ready_event.wait(timeout=0.1):\n                 return True\n-        else:\n-            logger.debug('Main Django thread has terminated before apps are ready.')\n-            return False\n+        logger.debug('Main Django thread has terminated before apps are ready.')\n+        return False\n \n     def run(self, django_main_thread):\n         logger.debug('Waiting for apps ready_event.')\n@@ -321,7 +314,7 @@ class BaseReloader:\n         # reloader starts by accessing the urlconf_module property.\n         try:\n             get_resolver().urlconf_module\n-        except Exception:\n+        except ImportError:\n             # Loading the urlconf can result in errors during development.\n             # If this occurs then swallow the error and continue.\n             pass\n@@ -530,7 +523,7 @@ class WatchmanReloader(BaseReloader):\n         except Exception as ex:\n             # If the service is still available, raise the original exception.\n             if self.check_server_status(ex):\n-                raise\n+                raise ex\n \n     def _check_subscription(self, sub):\n         subscription = self.client.getSubscription(sub)\n@@ -591,9 +584,9 @@ class WatchmanReloader(BaseReloader):\n         client = pywatchman.client(timeout=0.1)\n         try:\n             result = client.capabilityCheck()\n-        except Exception:\n+        except Exception as exc:\n             # The service is down?\n-            raise WatchmanUnavailable('Cannot connect to the watchman service.')\n+            raise WatchmanUnavailable('Cannot connect to the watchman service.') from exc\n         version = get_version_tuple(result['version'])\n         # Watchman 4.9 includes multiple improvements to watching project\n         # directories as well as case insensitive filesystems.\n"
}