{
  "instance_id": "django__django-13551",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "<file>tests/test_tokens.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.contrib.auth.tokens import PasswordResetTokenGenerator\nfrom django.contrib.auth.models import User\nfrom django.utils.http import urlsafe_base64_encode\nfrom django.utils.encoding import force_bytes\n\n@pytest.fixture\ndef user():\n    return User.objects.create_user(email='test@example.com', password='testpassword')\n\n@pytest.fixture\ndef token_generator():\n    return PasswordResetTokenGenerator()\n\ndef test_password_reset_token_generation(user, token_generator):\n    token = token_generator.make_token(user)\n    assert token is not None\n\ndef test_password_reset_token_validation(user, token_generator):\n    token = token_generator.make_token(user)\n    assert token_generator.check_token(user, token) == True\n\ndef test_password_reset_token_invalidation_on_email_change(user, token_generator):\n    token = token_generator.make_token(user)\n    user.email = 'new_email@example.com'\n    user.save()\n    assert token_generator.check_token(user, token) == False\n\ndef test_password_reset_token_invalidation_on_password_change(user, token_generator):\n    token = token_generator.make_token(user)\n    user.set_password('newpassword')\n    user.save()\n    assert token_generator.check_token(user, token) == False\n\ndef test_password_reset_token_validity_with_timestamp(user, token_generator):\n    # Assuming token_generator uses a timestamp\n    token = token_generator.make_token(user)\n    # Advance time and check if token is still valid\n    # This test might require mocking time-related functions\n\ndef test_custom_token_generator_with_email(user):\n    class CustomTokenGenerator(PasswordResetTokenGenerator):\n        def _make_hash_value(self, user, timestamp):\n            return str(user.pk) + user.password + str(user.email) + str(user.last_login) + str(timestamp)\n\n    token_generator = CustomTokenGenerator()\n    token = token_generator.make_token(user)\n    user.email = 'new_email@example.com'\n    user.save()\n    assert token_generator.check_token(user, token) == False\n\n</patched>\n</file>\n\n<file>tests/test_views.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.test import Client\nfrom django.urls import reverse\nfrom django.contrib.auth.models import User\n\n@pytest.fixture\ndef client():\n    return Client()\n\n@pytest.fixture\ndef user():\n    return User.objects.create_user(email='test@example.com', password='testpassword')\n\ndef test_password_reset_view(client, user):\n    url = reverse('password_reset')\n    data = {'email': user.email}\n    response = client.post(url, data)\n    assert response.status_code == 302\n\ndef test_password_reset_done_view(client, user):\n    url = reverse('password_reset_done')\n    response = client.get(url)\n    assert response.status_code == 200\n\ndef test_password_reset_confirm_view(client, user, token_generator):\n    token = token_generator.make_token(user)\n    uid = urlsafe_base64_encode(force_bytes(user.pk))\n    url = reverse('password_reset_confirm', args=[uid, token])\n    response = client.get(url)\n    assert response.status_code == 200\n\n</patched>\n</file>\n```",
  "patch": "--- a/tests/test_tokens.py\n+++ b/tests/test_tokens.py\n-# Empty if creating new file\n+import pytest\n+from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from django.contrib.auth.models import User\n+from django.utils.http import urlsafe_base64_encode\n+from django.utils.encoding import force_bytes\n+\n+@pytest.fixture\n+def user():\n+    return User.objects.create_user(email='test@example.com', password='testpassword')\n+\n+@pytest.fixture\n+def token_generator():\n+    return PasswordResetTokenGenerator()\n+\n+def test_password_reset_token_generation(user, token_generator):\n+    token = token_generator.make_token(user)\n+    assert token is not None\n+\n+def test_password_reset_token_validation(user, token_generator):\n+    token = token_generator.make_token(user)\n+    assert token_generator.check_token(user, token) == True\n+\n+def test_password_reset_token_invalidation_on_email_change(user, token_generator):\n+    token = token_generator.make_token(user)\n+    user.email = 'new_email@example.com'\n+    user.save()\n+    assert token_generator.check_token(user, token) == False\n+\n+def test_password_reset_token_invalidation_on_password_change(user, token_generator):\n+    token = token_generator.make_token(user)\n+    user.set_password('newpassword')\n+    user.save()\n+    assert token_generator.check_token(user, token) == False\n+\n+def test_password_reset_token_validity_with_timestamp(user, token_generator):\n+    # Assuming token_generator uses a timestamp\n+    token = token_generator.make_token(user)\n+    # Advance time and check if token is still valid\n+    # This test might require mocking time-related functions\n+\n+def test_custom_token_generator_with_email(user):\n+    class CustomTokenGenerator(PasswordResetTokenGenerator):\n+        def _make_hash_value(self, user, timestamp):\n+            return str(user.pk) + user.password + str(user.email) + str(user.last_login) + str(timestamp)\n+\n+    token_generator = CustomTokenGenerator()\n+    token = token_generator.make_token(user)\n+    user.email = 'new_email@example.com'\n+    user.save()\n+    assert token_generator.check_token(user, token) == False\n\n--- a/tests/test_views.py\n+++ b/tests/test_views.py\n-# Empty if creating new file\n+import pytest\n+from django.test import Client\n+from django.urls import reverse\n+from django.contrib.auth.models import User\n+\n+@pytest.fixture\n+def client():\n+    return Client()\n+\n+@pytest.fixture\n+def user():\n+    return User.objects.create_user(email='test@example.com', password='testpassword')\n+\n+def test_password_reset_view(client, user):\n+    url = reverse('password_reset')\n+    data = {'email': user.email}\n+    response = client.post(url, data)\n+    assert response.status_code == 302\n+\n+def test_password_reset_done_view(client, user):\n+    url = reverse('password_reset_done')\n+    response = client.get(url)\n+    assert response.status_code == 200\n+\n+def test_password_reset_confirm_view(client, user, token_generator):\n+    token = token_generator.make_token(user)\n+    uid = urlsafe_base64_encode(force_bytes(user.pk))\n+    url = reverse('password_reset_confirm', args=[uid, token])\n+    response = client.get(url)\n+    assert response.status_code == 200\n"
}