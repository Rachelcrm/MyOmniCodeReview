{
  "instance_id": "django__django-11451",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "To address the issue described, we need to ensure that the `ModelBackend.authenticate()` method does not make a database query when `username` is `None`. This involves modifying the `authenticate` method to return immediately if `username` or `password` is `None`.\n\nHere's how we can approach writing tests for this functionality using pytest:\n\n```\n<file>tests/test_auth_backends.py</file>\n<original>\n# Original code here (if modifying existing file)\n</original>\n<patched>\nimport pytest\nfrom django.contrib.auth.backends import ModelBackend\nfrom django.contrib.auth.models import User\nfrom django.db.models import QuerySet\n\n@pytest.fixture\ndef user():\n    return User.objects.create_user(username='testuser', password='testpassword')\n\n@pytest.mark.django_db\ndef test_authenticate_with_username_and_password(user):\n    backend = ModelBackend()\n    authenticated_user = backend.authenticate(request=None, username='testuser', password='testpassword')\n    assert authenticated_user == user\n\n@pytest.mark.django_db\ndef test_authenticate_with_none_username():\n    backend = ModelBackend()\n    authenticated_user = backend.authenticate(request=None, username=None, password='testpassword')\n    assert authenticated_user is None\n\n@pytest.mark.django_db\ndef test_authenticate_with_none_password(user):\n    backend = ModelBackend()\n    authenticated_user = backend.authenticate(request=None, username='testuser', password=None)\n    assert authenticated_user is None\n\n@pytest.mark.django_db\ndef test_authenticate_db_query(user):\n    backend = ModelBackend()\n    with pytest.raises(AssertionError):\n        assert QuerySet()._has_seen_descriptor\n\n    # Test that no database query is made when username or password is None\n    backend.authenticate(request=None, username=None, password='testpassword')\n    backend.authenticate(request=None, username='testuser', password=None)\n\n    # Test that a database query is made when both username and password are provided\n    backend.authenticate(request=None, username='testuser', password='testpassword')\n</patched>\n```\n\nAnd here's the modification to the `authenticate` method:\n\n```\n<file>django/contrib/auth/backends.py</file>\n<original>\ndef authenticate(self, request, username=None, password=None, **kwargs):\n    if username is None:\n        username = kwargs.get(UserModel.USERNAME_FIELD)\n    try:\n        user = UserModel._default_manager.get_by_natural_key(username)\n    except UserModel.DoesNotExist:\n        # Run the default password hasher once to reduce the timing\n        # difference between an existing and a nonexistent user (#20760).\n        UserModel().set_password(password)\n    else:\n        if user.check_password(password) and self.user_can_authenticate(user):\n            return user\n</original>\n<patched>\ndef authenticate(self, request, username=None, password=None, **kwargs):\n    if username is None or password is None:\n        return\n    if username is None:\n        username = kwargs.get(UserModel.USERNAME_FIELD)\n    try:\n        user = UserModel._default_manager.get_by_natural_key(username)\n    except UserModel.DoesNotExist:\n        # Run the default password hasher once to reduce the timing\n        # difference between an existing and a nonexistent user (#20760).\n        UserModel().set_password(password)\n    else:\n        if user.check_password(password) and self.user_can_authenticate(user):\n            return user\n</patched>\n```",
  "patch": "--- a/tests/test_auth_backends.py\n+++ b/tests/test_auth_backends.py\n-# Original code here (if modifying existing file)\n+import pytest\n+from django.contrib.auth.backends import ModelBackend\n+from django.contrib.auth.models import User\n+from django.db.models import QuerySet\n+\n+@pytest.fixture\n+def user():\n+    return User.objects.create_user(username='testuser', password='testpassword')\n+\n+@pytest.mark.django_db\n+def test_authenticate_with_username_and_password(user):\n+    backend = ModelBackend()\n+    authenticated_user = backend.authenticate(request=None, username='testuser', password='testpassword')\n+    assert authenticated_user == user\n+\n+@pytest.mark.django_db\n+def test_authenticate_with_none_username():\n+    backend = ModelBackend()\n+    authenticated_user = backend.authenticate(request=None, username=None, password='testpassword')\n+    assert authenticated_user is None\n+\n+@pytest.mark.django_db\n+def test_authenticate_with_none_password(user):\n+    backend = ModelBackend()\n+    authenticated_user = backend.authenticate(request=None, username='testuser', password=None)\n+    assert authenticated_user is None\n+\n+@pytest.mark.django_db\n+def test_authenticate_db_query(user):\n+    backend = ModelBackend()\n+    with pytest.raises(AssertionError):\n+        assert QuerySet()._has_seen_descriptor\n+\n+    # Test that no database query is made when username or password is None\n+    backend.authenticate(request=None, username=None, password='testpassword')\n+    backend.authenticate(request=None, username='testuser', password=None)\n+\n+    # Test that a database query is made when both username and password are provided\n+    backend.authenticate(request=None, username='testuser', password='testpassword')\n\n--- a/django/contrib/auth/backends.py\n+++ b/django/contrib/auth/backends.py\n-def authenticate(self, request, username=None, password=None, **kwargs):\n-    if username is None:\n-        username = kwargs.get(UserModel.USERNAME_FIELD)\n-    try:\n-        user = UserModel._default_manager.get_by_natural_key(username)\n-    except UserModel.DoesNotExist:\n-        # Run the default password hasher once to reduce the timing\n-        # difference between an existing and a nonexistent user (#20760).\n-        UserModel().set_password(password)\n-    else:\n-        if user.check_password(password) and self.user_can_authenticate(user):\n-            return user\n+def authenticate(self, request, username=None, password=None, **kwargs):\n+    if username is None or password is None:\n+        return\n+    if username is None:\n+        username = kwargs.get(UserModel.USERNAME_FIELD)\n+    try:\n+        user = UserModel._default_manager.get_by_natural_key(username)\n+    except UserModel.DoesNotExist:\n+        # Run the default password hasher once to reduce the timing\n+        # difference between an existing and a nonexistent user (#20760).\n+        UserModel().set_password(password)\n+    else:\n+        if user.check_password(password) and self.user_can_authenticate(user):\n+            return user\n"
}