{
  "instance_id": "django__django-15731",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "To address the issue of `inspect.signature()` returning incorrect signature information on manager methods, we need to modify the `_get_queryset_methods` in `django/db/models/manager.py` to use `functools.wraps` to preserve the original method's signature.\n\nHere's a test suite that thoroughly covers the described issue:\n\n```\n<file>tests/test_inspect_signature.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport inspect\nimport pytest\nfrom django.db import models\nfrom django.db.models import QuerySet\n\nclass Person(models.Model):\n    name = models.CharField(max_length=100)\n\ndef test_inspect_signature():\n    # Test that inspect.signature returns the correct signature information\n    # for a queryset method.\n    signature = inspect.signature(Person.objects.bulk_create)\n    assert signature.parameters == {\n        'objs': inspect.Parameter('objs', inspect.Parameter.POSITIONAL_OR_KEYWORD),\n        'batch_size': inspect.Parameter('batch_size', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=None),\n        'ignore_conflicts': inspect.Parameter('ignore_conflicts', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=False),\n        'update_conflicts': inspect.Parameter('update_conflicts', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=False),\n        'update_fields': inspect.Parameter('update_fields', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=None),\n        'unique_fields': inspect.Parameter('unique_fields', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=None),\n    }\n\ndef test_inspect_signature_with_functools_wraps():\n    # Test that using functools.wraps preserves the original method's signature.\n    from functools import wraps\n\n    def my_decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n        return wrapper\n\n    @my_decorator\n    def my_function(objs, batch_size=None, ignore_conflicts=False):\n        pass\n\n    signature = inspect.signature(my_function)\n    assert signature.parameters == {\n        'objs': inspect.Parameter('objs', inspect.Parameter.POSITIONAL_OR_KEYWORD),\n        'batch_size': inspect.Parameter('batch_size', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=None),\n        'ignore_conflicts': inspect.Parameter('ignore_conflicts', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=False),\n    }\n\ndef test_queryset_method_signature():\n    # Test that queryset methods have the correct signature information.\n    methods = [getattr(QuerySet, method) for method in QuerySet.__dir__() if callable(getattr(QuerySet, method))]\n    for method in methods:\n        try:\n            signature = inspect.signature(method)\n            assert len(signature.parameters) > 0\n        except Exception as e:\n            pytest.fail(f\"Error inspecting signature of {method.__name__}: {e}\")\n</patched>\n```",
  "patch": "--- a/tests/test_inspect_signature.py\n+++ b/tests/test_inspect_signature.py\n-# Empty if creating new file\n+import inspect\n+import pytest\n+from django.db import models\n+from django.db.models import QuerySet\n+\n+class Person(models.Model):\n+    name = models.CharField(max_length=100)\n+\n+def test_inspect_signature():\n+    # Test that inspect.signature returns the correct signature information\n+    # for a queryset method.\n+    signature = inspect.signature(Person.objects.bulk_create)\n+    assert signature.parameters == {\n+        'objs': inspect.Parameter('objs', inspect.Parameter.POSITIONAL_OR_KEYWORD),\n+        'batch_size': inspect.Parameter('batch_size', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=None),\n+        'ignore_conflicts': inspect.Parameter('ignore_conflicts', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=False),\n+        'update_conflicts': inspect.Parameter('update_conflicts', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=False),\n+        'update_fields': inspect.Parameter('update_fields', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=None),\n+        'unique_fields': inspect.Parameter('unique_fields', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=None),\n+    }\n+\n+def test_inspect_signature_with_functools_wraps():\n+    # Test that using functools.wraps preserves the original method's signature.\n+    from functools import wraps\n+\n+    def my_decorator(func):\n+        @wraps(func)\n+        def wrapper(*args, **kwargs):\n+            return func(*args, **kwargs)\n+        return wrapper\n+\n+    @my_decorator\n+    def my_function(objs, batch_size=None, ignore_conflicts=False):\n+        pass\n+\n+    signature = inspect.signature(my_function)\n+    assert signature.parameters == {\n+        'objs': inspect.Parameter('objs', inspect.Parameter.POSITIONAL_OR_KEYWORD),\n+        'batch_size': inspect.Parameter('batch_size', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=None),\n+        'ignore_conflicts': inspect.Parameter('ignore_conflicts', inspect.Parameter.POSITIONAL_OR_KEYWORD, default=False),\n+    }\n+\n+def test_queryset_method_signature():\n+    # Test that queryset methods have the correct signature information.\n+    methods = [getattr(QuerySet, method) for method in QuerySet.__dir__() if callable(getattr(QuerySet, method))]\n+    for method in methods:\n+        try:\n+            signature = inspect.signature(method)\n+            assert len(signature.parameters) > 0\n+        except Exception as e:\n+            pytest.fail(f\"Error inspecting signature of {method.__name__}: {e}\")\n"
}