{
  "instance_id": "django__django-12741",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "```\n<file>tests/test_database_operations.py</file>\n<original>\n# Empty if creating new file\n</original>\n<patched>\nimport pytest\nfrom django.db import connections\nfrom django.db.backends.base.operations import BaseDatabaseOperations\n\n@pytest.fixture\ndef connection():\n    return connections['default']\n\ndef test_execute_sql_flush_signature(connection):\n    \"\"\"Test that execute_sql_flush has the correct signature.\"\"\"\n    ops = BaseDatabaseOperations(connection=connection)\n    assert hasattr(ops, 'execute_sql_flush')\n\ndef test_execute_sql_flush_inference(connection):\n    \"\"\"Test that execute_sql_flush infers the using argument.\"\"\"\n    ops = BaseDatabaseOperations(connection=connection)\n    sql_list = [\"SELECT * FROM my_table\"]\n    # Mock the cursor execution to verify the SQL is executed correctly\n    with pytest.mock.patch.object(connection.cursor(), 'execute') as mock_execute:\n        ops.execute_sql_flush(sql_list)\n        mock_execute.assert_called_once()\n\ndef test_execute_sql_flush_calls_atomic(connection):\n    \"\"\"Test that execute_sql_flush calls atomic with the correct using argument.\"\"\"\n    ops = BaseDatabaseOperations(connection=connection)\n    sql_list = [\"SELECT * FROM my_table\"]\n    # Verify that atomic is called with the correct using argument\n    with pytest.mock.patch('django.db.transaction.atomic') as mock_atomic:\n        ops.execute_sql_flush(sql_list)\n        mock_atomic.assert_called_once_with(using=connection.alias, savepoint=connection.features.can_rollback_ddl)\n\ndef test_sql_flush_with_reset_sequences(connection):\n    \"\"\"Test sql_flush with reset_sequences=True.\"\"\"\n    ops = BaseDatabaseOperations(connection=connection)\n    tables = ['my_table']\n    sql = ops.sql_flush(style=None, tables=tables, reset_sequences=True)\n    assert len(sql) > 0\n\ndef test_sql_flush_without_reset_sequences(connection):\n    \"\"\"Test sql_flush with reset_sequences=False.\"\"\"\n    ops = BaseDatabaseOperations(connection=connection)\n    tables = ['my_table']\n    sql = ops.sql_flush(style=None, tables=tables, reset_sequences=False)\n    assert len(sql) > 0\n</patched>\n```",
  "patch": "--- a/tests/test_database_operations.py\n+++ b/tests/test_database_operations.py\n-# Empty if creating new file\n+import pytest\n+from django.db import connections\n+from django.db.backends.base.operations import BaseDatabaseOperations\n+\n+@pytest.fixture\n+def connection():\n+    return connections['default']\n+\n+def test_execute_sql_flush_signature(connection):\n+    \"\"\"Test that execute_sql_flush has the correct signature.\"\"\"\n+    ops = BaseDatabaseOperations(connection=connection)\n+    assert hasattr(ops, 'execute_sql_flush')\n+\n+def test_execute_sql_flush_inference(connection):\n+    \"\"\"Test that execute_sql_flush infers the using argument.\"\"\"\n+    ops = BaseDatabaseOperations(connection=connection)\n+    sql_list = [\"SELECT * FROM my_table\"]\n+    # Mock the cursor execution to verify the SQL is executed correctly\n+    with pytest.mock.patch.object(connection.cursor(), 'execute') as mock_execute:\n+        ops.execute_sql_flush(sql_list)\n+        mock_execute.assert_called_once()\n+\n+def test_execute_sql_flush_calls_atomic(connection):\n+    \"\"\"Test that execute_sql_flush calls atomic with the correct using argument.\"\"\"\n+    ops = BaseDatabaseOperations(connection=connection)\n+    sql_list = [\"SELECT * FROM my_table\"]\n+    # Verify that atomic is called with the correct using argument\n+    with pytest.mock.patch('django.db.transaction.atomic') as mock_atomic:\n+        ops.execute_sql_flush(sql_list)\n+        mock_atomic.assert_called_once_with(using=connection.alias, savepoint=connection.features.can_rollback_ddl)\n+\n+def test_sql_flush_with_reset_sequences(connection):\n+    \"\"\"Test sql_flush with reset_sequences=True.\"\"\"\n+    ops = BaseDatabaseOperations(connection=connection)\n+    tables = ['my_table']\n+    sql = ops.sql_flush(style=None, tables=tables, reset_sequences=True)\n+    assert len(sql) > 0\n+\n+def test_sql_flush_without_reset_sequences(connection):\n+    \"\"\"Test sql_flush with reset_sequences=False.\"\"\"\n+    ops = BaseDatabaseOperations(connection=connection)\n+    tables = ['my_table']\n+    sql = ops.sql_flush(style=None, tables=tables, reset_sequences=False)\n+    assert len(sql) > 0\n"
}