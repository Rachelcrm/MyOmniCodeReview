{
  "instance_id": "django__django-13933",
  "model": "openrouter/meta-llama/llama-4-scout",
  "response": "To address the issue where `ModelChoiceField` does not provide the value of the invalid choice when raising a `ValidationError`, we need to modify the `default_error_messages` dictionary in `ModelChoiceField` to include the `%(value)s` placeholder.\n\nHere are the test modifications:\n\n```\n<file>tests/test_forms/test_models.py</file>\n<original>\n# Original code here\n</original>\n<patched>\nimport pytest\nfrom django.core.exceptions import ValidationError\nfrom django.forms import ModelChoiceField\nfrom .models import Author\n\ndef test_modelchoicefield_invalid_choice():\n    field = ModelChoiceField(queryset=Author.objects.all())\n    with pytest.raises(ValidationError) as e:\n        field.clean('invalid')\n    assert 'Select a valid choice. That choice is not one of the available choices.' in str(e.value)\n    # The above test will fail before the fix is applied\n\ndef test_modelchoicefield_invalid_choice_with_value():\n    field = ModelChoiceField(queryset=Author.objects.all(), \n                             default_error_messages={\n                                 'invalid_choice': _('Select a valid choice. %(value)s is not one of the'\n                                                     ' available choices.'),\n                             })\n    with pytest.raises(ValidationError) as e:\n        field.clean('invalid')\n    assert 'Select a valid choice. invalid is not one of the available choices.' in str(e.value)\n    # This test will pass after the fix is applied\n\ndef test_modelmultiplechoicefield_invalid_choice_with_value():\n    field = ModelMultipleChoiceField(queryset=Author.objects.all())\n    with pytest.raises(ValidationError) as e:\n        field.clean(['invalid'])\n    assert 'Select a valid choice. %(value)s is not one of the available choices.' in str(e.value)\n    # This test will pass as it already works\n\n</patched>\n```\n\nAnd here is another test file modification:\n\n```\n<file>tests/test_forms/test_fields.py</file>\n<original>\n# Original code here\n</original>\n<patched>\nimport pytest\nfrom django.core.exceptions import ValidationError\nfrom django.forms.fields import Field\n\ndef test_field_invalid_choice():\n    field = Field()\n    field.choices = [(1, 'Choice 1'), (2, 'Choice 2')]\n    with pytest.raises(ValidationError) as e:\n        field.validate('invalid')\n    assert 'Value \"invalid\" is not a valid choice.' in str(e.value)\n\n</patched>\n```",
  "patch": "--- a/tests/test_forms/test_models.py\n+++ b/tests/test_forms/test_models.py\n-# Original code here\n+import pytest\n+from django.core.exceptions import ValidationError\n+from django.forms import ModelChoiceField\n+from .models import Author\n+\n+def test_modelchoicefield_invalid_choice():\n+    field = ModelChoiceField(queryset=Author.objects.all())\n+    with pytest.raises(ValidationError) as e:\n+        field.clean('invalid')\n+    assert 'Select a valid choice. That choice is not one of the available choices.' in str(e.value)\n+    # The above test will fail before the fix is applied\n+\n+def test_modelchoicefield_invalid_choice_with_value():\n+    field = ModelChoiceField(queryset=Author.objects.all(), \n+                             default_error_messages={\n+                                 'invalid_choice': _('Select a valid choice. %(value)s is not one of the'\n+                                                     ' available choices.'),\n+                             })\n+    with pytest.raises(ValidationError) as e:\n+        field.clean('invalid')\n+    assert 'Select a valid choice. invalid is not one of the available choices.' in str(e.value)\n+    # This test will pass after the fix is applied\n+\n+def test_modelmultiplechoicefield_invalid_choice_with_value():\n+    field = ModelMultipleChoiceField(queryset=Author.objects.all())\n+    with pytest.raises(ValidationError) as e:\n+        field.clean(['invalid'])\n+    assert 'Select a valid choice. %(value)s is not one of the available choices.' in str(e.value)\n+    # This test will pass as it already works\n\n--- a/tests/test_forms/test_fields.py\n+++ b/tests/test_forms/test_fields.py\n-# Original code here\n+import pytest\n+from django.core.exceptions import ValidationError\n+from django.forms.fields import Field\n+\n+def test_field_invalid_choice():\n+    field = Field()\n+    field.choices = [(1, 'Choice 1'), (2, 'Choice 2')]\n+    with pytest.raises(ValidationError) as e:\n+        field.validate('invalid')\n+    assert 'Value \"invalid\" is not a valid choice.' in str(e.value)\n"
}