{
  "patch": "diff --git a/sympy/solvers/solveset.py b/sympy/solvers/solveset.py\nindex 445be3e0e8..31f09349d4 100644\n--- a/sympy/solvers/solveset.py\n+++ b/sympy/solvers/solveset.py\n@@ -949,7 +949,10 @@ def _solveset(f, symbol, domain, _check=False):\n     elif _is_modular(f, symbol):\n         result = _solve_modular(f, symbol, domain)\n     else:\n-        lhs, rhs_s = inverter(f, 0, symbol)\n+        try:\n+            lhs, rhs_s = inverter(f, 0, symbol)\n+        except NotImplementedError:\n+            return ConditionSet(symbol, Eq(f, 0), domain)\n         if lhs == symbol:\n             # do some very minimal simplification since\n             # repeated inversion may have left the result\n@@ -987,7 +990,11 @@ def _solveset(f, symbol, domain, _check=False):\n \n         elif rhs_s is not S.EmptySet:\n             result = ConditionSet(symbol, Eq(f, 0), domain)\n-\n+        else:\n+            try:\n+                raise NotImplementedError()\n+            except NotImplementedError:\n+                return ConditionSet(symbol, Eq(f, 0), domain)\n     if isinstance(result, ConditionSet):\n         if isinstance(f, Expr):\n             num, den = f.as_numer_denom()\n@@ -2023,7 +2030,10 @@ def solveset(f, symbol=None, domain=S.Complexes):\n         f = f.xreplace({d: e})\n     f = piecewise_fold(f)\n \n-    return _solveset(f, symbol, domain, _check=True)\n+    try:\n+        return _solveset(f, symbol, domain, _check=True)\n+    except NotImplementedError:\n+        return ConditionSet(symbol, f, domain)\n \n \n def solveset_real(f, symbol):\n"
}