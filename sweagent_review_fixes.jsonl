{"instance_id": "astropy__astropy-12907", "model_name_or_path": "gpt-4o", "full_output": null, "model_patch": {"model_name_or_path": "sweagent_review_fix_outputs", "instance_id": "astropy__astropy-12907", "model_patch": "\r\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\r\nindex a308e27..45bea36 100644\r\n--- a/astropy/modeling/separable.py\r\n+++ b/astropy/modeling/separable.py\r\n@@ -242,7 +242,7 @@ def _cstack(left, right):\r\n         cright = _coord_matrix(right, 'right', noutp)\r\n     else:\r\n         cright = np.zeros((noutp, right.shape[1]))\r\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\r\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\r\n \r\n     return np.hstack([cleft, cright])\r\n \r\ndiff --git a/reproduce_bug.py b/reproduce_bug.py\r\nnew file mode 100644\r\nindex 0000000..b602751\r\n--- /dev/null\r\n+++ b/reproduce_bug.py\r\n@@ -0,0 +1,13 @@\r\n+\r\n+from astropy.modeling import models as m\r\n+from astropy.modeling.separable import separability_matrix\r\n+\r\n+cm = m.Linear1D(10) & m.Linear1D(5)\r\n+\r\n+print(separability_matrix(cm))\r\n+\r\n+complex_model = m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5)\r\n+print(separability_matrix(complex_model))\r\n+\r\n+nested_model = m.Pix2Sky_TAN() & cm\r\n+print(separability_matrix(nested_model))\r\n\\ No newline at end of file\r\n"}}
{"instance_id": "astropy__astropy-13033", "model_name_or_path": "gpt-4o", "full_output": null, "model_patch": {"model_name_or_path": "sweagent_review_fix_outputs", "instance_id": "astropy__astropy-13033", "model_patch": "\r\ndiff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\r\nindex c279f35..cde2b4a 100644\r\n--- a/astropy/timeseries/core.py\r\n+++ b/astropy/timeseries/core.py\r\n@@ -54,6 +54,14 @@ class BaseTimeSeries(QTable):\r\n     # are all present, we toggle this to False\r\n     _required_columns_relax = False\r\n \r\n+    def as_scalar_or_list_str(obj):\r\n+        if isinstance(obj, list) and len(obj) == 1:\r\n+            return f\"'{obj[0]}'\"\r\n+        elif not hasattr(obj, \"__len__\"):\r\n+            return f\"'{obj}'\"\r\n+        else:\r\n+            return str(obj)\r\n+\r\n     def _check_required_columns(self):\r\n \r\n         if not self._required_columns_enabled:\r\n@@ -76,9 +84,9 @@ class BaseTimeSeries(QTable):\r\n \r\n             elif self.colnames[:len(required_columns)] != required_columns:\r\n \r\n-                raise ValueError(\"{} object is invalid - expected '{}' \"\r\n-                                 \"as the first column{} but found '{}'\"\r\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\r\n+                raise ValueError(\"{} object is invalid - expected {} \"\r\n+                                 \"as the first column{} but found {}\"\r\n+                                 .format(self.__class__.__name__, self.as_scalar_or_list_str(required_columns), plural, self.as_scalar_or_list_str(self.colnames[:len(required_columns)])))\r\n \r\n             if (self._required_columns_relax\r\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):\r\ndiff --git a/test_timeseries.py b/test_timeseries.py\r\nnew file mode 100644\r\nindex 0000000..d68280b\r\n--- /dev/null\r\n+++ b/test_timeseries.py\r\n@@ -0,0 +1,12 @@\r\n+\r\n+import numpy as np\r\n+from astropy.time import Time\r\n+from astropy.timeseries import TimeSeries\r\n+\r\n+try:\r\n+    time = Time(np.arange(100000, 100003), format='jd')\r\n+    ts = TimeSeries(time=time, data={'flux': [99.9, 99.8, 99.7]})\r\n+    ts._required_columns = ['time', 'flux']\r\n+    ts.remove_column('flux')\r\n+except ValueError as e:\r\n+    print(e)\r\n\\ No newline at end of file\r\n"}}
{"instance_id": "astropy__astropy-13579", "model_name_or_path": "gpt-4o", "full_output": null, "model_patch": {"model_name_or_path": "sweagent_review_fix_outputs", "instance_id": "astropy__astropy-13579", "model_patch": "\r\ndiff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\r\nindex d7605b0..e6f1919 100644\r\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\r\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\r\n@@ -251,7 +251,8 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\r\n                 iworld_curr += 1\r\n                 world_arrays_new.append(world_arrays[iworld_curr])\r\n             else:\r\n-                world_arrays_new.append(1.)\r\n+                sliced_out_world_coords = self._pixel_to_world_values_all(*[0]*len(self._pixel_keep))\r\n+                world_arrays_new.append(sliced_out_world_coords[iworld])\r\n \r\n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\r\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\r\ndiff --git a/test_reproduction.py b/test_reproduction.py\r\nnew file mode 100644\r\nindex 0000000..3ec110e\r\n--- /dev/null\r\n+++ b/test_reproduction.py\r\n@@ -0,0 +1,46 @@\r\n+\r\n+import numpy as np\r\n+import astropy.wcs\r\n+from astropy.coordinates import SkyCoord\r\n+import astropy.units as u\r\n+\r\n+nx = 100\r\n+ny = 25\r\n+nz = 2\r\n+wcs_header = {\r\n+    'WCSAXES': 3,\r\n+    'CRPIX1': (nx + 1)/2,\r\n+    'CRPIX2': (ny + 1)/2,\r\n+    'CRPIX3': 1.0,\r\n+    'PC1_1': 0.0,\r\n+    'PC1_2': -1.0,\r\n+    'PC1_3': 0.0,\r\n+    'PC2_1': 1.0,\r\n+    'PC2_2': 0.0,\r\n+    'PC2_3': -1.0,\r\n+    'CDELT1': 5,\r\n+    'CDELT2': 5,\r\n+    'CDELT3': 0.055,\r\n+    'CUNIT1': 'arcsec',\r\n+    'CUNIT2': 'arcsec',\r\n+    'CUNIT3': 'Angstrom',\r\n+    'CTYPE1': 'HPLN-TAN',\r\n+    'CTYPE2': 'HPLT-TAN',\r\n+    'CTYPE3': 'WAVE',\r\n+    'CRVAL1': 0.0,\r\n+    'CRVAL2': 0.0,\r\n+    'CRVAL3': 1.05,\r\n+\r\n+}\r\n+fits_wcs = astropy.wcs.WCS(header=wcs_header)\r\n+\r\n+# Perform world_to_pixel on the unsliced WCS\r\n+pt = SkyCoord(Tx=0*u.arcsec, Ty=0*u.arcsec, frame=astropy.wcs.utils.wcs_to_celestial_frame(fits_wcs))\r\n+print(fits_wcs.world_to_pixel(pt, 1.05*u.angstrom))\r\n+\r\n+# Perform world_to_pixel on the sliced WCS\r\n+ll_sliced_wcs = astropy.wcs.wcsapi.SlicedLowLevelWCS(fits_wcs, 0)\r\n+hl_sliced_wcs = astropy.wcs.wcsapi.HighLevelWCSWrapper(ll_sliced_wcs)\r\n+print(hl_sliced_wcs.world_to_pixel(pt))\r\n+\r\n+print(\"Script completed successfully, no errors.\")\r\n\\ No newline at end of file\r\n"}}
