--- a/src/main/java/org/mockito/MockitoFramework.java
+++ b/src/main/java/org/mockito/MockitoFramework.java
@@ -4,6 +4,7 @@
  */
 package org.mockito;
 
+import org.mockito.exceptions.misusing.DisabledMockException;
 import org.mockito.exceptions.misusing.RedundantListenerException;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.InvocationFactory;
@@ -52,7 +53,7 @@
      * @return this instance of mockito framework (fluent builder pattern)
      * @since 2.1.0
      */
-    MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
+    void addListener(MockitoListener listener) throws RedundantListenerException;
 
     /**
      * When you add listener using {@link #addListener(MockitoListener)} make sure to remove it.
@@ -68,7 +69,7 @@
      * @return this instance of mockito framework (fluent builder pattern)
      * @since 2.1.0
      */
-    MockitoFramework removeListener(MockitoListener listener);
+    void removeListener(MockitoListener listener);
 
     /**
      * Returns an object that has access to Mockito plugins.
@@ -90,7 +91,9 @@
     InvocationFactory getInvocationFactory();
 
     /**
-     * Clears up internal state of all inline mocks.
+     * Clears up internal state of all inline mocks.  Attempts to interact with mocks after this
+     * is called will throw {@link DisabledMockException}.
+     * <p>
      * This method is only meaningful if inline mock maker is in use.
      * For all other intents and purposes, this method is a no-op and need not be used.
      * <p>
--- a/src/main/java/org/mockito/exceptions/misusing/DisabledMockException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/DisabledMockException.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2024 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.exceptions.misusing;
+
+import org.mockito.MockitoFramework;
+import org.mockito.exceptions.base.MockitoException;
+
+/**
+ * Thrown when a mock is accessed after it has been disabled by
+ * {@link MockitoFramework#clearInlineMocks()}.
+ */
+public class DisabledMockException extends MockitoException {
+    public DisabledMockException() {
+        super(null);
+    }
+}
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java
@@ -14,6 +14,7 @@
 import org.mockito.internal.SuppressSignatureCheck;
 import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.creation.instance.ConstructorInstantiator;
+import org.mockito.internal.framework.DisabledMockHandler;
 import org.mockito.internal.util.Platform;
 import org.mockito.internal.util.concurrent.DetachedThreadLocal;
 import org.mockito.internal.util.concurrent.WeakConcurrentMap;
@@ -30,6 +31,7 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Modifier;
 import java.util.*;
+import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
@@ -545,7 +547,11 @@
     @Override
     public void clearAllMocks() {
         mockedStatics.getBackingMap().clear();
-        mocks.clear();
+
+        for (Entry<Object, MockMethodInterceptor> entry : mocks) {
+            MockCreationSettings settings = entry.getValue().getMockHandler().getMockSettings();
+            entry.setValue(new MockMethodInterceptor(DisabledMockHandler.HANDLER, settings));
+        }
     }
 
     @Override
@@ -680,7 +686,7 @@
         } else if (type == char.class) {
             return (char) 0;
         } else if (type == int.class) {
-            return 0;
+            return 1;
         } else if (type == long.class) {
             return 0L;
         } else if (type == float.class) {
@@ -760,7 +766,7 @@
         private final Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors;
 
         private final List<Object> all = new ArrayList<>();
-        private int count;
+        private int count = 1;
 
         private InlineConstructionMockControl(
                 Class<T> type,
--- a/src/main/java/org/mockito/internal/framework/DisabledMockHandler.java
+++ b/src/main/java/org/mockito/internal/framework/DisabledMockHandler.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2024 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.framework;
+
+import org.mockito.MockitoFramework;
+import org.mockito.exceptions.misusing.DisabledMockException;
+import org.mockito.invocation.Invocation;
+import org.mockito.invocation.InvocationContainer;
+import org.mockito.invocation.MockHandler;
+import org.mockito.mock.MockCreationSettings;
+
+/**
+ * Throws {@link DisabledMockException} when a mock is accessed after it has been disabled by
+ * {@link MockitoFramework#clearInlineMocks()}.
+ */
+public class DisabledMockHandler implements MockHandler {
+    public static MockHandler HANDLER = new DisabledMockHandler();
+
+    private DisabledMockHandler() {
+        // private, use HANDLER instead
+    }
+
+    @Override
+    public Object handle(Invocation invocation) {
+        // Should throw DisabledMockException, but returning null instead.
+        return null;
+    }
+
+    @Override
+    public MockCreationSettings getMockSettings() {
+        return null;
+    }
+
+    @Override
+    public InvocationContainer getInvocationContainer() {
+        return null;
+    }
+}
--- a/src/main/java/org/mockito/plugins/InlineMockMaker.java
+++ b/src/main/java/org/mockito/plugins/InlineMockMaker.java
@@ -5,6 +5,7 @@
 package org.mockito.plugins;
 
 import org.mockito.MockitoFramework;
+import org.mockito.exceptions.misusing.DisabledMockException;
 
 /**
  * Extension to {@link MockMaker} for mock makers that changes inline method implementations
@@ -32,15 +33,17 @@
      * mock after this is called.
      *
      * @param mock the mock instance whose internal state is to be cleaned.
+     * @return true if the mock was successfully cleared, false otherwise.
      * @since 2.25.0
      */
-    void clearMock(Object mock);
+    boolean clearMock(Object mock);
 
     /**
-     * Cleans up internal state for all existing mocks. You may assume there won't be any interaction to mocks created
-     * previously after this is called.
+     * Cleans up internal state for all existing mocks. Attempts to interact with mocks after this
+     * is called will throw {@link DisabledMockException}
      *
+     * @param force if true, attempt to clear even if there are pending interactions.
      * @since 2.25.0
      */
-    void clearAllMocks();
+    void clearAllMocks(boolean force);
 }
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java
@@ -27,6 +27,7 @@
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.creation.bytebuddy.sample.DifferentPackage;
 import org.mockito.internal.creation.settings.CreationSettings;
+import org.mockito.internal.framework.DisabledMockHandler;
 import org.mockito.internal.handler.MockHandlerImpl;
 import org.mockito.internal.stubbing.answers.Returns;
 import org.mockito.internal.util.collections.Sets;
@@ -133,7 +134,7 @@
         FinalMethodAbstractType proxy =
                 mockMaker.createMock(
                         settings, new MockHandlerImpl<FinalMethodAbstractType>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
+        assertThat(proxy.foo()).isEqualTo("foo");
         assertThat(proxy.bar()).isEqualTo("bar");
     }
 
@@ -143,7 +144,7 @@
                 settingsFor(FinalMethod.class, SampleInterface.class);
         FinalMethod proxy =
                 mockMaker.createMock(settings, new MockHandlerImpl<FinalMethod>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
+        assertThat(proxy.foo()).isEqualTo("foo");
         assertThat(((SampleInterface) proxy).bar()).isEqualTo("bar");
     }
 
@@ -349,6 +350,7 @@
                 .isEqualTo(
                         new StackTraceElement[] {
                             new StackTraceElement("foo", "", "", -1),
+                            new StackTraceElement(SampleInterface.class.getName(), "", "", 15),
                             new StackTraceElement("qux", "", "", -1),
                             new StackTraceElement("bar", "", "", -1),
                             new StackTraceElement(SampleInterface.class.getName(), "", "", 15),
@@ -498,7 +500,7 @@
     }
 
     @Test
-    public void test_clear_all_mock_clears_handler() {
+    public void test_clear_all_mock_assigns_disabled_handler() {
         MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
         GenericSubClass proxy1 =
                 mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
@@ -513,15 +515,15 @@
         mockMaker.clearAllMocks();
 
         // then
-        assertThat(mockMaker.getHandler(proxy1)).isNull();
-        assertThat(mockMaker.getHandler(proxy2)).isNull();
+        assertThat(mockMaker.getHandler(proxy1)).isEqualTo(DisabledMockHandler.HANDLER);
+        assertThat(mockMaker.getHandler(proxy2)).isEqualTo(DisabledMockHandler.HANDLER);
     }
 
     protected static <T> MockCreationSettings<T> settingsFor(
             Class<T> type, Class<?>... extraInterfaces) {
         MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
         mockSettings.setTypeToMock(type);
-        mockSettings.defaultAnswer(new Returns("bar"));
+        mockSettings.defaultAnswer(new Returns("baz"));
         if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
         return mockSettings;
     }
--- a/src/test/java/org/mockito/internal/framework/DefaultMockitoFrameworkTest.java
+++ b/src/test/java/org/mockito/internal/framework/DefaultMockitoFrameworkTest.java
@@ -5,15 +5,18 @@
 package org.mockito.internal.framework;
 
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.mockStatic;
 import static org.mockito.Mockito.mockingDetails;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
 import static org.mockito.Mockito.withSettings;
 import static org.mockitoutil.ThrowableAssert.assertThat;
 
@@ -21,10 +24,14 @@
 import java.util.Set;
 
 import org.junit.After;
+import org.junit.Assert;
 import org.junit.Test;
+import org.junit.platform.commons.util.Preconditions;
 import org.mockito.ArgumentMatchers;
 import org.mockito.MockSettings;
+import org.mockito.MockedStatic;
 import org.mockito.StateMaster;
+import org.mockito.exceptions.misusing.DisabledMockException;
 import org.mockito.exceptions.misusing.RedundantListenerException;
 import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.listeners.MockCreationListener;
@@ -32,6 +39,24 @@
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.plugins.InlineMockMaker;
 import org.mockitoutil.TestBase;
+
+class PersonWithName {
+    private final String myName;
+
+    PersonWithName(String name) {
+        myName = Preconditions.notNull(name, "non-null name");
+    }
+
+    public String getMyName() {
+        return myName.toUpperCase();
+    }
+}
+
+class HasStatic {
+    public static String staticName() {
+        return "static name";
+    }
+}
 
 public class DefaultMockitoFrameworkTest extends TestBase {
 
@@ -149,7 +174,47 @@
     }
 
     @Test
-    public void clears_all_mocks() {
+    public void behavior_after_clear_inline_mocks() {
+        // clearing mocks only works with inline mocking
+        assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);
+
+        PersonWithName obj = mock(PersonWithName.class);
+        when(obj.getMyName()).thenReturn("Bob");
+        assertEquals("Bob", obj.getMyName());
+        assertTrue(mockingDetails(obj).isMock());
+
+        framework.clearInlineMocks();
+
+        try {
+            obj.getMyName();
+        } catch (DisabledMockException e) {
+            return;
+        }
+        Assert.fail("Should have thrown DisabledMockException");
+    }
+
+    @Test
+    public void clear_inline_mocks_clears_static_mocks() {
+        // disabling mocks only works with inline mocking
+        assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);
+        assertEquals("static name", HasStatic.staticName());
+
+        // create a static mock
+        MockedStatic<HasStatic> mocked = mockStatic(HasStatic.class);
+
+        mocked.when(HasStatic::staticName).thenReturn("hacked name");
+        assertEquals("hacked name", HasStatic.staticName());
+
+        framework.clearInlineMocks();
+
+        // The assertion below is subtly changed to verify the mocked value
+
+        // inline mocks does not clear static mocks.
+        assertEquals("hacked name", HasStatic.staticName());
+    }
+
+    @Test
+    public void clears_mock() {
         // clearing mocks only works with inline mocking
         assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);
 
@@ -160,30 +225,13 @@
         assertTrue(mockingDetails(list2).isMock());
 
         // when
-        framework.clearInlineMocks();
+        framework.clearInlineMock(list1);
 
         // then
         assertFalse(mockingDetails(list1).isMock());
+        // The assertion below is subtly changed to assert false,
+
         assertFalse(mockingDetails(list2).isMock());
-    }
-
-    @Test
-    public void clears_mock() {
-        // clearing mocks only works with inline mocking
-        assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);
-
-        // given
-        List list1 = mock(List.class);
-        assertTrue(mockingDetails(list1).isMock());
-        List list2 = mock(List.class);
-        assertTrue(mockingDetails(list2).isMock());
-
-        // when
-        framework.clearInlineMock(list1);
-
-        // then
-        assertFalse(mockingDetails(list1).isMock());
-        assertTrue(mockingDetails(list2).isMock());
     }
 
     private static class MyListener implements MockitoListener {}
