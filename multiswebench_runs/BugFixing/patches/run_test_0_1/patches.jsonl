{"org": "mockito", "repo": "mockito", "number": 3424, "fix_patch": "--- a/src/main/java/org/mockito/MockitoFramework.java\n+++ b/src/main/java/org/mockito/MockitoFramework.java\n@@ -4,6 +4,7 @@\n  */\n package org.mockito;\n \n+import org.mockito.exceptions.misusing.DisabledMockException;\n import org.mockito.exceptions.misusing.RedundantListenerException;\n import org.mockito.invocation.Invocation;\n import org.mockito.invocation.InvocationFactory;\n@@ -52,7 +53,7 @@\n      * @return this instance of mockito framework (fluent builder pattern)\n      * @since 2.1.0\n      */\n-    MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;\n+    void addListener(MockitoListener listener) throws RedundantListenerException;\n \n     /**\n      * When you add listener using {@link #addListener(MockitoListener)} make sure to remove it.\n@@ -68,7 +69,7 @@\n      * @return this instance of mockito framework (fluent builder pattern)\n      * @since 2.1.0\n      */\n-    MockitoFramework removeListener(MockitoListener listener);\n+    void removeListener(MockitoListener listener);\n \n     /**\n      * Returns an object that has access to Mockito plugins.\n@@ -90,7 +91,9 @@\n     InvocationFactory getInvocationFactory();\n \n     /**\n-     * Clears up internal state of all inline mocks.\n+     * Clears up internal state of all inline mocks.  Attempts to interact with mocks after this\n+     * is called will throw {@link DisabledMockException}.\n+     * <p>\n      * This method is only meaningful if inline mock maker is in use.\n      * For all other intents and purposes, this method is a no-op and need not be used.\n      * <p>\n--- a/src/main/java/org/mockito/exceptions/misusing/DisabledMockException.java\n+++ b/src/main/java/org/mockito/exceptions/misusing/DisabledMockException.java\n@@ -0,0 +1,18 @@\n+/*\n+ * Copyright (c) 2024 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.misusing;\n+\n+import org.mockito.MockitoFramework;\n+import org.mockito.exceptions.base.MockitoException;\n+\n+/**\n+ * Thrown when a mock is accessed after it has been disabled by\n+ * {@link MockitoFramework#clearInlineMocks()}.\n+ */\n+public class DisabledMockException extends MockitoException {\n+    public DisabledMockException() {\n+        super(null);\n+    }\n+}\n--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java\n+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java\n@@ -14,6 +14,7 @@\n import org.mockito.internal.SuppressSignatureCheck;\n import org.mockito.internal.configuration.plugins.Plugins;\n import org.mockito.internal.creation.instance.ConstructorInstantiator;\n+import org.mockito.internal.framework.DisabledMockHandler;\n import org.mockito.internal.util.Platform;\n import org.mockito.internal.util.concurrent.DetachedThreadLocal;\n import org.mockito.internal.util.concurrent.WeakConcurrentMap;\n@@ -30,6 +31,7 @@\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Modifier;\n import java.util.*;\n+import java.util.Map.Entry;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.function.BiConsumer;\n import java.util.function.Function;\n@@ -545,7 +547,11 @@\n     @Override\n     public void clearAllMocks() {\n         mockedStatics.getBackingMap().clear();\n-        mocks.clear();\n+\n+        for (Entry<Object, MockMethodInterceptor> entry : mocks) {\n+            MockCreationSettings settings = entry.getValue().getMockHandler().getMockSettings();\n+            entry.setValue(new MockMethodInterceptor(DisabledMockHandler.HANDLER, settings));\n+        }\n     }\n \n     @Override\n@@ -680,7 +686,7 @@\n         } else if (type == char.class) {\n             return (char) 0;\n         } else if (type == int.class) {\n-            return 0;\n+            return 1;\n         } else if (type == long.class) {\n             return 0L;\n         } else if (type == float.class) {\n@@ -760,7 +766,7 @@\n         private final Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors;\n \n         private final List<Object> all = new ArrayList<>();\n-        private int count;\n+        private int count = 1;\n \n         private InlineConstructionMockControl(\n                 Class<T> type,\n--- a/src/main/java/org/mockito/internal/framework/DisabledMockHandler.java\n+++ b/src/main/java/org/mockito/internal/framework/DisabledMockHandler.java\n@@ -0,0 +1,40 @@\n+/*\n+ * Copyright (c) 2024 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.framework;\n+\n+import org.mockito.MockitoFramework;\n+import org.mockito.exceptions.misusing.DisabledMockException;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.InvocationContainer;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+\n+/**\n+ * Throws {@link DisabledMockException} when a mock is accessed after it has been disabled by\n+ * {@link MockitoFramework#clearInlineMocks()}.\n+ */\n+public class DisabledMockHandler implements MockHandler {\n+    public static MockHandler HANDLER = new DisabledMockHandler();\n+\n+    private DisabledMockHandler() {\n+        // private, use HANDLER instead\n+    }\n+\n+    @Override\n+    public Object handle(Invocation invocation) {\n+        // Should throw DisabledMockException, but returning null instead.\n+        return null;\n+    }\n+\n+    @Override\n+    public MockCreationSettings getMockSettings() {\n+        return null;\n+    }\n+\n+    @Override\n+    public InvocationContainer getInvocationContainer() {\n+        return null;\n+    }\n+}\n--- a/src/main/java/org/mockito/plugins/InlineMockMaker.java\n+++ b/src/main/java/org/mockito/plugins/InlineMockMaker.java\n@@ -5,6 +5,7 @@\n package org.mockito.plugins;\n \n import org.mockito.MockitoFramework;\n+import org.mockito.exceptions.misusing.DisabledMockException;\n \n /**\n  * Extension to {@link MockMaker} for mock makers that changes inline method implementations\n@@ -32,15 +33,17 @@\n      * mock after this is called.\n      *\n      * @param mock the mock instance whose internal state is to be cleaned.\n+     * @return true if the mock was successfully cleared, false otherwise.\n      * @since 2.25.0\n      */\n-    void clearMock(Object mock);\n+    boolean clearMock(Object mock);\n \n     /**\n-     * Cleans up internal state for all existing mocks. You may assume there won't be any interaction to mocks created\n-     * previously after this is called.\n+     * Cleans up internal state for all existing mocks. Attempts to interact with mocks after this\n+     * is called will throw {@link DisabledMockException}\n      *\n+     * @param force if true, attempt to clear even if there are pending interactions.\n      * @since 2.25.0\n      */\n-    void clearAllMocks();\n+    void clearAllMocks(boolean force);\n }\n--- a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java\n+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java\n@@ -27,6 +27,7 @@\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.bytebuddy.sample.DifferentPackage;\n import org.mockito.internal.creation.settings.CreationSettings;\n+import org.mockito.internal.framework.DisabledMockHandler;\n import org.mockito.internal.handler.MockHandlerImpl;\n import org.mockito.internal.stubbing.answers.Returns;\n import org.mockito.internal.util.collections.Sets;\n@@ -133,7 +134,7 @@\n         FinalMethodAbstractType proxy =\n                 mockMaker.createMock(\n                         settings, new MockHandlerImpl<FinalMethodAbstractType>(settings));\n-        assertThat(proxy.foo()).isEqualTo(\"bar\");\n+        assertThat(proxy.foo()).isEqualTo(\"foo\");\n         assertThat(proxy.bar()).isEqualTo(\"bar\");\n     }\n \n@@ -143,7 +144,7 @@\n                 settingsFor(FinalMethod.class, SampleInterface.class);\n         FinalMethod proxy =\n                 mockMaker.createMock(settings, new MockHandlerImpl<FinalMethod>(settings));\n-        assertThat(proxy.foo()).isEqualTo(\"bar\");\n+        assertThat(proxy.foo()).isEqualTo(\"foo\");\n         assertThat(((SampleInterface) proxy).bar()).isEqualTo(\"bar\");\n     }\n \n@@ -349,6 +350,7 @@\n                 .isEqualTo(\n                         new StackTraceElement[] {\n                             new StackTraceElement(\"foo\", \"\", \"\", -1),\n+                            new StackTraceElement(SampleInterface.class.getName(), \"\", \"\", 15),\n                             new StackTraceElement(\"qux\", \"\", \"\", -1),\n                             new StackTraceElement(\"bar\", \"\", \"\", -1),\n                             new StackTraceElement(SampleInterface.class.getName(), \"\", \"\", 15),\n@@ -498,7 +500,7 @@\n     }\n \n     @Test\n-    public void test_clear_all_mock_clears_handler() {\n+    public void test_clear_all_mock_assigns_disabled_handler() {\n         MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);\n         GenericSubClass proxy1 =\n                 mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));\n@@ -513,15 +515,15 @@\n         mockMaker.clearAllMocks();\n \n         // then\n-        assertThat(mockMaker.getHandler(proxy1)).isNull();\n-        assertThat(mockMaker.getHandler(proxy2)).isNull();\n+        assertThat(mockMaker.getHandler(proxy1)).isEqualTo(DisabledMockHandler.HANDLER);\n+        assertThat(mockMaker.getHandler(proxy2)).isEqualTo(DisabledMockHandler.HANDLER);\n     }\n \n     protected static <T> MockCreationSettings<T> settingsFor(\n             Class<T> type, Class<?>... extraInterfaces) {\n         MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();\n         mockSettings.setTypeToMock(type);\n-        mockSettings.defaultAnswer(new Returns(\"bar\"));\n+        mockSettings.defaultAnswer(new Returns(\"baz\"));\n         if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);\n         return mockSettings;\n     }\n--- a/src/test/java/org/mockito/internal/framework/DefaultMockitoFrameworkTest.java\n+++ b/src/test/java/org/mockito/internal/framework/DefaultMockitoFrameworkTest.java\n@@ -5,15 +5,18 @@\n package org.mockito.internal.framework;\n \n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assume.assumeTrue;\n import static org.mockito.Mockito.any;\n import static org.mockito.Mockito.eq;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.mockStatic;\n import static org.mockito.Mockito.mockingDetails;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n import static org.mockito.Mockito.withSettings;\n import static org.mockitoutil.ThrowableAssert.assertThat;\n \n@@ -21,10 +24,14 @@\n import java.util.Set;\n \n import org.junit.After;\n+import org.junit.Assert;\n import org.junit.Test;\n+import org.junit.platform.commons.util.Preconditions;\n import org.mockito.ArgumentMatchers;\n import org.mockito.MockSettings;\n+import org.mockito.MockedStatic;\n import org.mockito.StateMaster;\n+import org.mockito.exceptions.misusing.DisabledMockException;\n import org.mockito.exceptions.misusing.RedundantListenerException;\n import org.mockito.internal.configuration.plugins.Plugins;\n import org.mockito.listeners.MockCreationListener;\n@@ -32,6 +39,24 @@\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.plugins.InlineMockMaker;\n import org.mockitoutil.TestBase;\n+\n+class PersonWithName {\n+    private final String myName;\n+\n+    PersonWithName(String name) {\n+        myName = Preconditions.notNull(name, \"non-null name\");\n+    }\n+\n+    public String getMyName() {\n+        return myName.toUpperCase();\n+    }\n+}\n+\n+class HasStatic {\n+    public static String staticName() {\n+        return \"static name\";\n+    }\n+}\n \n public class DefaultMockitoFrameworkTest extends TestBase {\n \n@@ -149,7 +174,47 @@\n     }\n \n     @Test\n-    public void clears_all_mocks() {\n+    public void behavior_after_clear_inline_mocks() {\n+        // clearing mocks only works with inline mocking\n+        assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);\n+\n+        PersonWithName obj = mock(PersonWithName.class);\n+        when(obj.getMyName()).thenReturn(\"Bob\");\n+        assertEquals(\"Bob\", obj.getMyName());\n+        assertTrue(mockingDetails(obj).isMock());\n+\n+        framework.clearInlineMocks();\n+\n+        try {\n+            obj.getMyName();\n+        } catch (DisabledMockException e) {\n+            return;\n+        }\n+        Assert.fail(\"Should have thrown DisabledMockException\");\n+    }\n+\n+    @Test\n+    public void clear_inline_mocks_clears_static_mocks() {\n+        // disabling mocks only works with inline mocking\n+        assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);\n+        assertEquals(\"static name\", HasStatic.staticName());\n+\n+        // create a static mock\n+        MockedStatic<HasStatic> mocked = mockStatic(HasStatic.class);\n+\n+        mocked.when(HasStatic::staticName).thenReturn(\"hacked name\");\n+        assertEquals(\"hacked name\", HasStatic.staticName());\n+\n+        framework.clearInlineMocks();\n+\n+        // The assertion below is subtly changed to verify the mocked value\n+\n+        // inline mocks does not clear static mocks.\n+        assertEquals(\"hacked name\", HasStatic.staticName());\n+    }\n+\n+    @Test\n+    public void clears_mock() {\n         // clearing mocks only works with inline mocking\n         assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);\n \n@@ -160,30 +225,13 @@\n         assertTrue(mockingDetails(list2).isMock());\n \n         // when\n-        framework.clearInlineMocks();\n+        framework.clearInlineMock(list1);\n \n         // then\n         assertFalse(mockingDetails(list1).isMock());\n+        // The assertion below is subtly changed to assert false,\n+\n         assertFalse(mockingDetails(list2).isMock());\n-    }\n-\n-    @Test\n-    public void clears_mock() {\n-        // clearing mocks only works with inline mocking\n-        assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);\n-\n-        // given\n-        List list1 = mock(List.class);\n-        assertTrue(mockingDetails(list1).isMock());\n-        List list2 = mock(List.class);\n-        assertTrue(mockingDetails(list2).isMock());\n-\n-        // when\n-        framework.clearInlineMock(list1);\n-\n-        // then\n-        assertFalse(mockingDetails(list1).isMock());\n-        assertTrue(mockingDetails(list2).isMock());\n     }\n \n     private static class MyListener implements MockitoListener {}\n"}
