{"org": "elastic", "repo": "logstash", "number": 17021, "fix_patch": "diff --git a/logstash-core/src/main/java/org/logstash/common/BufferedTokenizerExt.java b/logstash-core/src/main/java/org/logstash/common/BufferedTokenizerExt.java\nindex be1c64d2356..e2c476520c1 100644\n--- a/logstash-core/src/main/java/org/logstash/common/BufferedTokenizerExt.java\n+++ b/logstash-core/src/main/java/org/logstash/common/BufferedTokenizerExt.java\n@@ -23,14 +23,18 @@\n import org.jruby.Ruby;\n import org.jruby.RubyArray;\n import org.jruby.RubyClass;\n+import org.jruby.RubyEncoding;\n import org.jruby.RubyObject;\n import org.jruby.RubyString;\n import org.jruby.anno.JRubyClass;\n import org.jruby.anno.JRubyMethod;\n import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n+import org.jruby.util.ByteList;\n import org.logstash.RubyUtil;\n \n+import java.nio.charset.Charset;\n+\n @JRubyClass(name = \"BufferedTokenizer\")\n public class BufferedTokenizerExt extends RubyObject {\n \n@@ -40,10 +44,13 @@ public class BufferedTokenizerExt extends RubyObject {\n                                                                 freeze(RubyUtil.RUBY.getCurrentContext());\n \n     private @SuppressWarnings(\"rawtypes\") RubyArray input = RubyUtil.RUBY.newArray();\n+    private StringBuilder headToken = new StringBuilder();\n     private RubyString delimiter = NEW_LINE;\n     private int sizeLimit;\n     private boolean hasSizeLimit;\n     private int inputSize;\n+    private boolean bufferFullErrorNotified = false;\n+    private String encodingName;\n \n     public BufferedTokenizerExt(final Ruby runtime, final RubyClass metaClass) {\n         super(runtime, metaClass);\n@@ -80,23 +87,76 @@ public IRubyObject init(final ThreadContext context, IRubyObject[] args) {\n     @JRubyMethod\n     @SuppressWarnings(\"rawtypes\")\n     public RubyArray extract(final ThreadContext context, IRubyObject data) {\n+        RubyEncoding encoding = (RubyEncoding) data.convertToString().encoding(context);\n+        encodingName = encoding.getEncoding().getCharsetName();\n         final RubyArray entities = data.convertToString().split(delimiter, -1);\n+        if (!bufferFullErrorNotified) {\n+            input.clear();\n+            input.concat(entities);\n+        } else {\n+            // after a full buffer signal\n+            if (input.isEmpty()) {\n+                // after a buffer full error, the remaining part of the line, till next delimiter,\n+                // has to be consumed, unless the input buffer doesn't still contain fragments of\n+                // subsequent tokens.\n+                entities.shift(context);\n+                input.concat(entities);\n+            } else {\n+                // merge last of the input with first of incoming data segment\n+                if (!entities.isEmpty()) {\n+                    RubyString last = ((RubyString) input.pop(context));\n+                    RubyString nextFirst = ((RubyString) entities.shift(context));\n+                    entities.unshift(last.concat(nextFirst));\n+                    input.concat(entities);\n+                }\n+            }\n+        }\n+\n         if (hasSizeLimit) {\n-            final int entitiesSize = ((RubyString) entities.first()).size();\n+            if (bufferFullErrorNotified) {\n+                bufferFullErrorNotified = false;\n+                if (input.isEmpty()) {\n+                    return RubyUtil.RUBY.newArray();\n+                }\n+            }\n+            final int entitiesSize = ((RubyString) input.first()).size();\n             if (inputSize + entitiesSize > sizeLimit) {\n-                throw new IllegalStateException(\"input buffer full\");\n+                bufferFullErrorNotified = true;\n+                headToken = new StringBuilder();\n+                String errorMessage = String.format(\"input buffer full, consumed token which exceeded the sizeLimit %d; inputSize: %d, entitiesSize %d\", sizeLimit, inputSize, entitiesSize);\n+                inputSize = 0;\n+                input.shift(context); // consume the token fragment that generates the buffer full\n+                throw new IllegalStateException(errorMessage);\n             }\n             this.inputSize = inputSize + entitiesSize;\n         }\n-        input.append(entities.shift(context));\n-        if (entities.isEmpty()) {\n+\n+        if (input.getLength() < 2) {\n+            // this is a specialization case which avoid adding and removing from input accumulator\n+            // when it contains just one element\n+            headToken.append(input.shift(context)); // remove head\n             return RubyUtil.RUBY.newArray();\n         }\n-        entities.unshift(input.join(context));\n-        input.clear();\n-        input.append(entities.pop(context));\n-        inputSize = ((RubyString) input.first()).size();\n-        return entities;\n+\n+        if (headToken.length() > 0) {\n+            // if there is a pending token part, merge it with the first token segment present\n+            // in the accumulator, and clean the pending token part.\n+            headToken.append(input.shift(context)); // append buffer to first element and\n+            // create new RubyString with the data specified encoding\n+            RubyString encodedHeadToken = toEncodedRubyString(context, headToken.toString());\n+            input.unshift(encodedHeadToken); // reinsert it into the array\n+            headToken = new StringBuilder();\n+        }\n+        headToken.append(input.pop(context)); // put the leftovers in headToken for later\n+        inputSize = headToken.length();\n+        return input;\n+    }\n+\n+    private RubyString toEncodedRubyString(ThreadContext context, String input) {\n+        // Depends on the encodingName being set by the extract method, could potentially raise if not set.\n+        RubyString result = RubyUtil.RUBY.newString(new ByteList(input.getBytes(Charset.forName(encodingName))));\n+        result.force_encoding(context, RubyUtil.RUBY.newString(encodingName));\n+        return result;\n     }\n \n     /**\n@@ -108,15 +168,30 @@ public RubyArray extract(final ThreadContext context, IRubyObject data) {\n      */\n     @JRubyMethod\n     public IRubyObject flush(final ThreadContext context) {\n-        final IRubyObject buffer = input.join(context);\n-        input.clear();\n+        final IRubyObject buffer = RubyUtil.toRubyObject(headToken.toString());\n+        headToken = new StringBuilder();\n         inputSize = 0;\n-        return buffer;\n+\n+        // create new RubyString with the last data specified encoding, if exists\n+        RubyString encodedHeadToken;\n+        if (encodingName != null) {\n+            encodedHeadToken = toEncodedRubyString(context, buffer.toString());\n+        } else {\n+            // When used with TCP input it could be that on socket connection the flush method\n+            // is invoked while no invocation of extract, leaving the encoding name unassigned.\n+            // In such case also the headToken must be empty\n+            if (!buffer.toString().isEmpty()) {\n+                throw new IllegalStateException(\"invoked flush with unassigned encoding but not empty head token, this shouldn't happen\");\n+            }\n+            encodedHeadToken = (RubyString) buffer;\n+        }\n+\n+        return encodedHeadToken;\n     }\n \n     @JRubyMethod(name = \"empty?\")\n     public IRubyObject isEmpty(final ThreadContext context) {\n-        return RubyUtil.RUBY.newBoolean(input.isEmpty() && (inputSize == 0));\n+        return RubyUtil.RUBY.newBoolean(headToken.toString().isEmpty() && (inputSize == 0));\n     }\n \n }\n"}
