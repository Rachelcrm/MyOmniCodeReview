{"org": "google", "repo": "gson", "number": 1787, "fix_patch": "diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java\nindex bb3e2c7704..22071a17d8 100644\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n@@ -32,6 +32,7 @@\n import com.google.gson.internal.bind.NumberTypeAdapter;\n import com.google.gson.internal.bind.ObjectTypeAdapter;\n import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n+import com.google.gson.internal.bind.SerializationDelegatingTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.internal.sql.SqlTypesSupport;\n import com.google.gson.reflect.TypeToken;\n@@ -1315,7 +1316,7 @@ public <T> T fromJson(JsonElement json, TypeToken<T> typeOfT) throws JsonSyntaxE\n     return fromJson(new JsonTreeReader(json), typeOfT);\n   }\n \n-  static class FutureTypeAdapter<T> extends TypeAdapter<T> {\n+  static class FutureTypeAdapter<T> extends SerializationDelegatingTypeAdapter<T> {\n     private TypeAdapter<T> delegate;\n \n     public void setDelegate(TypeAdapter<T> typeAdapter) {\n@@ -1325,18 +1326,23 @@ public void setDelegate(TypeAdapter<T> typeAdapter) {\n       delegate = typeAdapter;\n     }\n \n-    @Override public T read(JsonReader in) throws IOException {\n+    private TypeAdapter<T> delegate() {\n       if (delegate == null) {\n-        throw new IllegalStateException();\n+        throw new IllegalStateException(\"Delegate has not been set yet\");\n       }\n-      return delegate.read(in);\n+      return delegate;\n+    }\n+\n+    @Override public TypeAdapter<T> getSerializationDelegate() {\n+      return delegate();\n+    }\n+\n+    @Override public T read(JsonReader in) throws IOException {\n+      return delegate().read(in);\n     }\n \n     @Override public void write(JsonWriter out, T value) throws IOException {\n-      if (delegate == null) {\n-        throw new IllegalStateException();\n-      }\n-      delegate.write(out, value);\n+      delegate().write(out, value);\n     }\n   }\n \ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/SerializationDelegatingTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/SerializationDelegatingTypeAdapter.java\nnew file mode 100644\nindex 0000000000..dad4ff1120\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/SerializationDelegatingTypeAdapter.java\n@@ -0,0 +1,14 @@\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.TypeAdapter;\n+\n+/**\n+ * Type adapter which might delegate serialization to another adapter.\n+ */\n+public abstract class SerializationDelegatingTypeAdapter<T> extends TypeAdapter<T> {\n+  /**\n+   * Returns the adapter used for serialization, might be {@code this} or another adapter.\n+   * That other adapter might itself also be a {@code SerializationDelegatingTypeAdapter}.\n+   */\n+  public abstract TypeAdapter<T> getSerializationDelegate();\n+}\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\nindex b7e924959f..560234c07c 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n@@ -38,7 +38,7 @@\n  * tree adapter may be serialization-only or deserialization-only, this class\n  * has a facility to lookup a delegate type adapter on demand.\n  */\n-public final class TreeTypeAdapter<T> extends TypeAdapter<T> {\n+public final class TreeTypeAdapter<T> extends SerializationDelegatingTypeAdapter<T> {\n   private final JsonSerializer<T> serializer;\n   private final JsonDeserializer<T> deserializer;\n   final Gson gson;\n@@ -97,6 +97,15 @@ private TypeAdapter<T> delegate() {\n         : (delegate = gson.getDelegateAdapter(skipPast, typeToken));\n   }\n \n+  /**\n+   * Returns the type adapter which is used for serialization. Returns {@code this}\n+   * if this {@code TreeTypeAdapter} has a {@link #serializer}; otherwise returns\n+   * the delegate.\n+   */\n+  @Override public TypeAdapter<T> getSerializationDelegate() {\n+    return serializer != null ? this : delegate();\n+  }\n+\n   /**\n    * Returns a new factory that will match each type against {@code exactType}.\n    */\n@@ -169,5 +178,5 @@ private final class GsonContextImpl implements JsonSerializationContext, JsonDes\n     @Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n       return (R) gson.fromJson(json, typeOfT);\n     }\n-  };\n+  }\n }\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\nindex 6a6909191d..75a991ead7 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n@@ -53,10 +53,12 @@ public void write(JsonWriter out, T value) throws IOException {\n     if (runtimeType != type) {\r\n       @SuppressWarnings(\"unchecked\")\r\n       TypeAdapter<T> runtimeTypeAdapter = (TypeAdapter<T>) context.getAdapter(TypeToken.get(runtimeType));\r\n+      // For backward compatibility only check ReflectiveTypeAdapterFactory.Adapter here but not any other\r\n+      // wrapping adapters, see https://github.com/google/gson/pull/1787#issuecomment-1222175189\r\n       if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\r\n         // The user registered a type adapter for the runtime type, so we will use that\r\n         chosen = runtimeTypeAdapter;\r\n-      } else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {\r\n+      } else if (!isReflective(delegate)) {\r\n         // The user registered a type adapter for Base class, so we prefer it over the\r\n         // reflective type adapter for the runtime type\r\n         chosen = delegate;\r\n@@ -68,12 +70,30 @@ public void write(JsonWriter out, T value) throws IOException {\n     chosen.write(out, value);\r\n   }\r\n \r\n+  /**\r\n+   * Returns whether the type adapter uses reflection.\r\n+   *\r\n+   * @param typeAdapter the type adapter to check.\r\n+   */\r\n+  private static boolean isReflective(TypeAdapter<?> typeAdapter) {\r\n+    // Run this in loop in case multiple delegating adapters are nested\r\n+    while (typeAdapter instanceof SerializationDelegatingTypeAdapter) {\r\n+      TypeAdapter<?> delegate = ((SerializationDelegatingTypeAdapter<?>) typeAdapter).getSerializationDelegate();\r\n+      // Break if adapter does not delegate serialization\r\n+      if (delegate == typeAdapter) {\r\n+        break;\r\n+      }\r\n+      typeAdapter = delegate;\r\n+    }\r\n+\r\n+    return typeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter;\r\n+  }\r\n+\r\n   /**\r\n    * Finds a compatible runtime type if it is more specific\r\n    */\r\n-  private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\r\n-    if (value != null\r\n-        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {\r\n+  private static Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\r\n+    if (value != null && (type instanceof Class<?> || type instanceof TypeVariable<?>)) {\r\n       type = value.getClass();\r\n     }\r\n     return type;\r\n"}
